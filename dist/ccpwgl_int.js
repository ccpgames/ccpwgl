(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ccpwgl_int"] = factory();
	else
		root["ccpwgl_int"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 26);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var Tw2Constant_namespaceObject = {};
__webpack_require__.r(Tw2Constant_namespaceObject);
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_COLOR_BUFFER_BIT", function() { return GL_COLOR_BUFFER_BIT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_BUFFER_BIT", function() { return GL_DEPTH_BUFFER_BIT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_STENCIL_BUFFER_BIT", function() { return GL_STENCIL_BUFFER_BIT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_2D", function() { return GL_TEXTURE_2D; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_CUBE_MAP", function() { return GL_TEXTURE_CUBE_MAP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_3D", function() { return GL_TEXTURE_3D; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_MAG_FILTER", function() { return GL_TEXTURE_MAG_FILTER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_MIN_FILTER", function() { return GL_TEXTURE_MIN_FILTER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_WRAP_S", function() { return GL_TEXTURE_WRAP_S; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TEXTURE_WRAP_T", function() { return GL_TEXTURE_WRAP_T; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BYTE", function() { return GL_BYTE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_UNSIGNED_BYTE", function() { return GL_UNSIGNED_BYTE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SHORT", function() { return GL_SHORT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_UNSIGNED_SHORT", function() { return GL_UNSIGNED_SHORT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INT", function() { return GL_INT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_UNSIGNED_INT", function() { return GL_UNSIGNED_INT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT", function() { return GL_FLOAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_HALF_FLOAT_OES", function() { return GL_HALF_FLOAT_OES; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_HALF_FLOAT", function() { return GL_HALF_FLOAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_COMPONENT16", function() { return GL_DEPTH_COMPONENT16; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_COMPONENT24", function() { return GL_DEPTH_COMPONENT24; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_COMPONENT32F", function() { return GL_DEPTH_COMPONENT32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_VEC2", function() { return GL_FLOAT_VEC2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_VEC3", function() { return GL_FLOAT_VEC3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_VEC4", function() { return GL_FLOAT_VEC4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INT_VEC2", function() { return GL_INT_VEC2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INT_VEC3", function() { return GL_INT_VEC3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INT_VEC4", function() { return GL_INT_VEC4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BOOL", function() { return GL_BOOL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BOOL_VEC2", function() { return GL_BOOL_VEC2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BOOL_VEC3", function() { return GL_BOOL_VEC3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BOOL_VEC4", function() { return GL_BOOL_VEC4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_MAT2", function() { return GL_FLOAT_MAT2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_MAT3", function() { return GL_FLOAT_MAT3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FLOAT_MAT4", function() { return GL_FLOAT_MAT4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TYPE_LENGTH", function() { return GL_TYPE_LENGTH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SAMPLER_2D", function() { return GL_SAMPLER_2D; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SAMPLER_3D", function() { return GL_SAMPLER_3D; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SAMPLER_CUBE", function() { return GL_SAMPLER_CUBE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_COMPONENT", function() { return GL_DEPTH_COMPONENT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ALPHA", function() { return GL_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB", function() { return GL_RGB; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA", function() { return GL_RGBA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LUMINANCE", function() { return GL_LUMINANCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LUMINANCE_ALPHA", function() { return GL_LUMINANCE_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_STENCIL", function() { return GL_DEPTH_STENCIL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_UNSIGNED_INT_24_8_WEBGL", function() { return GL_UNSIGNED_INT_24_8_WEBGL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_R8", function() { return GL_R8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_R16F", function() { return GL_R16F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_R32F", function() { return GL_R32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_R8UI", function() { return GL_R8UI; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RG8", function() { return GL_RG8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RG16F", function() { return GL_RG16F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RG32F", function() { return GL_RG32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB8", function() { return GL_RGB8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SRGB8", function() { return GL_SRGB8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB565", function() { return GL_RGB565; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_R11F_G11F_B10F", function() { return GL_R11F_G11F_B10F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB9_E5", function() { return GL_RGB9_E5; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB16F", function() { return GL_RGB16F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB32F", function() { return GL_RGB32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB8UI", function() { return GL_RGB8UI; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA8", function() { return GL_RGBA8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGB5_A1", function() { return GL_RGB5_A1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA16F", function() { return GL_RGBA16F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA32F", function() { return GL_RGBA32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA8UI", function() { return GL_RGBA8UI; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA16I", function() { return GL_RGBA16I; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA16UI", function() { return GL_RGBA16UI; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA32I", function() { return GL_RGBA32I; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_RGBA32UI", function() { return GL_RGBA32UI; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_NEAREST", function() { return GL_NEAREST; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINEAR", function() { return GL_LINEAR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_NEAREST_MIPMAP_NEAREST", function() { return GL_NEAREST_MIPMAP_NEAREST; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINEAR_MIPMAP_NEAREST", function() { return GL_LINEAR_MIPMAP_NEAREST; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_NEAREST_MIPMAP_LINEAR", function() { return GL_NEAREST_MIPMAP_LINEAR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINEAR_MIPMAP_LINEAR", function() { return GL_LINEAR_MIPMAP_LINEAR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_REPEAT", function() { return GL_REPEAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CLAMP_TO_EDGE", function() { return GL_CLAMP_TO_EDGE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_MIRRORED_REPEAT", function() { return GL_MIRRORED_REPEAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ZERO", function() { return GL_ZERO; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE", function() { return GL_ONE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SRC_COLOR", function() { return GL_SRC_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_SRC_COLOR", function() { return GL_ONE_MINUS_SRC_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SRC_ALPHA", function() { return GL_SRC_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_SRC_ALPHA", function() { return GL_ONE_MINUS_SRC_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DST_ALPHA", function() { return GL_DST_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_DST_ALPHA", function() { return GL_ONE_MINUS_DST_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DST_COLOR", function() { return GL_DST_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_DST_COLOR", function() { return GL_ONE_MINUS_DST_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_SRC_ALPHA_SATURATE", function() { return GL_SRC_ALPHA_SATURATE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CONSTANT_COLOR", function() { return GL_CONSTANT_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_CONSTANT_COLOR", function() { return GL_ONE_MINUS_CONSTANT_COLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CONSTANT_ALPHA", function() { return GL_CONSTANT_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ONE_MINUS_CONSTANT_ALPHA", function() { return GL_ONE_MINUS_CONSTANT_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_VERTEX_SHADER", function() { return GL_VERTEX_SHADER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FRAGMENT_SHADER", function() { return GL_FRAGMENT_SHADER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FRONT", function() { return GL_FRONT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BACK", function() { return GL_BACK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_FRONT_AND_BACK", function() { return GL_FRONT_AND_BACK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_NEVER", function() { return GL_NEVER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LESS", function() { return GL_LESS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_EQUAL", function() { return GL_EQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LEQUAL", function() { return GL_LEQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_GREATER", function() { return GL_GREATER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_NOTEQUAL", function() { return GL_NOTEQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_GEQUAL", function() { return GL_GEQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ALWAYS", function() { return GL_ALWAYS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_KEEP", function() { return GL_KEEP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_REPLACE", function() { return GL_REPLACE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INCR", function() { return GL_INCR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DECR", function() { return GL_DECR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INCR_WRAP", function() { return GL_INCR_WRAP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DECR_WRAP", function() { return GL_DECR_WRAP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_INVERT", function() { return GL_INVERT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_STREAM_DRAW", function() { return GL_STREAM_DRAW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_STATIC_DRAW", function() { return GL_STATIC_DRAW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DYNAMIC_DRAW", function() { return GL_DYNAMIC_DRAW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ARRAY_BUFFER", function() { return GL_ARRAY_BUFFER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_ELEMENT_ARRAY_BUFFER", function() { return GL_ELEMENT_ARRAY_BUFFER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_POINTS", function() { return GL_POINTS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINES", function() { return GL_LINES; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINE_LOOP", function() { return GL_LINE_LOOP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_LINE_STRIP", function() { return GL_LINE_STRIP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TRIANGLES", function() { return GL_TRIANGLES; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TRIANGLE_STRIP", function() { return GL_TRIANGLE_STRIP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_TRIANGLE_FAN", function() { return GL_TRIANGLE_FAN; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CW", function() { return GL_CW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CCW", function() { return GL_CCW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_CULL_FACE", function() { return GL_CULL_FACE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_DEPTH_TEST", function() { return GL_DEPTH_TEST; });
__webpack_require__.d(Tw2Constant_namespaceObject, "GL_BLEND", function() { return GL_BLEND; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_ANY", function() { return RM_ANY; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_OPAQUE", function() { return RM_OPAQUE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_DECAL", function() { return RM_DECAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_TRANSPARENT", function() { return RM_TRANSPARENT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_ADDITIVE", function() { return RM_ADDITIVE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_DEPTH", function() { return RM_DEPTH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_FULLSCREEN", function() { return RM_FULLSCREEN; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_PICKABLE", function() { return RM_PICKABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RM_DISTORTION", function() { return RM_DISTORTION; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ZENABLE", function() { return RS_ZENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FILLMODE", function() { return RS_FILLMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SHADEMODE", function() { return RS_SHADEMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ZWRITEENABLE", function() { return RS_ZWRITEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ALPHATESTENABLE", function() { return RS_ALPHATESTENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_LASTPIXEL", function() { return RS_LASTPIXEL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SRCBLEND", function() { return RS_SRCBLEND; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DESTBLEND", function() { return RS_DESTBLEND; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CULLMODE", function() { return RS_CULLMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ZFUNC", function() { return RS_ZFUNC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ALPHAREF", function() { return RS_ALPHAREF; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ALPHAFUNC", function() { return RS_ALPHAFUNC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DITHERENABLE", function() { return RS_DITHERENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ALPHABLENDENABLE", function() { return RS_ALPHABLENDENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGENABLE", function() { return RS_FOGENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SPECULARENABLE", function() { return RS_SPECULARENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGCOLOR", function() { return RS_FOGCOLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGTABLEMODE", function() { return RS_FOGTABLEMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGSTART", function() { return RS_FOGSTART; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGEND", function() { return RS_FOGEND; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGDENSITY", function() { return RS_FOGDENSITY; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_RANGEFOGENABLE", function() { return RS_RANGEFOGENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILENABLE", function() { return RS_STENCILENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILFAIL", function() { return RS_STENCILFAIL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILZFAIL", function() { return RS_STENCILZFAIL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILPASS", function() { return RS_STENCILPASS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILFUNC", function() { return RS_STENCILFUNC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILREF", function() { return RS_STENCILREF; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILMASK", function() { return RS_STENCILMASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_STENCILWRITEMASK", function() { return RS_STENCILWRITEMASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_TEXTUREFACTOR", function() { return RS_TEXTUREFACTOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP0", function() { return RS_WRAP0; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP1", function() { return RS_WRAP1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP2", function() { return RS_WRAP2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP3", function() { return RS_WRAP3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP4", function() { return RS_WRAP4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP5", function() { return RS_WRAP5; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP6", function() { return RS_WRAP6; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_WRAP7", function() { return RS_WRAP7; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CLIPPING", function() { return RS_CLIPPING; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_LIGHTING", function() { return RS_LIGHTING; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_AMBIENT", function() { return RS_AMBIENT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_FOGVERTEXMODE", function() { return RS_FOGVERTEXMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_COLORVERTEX", function() { return RS_COLORVERTEX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_LOCALVIEWER", function() { return RS_LOCALVIEWER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_NORMALIZENORMALS", function() { return RS_NORMALIZENORMALS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DIFFUSEMATERIALSOURCE", function() { return RS_DIFFUSEMATERIALSOURCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SPECULARMATERIALSOURCE", function() { return RS_SPECULARMATERIALSOURCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_AMBIENTMATERIALSOURCE", function() { return RS_AMBIENTMATERIALSOURCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_EMISSIVEMATERIALSOURCE", function() { return RS_EMISSIVEMATERIALSOURCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_VERTEXBLEND", function() { return RS_VERTEXBLEND; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CLIPPLANEENABLE", function() { return RS_CLIPPLANEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSIZE", function() { return RS_POINTSIZE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSIZE_MIN", function() { return RS_POINTSIZE_MIN; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSPRITEENABLE", function() { return RS_POINTSPRITEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSCALEENABLE", function() { return RS_POINTSCALEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSCALE_A", function() { return RS_POINTSCALE_A; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSCALE_B", function() { return RS_POINTSCALE_B; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSCALE_C", function() { return RS_POINTSCALE_C; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_MULTISAMPLEANTIALIAS", function() { return RS_MULTISAMPLEANTIALIAS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_MULTISAMPLEMASK", function() { return RS_MULTISAMPLEMASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_PATCHEDGESTYLE", function() { return RS_PATCHEDGESTYLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DEBUGMONITORTOKEN", function() { return RS_DEBUGMONITORTOKEN; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POINTSIZE_MAX", function() { return RS_POINTSIZE_MAX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_INDEXEDVERTEXBLENDENABLE", function() { return RS_INDEXEDVERTEXBLENDENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_COLORWRITEENABLE", function() { return RS_COLORWRITEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_TWEENFACTOR", function() { return RS_TWEENFACTOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_BLENDOP", function() { return RS_BLENDOP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_POSITIONDEGREE", function() { return RS_POSITIONDEGREE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_NORMALDEGREE", function() { return RS_NORMALDEGREE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SCISSORTESTENABLE", function() { return RS_SCISSORTESTENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SLOPESCALEDEPTHBIAS", function() { return RS_SLOPESCALEDEPTHBIAS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_ANTIALIASEDLINEENABLE", function() { return RS_ANTIALIASEDLINEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_TWOSIDEDSTENCILMODE", function() { return RS_TWOSIDEDSTENCILMODE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CCW_STENCILFAIL", function() { return RS_CCW_STENCILFAIL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CCW_STENCILZFAIL", function() { return RS_CCW_STENCILZFAIL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CCW_STENCILPASS", function() { return RS_CCW_STENCILPASS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_CCW_STENCILFUNC", function() { return RS_CCW_STENCILFUNC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_COLORWRITEENABLE1", function() { return RS_COLORWRITEENABLE1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_COLORWRITEENABLE2", function() { return RS_COLORWRITEENABLE2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_COLORWRITEENABLE3", function() { return RS_COLORWRITEENABLE3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_BLENDFACTOR", function() { return RS_BLENDFACTOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SRGBWRITEENABLE", function() { return RS_SRGBWRITEENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DEPTHBIAS", function() { return RS_DEPTHBIAS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SEPARATEALPHABLENDENABLE", function() { return RS_SEPARATEALPHABLENDENABLE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_SRCBLENDALPHA", function() { return RS_SRCBLENDALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_DESTBLENDALPHA", function() { return RS_DESTBLENDALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "RS_BLENDOPALPHA", function() { return RS_BLENDOPALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CULL_NONE", function() { return CULL_NONE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CULL_CW", function() { return CULL_CW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CULL_CCW", function() { return CULL_CCW; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_NEVER", function() { return CMP_NEVER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_LESS", function() { return CMP_LESS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_EQUAL", function() { return CMP_EQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_LEQUAL", function() { return CMP_LEQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_GREATER", function() { return CMP_GREATER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_NOTEQUAL", function() { return CMP_NOTEQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_GREATEREQUAL", function() { return CMP_GREATEREQUAL; });
__webpack_require__.d(Tw2Constant_namespaceObject, "CMP_ALWAYS", function() { return CMP_ALWAYS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_ZERO", function() { return BLEND_ZERO; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_ONE", function() { return BLEND_ONE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_SRCCOLOR", function() { return BLEND_SRCCOLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_INVSRCCOLOR", function() { return BLEND_INVSRCCOLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_SRCALPHA", function() { return BLEND_SRCALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_INVSRCALPHA", function() { return BLEND_INVSRCALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_DESTALPHA", function() { return BLEND_DESTALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_INVDESTALPHA", function() { return BLEND_INVDESTALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_DESTCOLOR", function() { return BLEND_DESTCOLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_INVDESTCOLOR", function() { return BLEND_INVDESTCOLOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_SRCALPHASAT", function() { return BLEND_SRCALPHASAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_BOTHSRCALPHA", function() { return BLEND_BOTHSRCALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_BOTHINVSRCALPHA", function() { return BLEND_BOTHINVSRCALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_BLENDFACTOR", function() { return BLEND_BLENDFACTOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLEND_INVBLENDFACTOR", function() { return BLEND_INVBLENDFACTOR; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLENDOP_ADD", function() { return BLENDOP_ADD; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLENDOP_SUBTRACT", function() { return BLENDOP_SUBTRACT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLENDOP_REVSUBTRACT", function() { return BLENDOP_REVSUBTRACT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLENDOP_MIN", function() { return BLENDOP_MIN; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BLENDOP_MAX", function() { return BLENDOP_MAX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_ALPHA", function() { return TF_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_LUMINANCE", function() { return TF_LUMINANCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_LUMINANCE_ALPHA", function() { return TF_LUMINANCE_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RGB", function() { return TF_RGB; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RGBA", function() { return TF_RGBA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RED", function() { return TF_RED; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_R", function() { return TF_R; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RG", function() { return TF_RG; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RED_INTEGER", function() { return TF_RED_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_R_INTEGER", function() { return TF_R_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RG_INTEGER", function() { return TF_RG_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RGB_INTEGER", function() { return TF_RGB_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TF_RGBA_INTEGER", function() { return TF_RGBA_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_BYTE", function() { return TT_UNSIGNED_BYTE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INT", function() { return TT_UNSIGNED_INT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_FLOAT", function() { return TT_FLOAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_HALF_FLOAT", function() { return TT_HALF_FLOAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_BYTE", function() { return TT_BYTE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_SHORT", function() { return TT_SHORT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_SHORT", function() { return TT_UNSIGNED_SHORT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_INT", function() { return TT_INT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INTEGER", function() { return TT_UNSIGNED_INTEGER; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_SHORT_4_4_4_4", function() { return TT_UNSIGNED_SHORT_4_4_4_4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_SHORT_5_5_5_1", function() { return TT_UNSIGNED_SHORT_5_5_5_1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_SHORT_5_6_5", function() { return TT_UNSIGNED_SHORT_5_6_5; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INT_2_10_10_10_REV", function() { return TT_UNSIGNED_INT_2_10_10_10_REV; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INT_24_8", function() { return TT_UNSIGNED_INT_24_8; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INT_10F_11F_11F_REV", function() { return TT_UNSIGNED_INT_10F_11F_11F_REV; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_UNSIGNED_INT_5_9_9_9_REV", function() { return TT_UNSIGNED_INT_5_9_9_9_REV; });
__webpack_require__.d(Tw2Constant_namespaceObject, "TT_FLOAT_32_UNSIGNED_INT_24_8_REV", function() { return TT_FLOAT_32_UNSIGNED_INT_24_8_REV; });
__webpack_require__.d(Tw2Constant_namespaceObject, "WrapModes", function() { return WrapModes; });
__webpack_require__.d(Tw2Constant_namespaceObject, "BlendTable", function() { return BlendTable; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FilterMode", function() { return FilterMode; });
__webpack_require__.d(Tw2Constant_namespaceObject, "MipFilterMode", function() { return MipFilterMode; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_MAGIC", function() { return DDS_MAGIC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_CAPS", function() { return DDSD_CAPS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_HEIGHT", function() { return DDSD_HEIGHT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_WIDTH", function() { return DDSD_WIDTH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_PITCH", function() { return DDSD_PITCH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_PIXELFORMAT", function() { return DDSD_PIXELFORMAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_MIPMAPCOUNT", function() { return DDSD_MIPMAPCOUNT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_LINEARSIZE", function() { return DDSD_LINEARSIZE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSD_DEPTH", function() { return DDSD_DEPTH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS_COMPLEX", function() { return DDSCAPS_COMPLEX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS_MIPMAP", function() { return DDSCAPS_MIPMAP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS_TEXTURE", function() { return DDSCAPS_TEXTURE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP", function() { return DDSCAPS2_CUBEMAP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_POSITIVEX", function() { return DDSCAPS2_CUBEMAP_POSITIVEX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_NEGATIVEX", function() { return DDSCAPS2_CUBEMAP_NEGATIVEX; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_POSITIVEY", function() { return DDSCAPS2_CUBEMAP_POSITIVEY; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_NEGATIVEY", function() { return DDSCAPS2_CUBEMAP_NEGATIVEY; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_POSITIVEZ", function() { return DDSCAPS2_CUBEMAP_POSITIVEZ; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_CUBEMAP_NEGATIVEZ", function() { return DDSCAPS2_CUBEMAP_NEGATIVEZ; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDSCAPS2_VOLUME", function() { return DDSCAPS2_VOLUME; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_ALPHAPIXELS", function() { return DDPF_ALPHAPIXELS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_ALPHA", function() { return DDPF_ALPHA; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_FOURCC", function() { return DDPF_FOURCC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_RGB", function() { return DDPF_RGB; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_YUV", function() { return DDPF_YUV; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDPF_LUMINANCE", function() { return DDPF_LUMINANCE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_LENGTH_INT", function() { return DDS_HEADER_LENGTH_INT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_MAGIC", function() { return DDS_HEADER_OFFSET_MAGIC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_SIZE", function() { return DDS_HEADER_OFFSET_SIZE; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_FLAGS", function() { return DDS_HEADER_OFFSET_FLAGS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_HEIGHT", function() { return DDS_HEADER_OFFSET_HEIGHT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_WIDTH", function() { return DDS_HEADER_OFFSET_WIDTH; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_MIPMAP_COUNT", function() { return DDS_HEADER_OFFSET_MIPMAP_COUNT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_PF_FLAGS", function() { return DDS_HEADER_OFFSET_PF_FLAGS; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_PF_FOURCC", function() { return DDS_HEADER_OFFSET_PF_FOURCC; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_RGB_BPP", function() { return DDS_HEADER_OFFSET_RGB_BPP; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_R_MASK", function() { return DDS_HEADER_OFFSET_R_MASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_G_MASK", function() { return DDS_HEADER_OFFSET_G_MASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_B_MASK", function() { return DDS_HEADER_OFFSET_B_MASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_A_MASK", function() { return DDS_HEADER_OFFSET_A_MASK; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_CAPS1", function() { return DDS_HEADER_OFFSET_CAPS1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_CAPS2", function() { return DDS_HEADER_OFFSET_CAPS2; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_CAPS3", function() { return DDS_HEADER_OFFSET_CAPS3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_CAPS4", function() { return DDS_HEADER_OFFSET_CAPS4; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DDS_HEADER_OFFSET_DXGI_FORMAT", function() { return DDS_HEADER_OFFSET_DXGI_FORMAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_DXT1", function() { return FOURCC_DXT1; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_DXT5", function() { return FOURCC_DXT5; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_DXT3", function() { return FOURCC_DXT3; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_DXT10", function() { return FOURCC_DXT10; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_D3DFMT_R16G16B16A16F", function() { return FOURCC_D3DFMT_R16G16B16A16F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "FOURCC_D3DFMT_R32G32B32A32F", function() { return FOURCC_D3DFMT_R32G32B32A32F; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DXGI_FORMAT_R16G16B16A16_FLOAT", function() { return DXGI_FORMAT_R16G16B16A16_FLOAT; });
__webpack_require__.d(Tw2Constant_namespaceObject, "DXGI_FORMAT_B8G8R8X8_UNORM", function() { return DXGI_FORMAT_B8G8R8X8_UNORM; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorRequestAnimationFrame", function() { return VendorRequestAnimationFrame; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorCancelAnimationFrame", function() { return VendorCancelAnimationFrame; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorRequestFullScreen", function() { return VendorRequestFullScreen; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorExitFullScreen", function() { return VendorExitFullScreen; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorGetFullScreenElement", function() { return VendorGetFullScreenElement; });
__webpack_require__.d(Tw2Constant_namespaceObject, "VendorWebglPrefixes", function() { return VendorWebglPrefixes; });
__webpack_require__.d(Tw2Constant_namespaceObject, "WebglContextNames", function() { return WebglContextNames; });
__webpack_require__.d(Tw2Constant_namespaceObject, "Webgl2ContextNames", function() { return Webgl2ContextNames; });
__webpack_require__.d(Tw2Constant_namespaceObject, "WebglVersion", function() { return WebglVersion; });

// EXTERNAL MODULE: ./global/math/index.js + 17 modules
var math = __webpack_require__(4);

// EXTERNAL MODULE: ./global/util/index.js + 5 modules
var util = __webpack_require__(3);

// EXTERNAL MODULE: ./core/Tw2EventEmitter.js
var Tw2EventEmitter = __webpack_require__(10);

// CONCATENATED MODULE: ./global/engine/Tw2Logger.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * eventLog
 * @typedef {{}} eventLog
 * @property {string} eventLog.type       - The log's type
 * @property {string} eventLog.name       - The log's name
 * @property {string} eventLog.message    - The log's message
 * @property {boolean} [eventLog.hide]    - Toggles log visibility
 * @property {boolean} [eventLog._logged] - Identifies if the log has been logged
 * @property {Error} [eventLog.err]       - Optional error (output to the console)
 * @property {*} [eventLog.data]          - Optional data (output to the console)
 */

/**
 * Handles basic event logging
 *
 * @property {string} name                   - The name of the logger
 * @property {boolean} display               - Toggles console logging
 * @property {{}} visible                    - Visibility options
 * @property {boolean} visible.log           - Toggles console log output
 * @property {boolean} visible.info          - Toggles console info output
 * @property {boolean} visible.debug         - Toggles console debug output
 * @property {boolean} visible.warn          - Toggles console warn output
 * @property {boolean} visible.error         - Toggles console error output
 * @property {number} history                - The maximum history to store
 * @property {number} throttle               - The maximum throttling per log type
 * @property {Array} _logs                   - Stored logs
 * @property {?{string:string[]}} _throttled - Throttles message cache
 */

let Tw2Logger_Tw2Logger =
/*#__PURE__*/
function (_Tw2EventEmitter) {
  _inherits(Tw2Logger, _Tw2EventEmitter);

  function Tw2Logger() {
    var _this;

    _classCallCheck(this, Tw2Logger);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2Logger).call(this, ...args));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "name", '');

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "display", true);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "visible", {
      log: true,
      info: true,
      debug: true,
      warn: true,
      error: true
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "history", 100);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "throttle", 20);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_logs", []);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_throttled", null);

    return _this;
  }

  _createClass(Tw2Logger, [{
    key: "Set",

    /**
     * Sets the logger's properties
     * @param {*} [opt]
     */
    value: function Set(opt) {
      if (!opt) return;
      Object(util["assignIfExists"])(this, opt, ['name', 'display', 'history', 'throttle']);
      Object(util["assignIfExists"])(this.visible, opt.visible, ['log', 'info', 'debug', 'warn', 'error']);
    }
    /**
     * Adds an event log and outputs it to the console
     * @param {*|eventLog|Error} log - The eventLog or error to log
     * @returns {eventLog} log
     */

  }, {
    key: "log",
    value: function log(_log) {
      if (_log._logged) return _log; // Allow errors as logs

      if (Object(util["isError"])(_log)) {
        _log = {
          err: _log
        };
      } // Normalize log details


      if (_log.err) {
        _log.type = 'error';
        if (!_log.name) _log.name = _log.err.name;
        if (!_log.message) _log.message = _log.err.message;
      } else {
        _log.type = Tw2Logger.LogType[_log.type ? _log.type.toUpperCase() : 'LOG'] || 'log';
        _log.message = _log.message || '';
      } // Normalize the log name


      let name = _log.name || this.constructor.category;
      name = name.replace(/_/g, ' ');
      name = name.charAt(0).toUpperCase() + name.slice(1);
      _log.name = name;

      if (!this.display || !this.visible[_log.type]) {
        _log.hide = true;
      } // Throttle excessive output


      if (!this.throttle) {
        this._throttled = null;
      } else {
        if (!_log.hide) {
          if (!this._throttled) this._throttled = {};
          if (!this._throttled[_log.type]) this._throttled[_log.type] = [];
          const t = this._throttled[_log.type];

          if (!t.includes(_log.message)) {
            t.unshift(_log.message);
            t.splice(this.throttle);
          } else {
            _log.hide = true;
          }
        }
      } // Output to the console


      if (!_log.hide) {
        let header = `${this.name} ${_log.name}:`;

        if (_log.err || _log.data) {
          console.group(header, _log.message);
          if (_log.err) console.debug(_log.err.stack || _log.err.toString());
          if (_log.data) console.debug(JSON.stringify(_log.data, null, 4));
          console.groupEnd();
        } else {
          console[_log.type](header, _log.message);
        }
      } // Manage log history


      if (this.history) {
        this._logs.unshift(_log);

        this._logs.splice(this.history);
      } else {
        this._logs = [];
      }

      _log._logged = true;
      this.emit(_log.type, _log);
      return _log;
    }
    /**
     * Log types
     * @type {*}
     */

  }]);

  return Tw2Logger;
}(Tw2EventEmitter["a" /* Tw2EventEmitter */]);

_defineProperty(Tw2Logger_Tw2Logger, "LogType", {
  ERROR: 'error',
  WARNING: 'warn',
  INFO: 'info',
  LOG: 'log',
  DEBUG: 'debug'
});

_defineProperty(Tw2Logger_Tw2Logger, "category", 'logger');

const logger = new Tw2Logger_Tw2Logger();
/**
 * The default event logger
 * @type {Tw2Logger}
 */

Tw2EventEmitter["a" /* Tw2EventEmitter */].defaultLogger = logger;
// CONCATENATED MODULE: ./global/engine/Tw2MotherLode.js
function Tw2MotherLode_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MotherLode_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MotherLode_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MotherLode_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MotherLode_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Manages loaded resources
 *
 * @property {Object} _loadedObjects            - loaded resources
 * @property {{string:Array<eventLog>}} _errors - Not implemented yet
 * @class
 */
let Tw2MotherLode =
/*#__PURE__*/
function () {
  function Tw2MotherLode() {
    Tw2MotherLode_classCallCheck(this, Tw2MotherLode);

    this._loadedObjects = {};
    this._errors = {};
  }
  /**
   * Adds an error log for a given path
   * @param {string} path
   * @param {Tw2Error|Error} err
   * @returns {Tw2Error|Error} err
   */


  Tw2MotherLode_createClass(Tw2MotherLode, [{
    key: "AddError",
    value: function AddError(path, err) {
      this._errors[path] = this._errors[path] || [];

      if (!this._errors[path].includes(err)) {
        err.data = err.data || {};
        err.data.path = err.data.path || path;

        this._errors[path].push(err);
      }

      return err;
    }
    /**
     * Gets a path's error logs
     * @param {string} path
     * @returns {?Array<Tw2Error|Error>}
     */

  }, {
    key: "GetErrors",
    value: function GetErrors(path) {
      return path && path in this._errors ? Object.assign([], this._errors[path]) : null;
    }
    /**
     * Checks if a path has any errors
     * @param {string} path
     * @returns {*|boolean}
     */

  }, {
    key: "HasErrors",
    value: function HasErrors(path) {
      return path && path in this._errors;
    }
    /**
     * Finds a loaded object by it's file path
     * @param {string} path
     * @returns {Tw2LoadingObject|Tw2Resource}
     */

  }, {
    key: "Find",
    value: function Find(path) {
      if (path in this._loadedObjects) {
        return this._loadedObjects[path];
      }

      return null;
    }
    /**
     * Adds a loaded object
     * @param {string} path
     * @param {Tw2LoadingObject|Tw2Resource} obj
     */

  }, {
    key: "Add",
    value: function Add(path, obj) {
      this._loadedObjects[path] = obj;
    }
    /**
     * Removes a loaded object by it's file path
     * @param {string} path
     */

  }, {
    key: "Remove",
    value: function Remove(path) {
      delete this._loadedObjects[path];
    }
    /**
     * Clears the loaded object object
     */

  }, {
    key: "Clear",
    value: function Clear() {
      this._loadedObjects = {};
    }
    /**
     * Unloads all loaded objects and then clears the loadedObject object
     */

  }, {
    key: "UnloadAndClear",
    value: function UnloadAndClear() {
      for (const path in this._loadedObjects) {
        if (this._loadedObjects.hasOwnProperty(path)) {
          this._loadedObjects[path].Unload();
        }
      }

      this._loadedObjects = {};
    }
    /**
     * Purges inactive loaded objects (resources that have been loaded but are not being actively used)
     * - Loaded objects can flagged with `doNotPurge` to ensure they are never removed
     * - Resource auto purging can be managed in `ccpwgl` or `ccpwgl_int.resMan` - {@link Tw2ResMan}
     *     ccpwgl.setResourceUnloadPolicy()
     *     ccpwgl_int.resMan.autoPurgeResources=true
     *     ccpwgl_int.resMan.purgeTime=30
     * @param {Number} curFrame - the current frame count
     * @param {Number} frameLimit - how many frames the object can stay alive for before being purged
     * @param {Number} frameDistance - how long the resource has been alive for
     */

  }, {
    key: "PurgeInactive",
    value: function PurgeInactive(curFrame, frameLimit, frameDistance) {
      for (const path in this._loadedObjects) {
        if (this._loadedObjects.hasOwnProperty(path)) {
          const res = this._loadedObjects[path];

          if (!res.doNotPurge) {
            if (res.IsPurged()) {
              res.OnUnloaded();
              this.Remove(path);
            }

            if (res._isGood && (curFrame - res.activeFrame) % frameLimit >= frameDistance) {
              if (res.Unload()) {
                res.OnUnloaded();
                this.Remove(path);
              }
            }
          }
        }
      }
    }
  }]);

  return Tw2MotherLode;
}();
// EXTERNAL MODULE: ./core/resource/Tw2LoadingObject.js
var Tw2LoadingObject = __webpack_require__(15);

// EXTERNAL MODULE: ./core/index.js + 60 modules
var core = __webpack_require__(1);

// CONCATENATED MODULE: ./global/engine/Tw2ResMan.js
function Tw2ResMan_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ResMan_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ResMan_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ResMan_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ResMan_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ResMan_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ResMan_assertThisInitialized(self); }

function Tw2ResMan_getPrototypeOf(o) { Tw2ResMan_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ResMan_getPrototypeOf(o); }

function Tw2ResMan_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ResMan_setPrototypeOf(subClass, superClass); }

function Tw2ResMan_setPrototypeOf(o, p) { Tw2ResMan_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ResMan_setPrototypeOf(o, p); }

function Tw2ResMan_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ResMan_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/**
 * Resource Manager
 *
 * @property {Tw2MotherLode} motherLode
 * @property {Boolean} systemMirror - Toggles whether {@link Tw2GeometryRes} Index and Buffer data arrays are visible
 * @property {Number} maxPrepareTime
 * @property {Boolean} autoPurgeResources=true - Sets whether resources should be purged automatically
 * @property {Number} purgeTime=30 = Sets how long resources can remain inactive before they are purged
 * @property {Number} activeFrame
 * @property {Number} _prepareBudget
 * @property {Array} _prepareQueue
 * @property {Number} _purgeTime
 * @property {Number} _purgeFrame
 * @property {Number} _purgeFrameLimit
 * @property {Number} _pendingLoads - a count of how many things are pending load
 * @property {Number} _noLoadFrames
 * @class
 */

let Tw2ResMan_Tw2ResMan =
/*#__PURE__*/
function (_Tw2EventEmitter) {
  Tw2ResMan_inherits(Tw2ResMan, _Tw2EventEmitter);

  function Tw2ResMan() {
    var _this;

    Tw2ResMan_classCallCheck(this, Tw2ResMan);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ResMan_possibleConstructorReturn(this, Tw2ResMan_getPrototypeOf(Tw2ResMan).call(this, ...args));

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "motherLode", new Tw2MotherLode());

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "systemMirror", false);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "maxPrepareTime", 0.05);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "autoPurgeResources", true);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "activeFrame", 0);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "purgeTime", 30);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_prepareBudget", 0);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_prepareQueue", []);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_purgeTime", 0);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_purgeFrame", 0);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_purgeFrameLimit", 1000);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_pendingLoads", 0);

    Tw2ResMan_defineProperty(Tw2ResMan_assertThisInitialized(Tw2ResMan_assertThisInitialized(_this)), "_noLoadFrames", 0);

    return _this;
  }

  Tw2ResMan_createClass(Tw2ResMan, [{
    key: "Set",

    /**
     * Sets resource manager options
     * @param {*} [opt]
     */
    value: function Set(opt) {
      if (!opt) return;
      Object(util["assignIfExists"])(this, opt, ['systemMirror', 'maxPrepareTime', 'autoPurgeResources', 'purgeTime']);
    }
    /**
     * Fires on resource errors
     * - Used when a resource can only be identified by it's path
     * @param {string} path
     * @param {Error} err
     * @returns {Error} err
     */

  }, {
    key: "OnResError",
    value: function OnResError(path) {
      let err = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new core["Tw2Error"]({
        path
      });
      path = Tw2ResMan.NormalizePath(path);
      const res = this.motherLode.Find(path);

      if (res) {
        res.OnError(err);
      } else {
        this.OnResEvent('error', path, {
          type: 'error',
          message: err.message,
          err
        });
      }

      return err;
    }
    /**
     * Fires on resource events
     * @param {string} eventName - The event's name
     * @param {string} path      - The resource's path
     * @param {*} [log={}]       - The event's log
     */

  }, {
    key: "OnResEvent",
    value: function OnResEvent(eventName, path) {
      let log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const defaultLog = Tw2ResMan.DefaultLog[eventName.toUpperCase()];

      if (defaultLog) {
        log = Object.assign({}, defaultLog, log);
        const eventData = {
          res: this.motherLode.Find(path),
          path,
          log
        };
        const err = log.err;

        if (err) {
          this.motherLode.AddError(path, err);
          eventData.err = err;
          Object.assign(eventData, err.data);
        }

        log.message = log.message.includes(path) ? log.message : log.message += ` "${path}"`;
        this.emit(eventName.toLowerCase(), eventData);
      }
    }
    /**
     * IsLoading
     * @returns {Boolean}
     *
     */

  }, {
    key: "IsLoading",
    value: function IsLoading() {
      return this._noLoadFrames < 2;
    }
    /**
     * Clears the motherLode {@link Tw2MotherLode}
     */

  }, {
    key: "Clear",
    value: function Clear() {
      this.motherLode.Clear();
    }
    /**
     * Unloads and Clears the motherLode {@link Tw2MotherLode}
     */

  }, {
    key: "UnloadAndClear",
    value: function UnloadAndClear() {
      this.motherLode.UnloadAndClear();
    }
    /**
     * Internal update function. It is called every frame.
     * @param {Number} dt - deltaTime
     * @returns {Boolean}
     */

  }, {
    key: "PrepareLoop",
    value: function PrepareLoop(dt) {
      if (this._prepareQueue.length === 0 && this._pendingLoads === 0) {
        if (this._noLoadFrames < 2) {
          this._noLoadFrames++;
        }
      } else {
        this._noLoadFrames = 0;
      }

      this._prepareBudget = this.maxPrepareTime;
      const startTime = Date.now();

      while (this._prepareQueue.length) {
        const res = this._prepareQueue[0][0],
              data = this._prepareQueue[0][1],
              xml = this._prepareQueue[0][2];

        this._prepareQueue.shift();

        try {
          res.Prepare(data, xml);
        } catch (err) {
          res.OnError(err);
        }

        this._prepareBudget -= (Date.now() - startTime) * 0.001;
        if (this._prepareBudget < 0) break;
      }

      this._purgeTime += dt;

      if (this._purgeTime > 1) {
        this.activeFrame += 1;
        this._purgeTime -= Math.floor(this._purgeTime);
        this._purgeFrame += 1;

        if (this._purgeFrame >= 5) {
          if (this.autoPurgeResources) {
            this.motherLode.PurgeInactive(this._purgeFrame, this._purgeFrameLimit, this.purgeTime);
          }
        }
      }

      return true;
    }
    /**
     * Gets a resource
     * @param {String} path
     * @returns {Tw2Resource} resource
     */

  }, {
    key: "GetResource",
    value: function GetResource(path) {
      let res;
      path = Tw2ResMan.NormalizePath(path); // Check if already loaded

      res = this.motherLode.Find(path);

      if (res) {
        if (res.IsPurged()) res.Reload();
        return res;
      }

      if (path.indexOf('dynamic:/') === 0) {
        this.OnResError(path, new core["ErrFeatureNotImplemented"]({
          feature: 'Dynamic resources'
        }));
        return null;
      }

      const extension = Tw2ResMan.GetPathExt(path);

      if (extension === null) {
        this.OnResError(path, new core["ErrResourceExtensionUndefined"]({
          path
        }));
        return null;
      }

      const Constructor = Tw2Store_store.GetExtension(extension);

      if (!Constructor) {
        this.OnResError(path, new core["ErrResourceExtensionUnregistered"]({
          path,
          extension
        }));
        return null;
      }

      try {
        res = new Constructor();
        res.path = path;
        return Tw2ResMan.LoadResource(this, res);
      } catch (err) {
        this.OnResError(path, err);
        return null;
      }
    }
    /**
     * Gets a resource object
     * @param {string} path
     * @param {Function} onResolved - Callback fired when the object has loaded
     * @param {Function} onRejected - Callback fired when the object fails to load
     */

  }, {
    key: "GetObject",
    value: function GetObject(path, onResolved, onRejected) {
      path = Tw2ResMan.NormalizePath(path); // Check if already loaded

      let res = this.motherLode.Find(path);

      if (res) {
        res.AddObject(onResolved, onRejected);
        return;
      }

      try {
        res = new Tw2LoadingObject["a" /* Tw2LoadingObject */]();
        res.path = path;
        res.AddObject(onResolved, onRejected);
        Tw2ResMan.LoadResource(this, res);
      } catch (err) {
        this.OnResError(path, err);
      }
    }
    /**
     * Reloads a resource
     * @param {Tw2Resource} resource
     * @returns {Tw2Resource} resource
     */

  }, {
    key: "ReloadResource",
    value: function ReloadResource(resource) {
      const path = resource.path; // Check if already loaded and good

      const res = this.motherLode.Find(path);

      if (res && !res.IsPurged()) {
        return res;
      }

      try {
        return Tw2ResMan.LoadResource(this, resource);
      } catch (err) {
        this.OnResError(path, err);
        return resource;
      }
    }
    /**
     * Builds a url from a resource path
     * @param {string} path
     * @returns {string}
     */

  }, {
    key: "BuildUrl",
    value: function BuildUrl(path) {
      const prefixIndex = path.indexOf(':/');

      if (prefixIndex === -1) {
        throw new core["ErrResourcePrefixUndefined"]({
          path
        });
      }

      const prefix = path.substr(0, prefixIndex);

      if (prefix === 'http' || prefix === 'https') {
        return path;
      }

      const fullPrefix = Tw2Store_store.GetPath(prefix);

      if (!fullPrefix) {
        throw new core["ErrResourcePrefixUnregistered"]({
          path,
          prefix
        });
      }

      return fullPrefix + path.substr(prefixIndex + 2);
    }
    /**
     * Normalizes a file path by making it lower case and replaces all '\\' with '/'
     * @param {string} path
     * @returns {string}
     */

  }], [{
    key: "NormalizePath",
    value: function NormalizePath(path) {
      if (path.substr(0, 5) === 'str:/') return path;
      path = path.toLowerCase();
      path.replace('\\', '/');
      return path;
    }
    /**
     * Gets a path's extension
     * @param {string} path
     * @returns {?string}
     */

  }, {
    key: "GetPathExt",
    value: function GetPathExt(path) {
      if (path.substr(0, 5) === 'str:/') {
        const slash = path.indexOf('/', 5);
        if (slash === -1) return null;
        return path.substr(5, slash - 5);
      } else {
        const dot = path.lastIndexOf('.');
        if (dot === -1) return null;
        return path.substr(dot + 1);
      }
    }
    /**
     * Loads a resource
     * @param {Tw2ResMan} resMan
     * @param {Tw2Resource|Tw2LoadingObject} res
     * @returns {Tw2Resource|Tw2LoadingObject} res
     */

  }, {
    key: "LoadResource",
    value: function LoadResource(resMan, res) {
      const path = res.path,
            url = resMan.BuildUrl(path);
      resMan.motherLode.Add(path, res);

      if (res.DoCustomLoad && res.DoCustomLoad(url, Tw2ResMan.GetPathExt(url))) {
        return res;
      }

      const httpRequest = Tw2ResMan.CreateHttpRequest(res);
      httpRequest.onreadystatechange = Tw2ResMan.DoLoadResource(resMan, res);
      httpRequest.open('GET', url);

      try {
        httpRequest.send();
        resMan._pendingLoads++;
        res.OnRequested();
      } catch (err) {
        throw new core["ErrHTTPRequestSend"]({
          path
        });
      }

      return res;
    }
    /**
     * Creates an onreadystatechange callback
     * @param {Tw2ResMan} resMan
     * @param {Tw2Resource} res
     */

  }, {
    key: "DoLoadResource",
    value: function DoLoadResource(resMan, res) {
      const path = res.path;
      return function () {
        let readyState = 0;

        try {
          readyState = this.readyState;
        } catch (err) {
          resMan._pendingLoads--;
          res.OnError(new core["ErrHTTPReadyState"]({
            path
          }));
          return;
        }

        if (readyState === 4) {
          const status = this.status;

          if (status === 200) {
            let data = null,
                xml = null;

            try {
              data = this.responseText;
              xml = this.responseXML;
            } catch (e) {
              data = this.response;
            }

            resMan._prepareQueue.push([res, data, xml]);

            res.OnLoaded();
          } else {
            res.OnError(new core["ErrHTTPStatus"]({
              path,
              status
            }));
          }

          resMan._pendingLoads--;
        }
      };
    }
    /**
     * Creates an HTTP request
     * @param {Tw2Resource} res
     * @returns {XMLHttpRequest|ActiveXObject}
     */

  }, {
    key: "CreateHttpRequest",
    value: function CreateHttpRequest(res) {
      let httpRequest = null;

      if (window.XMLHttpRequest) {
        // Mozilla, Safari, ...
        httpRequest = new XMLHttpRequest();
      } else if (window.ActiveXObject) {
        // IE
        try {
          httpRequest = new window['ActiveXObject']('Msxml2.XMLHTTP');
        } catch (e) {
          try {
            httpRequest = new window['ActiveXObject']('Microsoft.XMLHTTP');
          } catch (e) {
            /*eslint-disable-line-no-empty*/
          }
        }
      }

      if (!httpRequest) {
        throw new core["ErrHTTPInstance"]({
          path: res.path
        });
      } else if (res.requestResponseType) {
        httpRequest.responseType = res.requestResponseType;
      }

      return httpRequest;
    } // Default log outputs for resource events

  }]);

  return Tw2ResMan;
}(Tw2EventEmitter["a" /* Tw2EventEmitter */]); // Global instance of Tw2ResMan

Tw2ResMan_defineProperty(Tw2ResMan_Tw2ResMan, "DefaultLog", {
  ERROR: {
    type: 'error',
    message: 'Uncaught error'
  },
  WARNING: {
    type: 'warn',
    message: 'Undefined warning'
  },
  REQUESTED: {
    type: 'info',
    message: 'Requested'
  },
  RELOADING: {
    type: 'info',
    message: 'Reloading'
  },
  LOADED: {
    type: 'info',
    message: 'Loaded'
  },
  PREPARED: {
    type: 'log',
    message: 'Prepared'
  },
  PURGED: {
    type: 'info',
    message: 'Purged'
  },
  UNLOADED: {
    type: 'info',
    message: 'Unloaded'
  },
  DEBUG: {
    type: 'debug',
    message: 'Debug'
  }
});

Tw2ResMan_defineProperty(Tw2ResMan_Tw2ResMan, "category", 'resource_manager');

const Tw2ResMan_resMan = new Tw2ResMan_Tw2ResMan();
// CONCATENATED MODULE: ./global/engine/Tw2Store.js
function Tw2Store_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Store_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Store_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Store_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Store_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Store_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Store_assertThisInitialized(self); }

function Tw2Store_getPrototypeOf(o) { Tw2Store_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Store_getPrototypeOf(o); }

function Tw2Store_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Store_setPrototypeOf(subClass, superClass); }

function Tw2Store_setPrototypeOf(o, p) { Tw2Store_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Store_setPrototypeOf(o, p); }

function Tw2Store_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * Stores engine data
 *
 * @property {Object.< string, string>} _path
 * @property {Object.< string, Array<string>>} _dynamicPath
 * @property {Object.< string, Tw2Parameter>} _variable
 * @property {Object.< string, Function>} _type
 * @property {Object.< string, Function>} _extension
 * @property {Object.< string, Function>} _class
 * @property {Object.< string, Tw2Schema>} _schema
 * @property {Object.< string, Array<string>>} _missing
 * @class
 */

let Tw2Store_Tw2Store =
/*#__PURE__*/
function (_Tw2EventEmitter) {
  Tw2Store_inherits(Tw2Store, _Tw2EventEmitter);

  function Tw2Store() {
    var _this;

    Tw2Store_classCallCheck(this, Tw2Store);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2Store_possibleConstructorReturn(this, Tw2Store_getPrototypeOf(Tw2Store).call(this, ...args));

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_type", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_path", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_variable", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_extension", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_class", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_dynamicPath", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_schema", {});

    Tw2Store_defineProperty(Tw2Store_assertThisInitialized(Tw2Store_assertThisInitialized(_this)), "_missing", {});

    return _this;
  }

  Tw2Store_createClass(Tw2Store, [{
    key: "HasPath",

    /**
     * Checks if a resource path exists
     * @param {string} prefix
     * @returns {boolean}
     */
    value: function HasPath(prefix) {
      return prefix && prefix in this._path;
    }
    /**
     * Gets a path by it's prefix
     * @param {string} prefix
     * @returns {?string}
     */

  }, {
    key: "GetPath",
    value: function GetPath(prefix) {
      return Tw2Store.GetStoreItem(this, 'path', prefix);
    }
    /**
     * Registers a resource path
     * @param {string} prefix
     * @param {string} path
     * @returns {boolean}
     */

  }, {
    key: "RegisterPath",
    value: function RegisterPath(prefix, path) {
      if (path.lastIndexOf('/') !== path.length - 1) {
        path += '/';
      }

      if (Tw2Store.RestrictedPathPrefixes.includes(prefix)) {
        this.emit('error', {
          type: 'path',
          key: prefix,
          value: path,
          log: {
            type: 'error',
            message: `Cannot register restricted prefix "${prefix}"`
          }
        });
        return false;
      }

      return Tw2Store.SetStoreItem(this, 'path', prefix, path, util["isString"]);
    }
    /**
     * Registers resource paths from an object or an array of objects
     * @param {{string:string}|Array<{string:string}>} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterPaths",
    value: function RegisterPaths(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterPath', obj);
    }
    /**
     * Checks if a dynamic path exists
     * @param {string} prefix
     * @returns {boolean}
     */

  }, {
    key: "HasDynamicPath",
    value: function HasDynamicPath(prefix) {
      return prefix && prefix in this._dynamicPath;
    }
    /**
     * Gets a dynamic path by it's prefix
     * @param {string} prefix
     * @returns {?Array<string>}
     */

  }, {
    key: "GetDynamicPath",
    value: function GetDynamicPath(prefix) {
      return Tw2Store.GetStoreItem(this, 'dynamicPath', prefix);
    }
    /**
     * Registers a dynamic path
     * @param {string} prefix
     * @param {string[]} paths
     * @returns {boolean}
     */

  }, {
    key: "RegisterDynamicPath",
    value: function RegisterDynamicPath(prefix, paths) {
      return Tw2Store.SetStoreItem(this, 'dynamicPath', prefix, paths, util["isArray"]);
    }
    /**
     * Registers dynamic paths from an object or array of objects
     * @param {{string:string[]}|Array<{string:string[]}>} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterDynamicPaths",
    value: function RegisterDynamicPaths(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterDynamicPath', obj);
    }
    /**
     * Checks if an extension exists
     * @param {string} ext
     * @returns {boolean}
     */

  }, {
    key: "HasExtension",
    value: function HasExtension(ext) {
      return ext && ext in this._extension;
    }
    /**
     * Gets a resource extension by name
     * @param {string} ext
     * @returns {?Function}
     */

  }, {
    key: "GetExtension",
    value: function GetExtension(ext) {
      return Tw2Store.GetStoreItem(this, 'extension', ext);
    }
    /**
     * Registers a resource extension
     * @param {string} ext
     * @param {Function} Constructor
     * @returns {boolean}
     */

  }, {
    key: "RegisterExtension",
    value: function RegisterExtension(ext, Constructor) {
      return Tw2Store.SetStoreItem(this, 'extension', ext, Constructor, util["isFunction"]);
    }
    /**
     * Registers resource extensions from an object or array of objects
     * @param {{string:Function}|Array<{string:Function}>} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterExtensions",
    value: function RegisterExtensions(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterExtension', obj);
    }
    /**
     * Checks if a constructor exists
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasClass",
    value: function HasClass(name) {
      return name && name in this._class;
    }
    /**
     * Gets a library constructor by name
     * @param {string} name
     * @returns {?Function}
     */

  }, {
    key: "GetClass",
    value: function GetClass(name) {
      let Constructor = Tw2Store.GetStoreItem(this, 'class', name); // Allow substitution of Trinity constructors with Tw2 constructors

      if (!Constructor && (name.includes('Tr2') || name.includes('Tri'))) {
        const substitute = 'Tw2' + name.substring(3);
        Constructor = Tw2Store.GetStoreItem(this, 'class', substitute);

        if (Constructor) {
          this.emit('substitute', {
            type: 'class',
            key: substitute,
            originalKey: name,
            value: Constructor,
            log: {
              type: 'warning',
              message: `"${name}" class not found, substituting with "${substitute}"`
            }
          });
        }
      } // Create a warning when a partially implemented class is called


      if (Constructor && Constructor.partialImplementation) {
        this.emit('partial', {
          type: 'class',
          key: name,
          value: Constructor,
          log: {
            type: 'warning',
            message: `"${name}" class partially implemented`
          }
        });
      }

      return Constructor;
    }
    /**
     * Registers library constructors
     * @param {string} name
     * @param {Function} Constructor
     * @returns {boolean}
     */

  }, {
    key: "RegisterClass",
    value: function RegisterClass(name, Constructor) {
      return Tw2Store.SetStoreItem(this, 'class', name, Constructor, util["isFunction"]);
    }
    /**
     * Registers library constructors from an object or array of objects
     * @param {{string:Function}|Array<{string:Function}>} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterClasses",
    value: function RegisterClasses(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterClass', obj);
    }
    /**
     * Checks if a variable exists
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasVariable",
    value: function HasVariable(name) {
      return name && name in this._variable;
    }
    /**
     * Gets a variable by name
     * @param {string} name
     * @returns {?*}
     */

  }, {
    key: "GetVariable",
    value: function GetVariable(name) {
      return Tw2Store.GetStoreItem(this, 'variable', name);
    }
    /**
     * Gets a variable's value
     * @param {string} name
     * @param {boolean} [serialize]
     * @returns {?*} null if the variable doesn't exist or it does but it has no GetValue method
     */

  }, {
    key: "GetVariableValue",
    value: function GetVariableValue(name, serialize) {
      const variable = this.GetVariable(name);
      return variable && variable.GetValue ? variable.GetValue(serialize) : null;
    }
    /**
     * Sets a variable's value
     * @param {string} name
     * @param {*} value
     * @returns {?boolean} null if the variable doesn't exist or it does but has no SetValue method
     */

  }, {
    key: "SetVariableValue",
    value: function SetVariableValue(name, value) {
      const variable = this.GetVariable(name);

      if (variable && variable.SetValue) {
        variable.SetValue(value);
        return true;
      }

      return null;
    }
    /**
     * Registers a variable
     * @param {string} name
     * @param {*|{value:*, Type: string|Function}} [value]
     * @param {string|Function} [Type]
     * @returns {?*}
     */

  }, {
    key: "RegisterVariable",
    value: function RegisterVariable(name, value, Type) {
      const variable = this.CreateType(name, value, Type);
      Tw2Store.SetStoreItem(this, 'variable', name, variable);
      return variable;
    }
    /**
     * Registers variables from an object or array of objects
     * @param {{string:*|{value:*,type:string|Function}|Array<{string:*|{value:*,type:string|Function}>}} obj
     */

  }, {
    key: "RegisterVariables",
    value: function RegisterVariables(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterVariable', obj);
    }
    /**
     * Gets a parameter constructor by it's short name
     * @param {string} name
     * @returns {?Function}
     */

  }, {
    key: "GetType",
    value: function GetType(name) {
      return Tw2Store.GetStoreItem(this, 'type', name);
    }
    /**
     * Checks if a type exists
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasType",
    value: function HasType(name) {
      return name && name in this._type;
    }
    /**
     * Gets a type by value
     * @param {*} value
     * @returns {?Function}
     */

  }, {
    key: "GetTypeByValue",
    value: function GetTypeByValue(value) {
      for (let type in this._type) {
        if (this._type.hasOwnProperty(type) && 'isValue' in this._type[type]) {
          if (this._type[type]['isValue'](value)) {
            return this._type[type];
          }
        }
      }

      return null;
    }
    /**
     * Creates a type by value and/or type name or function
     * @param {string} name
     * @param {?*} [value]
     * @param {?|string|Function} [Type]
     * @returns {?*} new parameter
     */

  }, {
    key: "CreateType",
    value: function CreateType(name, value, Type) {
      if (Object(util["isPlain"])(value)) {
        Type = value['Type'] || value['type'];
        value = value['value'];
      }

      if (!Type) {
        Type = this.GetTypeByValue(value);
      }

      if (Object(util["isString"])(Type)) {
        Type = this.GetType(Type);
      }

      if (Object(util["isFunction"])(Type)) {
        return new Type(name, value);
      }

      return null;
    }
    /**
     * Registers a parameter type
     * @param {string} name
     * @param {Function} Constructor
     * @returns {boolean}
     */

  }, {
    key: "RegisterType",
    value: function RegisterType(name, Constructor) {
      return Tw2Store.SetStoreItem(this, 'type', name, Constructor, util["isFunction"]);
    }
    /**
     * Registers parameter types from an object or array of objects
     * @param {{string: Function}|[{string:Function}]} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterTypes",
    value: function RegisterTypes(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterType', obj);
    }
    /**
     * Checks if a schema exists
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasSchema",
    value: function HasSchema(name) {
      return name && name in this._schema;
    }
    /**
     * Gets a schema by it's name
     * @param {string} name
     * @returns {?string}
     */

  }, {
    key: "GetSchema",
    value: function GetSchema(name) {
      return Tw2Store.GetStoreItem(this, 'schema', name);
    }
    /**
     * Registers a schema
     * @param {string} name
     * @param {string} schema
     * @returns {boolean}
     */

  }, {
    key: "RegisterSchema",
    value: function RegisterSchema(name, schema) {
      return Tw2Store.SetStoreItem(this, 'schema', name, schema, a => {
        return a && a.constructor.name === 'Tw2Schema';
      });
    }
    /**
     * Registers schemas from an object or an array of objects
     * @param {{string:string}|Array<{string:string}>} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterSchemas",
    value: function RegisterSchemas(obj) {
      return Tw2Store.RegisterFromObject(this, 'RegisterSchema', obj);
    }
    /**
     * Registers store values
     * @param {{}} [opt={}]
     * @param {boolean} [opt.uuid]
     * @param {*} opt.logger
     * @param {*} opt.paths
     * @param {*} opt.dynamicPaths
     * @param {*} opt.types
     * @param {*} opt.classes
     * @param {*} opt.extensions
     * @param {*} opt.variables
     * @param {*} opt.schemas
     */

  }, {
    key: "Register",
    value: function Register() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if ('uuid' in opt) Object(util["enableUUID"])(opt.uuid);
      if ('logger' in opt) logger.Set(opt.logger);
      if ('resMan' in opt) Tw2ResMan_resMan.Set(opt.resMan);
      this.RegisterPaths(opt.paths);
      this.RegisterDynamicPaths(opt.dynamicPaths);
      this.RegisterTypes(opt.types);
      this.RegisterClasses(opt.classes);
      this.RegisterExtensions(opt.extensions);
      this.RegisterVariables(opt.variables);
      this.RegisterSchemas(opt.schemas);
    }
    /**
     * Gets a value from a store
     * - Records missing keys for debugging
     * @param {Tw2Store} store
     * @param {string} type
     * @param {string} key
     * @returns {?*}
     */

  }], [{
    key: "GetStoreItem",
    value: function GetStoreItem(store, type, key) {
      const storeSet = store['_' + type];

      if (storeSet && Object(util["isString"])(key)) {
        if (key in storeSet) {
          return storeSet[key];
        }

        if (!store._missing[type]) {
          store._missing[type] = [];
        }

        if (!store._missing[type].includes(key)) {
          store._missing[type].push(key);
        }

        store.emit('missing', {
          type,
          key,
          log: {
            type: 'debug',
            message: `Missing ${type}: "${key}"`
          }
        });
      }

      return null;
    }
    /**
     * Sets a store value
     * @param {Tw2Store} store
     * @param {string} type
     * @param {string} key
     * @param {*} value
     * @param {Function} [validator]
     * @returns {boolean} true if successful
     */

  }, {
    key: "SetStoreItem",
    value: function SetStoreItem(store, type) {
      let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      let value = arguments.length > 3 ? arguments[3] : undefined;
      let validator = arguments.length > 4 ? arguments[4] : undefined;

      if (validator && !validator(value)) {
        store.emit('error', {
          type,
          key,
          value,
          log: {
            type: 'error',
            message: `Invalid ${type}: "${key}"`
          }
        });
        return false;
      }

      const storeSet = store['_' + type];

      if (storeSet && Object(util["isString"])(key) && !Object(util["isUndefined"])(value)) {
        const oldValue = storeSet[key];
        storeSet[key] = value;
        store.emit('registered', {
          type,
          key,
          value,
          oldValue,
          log: {
            type: 'debug',
            message: `${oldValue ? 'Re-registered' : 'Registered'} ${type} "${key}"`
          }
        });
        return true;
      }

      return false;
    }
    /**
     * Converts an object or array of objects into single function calls
     * @param {Tw2Store} store
     * @param {string} funcName
     * @param {Array|Object} obj
     * @returns {boolean}
     */

  }, {
    key: "RegisterFromObject",
    value: function RegisterFromObject(store, funcName, obj) {
      if (obj && funcName in store) {
        obj = Object(util["toArray"])(obj);

        for (let i = 0; i < obj.length; i++) {
          for (let key in obj[i]) {
            if (obj[i].hasOwnProperty(key)) {
              store[funcName](key, obj[i][key]);
            }
          }
        }

        return true;
      }

      return false;
    }
    /**
     * Restricted path prefixes
     * @type {string[]}
     */

  }]);

  return Tw2Store;
}(Tw2EventEmitter["a" /* Tw2EventEmitter */]);

Tw2Store_defineProperty(Tw2Store_Tw2Store, "RestrictedPathPrefixes", ['dynamic', 'rgba']);

Tw2Store_defineProperty(Tw2Store_Tw2Store, "category", 'variable_store');

const Tw2Store_store = new Tw2Store_Tw2Store();
// EXTERNAL MODULE: ./core/mesh/Tw2Effect.js
var Tw2Effect = __webpack_require__(13);

// EXTERNAL MODULE: ./core/vertex/index.js + 2 modules
var vertex = __webpack_require__(7);

// CONCATENATED MODULE: ./global/engine/Tw2Constant.js
/*

    Webgl & Webgl2

*/
const GL_COLOR_BUFFER_BIT = 16384;
const GL_DEPTH_BUFFER_BIT = 256;
const GL_STENCIL_BUFFER_BIT = 1024;
const GL_TEXTURE_2D = 3553;
const GL_TEXTURE_CUBE_MAP = 34067;
const GL_TEXTURE_3D = 32879;
const GL_TEXTURE_MAG_FILTER = 10240;
const GL_TEXTURE_MIN_FILTER = 10241;
const GL_TEXTURE_WRAP_S = 10242;
const GL_TEXTURE_WRAP_T = 10243;
const GL_BYTE = 5120;
const GL_UNSIGNED_BYTE = 5121;
const GL_SHORT = 5122;
const GL_UNSIGNED_SHORT = 5123;
const GL_INT = 5124;
const GL_UNSIGNED_INT = 5125;
const GL_FLOAT = 5126;
const GL_HALF_FLOAT_OES = 36193; //webgl only

const GL_HALF_FLOAT = 5131; //webgl2

const GL_DEPTH_COMPONENT16 = 33189; //webgl2

const GL_DEPTH_COMPONENT24 = 33190; //webgl2

const GL_DEPTH_COMPONENT32F = 36012; //webgl2

const GL_FLOAT_VEC2 = 35664;
const GL_FLOAT_VEC3 = 35665;
const GL_FLOAT_VEC4 = 35666;
const GL_INT_VEC2 = 35667;
const GL_INT_VEC3 = 35668;
const GL_INT_VEC4 = 35669;
const GL_BOOL = 35670;
const GL_BOOL_VEC2 = 35671;
const GL_BOOL_VEC3 = 35672;
const GL_BOOL_VEC4 = 35673;
const GL_FLOAT_MAT2 = 35674;
const GL_FLOAT_MAT3 = 35675;
const GL_FLOAT_MAT4 = 35676;
const GL_TYPE_LENGTH = {
  [GL_FLOAT]: 1,
  [GL_INT]: 1,
  [GL_BYTE]: 1,
  [GL_BOOL]: 1,
  [GL_FLOAT_VEC2]: 2,
  [GL_INT_VEC2]: 2,
  [GL_BOOL_VEC2]: 2,
  [GL_FLOAT_VEC3]: 3,
  [GL_INT_VEC3]: 3,
  [GL_BOOL_VEC3]: 3,
  [GL_FLOAT_VEC4]: 4,
  [GL_INT_VEC4]: 4,
  [GL_BOOL_VEC4]: 4,
  [GL_FLOAT_MAT3]: 9,
  [GL_FLOAT_MAT4]: 16
};
const GL_SAMPLER_2D = 35678;
const GL_SAMPLER_3D = 35679;
const GL_SAMPLER_CUBE = 35680;
const GL_DEPTH_COMPONENT = 6402;
const GL_ALPHA = 6406;
const GL_RGB = 6407;
const GL_RGBA = 6408;
const GL_LUMINANCE = 6409;
const GL_LUMINANCE_ALPHA = 6410;
const GL_DEPTH_STENCIL = 34041;
const GL_UNSIGNED_INT_24_8_WEBGL = 34042;
const GL_R8 = 33321; //webgl2

const GL_R16F = 33325; //webgl2

const GL_R32F = 33326; //webgl2

const GL_R8UI = 33330; //webgl2

const GL_RG8 = 33323; //webgl2

const GL_RG16F = 33327; //webgl2

const GL_RG32F = 33328; //webgl2

const GL_RGB8 = 32849; //webgl2

const GL_SRGB8 = 35905; //webgl2

const GL_RGB565 = 36194; //webgl2

const GL_R11F_G11F_B10F = 35898; //webgl2

const GL_RGB9_E5 = 35901; //webgl2

const GL_RGB16F = 34843; //webgl2

const GL_RGB32F = 34837; //webgl2

const GL_RGB8UI = 36221; //webgl2

const GL_RGBA8 = 32856; //webgl2

const GL_RGB5_A1 = 32855; //webgl2

const GL_RGBA16F = 34842; //webgl2

const GL_RGBA32F = 34836; //webgl2

const GL_RGBA8UI = 36220; //webgl2

const GL_RGBA16I = 36232; //webgl2

const GL_RGBA16UI = 36214; //webgl2

const GL_RGBA32I = 36226; //webgl2

const GL_RGBA32UI = 36208; //webgl2

const GL_NEAREST = 9728;
const GL_LINEAR = 9729;
const GL_NEAREST_MIPMAP_NEAREST = 9984;
const GL_LINEAR_MIPMAP_NEAREST = 9985;
const GL_NEAREST_MIPMAP_LINEAR = 9986;
const GL_LINEAR_MIPMAP_LINEAR = 9987;
const GL_REPEAT = 10497;
const GL_CLAMP_TO_EDGE = 33071;
const GL_MIRRORED_REPEAT = 33648;
const GL_ZERO = 0;
const GL_ONE = 1;
const GL_SRC_COLOR = 768;
const GL_ONE_MINUS_SRC_COLOR = 769;
const GL_SRC_ALPHA = 770;
const GL_ONE_MINUS_SRC_ALPHA = 771;
const GL_DST_ALPHA = 772;
const GL_ONE_MINUS_DST_ALPHA = 773;
const GL_DST_COLOR = 774;
const GL_ONE_MINUS_DST_COLOR = 775;
const GL_SRC_ALPHA_SATURATE = 776;
const GL_CONSTANT_COLOR = 32769;
const GL_ONE_MINUS_CONSTANT_COLOR = 32770;
const GL_CONSTANT_ALPHA = 32771;
const GL_ONE_MINUS_CONSTANT_ALPHA = 32772;
const GL_VERTEX_SHADER = 35633;
const GL_FRAGMENT_SHADER = 35632;
const GL_FRONT = 1028;
const GL_BACK = 1029;
const GL_FRONT_AND_BACK = 1032;
const GL_NEVER = 512;
const GL_LESS = 513;
const GL_EQUAL = 514;
const GL_LEQUAL = 515;
const GL_GREATER = 516;
const GL_NOTEQUAL = 517;
const GL_GEQUAL = 518;
const GL_ALWAYS = 519;
const GL_KEEP = 7680;
const GL_REPLACE = 7681;
const GL_INCR = 7682;
const GL_DECR = 7683;
const GL_INCR_WRAP = 34055;
const GL_DECR_WRAP = 34056;
const GL_INVERT = 5386;
const GL_STREAM_DRAW = 35040;
const GL_STATIC_DRAW = 35044;
const GL_DYNAMIC_DRAW = 35048;
const GL_ARRAY_BUFFER = 34962;
const GL_ELEMENT_ARRAY_BUFFER = 34963;
const GL_POINTS = 0;
const GL_LINES = 1;
const GL_LINE_LOOP = 2;
const GL_LINE_STRIP = 3;
const GL_TRIANGLES = 4;
const GL_TRIANGLE_STRIP = 5;
const GL_TRIANGLE_FAN = 6;
const GL_CW = 2304;
const GL_CCW = 2305;
const GL_CULL_FACE = 2884;
const GL_DEPTH_TEST = 2929;
const GL_BLEND = 3042;
/*

    Direct 3D and CCP

*/
// Render Mode

const RM_ANY = -1;
const RM_OPAQUE = 0;
const RM_DECAL = 1;
const RM_TRANSPARENT = 2;
const RM_ADDITIVE = 3;
const RM_DEPTH = 4;
const RM_FULLSCREEN = 5;
const RM_PICKABLE = 6;
const RM_DISTORTION = 7; // Render States

const RS_ZENABLE = 7; // D3DZBUFFERTYPE (or TRUE/FALSE for legacy)

const RS_FILLMODE = 8; // D3DFILLMODE

const RS_SHADEMODE = 9; // D3DSHADEMODE

const RS_ZWRITEENABLE = 14; // TRUE to enable z writes

const RS_ALPHATESTENABLE = 15; // TRUE to enable alpha tests

const RS_LASTPIXEL = 16; // TRUE for last-pixel on lines

const RS_SRCBLEND = 19; // D3DBLEND

const RS_DESTBLEND = 20; // D3DBLEND

const RS_CULLMODE = 22; // D3DCULL

const RS_ZFUNC = 23; // D3DCMPFUNC

const RS_ALPHAREF = 24; // D3DFIXED

const RS_ALPHAFUNC = 25; // D3DCMPFUNC

const RS_DITHERENABLE = 26; // TRUE to enable dithering

const RS_ALPHABLENDENABLE = 27; // TRUE to enable alpha blending

const RS_FOGENABLE = 28; // TRUE to enable fog blending

const RS_SPECULARENABLE = 29; // TRUE to enable specular

const RS_FOGCOLOR = 34; // D3DCOLOR

const RS_FOGTABLEMODE = 35; // D3DFOGMODE

const RS_FOGSTART = 36; // Fog start (for both vertex and pixel fog)

const RS_FOGEND = 37; // Fog end

const RS_FOGDENSITY = 38; // Fog density

const RS_RANGEFOGENABLE = 48; // Enables range-based fog

const RS_STENCILENABLE = 52; // BOOL enable/disable stenciling

const RS_STENCILFAIL = 53; // D3DSTENCILOP to do if stencil test fails

const RS_STENCILZFAIL = 54; // D3DSTENCILOP to do if stencil test passes and Z test fails

const RS_STENCILPASS = 55; // D3DSTENCILOP to do if both stencil and Z tests pass

const RS_STENCILFUNC = 56; // D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true

const RS_STENCILREF = 57; // Reference value used in stencil test

const RS_STENCILMASK = 58; // Mask value used in stencil test

const RS_STENCILWRITEMASK = 59; // Write mask applied to values written to stencil buffer

const RS_TEXTUREFACTOR = 60; // D3DCOLOR used for multi-texture blend

const RS_WRAP0 = 128; // wrap for 1st texture coord. set

const RS_WRAP1 = 129; // wrap for 2nd texture coord. set

const RS_WRAP2 = 130; // wrap for 3rd texture coord. set

const RS_WRAP3 = 131; // wrap for 4th texture coord. set

const RS_WRAP4 = 132; // wrap for 5th texture coord. set

const RS_WRAP5 = 133; // wrap for 6th texture coord. set

const RS_WRAP6 = 134; // wrap for 7th texture coord. set

const RS_WRAP7 = 135; // wrap for 8th texture coord. set

const RS_CLIPPING = 136;
const RS_LIGHTING = 137;
const RS_AMBIENT = 139;
const RS_FOGVERTEXMODE = 140;
const RS_COLORVERTEX = 141;
const RS_LOCALVIEWER = 142;
const RS_NORMALIZENORMALS = 143;
const RS_DIFFUSEMATERIALSOURCE = 145;
const RS_SPECULARMATERIALSOURCE = 146;
const RS_AMBIENTMATERIALSOURCE = 147;
const RS_EMISSIVEMATERIALSOURCE = 148;
const RS_VERTEXBLEND = 151;
const RS_CLIPPLANEENABLE = 152;
const RS_POINTSIZE = 154; // float point size

const RS_POINTSIZE_MIN = 155; // float point size min threshold

const RS_POINTSPRITEENABLE = 156; // BOOL point texture coord control

const RS_POINTSCALEENABLE = 157; // BOOL point size scale enable

const RS_POINTSCALE_A = 158; // float point attenuation A value

const RS_POINTSCALE_B = 159; // float point attenuation B value

const RS_POINTSCALE_C = 160; // float point attenuation C value

const RS_MULTISAMPLEANTIALIAS = 161; // BOOL - set to do FSAA with multisample buffer

const RS_MULTISAMPLEMASK = 162; // DWORD - per-sample enable/disable

const RS_PATCHEDGESTYLE = 163; // Sets whether patch edges will use float style tessellation

const RS_DEBUGMONITORTOKEN = 165; // DEBUG ONLY - token to debug monitor

const RS_POINTSIZE_MAX = 166; // float point size max threshold

const RS_INDEXEDVERTEXBLENDENABLE = 167;
const RS_COLORWRITEENABLE = 168; // per-channel write enable

const RS_TWEENFACTOR = 170; // float tween factor

const RS_BLENDOP = 171; // D3DBLENDOP setting

const RS_POSITIONDEGREE = 172; // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)

const RS_NORMALDEGREE = 173; // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC

const RS_SCISSORTESTENABLE = 174;
const RS_SLOPESCALEDEPTHBIAS = 175;
const RS_ANTIALIASEDLINEENABLE = 176;
const RS_TWOSIDEDSTENCILMODE = 185; // BOOL enable/disable 2 sided stenciling

const RS_CCW_STENCILFAIL = 186; // D3DSTENCILOP to do if ccw stencil test fails

const RS_CCW_STENCILZFAIL = 187; // D3DSTENCILOP to do if ccw stencil test passes and Z test fails

const RS_CCW_STENCILPASS = 188; // D3DSTENCILOP to do if both ccw stencil and Z tests pass

const RS_CCW_STENCILFUNC = 189; // D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true

const RS_COLORWRITEENABLE1 = 190; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS

const RS_COLORWRITEENABLE2 = 191; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS

const RS_COLORWRITEENABLE3 = 192; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS

const RS_BLENDFACTOR = 193; // D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR

const RS_SRGBWRITEENABLE = 194; // Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE)

const RS_DEPTHBIAS = 195;
const RS_SEPARATEALPHABLENDENABLE = 206; // TRUE to enable a separate blending function for the alpha channel

const RS_SRCBLENDALPHA = 207; // SRC blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE

const RS_DESTBLENDALPHA = 208; // DST blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE

const RS_BLENDOPALPHA = 209; // Blending operation for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE */// Cull Modes

const CULL_NONE = 1;
const CULL_CW = 2;
const CULL_CCW = 3; // Compare

const CMP_NEVER = 1;
const CMP_LESS = 2;
const CMP_EQUAL = 3;
const CMP_LEQUAL = 4;
const CMP_GREATER = 5;
const CMP_NOTEQUAL = 6;
const CMP_GREATEREQUAL = 7;
const CMP_ALWAYS = 8; // Blend

const BLEND_ZERO = 1;
const BLEND_ONE = 2;
const BLEND_SRCCOLOR = 3;
const BLEND_INVSRCCOLOR = 4;
const BLEND_SRCALPHA = 5;
const BLEND_INVSRCALPHA = 6;
const BLEND_DESTALPHA = 7;
const BLEND_INVDESTALPHA = 8;
const BLEND_DESTCOLOR = 9;
const BLEND_INVDESTCOLOR = 10;
const BLEND_SRCALPHASAT = 11;
const BLEND_BOTHSRCALPHA = 12;
const BLEND_BOTHINVSRCALPHA = 13;
const BLEND_BLENDFACTOR = 14;
const BLEND_INVBLENDFACTOR = 15; // Blend Operations

const BLENDOP_ADD = 1;
const BLENDOP_SUBTRACT = 2;
const BLENDOP_REVSUBTRACT = 3;
const BLENDOP_MIN = 4;
const BLENDOP_MAX = 5; // Texture format aliases

const TF_ALPHA = 0;
const TF_LUMINANCE = 1;
const TF_LUMINANCE_ALPHA = 2;
const TF_RGB = 4;
const TF_RGBA = 5;
const TF_RED = 6;
const TF_R = 6;
const TF_RG = 7;
const TF_RED_INTEGER = 8;
const TF_R_INTEGER = 8;
const TF_RG_INTEGER = 9;
const TF_RGB_INTEGER = 10;
const TF_RGBA_INTEGER = 11; // Texture types aliases

const TT_UNSIGNED_BYTE = 0;
const TT_UNSIGNED_INT = 0;
const TT_FLOAT = 1;
const TT_HALF_FLOAT = 2;
const TT_BYTE = 3;
const TT_SHORT = 4;
const TT_UNSIGNED_SHORT = 5;
const TT_INT = 6;
const TT_UNSIGNED_INTEGER = 7;
const TT_UNSIGNED_SHORT_4_4_4_4 = 8;
const TT_UNSIGNED_SHORT_5_5_5_1 = 9;
const TT_UNSIGNED_SHORT_5_6_5 = 10;
const TT_UNSIGNED_INT_2_10_10_10_REV = 11;
const TT_UNSIGNED_INT_24_8 = 12;
const TT_UNSIGNED_INT_10F_11F_11F_REV = 13;
const TT_UNSIGNED_INT_5_9_9_9_REV = 14;
const TT_FLOAT_32_UNSIGNED_INT_24_8_REV = 15; // Texture Wrap modes

const WrapModes = [0, GL_REPEAT, GL_MIRRORED_REPEAT, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE]; // Blend Table

const BlendTable = [-1, // --
GL_ZERO, // D3DBLEND_ZERO
GL_ONE, // D3DBLEND_ONE
GL_SRC_COLOR, // D3DBLEND_SRCCOLOR
GL_ONE_MINUS_SRC_COLOR, // D3DBLEND_INVSRCCOLOR
GL_SRC_ALPHA, // D3DBLEND_SRCALPHA
GL_ONE_MINUS_SRC_ALPHA, // D3DBLEND_INVSRCALPHA
GL_DST_ALPHA, // D3DBLEND_DESTALPHA
GL_ONE_MINUS_DST_ALPHA, // D3DBLEND_INVDESTALPHA
GL_DST_COLOR, // D3DBLEND_DESTCOLOR
GL_ONE_MINUS_DST_COLOR, // D3DBLEND_INVDESTCOLOR
GL_SRC_ALPHA_SATURATE, // D3DBLEND_SRCALPHASAT
-1, // D3DBLEND_BOTHSRCALPHA
-1, // D3DBLEND_BOTHINVSRCALPHA
GL_CONSTANT_COLOR, // D3DBLEND_BLENDFACTOR
GL_ONE_MINUS_CONSTANT_COLOR // D3DBLEND_INVBLENDFACTOR
]; // Filter mode conversions

const FilterMode = {
  [GL_NEAREST]: 1,
  [GL_LINEAR]: 2
}; // Mip filter mode conversions

const MipFilterMode = {
  [GL_NEAREST]: 0,
  [GL_LINEAR]: 0,
  [GL_NEAREST_MIPMAP_NEAREST]: 1,
  [GL_LINEAR_MIPMAP_NEAREST]: 1,
  [GL_NEAREST_MIPMAP_LINEAR]: 2,
  [GL_LINEAR_MIPMAP_LINEAR]: 2
};
/*

  Direct Draw Surface
  https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide

*/

const DDS_MAGIC = 0x20534444;
const DDSD_CAPS = 0x1;
const DDSD_HEIGHT = 0x2;
const DDSD_WIDTH = 0x4;
const DDSD_PITCH = 0x8;
const DDSD_PIXELFORMAT = 0x1000;
const DDSD_MIPMAPCOUNT = 0x20000;
const DDSD_LINEARSIZE = 0x80000;
const DDSD_DEPTH = 0x800000;
const DDSCAPS_COMPLEX = 0x8;
const DDSCAPS_MIPMAP = 0x400000;
const DDSCAPS_TEXTURE = 0x1000;
const DDSCAPS2_CUBEMAP = 0x200;
const DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
const DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
const DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
const DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
const DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
const DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
const DDSCAPS2_VOLUME = 0x200000;
const DDPF_ALPHAPIXELS = 0x1;
const DDPF_ALPHA = 0x2;
const DDPF_FOURCC = 0x4;
const DDPF_RGB = 0x40;
const DDPF_YUV = 0x200;
const DDPF_LUMINANCE = 0x20000;
const DDS_HEADER_LENGTH_INT = 31;
const DDS_HEADER_OFFSET_MAGIC = 0;
const DDS_HEADER_OFFSET_SIZE = 1;
const DDS_HEADER_OFFSET_FLAGS = 2;
const DDS_HEADER_OFFSET_HEIGHT = 3;
const DDS_HEADER_OFFSET_WIDTH = 4;
const DDS_HEADER_OFFSET_MIPMAP_COUNT = 7;
const DDS_HEADER_OFFSET_PF_FLAGS = 20;
const DDS_HEADER_OFFSET_PF_FOURCC = 21;
const DDS_HEADER_OFFSET_RGB_BPP = 22;
const DDS_HEADER_OFFSET_R_MASK = 23;
const DDS_HEADER_OFFSET_G_MASK = 24;
const DDS_HEADER_OFFSET_B_MASK = 25;
const DDS_HEADER_OFFSET_A_MASK = 26;
const DDS_HEADER_OFFSET_CAPS1 = 27;
const DDS_HEADER_OFFSET_CAPS2 = 28;
const DDS_HEADER_OFFSET_CAPS3 = 29;
const DDS_HEADER_OFFSET_CAPS4 = 30;
const DDS_HEADER_OFFSET_DXGI_FORMAT = 32;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT5 = 894720068;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT10 = 827611204;
const FOURCC_D3DFMT_R16G16B16A16F = 113;
const FOURCC_D3DFMT_R32G32B32A32F = 116;
const DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
const DXGI_FORMAT_B8G8R8X8_UNORM = 88;
/*

    Browser and Vendors

 */

/**
 * Vendor request animation frame names
 * @type {string[]}
 */

const VendorRequestAnimationFrame = ['requestAnimationFrame', 'webkitRequestAnimationFrame', 'mozRequestAnimationFrame', 'oRequestAnimationFrame', 'msRequestAnimationFrame'];
/**
 * Vendor cancel animation frame names
 * @type {string[]}
 */

const VendorCancelAnimationFrame = ['cancelAnimationFrame', 'webkitRequestAnimationFrame', 'mozRequestAnimationFrame', 'oRequestAnimationFrame', 'msRequestAnimationFrame'];
/**
 * Vendor request full screen
 * @type {string[]}
 */

const VendorRequestFullScreen = ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'];
/**
 * Vendor exit full screen
 * @type {string[]}
 */

const VendorExitFullScreen = ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'];
/**
 * Vendor get full screen element
 * @type {string[]}
 */

const VendorGetFullScreenElement = ['fullscreenElement', 'webkitFullscreenElement', 'mozFullScreenElement', 'msFullscreenElement'];
/**
 * Webgl vendor prefixes
 * @type {string[]}
 */

const VendorWebglPrefixes = ['', 'MOZ_', 'WEBKIT_', 'WEBGL_'];
/**
 * Webgl context names
 * @type {string[]}
 */

const WebglContextNames = ['webgl', 'experimental-webgl'];
/**
 * Webgl2 context names
 * @type {string[]}
 */

const Webgl2ContextNames = ['webgl2', 'experimental-webgl2'];
/**
 * Webgl version
 * @type {{NONE: number, WEBGL: number, WEBGL2: number}}
 */

const WebglVersion = {
  NONE: 0,
  WEBGL: 1,
  WEBGL2: 2
};
// CONCATENATED MODULE: ./global/engine/Tw2Device.js
function Tw2Device_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Device_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Device_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Device_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Device_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Device_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Device_assertThisInitialized(self); }

function Tw2Device_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Device_getPrototypeOf(o) { Tw2Device_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Device_getPrototypeOf(o); }

function Tw2Device_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Device_setPrototypeOf(subClass, superClass); }

function Tw2Device_setPrototypeOf(o, p) { Tw2Device_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Device_setPrototypeOf(o, p); }

function Tw2Device_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const WebGLDebugUtil = __webpack_require__(30);
/**
 * Tw2Device
 *
 * @property {?WebGLRenderingContext|*} gl         - The device's gl context
 * @property {?number} glVersion                   - The device's gl version
 * @property {?VRDisplay} vrDisplay                - An optional VRDisplay context
 * @property {?{}} ext                             - An object containing compatibility extensions
 * @property {boolean} debugMode                   - Toggles debug mode
 * @property {?{}} debugUtils                      - Webgl debug utils
 * @property {number} dt                           - Clock delta time
 * @property {number} startTime                    - Clock start time
 * @property {number} currentTime                  - Clock current time
 * @property {?number} previousTime                - Clock previous time
 * @property {vec3} eyePosition                    - The device's current eye position
 * @property {vec4} targetResolution               - The device's current target resolution
 * @property {mat4} world                          - The device's current world matrix
 * @property {mat4} view                           - The device's current view matrix
 * @property {mat4} viewInverse                    - The device's current inverse view matrix
 * @property {mat4} viewTranspose                  - The device's current view matrix transposed
 * @property {mat4} projection                     - The device's current projection matrix
 * @property {mat4} projectionInverse              - The device's current inverse projection matrix
 * @property {mat4} projectionTranspose            - The device's current projection matrix transposed
 * @property {mat4} viewProjection                 - The device's current view projection matrix
 * @property {mat4} viewProjectionTranspose        - The device's current view projection matrix transposed
 * @property {?HTMLCanvasElement} canvas           - The html canvas the gl context was created from
 * @property {number} viewportWidth                - The canvas's current width
 * @property {number} viewportHeight               - The canvas's current height
 * @property {number} viewportAspect               - The canvas's current display aspect
 * @property {number} viewportPixelRatio           - The canvas's pixel ratio
 * @property {string} effectDir                    - The directory used to translate ccp effect file paths
 * @property {number} mipLevelSkipCount            - Controls what quality ccp texture resource to load (mutates paths)
 * @property {string} shaderModel                  - Controls what quality ccp effect resource to load (mutates paths)
 * @property {boolean} enableAnisotropicFiltering  - Enables anisotropic filtering
 * @property {boolean} alphaBlendBackBuffer        - Enables alpha blending (glParams.alpha)
 * @property {boolean} antialiasing                - Identifies if antialiasing is enabled
 * @property {number} msaaSamples                  - The amount of samples used for antialiasing
 * @property {number[]} wrapModes                  - texture wrap modes
 * @property {*} shadowHandles                     - unused
 * @property {Tw2PerObjectData} perObjectData      - The current frame's per object data
 * @property {?{}} _alphaBlendState                - Alpha states for blending
 * @property {?{}} _alphaTestState                 - Alpha test states
 * @property {?{}} _depthOffsetState               - Depth states
 * @property {?Float32Array} _shadowStateBuffer    - unused
 * @property {Array<Function>} _scheduled          - Functions that are scheduled to be called per frame
 * @property {WebGLBuffer} _quadBuffer             - Webgl buffer for full screen quad
 * @property {Tw2VertexDeclaration} _quadDecl      - Quad vertex declarations
 * @property {WebGLBuffer} _cameraQuadBuffer       - Webgl buffer for camera space quad
 * @property {number} _currentRenderMode           - The device's current render mode
 * @property {WebGLTexture} _fallbackCube          - A fallback cube texture
 * @property {WebGLTexture} _fallbackTexture       - A fallback texture
 * @property {Tw2Effect} _blitEffect               - The blit effect used for rendering textures
 * @class
 */


let Tw2Device_Tw2Device =
/*#__PURE__*/
function (_Tw2EventEmitter) {
  Tw2Device_inherits(Tw2Device, _Tw2EventEmitter);

  function Tw2Device() {
    var _this;

    Tw2Device_classCallCheck(this, Tw2Device);

    _this = Tw2Device_possibleConstructorReturn(this, Tw2Device_getPrototypeOf(Tw2Device).call(this));
    _this.name = 'Device';
    _this.gl = null;
    _this.glVersion = WebglVersion.NONE;
    _this.vrDisplay = null;
    _this.ext = null;
    _this.dt = 0;
    _this.frameCounter = 0;
    _this.startTime = _this.Now();
    _this.currentTime = _this.startTime;
    _this.previousTime = null;
    _this.eyePosition = math["vec3"].create();
    _this.targetResolution = math["vec4"].create();
    _this.world = math["mat4"].create();
    _this.view = math["mat4"].create();
    _this.viewInverse = math["mat4"].create();
    _this.viewTranspose = math["mat4"].create();
    _this.projection = math["mat4"].create();
    _this.projectionInverse = math["mat4"].create();
    _this.projectionTranspose = math["mat4"].create();
    _this.viewProjection = math["mat4"].create();
    _this.viewProjectionTranspose = math["mat4"].create();
    _this.canvas = null;
    _this.viewportWidth = 0;
    _this.viewportHeight = 0;
    _this.viewportAspect = 0;
    _this.viewportPixelRatio = 'devicePixelRatio' in window ? window.devicePixelRatio : 1;
    _this.effectDir = '/effect.gles2/';
    _this.mipLevelSkipCount = 0;
    _this.shaderModel = 'hi';
    _this.enableAnisotropicFiltering = true;
    _this.alphaBlendBackBuffer = true;
    _this.antialiasing = true;
    _this.msaaSamples = 0;
    _this.wrapModes = [];
    _this.shadowHandles = null;
    _this.perObjectData = null;
    _this._alphaBlendState = null;
    _this._alphaTestState = null;
    _this._depthOffsetState = null;
    _this._shadowStateBuffer = null;
    _this._scheduled = [];
    _this._quadBuffer = null;
    _this._quadDecl = null;
    _this._cameraQuadBuffer = null;
    _this._currentRenderMode = RM_ANY;
    _this._fallbackCube = null;
    _this._fallbackTexture = null;
    _this._blitEffect = null;
    return _this;
  }
  /**
   * Gets the current device time
   * @returns {number}
   */


  Tw2Device_createClass(Tw2Device, [{
    key: "Now",
    value: function Now() {
      return this.constructor.Clock.now();
    }
    /**
     * Creates webgl Device
     * @param {HTMLCanvasElement} canvas - The html canvas to create a webgl rendering context from
     * @param {{}} [params]              - Optional gl parameters
     * @param {boolean} [params.webgl2]  - Optional flag to enable a webgl2 rendering context
     * @returns {number}                 - The webgl rendering context create (0 if failed)
     */

  }, {
    key: "CreateDevice",
    value: function CreateDevice(canvas, params) {
      this.gl = null;
      this.glVersion = WebglVersion.NONE;
      this.effectDir = '/effect.gles2/';
      this.canvas = null;

      const returnFalse = () => false,
            returnTrue = () => true;

      this.ext = {
        drawElementsInstanced: returnFalse,
        drawArraysInstanced: returnFalse,
        vertexAttribDivisor: returnFalse,
        hasInstancedArrays: returnFalse
      };

      let _Tw2Device$CreateCont = Tw2Device.CreateContext(canvas, params, params.webgl2),
          gl = _Tw2Device$CreateCont.gl,
          version = _Tw2Device$CreateCont.version;

      if (!gl) return this.glVersion;

      if (this.debugMode) {
        this.debugUtils = WebGLDebugUtil;
        gl = this.debugUtils.makeDebugContext(gl);
      }

      this.gl = gl;
      this.glVersion = version;
      this.canvas = canvas;
      this.emit('created', {
        device: this,
        gl,
        params,
        canvas,
        log: {
          type: 'debug',
          message: `Webgl${version} context created`
        }
      });

      switch (this.glVersion) {
        case WebglVersion.WEBGL2:
          this.ext = {
            drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
              gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
            },
            drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
              gl.drawArraysInstanced(mode, first, count, instanceCount);
            },
            vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
              gl.vertexAttribDivisor(location, divisor);
            },
            hasInstancedArrays: returnTrue
          };
          break;

        default:
          this.GetExtension('OES_standard_derivatives');
          this.GetExtension('OES_element_index_uint');
          this.GetExtension('OES_texture_float');
          this.GetExtension('EXT_shader_texture_lod');
          const instancedArrays = this.GetExtension('ANGLE_instanced_arrays');

          if (instancedArrays) {
            this.ext = {
              drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
                instancedArrays['drawElementsInstancedANGLE'](mode, count, type, offset, instanceCount);
              },
              drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
                instancedArrays['drawArraysInstancedANGLE'](mode, first, count, instanceCount);
              },
              vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
                instancedArrays['vertexAttribDivisorANGLE'](location, divisor);
              },
              hasInstancedArrays: returnTrue
            };
          }

      } // Optional extensions


      this.ext.CompressedTextureS3TC = this.GetExtension('compressed_texture_s3tc');
      this.ext.AnisotropicFilter = this.GetExtension('EXT_texture_filter_anisotropic');

      if (this.ext.AnisotropicFilter) {
        this.ext.AnisotropicFilter.maxAnisotropy = gl.getParameter(this.ext.AnisotropicFilter['MAX_TEXTURE_MAX_ANISOTROPY_EXT']);
      } // CCP mobile shader binary (is this depreciated?)


      const shaderBinary = this.GetExtension('CCP_shader_binary');

      if (shaderBinary) {
        const renderer = gl.getParameter(this.gl.RENDERER),
              maliVer = renderer.match(/Mali-(\w+).*/);

        if (maliVer) {
          this.effectDir = '/effect.gles2.mali' + maliVer[1] + '/';
          this.ext.ShaderBinary = shaderBinary;
        }
      } // Quality


      this.alphaBlendBackBuffer = !params || params['alpha'] === undefined || params['alpha'];
      this.msaaSamples = this.gl.getParameter(this.gl.SAMPLES);
      this.antialiasing = this.msaaSamples > 1;
      this.Resize();
      const vertices = [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0];
      this._quadBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._quadBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      this._cameraQuadBuffer = gl.createBuffer();
      this._quadDecl = new vertex["a" /* Tw2VertexDeclaration */]([['POSITION', 0, 4], ['TEXCOORD', 0, 2]]);
      this.wrapModes = Array.from(WrapModes);
      this._alphaBlendState = {
        dirty: false,
        states: {
          [RS_SRCBLEND]: BLEND_SRCALPHA,
          [RS_DESTBLEND]: BLEND_INVSRCALPHA,
          [RS_BLENDOP]: BLENDOP_ADD,
          [RS_SEPARATEALPHABLENDENABLE]: 0,
          [RS_BLENDOPALPHA]: BLENDOP_ADD,
          [RS_SRCBLENDALPHA]: BLEND_SRCALPHA,
          [RS_DESTBLENDALPHA]: BLEND_INVSRCALPHA
        }
      };
      this._alphaTestState = {
        dirty: false,
        states: {
          [RS_ALPHATESTENABLE]: 0,
          [RS_ALPHAREF]: -1,
          [RS_ALPHAFUNC]: CMP_GREATER,
          [RS_CLIPPING]: 0,
          [RS_CLIPPLANEENABLE]: 0
        }
      };
      this._depthOffsetState = {
        dirty: false,
        states: {
          [RS_SLOPESCALEDEPTHBIAS]: 0,
          [RS_DEPTHBIAS]: 0
        }
      };
      this._shadowStateBuffer = new Float32Array(24);
      return this.glVersion;
    }
    /**
     * Schedules a function to be called per tick
     * @param {Function} func
     */

  }, {
    key: "Schedule",
    value: function Schedule(func) {
      if (!this._scheduled.includes(func)) {
        this._scheduled.push(func);
      }
    }
    /**
     * Handles resize events
     */

  }, {
    key: "Resize",
    value: function Resize() {
      const vrEnabled = this.vrDisplay && this.vrDisplay['isPresenting'];

      if (vrEnabled) {
        const leftEye = this.vrDisplay['getEyeParameters']('left'),
              rightEye = this.vrDisplay['getEyeParameters']('right');
        this.canvas.width = Math.max(leftEye['renderWidth'], rightEye['renderWidth']) * 2;
        this.canvas.height = Math.max(rightEye['renderHeight'], rightEye['renderHeight']);
      } else {
        this.canvas.width = this.canvas.offsetWidth * this.viewportPixelRatio;
        this.canvas.height = this.canvas.offsetHeight * this.viewportPixelRatio;
      }

      this.viewportWidth = this.canvas.clientWidth;
      this.viewportHeight = this.canvas.clientHeight;
      this.viewportAspect = this.viewportWidth / this.viewportHeight;
      Tw2Store_store.SetVariableValue('ViewportSize', [this.viewportWidth, this.viewportHeight, this.viewportWidth, this.viewportHeight]);
      this.emit('resized', {
        width: this.viewportWidth,
        height: this.viewportHeight,
        aspect: this.viewportAspect,
        source: vrEnabled ? this.vrDisplay : this.canvas
      });
    }
    /**
     * Per frame Tick
     */

  }, {
    key: "Tick",
    value: function Tick() {
      if (this.canvas.clientWidth !== this.viewportWidth || this.canvas.clientHeight !== this.viewportHeight) {
        this.Resize();
      }

      const previousTime = this.previousTime === null ? 0 : this.previousTime,
            now = this.Now();
      this.currentTime = (now - this.startTime) * 0.001;
      this.dt = this.previousTime === null ? 0 : (now - this.previousTime) * 0.001;
      this.previousTime = now;
      Tw2Store_store.SetVariableValue('Time', [this.currentTime, this.currentTime - Math.floor(this.currentTime), this.frameCounter, previousTime]);
      this.emit('tick', {
        dt: this.dt,
        previous: previousTime,
        current: this.currentTime,
        frame: this.frameCounter
      });
      Tw2ResMan_resMan.PrepareLoop(this.dt);

      for (let i = 0; i < this._scheduled.length; ++i) {
        if (!this._scheduled[i](this.dt)) {
          this._scheduled.splice(i, 1);

          --i;
        }
      }

      this.frameCounter++;
    }
    /**
     * Requests an animation frame
     * @param {Function} callback
     * @returns {number}
     */

  }, {
    key: "RequestAnimationFrame",
    value: function RequestAnimationFrame(callback) {
      return this.vrDisplay ? this.vrDisplay.requestAnimationFrame(callback) : Tw2Device.RequestAnimationFrame(callback);
    }
    /**
     * Cancels an animation frame
     * @param id
     * @returns {*}
     */

  }, {
    key: "CancelAnimationFrame",
    value: function CancelAnimationFrame(id) {
      return this.vrDisplay ? this.vrDisplay.cancelAnimationFrame(id) : Tw2Device.CancelAnimationFrame(id);
    }
    /**
     * Sets World transform matrix
     * @param {mat4} matrix
     */

  }, {
    key: "SetWorld",
    value: function SetWorld(matrix) {
      math["mat4"].copy(this.world, matrix); //mat4.inverse(this.worldInverse, this.world);
    }
    /**
     * Sets view matrix
     * @param {mat4} matrix
     */

  }, {
    key: "SetView",
    value: function SetView(matrix) {
      math["mat4"].copy(this.view, matrix);
      math["mat4"].invert(this.viewInverse, this.view);
      math["mat4"].transpose(this.viewTranspose, this.view);
      math["mat4"].getTranslation(this.eyePosition, this.viewInverse);
      this.UpdateViewProjection();
    }
    /**
     * Sets projection matrix
     * @param {mat4} matrix
     * @param {boolean} [forceUpdateViewProjection]
     */

  }, {
    key: "SetProjection",
    value: function SetProjection(matrix, forceUpdateViewProjection) {
      math["mat4"].copy(this.projection, matrix);
      math["mat4"].transpose(this.projectionTranspose, this.projection);
      math["mat4"].invert(this.projectionInverse, this.projection);
      this.GetTargetResolution(this.targetResolution);
      if (forceUpdateViewProjection) this.UpdateViewProjection();
    }
    /**
     * Updates view projection matrices
     */

  }, {
    key: "UpdateViewProjection",
    value: function UpdateViewProjection() {
      math["mat4"].multiply(this.viewProjection, this.projection, this.view);
      math["mat4"].transpose(this.viewProjectionTranspose, this.viewProjection);
      Tw2Store_store.SetVariableValue('ViewProjectionMat', this.viewProjection);
    }
    /**
     * Gets the device's target resolution
     * @param {vec4} [out=vec4.create()]
     * @returns {vec4} out
     */

  }, {
    key: "GetTargetResolution",
    value: function GetTargetResolution() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : math["vec4"].create();
      const aspectRatio = this.projection[0] ? this.projection[5] / this.projection[0] : 0.0;
      let aspectAdjustment = 1.0;
      if (aspectRatio > 1.6) aspectAdjustment = aspectRatio / 1.6;
      const fov = 2.0 * Math.atan(aspectAdjustment / this.projection[5]);
      out[0] = this.viewportWidth;
      out[1] = this.viewportHeight;
      out[2] = fov;
      out[3] = fov * aspectRatio;
      return out;
    }
    /**
     * GetEyePosition
     * @param {vec3} [out=vec3.create()]
     * @return {vec3}
     */

  }, {
    key: "GetEyePosition",
    value: function GetEyePosition() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : math["vec3"].create();
      return math["vec3"].copy(out, this.eyePosition);
    }
    /**
     * Returns whether or not Alpha Test is enabled
     * return {Boolean}
     */

  }, {
    key: "IsAlphaTestEnabled",
    value: function IsAlphaTestEnabled() {
      return this._alphaTestState.states[RS_ALPHATESTENABLE];
    }
    /**
     * Checks if a frame buffer is complete
     *
     * @param frameBuffer
     * @returns {boolean}
     */

  }, {
    key: "IsFrameBufferComplete",
    value: function IsFrameBufferComplete(frameBuffer) {
      return this.gl.checkFramebufferStatus(frameBuffer) === this.gl.FRAMEBUFFER_COMPLETE;
    }
    /**
     * Gets a gl extension
     * @param {string} extension - The gl extension name
     * @returns{*}
     */

  }, {
    key: "GetExtension",
    value: function GetExtension(extension) {
      for (let i = 0; i < VendorWebglPrefixes.length; i++) {
        const ext = this.gl.getExtension(VendorWebglPrefixes[i] + extension);
        if (ext) return ext;
      }

      return null;
    }
    /**
     * Gets a fallback texture
     * @returns {*}
     */

  }, {
    key: "GetFallbackTexture",
    value: function GetFallbackTexture() {
      if (!this._fallbackTexture) {
        this._fallbackTexture = this.CreateSolidTexture();
      }

      return this._fallbackTexture;
    }
    /**
     * Gets a fallback cube map
     * @returns {*}
     */

  }, {
    key: "GetFallbackCubeMap",
    value: function GetFallbackCubeMap() {
      if (!this._fallbackCube) {
        this._fallbackCube = this.CreateSolidCube();
      }

      return this._fallbackCube;
    }
    /**
     * Creates a solid colored texture
     * @param {vec4|Array} [rgba] - The colour to create, if omitted defaults to completely transparent
     * @returns {WebGLTexture}
     */

  }, {
    key: "CreateSolidTexture",
    value: function CreateSolidTexture() {
      let rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 0];
      const gl = this.gl,
            texture = this.gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(rgba));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    /**
     * Creates a solid coloured cube texture
     * @param {vec4|Array} rgba
     * @returns {WebGLTexture}
     */

  }, {
    key: "CreateSolidCube",
    value: function CreateSolidCube() {
      let rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 0];
      const gl = this.gl,
            texture = this.gl.createTexture();
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

      for (let j = 0; j < 6; ++j) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(rgba));
      }

      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST); //gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
      return texture;
    }
    /**
     * RenderFullScreenQuad
     * @param {Tw2Effect} effect
     * @param {string} technique - Technique name
     * @returns {boolean}
     */

  }, {
    key: "RenderFullScreenQuad",
    value: function RenderFullScreenQuad(effect) {
      let technique = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Main';
      if (!effect || !effect.IsGood()) return false;
      const gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, this._quadBuffer);

      for (let pass = 0; pass < effect.GetPassCount(technique); ++pass) {
        effect.ApplyPass(technique, pass);
        if (!this._quadDecl.SetDeclaration(effect.GetPassInput(technique, pass), 24)) return false;
        this.ApplyShadowState();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      return true;
    }
    /**
     * Renders a Texture to the screen
     * @param {Tw2TextureRes} texture
     * @returns {boolean}
     */

  }, {
    key: "RenderTexture",
    value: function RenderTexture(texture) {
      if (this._blitEffect === null) {
        this._blitEffect = Tw2Effect["a" /* Tw2Effect */].create({
          effectFilePath: 'res:/graphics/effect/managed/space/system/blit.fx',
          textures: {
            BlitSource: ''
          }
        });
      }

      this._blitEffect.parameters['BlitSource'].SetTextureRes(texture);

      return this.RenderFullScreenQuad(this._blitEffect);
    }
    /**
     * RenderCameraSpaceQuad
     * @param {Tw2Effect} effect
     * @param {string} technique - Technique name
     * @returns {boolean}
     */

  }, {
    key: "RenderCameraSpaceQuad",
    value: function RenderCameraSpaceQuad(effect) {
      let technique = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Main';
      if (!effect || !effect.IsGood()) return false;
      const vertices = new Float32Array([1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0]);
      const projInv = this.projectionInverse;

      for (let i = 0; i < 4; ++i) {
        const vec = vertices.subarray(i * 6, i * 6 + 4);
        math["vec4"].transformMat4(vec, vec, projInv);
        math["vec3"].scale(vec, vec, 1 / vec[3]);
        vec[3] = 1;
      }

      const gl = this.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, this._cameraQuadBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      for (let pass = 0; pass < effect.GetPassCount(technique); ++pass) {
        effect.ApplyPass(technique, pass);
        if (!this._quadDecl.SetDeclaration(effect.GetPassInput(technique, pass), 24)) return false;
        this.ApplyShadowState();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      return true;
    }
    /**
     * Set a render state
     * @param state
     * @param value
     */

  }, {
    key: "SetRenderState",
    value: function SetRenderState(state, value) {
      const gl = this.gl;
      this._currentRenderMode = RM_ANY;

      switch (state) {
        case RS_ZENABLE:
          if (value) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }

          return;

        case RS_ZWRITEENABLE:
          gl.depthMask(!!value);
          return;

        case RS_ALPHATESTENABLE:
        case RS_ALPHAREF:
        case RS_ALPHAFUNC:
        case RS_CLIPPING:
        case RS_CLIPPLANEENABLE:
          if (this._alphaTestState[state] !== value) {
            this._alphaTestState.states[state] = value;
            this._alphaTestState.dirty = true;
          }

          return;

        case RS_SRCBLEND:
        case RS_DESTBLEND:
        case RS_BLENDOP:
        case RS_SEPARATEALPHABLENDENABLE:
        case RS_BLENDOPALPHA:
        case RS_SRCBLENDALPHA:
        case RS_DESTBLENDALPHA:
          if (this._alphaBlendState[state] !== value) {
            this._alphaBlendState.states[state] = value;
            this._alphaBlendState.dirty = true;
          }

          return;

        case RS_CULLMODE:
          switch (value) {
            case CULL_NONE:
              gl.disable(gl.CULL_FACE);
              return;

            case CULL_CW:
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.FRONT);
              return;

            case CULL_CCW:
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              return;
          }

          return;

        case RS_ZFUNC:
          gl.depthFunc(0x0200 + value - 1);
          return;

        case RS_ALPHABLENDENABLE:
          if (value) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);
          return;

        case RS_COLORWRITEENABLE:
          gl.colorMask((value & 1) !== 0, (value & 2) !== 0, (value & 4) !== 0, (value & 8) !== 0);
          return;

        case RS_SCISSORTESTENABLE:
          if (value) gl.enable(gl.SCISSOR_TEST);else gl.disable(gl.SCISSOR_TEST);
          return;

        case RS_SLOPESCALEDEPTHBIAS:
        case RS_DEPTHBIAS:
          value = math["num"].dwordToFloat(value);

          if (this._depthOffsetState[state] !== value) {
            this._depthOffsetState.states[state] = value;
            this._depthOffsetState.dirty = true;
          }

          return;
      }
    }
    /**
     * ApplyShadowState
     */

  }, {
    key: "ApplyShadowState",
    value: function ApplyShadowState() {
      const gl = this.gl;

      if (this._alphaBlendState.dirty) {
        let blendOp = gl.FUNC_ADD;

        if (this._alphaBlendState.states[RS_BLENDOP] === BLENDOP_SUBTRACT) {
          blendOp = gl.FUNC_SUBTRACT;
        } else if (this._alphaBlendState.states[RS_BLENDOP] === BLENDOP_REVSUBTRACT) {
          blendOp = gl.FUNC_REVERSE_SUBTRACT;
        }

        const srcBlend = BlendTable[this._alphaBlendState.states[RS_SRCBLEND]],
              destBlend = BlendTable[this._alphaBlendState.states[RS_DESTBLEND]];

        if (this._alphaBlendState.states[RS_SEPARATEALPHABLENDENABLE]) {
          let blendOpAlpha = gl.FUNC_ADD;

          if (this._alphaBlendState.states[RS_BLENDOP] === BLENDOP_SUBTRACT) {
            blendOpAlpha = gl.FUNC_SUBTRACT;
          } else if (this._alphaBlendState.states[RS_BLENDOP] === BLENDOP_REVSUBTRACT) {
            blendOpAlpha = gl.FUNC_REVERSE_SUBTRACT;
          }

          const srcBlendAlpha = BlendTable[this._alphaBlendState.states[RS_SRCBLENDALPHA]],
                destBlendAlpha = BlendTable[this._alphaBlendState.states[RS_DESTBLENDALPHA]];
          gl.blendEquationSeparate(blendOp, blendOpAlpha);
          gl.blendFuncSeparate(srcBlend, destBlend, srcBlendAlpha, destBlendAlpha);
        } else {
          gl.blendEquation(blendOp);
          gl.blendFunc(srcBlend, destBlend);
        }

        this._alphaBlendState.dirty = false;
      }

      if (this._depthOffsetState.dirty) {
        gl.polygonOffset(this._depthOffsetState.states[RS_SLOPESCALEDEPTHBIAS], this._depthOffsetState.states[RS_DEPTHBIAS]);
        this._depthOffsetState.dirty = false;
      }

      let alphaTestFunc, invertedAlphaTest, alphaTestRef;

      if (this.shadowHandles && this._alphaTestState.states[RS_ALPHATESTENABLE]) {
        switch (this._alphaTestState.states[RS_ALPHAFUNC]) {
          case CMP_NEVER:
            alphaTestFunc = 0;
            invertedAlphaTest = 1;
            alphaTestRef = -256;
            break;

          case CMP_LESS:
            alphaTestFunc = 0;
            invertedAlphaTest = -1;
            alphaTestRef = this._alphaTestState.states[RS_ALPHAREF] - 1;
            break;

          case CMP_EQUAL:
            alphaTestFunc = 1;
            invertedAlphaTest = 0;
            alphaTestRef = this._alphaTestState.states[RS_ALPHAREF];
            break;

          case CMP_LEQUAL:
            alphaTestFunc = 0;
            invertedAlphaTest = -1;
            alphaTestRef = this._alphaTestState.states[RS_ALPHAREF];
            break;

          case CMP_GREATER:
            alphaTestFunc = 0;
            invertedAlphaTest = 1;
            alphaTestRef = -this._alphaTestState.states[RS_ALPHAREF] - 1;
            break;

          /*
          case CMP_NOTEQUAL:
          var alphaTestFunc = 1;
          var invertedAlphaTest = 1;
          var alphaTestRef = this._alphaTestState.states[RS_ALPHAREF];
          break;
          */

          case CMP_GREATEREQUAL:
            alphaTestFunc = 0;
            invertedAlphaTest = 1;
            alphaTestRef = -this._alphaTestState.states[RS_ALPHAREF];
            break;

          default:
            alphaTestFunc = 0;
            invertedAlphaTest = 0;
            alphaTestRef = 1;
            break;
        }

        const clipPlaneEnable = 0;
        gl.uniform4f(this.shadowHandles.shadowStateInt, invertedAlphaTest, alphaTestRef, alphaTestFunc, clipPlaneEnable); //this._shadowStateBuffers
      }
    }
    /**
     * Sets a render mode
     * @param {number} renderMode
     */

  }, {
    key: "SetStandardStates",
    value: function SetStandardStates(renderMode) {
      if (this._currentRenderMode === renderMode) return;
      this.gl.frontFace(this.gl.CW);

      switch (renderMode) {
        case RM_OPAQUE:
        case RM_PICKABLE:
        case RM_DISTORTION:
          this.SetRenderState(RS_ZENABLE, true);
          this.SetRenderState(RS_ZWRITEENABLE, true);
          this.SetRenderState(RS_ZFUNC, CMP_LEQUAL);
          this.SetRenderState(RS_CULLMODE, CULL_CW);
          this.SetRenderState(RS_ALPHABLENDENABLE, false);
          this.SetRenderState(RS_ALPHATESTENABLE, false);
          this.SetRenderState(RS_SEPARATEALPHABLENDENABLE, false);
          this.SetRenderState(RS_SLOPESCALEDEPTHBIAS, 0);
          this.SetRenderState(RS_DEPTHBIAS, 0);
          this.SetRenderState(RS_COLORWRITEENABLE, 0xf);
          break;

        case RM_DECAL:
          this.SetRenderState(RS_ALPHABLENDENABLE, false);
          this.SetRenderState(RS_ALPHATESTENABLE, true);
          this.SetRenderState(RS_ALPHAFUNC, CMP_GREATER);
          this.SetRenderState(RS_ALPHAREF, 127);
          this.SetRenderState(RS_ZENABLE, true);
          this.SetRenderState(RS_ZWRITEENABLE, true);
          this.SetRenderState(RS_ZFUNC, CMP_LEQUAL);
          this.SetRenderState(RS_CULLMODE, CULL_CW);
          this.SetRenderState(RS_BLENDOP, BLENDOP_ADD);
          this.SetRenderState(RS_SLOPESCALEDEPTHBIAS, 0);
          this.SetRenderState(RS_DEPTHBIAS, 0);
          this.SetRenderState(RS_SEPARATEALPHABLENDENABLE, false);
          this.SetRenderState(RS_COLORWRITEENABLE, 0xf);
          break;

        case RM_TRANSPARENT:
          this.SetRenderState(RS_CULLMODE, CULL_CW);
          this.SetRenderState(RS_ALPHABLENDENABLE, true);
          this.SetRenderState(RS_SRCBLEND, BLEND_SRCALPHA);
          this.SetRenderState(RS_DESTBLEND, BLEND_INVSRCALPHA);
          this.SetRenderState(RS_BLENDOP, BLENDOP_ADD);
          this.SetRenderState(RS_ZENABLE, true);
          this.SetRenderState(RS_ZWRITEENABLE, false);
          this.SetRenderState(RS_ZFUNC, CMP_LEQUAL);
          this.SetRenderState(RS_ALPHATESTENABLE, false);
          this.SetRenderState(RS_SLOPESCALEDEPTHBIAS, 0); // -1.0

          this.SetRenderState(RS_DEPTHBIAS, 0);
          this.SetRenderState(RS_SEPARATEALPHABLENDENABLE, false);
          this.SetRenderState(RS_COLORWRITEENABLE, 0xf);
          break;

        case RM_ADDITIVE:
          this.SetRenderState(RS_CULLMODE, CULL_NONE);
          this.SetRenderState(RS_ALPHABLENDENABLE, true);
          this.SetRenderState(RS_SRCBLEND, BLEND_ONE);
          this.SetRenderState(RS_DESTBLEND, BLEND_ONE);
          this.SetRenderState(RS_BLENDOP, BLENDOP_ADD);
          this.SetRenderState(RS_ZENABLE, true);
          this.SetRenderState(RS_ZWRITEENABLE, false);
          this.SetRenderState(RS_ZFUNC, CMP_LEQUAL);
          this.SetRenderState(RS_ALPHATESTENABLE, false);
          this.SetRenderState(RS_SLOPESCALEDEPTHBIAS, 0);
          this.SetRenderState(RS_DEPTHBIAS, 0);
          this.SetRenderState(RS_SEPARATEALPHABLENDENABLE, false);
          this.SetRenderState(RS_COLORWRITEENABLE, 0xf);
          break;

        case RM_FULLSCREEN:
          this.SetRenderState(RS_ALPHABLENDENABLE, false);
          this.SetRenderState(RS_ALPHATESTENABLE, false);
          this.SetRenderState(RS_CULLMODE, CULL_NONE);
          this.SetRenderState(RS_ZENABLE, false);
          this.SetRenderState(RS_ZWRITEENABLE, false);
          this.SetRenderState(RS_ZFUNC, CMP_ALWAYS);
          this.SetRenderState(RS_SLOPESCALEDEPTHBIAS, 0);
          this.SetRenderState(RS_DEPTHBIAS, 0);
          this.SetRenderState(RS_SEPARATEALPHABLENDENABLE, false);
          this.SetRenderState(RS_COLORWRITEENABLE, 0xf);
          break;

        default:
          return;
      }

      this._currentRenderMode = renderMode;
    }
    /**
     * Creates webgl context
     * @param {HTMLCanvasElement} canvas
     * @param {*} params
     * @param {boolean} [enableWebgl2]
     * @returns {{gl: *, version: number}}
     */

  }], [{
    key: "CreateContext",
    value: function CreateContext(canvas, params, enableWebgl2) {
      /**
       * Creates a gl context
       * @param {HTMLCanvasElement} canvas
       * @param {*} [params]
       * @param {*} [contextNames]
       * @returns {*}
       */
      function create(canvas, params, contextNames) {
        contextNames = Array.isArray(contextNames) ? contextNames : [contextNames];

        for (let i = 0; i < contextNames.length; i++) {
          try {
            return canvas.getContext(contextNames[i], params);
          } catch (err) {
            /* eslint-disable-line no-empty */
          }
        }

        return null;
      }

      let gl = null,
          version = WebglVersion.NONE;

      if (enableWebgl2) {
        gl = create(canvas, params, Webgl2ContextNames);
        if (gl) version = WebglVersion.WEBGL2;
      }

      if (!gl) {
        gl = create(canvas, params, WebglContextNames);
        if (gl) version = WebglVersion.WEBGL;
      }

      return {
        gl,
        version
      };
    }
    /**
     * The constructor used to generate the time
     * @type {DateConstructor}
     */

  }]);

  return Tw2Device;
}(Tw2EventEmitter["a" /* Tw2EventEmitter */]); // Render Modes

Tw2Device_defineProperty(Tw2Device_Tw2Device, "Clock", Date);

Tw2Device_defineProperty(Tw2Device_Tw2Device, "RequestAnimationFrame", function () {
  const request = Object(util["get"])(window, VendorRequestAnimationFrame);
  return function (callback) {
    return request(callback);
  };
}());

Tw2Device_defineProperty(Tw2Device_Tw2Device, "CancelAnimationFrame", function () {
  const cancel = Object(util["get"])(window, VendorCancelAnimationFrame);
  return function (id) {
    return cancel(id);
  };
}());

Tw2Device_defineProperty(Tw2Device_Tw2Device, "category", 'device');

Tw2Device_Tw2Device.prototype.RM_ANY = RM_ANY;
Tw2Device_Tw2Device.prototype.RM_OPAQUE = RM_OPAQUE;
Tw2Device_Tw2Device.prototype.RM_DECAL = RM_DECAL;
Tw2Device_Tw2Device.prototype.RM_TRANSPARENT = RM_TRANSPARENT;
Tw2Device_Tw2Device.prototype.RM_ADDITIVE = RM_ADDITIVE;
Tw2Device_Tw2Device.prototype.RM_DEPTH = RM_DEPTH;
Tw2Device_Tw2Device.prototype.RM_DISTORTION = RM_DISTORTION;
Tw2Device_Tw2Device.prototype.RM_FULLSCREEN = RM_FULLSCREEN;
Tw2Device_Tw2Device.prototype.RM_PICKABLE = RM_PICKABLE;
Tw2Device_Tw2Device.prototype.RM_DISTORTION = RM_DISTORTION;
const device = new Tw2Device_Tw2Device();
// CONCATENATED MODULE: ./global/engine/index.js





// CONCATENATED MODULE: ./global/index.js
/* concated harmony reexport num */__webpack_require__.d(__webpack_exports__, "B", function() { return math["num"]; });
/* concated harmony reexport vec2 */__webpack_require__.d(__webpack_exports__, "G", function() { return math["vec2"]; });
/* concated harmony reexport vec3 */__webpack_require__.d(__webpack_exports__, "H", function() { return math["vec3"]; });
/* concated harmony reexport vec4 */__webpack_require__.d(__webpack_exports__, "I", function() { return math["vec4"]; });
/* concated harmony reexport quat */__webpack_require__.d(__webpack_exports__, "C", function() { return math["quat"]; });
/* concated harmony reexport mat3 */__webpack_require__.d(__webpack_exports__, "y", function() { return math["mat3"]; });
/* concated harmony reexport mat4 */__webpack_require__.d(__webpack_exports__, "z", function() { return math["mat4"]; });
/* concated harmony reexport noise */__webpack_require__.d(__webpack_exports__, "A", function() { return math["noise"]; });
/* concated harmony reexport curve */__webpack_require__.d(__webpack_exports__, "v", function() { return math["curve"]; });
/* concated harmony reexport device */__webpack_require__.d(__webpack_exports__, "w", function() { return device; });
/* concated harmony reexport resMan */__webpack_require__.d(__webpack_exports__, "D", function() { return Tw2ResMan_resMan; });
/* concated harmony reexport store */__webpack_require__.d(__webpack_exports__, "E", function() { return Tw2Store_store; });
/* concated harmony reexport logger */__webpack_require__.d(__webpack_exports__, "x", function() { return logger; });
/* unused concated harmony import GL_COLOR_BUFFER_BIT */
/* unused concated harmony import GL_DEPTH_BUFFER_BIT */
/* unused concated harmony import GL_STENCIL_BUFFER_BIT */
/* concated harmony reexport GL_TEXTURE_2D */__webpack_require__.d(__webpack_exports__, "s", function() { return GL_TEXTURE_2D; });
/* unused concated harmony import GL_TEXTURE_CUBE_MAP */
/* unused concated harmony import GL_TEXTURE_3D */
/* unused concated harmony import GL_TEXTURE_MAG_FILTER */
/* unused concated harmony import GL_TEXTURE_MIN_FILTER */
/* unused concated harmony import GL_TEXTURE_WRAP_S */
/* unused concated harmony import GL_TEXTURE_WRAP_T */
/* unused concated harmony import GL_BYTE */
/* unused concated harmony import GL_UNSIGNED_BYTE */
/* unused concated harmony import GL_SHORT */
/* unused concated harmony import GL_UNSIGNED_SHORT */
/* unused concated harmony import GL_INT */
/* unused concated harmony import GL_UNSIGNED_INT */
/* unused concated harmony import GL_FLOAT */
/* unused concated harmony import GL_HALF_FLOAT_OES */
/* unused concated harmony import GL_HALF_FLOAT */
/* unused concated harmony import GL_DEPTH_COMPONENT16 */
/* unused concated harmony import GL_DEPTH_COMPONENT24 */
/* unused concated harmony import GL_DEPTH_COMPONENT32F */
/* unused concated harmony import GL_FLOAT_VEC2 */
/* unused concated harmony import GL_FLOAT_VEC3 */
/* unused concated harmony import GL_FLOAT_VEC4 */
/* unused concated harmony import GL_INT_VEC2 */
/* unused concated harmony import GL_INT_VEC3 */
/* unused concated harmony import GL_INT_VEC4 */
/* unused concated harmony import GL_BOOL */
/* unused concated harmony import GL_BOOL_VEC2 */
/* unused concated harmony import GL_BOOL_VEC3 */
/* unused concated harmony import GL_BOOL_VEC4 */
/* unused concated harmony import GL_FLOAT_MAT2 */
/* unused concated harmony import GL_FLOAT_MAT3 */
/* unused concated harmony import GL_FLOAT_MAT4 */
/* unused concated harmony import GL_TYPE_LENGTH */
/* unused concated harmony import GL_SAMPLER_2D */
/* unused concated harmony import GL_SAMPLER_3D */
/* unused concated harmony import GL_SAMPLER_CUBE */
/* unused concated harmony import GL_DEPTH_COMPONENT */
/* unused concated harmony import GL_ALPHA */
/* unused concated harmony import GL_RGB */
/* unused concated harmony import GL_RGBA */
/* unused concated harmony import GL_LUMINANCE */
/* unused concated harmony import GL_LUMINANCE_ALPHA */
/* unused concated harmony import GL_DEPTH_STENCIL */
/* unused concated harmony import GL_UNSIGNED_INT_24_8_WEBGL */
/* unused concated harmony import GL_R8 */
/* unused concated harmony import GL_R16F */
/* unused concated harmony import GL_R32F */
/* unused concated harmony import GL_R8UI */
/* unused concated harmony import GL_RG8 */
/* unused concated harmony import GL_RG16F */
/* unused concated harmony import GL_RG32F */
/* unused concated harmony import GL_RGB8 */
/* unused concated harmony import GL_SRGB8 */
/* unused concated harmony import GL_RGB565 */
/* unused concated harmony import GL_R11F_G11F_B10F */
/* unused concated harmony import GL_RGB9_E5 */
/* unused concated harmony import GL_RGB16F */
/* unused concated harmony import GL_RGB32F */
/* unused concated harmony import GL_RGB8UI */
/* unused concated harmony import GL_RGBA8 */
/* unused concated harmony import GL_RGB5_A1 */
/* unused concated harmony import GL_RGBA16F */
/* unused concated harmony import GL_RGBA32F */
/* unused concated harmony import GL_RGBA8UI */
/* unused concated harmony import GL_RGBA16I */
/* unused concated harmony import GL_RGBA16UI */
/* unused concated harmony import GL_RGBA32I */
/* unused concated harmony import GL_RGBA32UI */
/* unused concated harmony import GL_NEAREST */
/* concated harmony reexport GL_LINEAR */__webpack_require__.d(__webpack_exports__, "q", function() { return GL_LINEAR; });
/* unused concated harmony import GL_NEAREST_MIPMAP_NEAREST */
/* unused concated harmony import GL_LINEAR_MIPMAP_NEAREST */
/* unused concated harmony import GL_NEAREST_MIPMAP_LINEAR */
/* unused concated harmony import GL_LINEAR_MIPMAP_LINEAR */
/* concated harmony reexport GL_REPEAT */__webpack_require__.d(__webpack_exports__, "r", function() { return GL_REPEAT; });
/* unused concated harmony import GL_CLAMP_TO_EDGE */
/* unused concated harmony import GL_MIRRORED_REPEAT */
/* unused concated harmony import GL_ZERO */
/* unused concated harmony import GL_ONE */
/* unused concated harmony import GL_SRC_COLOR */
/* unused concated harmony import GL_ONE_MINUS_SRC_COLOR */
/* unused concated harmony import GL_SRC_ALPHA */
/* unused concated harmony import GL_ONE_MINUS_SRC_ALPHA */
/* unused concated harmony import GL_DST_ALPHA */
/* unused concated harmony import GL_ONE_MINUS_DST_ALPHA */
/* unused concated harmony import GL_DST_COLOR */
/* unused concated harmony import GL_ONE_MINUS_DST_COLOR */
/* unused concated harmony import GL_SRC_ALPHA_SATURATE */
/* unused concated harmony import GL_CONSTANT_COLOR */
/* unused concated harmony import GL_ONE_MINUS_CONSTANT_COLOR */
/* unused concated harmony import GL_CONSTANT_ALPHA */
/* unused concated harmony import GL_ONE_MINUS_CONSTANT_ALPHA */
/* unused concated harmony import GL_VERTEX_SHADER */
/* unused concated harmony import GL_FRAGMENT_SHADER */
/* unused concated harmony import GL_FRONT */
/* unused concated harmony import GL_BACK */
/* unused concated harmony import GL_FRONT_AND_BACK */
/* unused concated harmony import GL_NEVER */
/* unused concated harmony import GL_LESS */
/* unused concated harmony import GL_EQUAL */
/* unused concated harmony import GL_LEQUAL */
/* unused concated harmony import GL_GREATER */
/* unused concated harmony import GL_NOTEQUAL */
/* unused concated harmony import GL_GEQUAL */
/* unused concated harmony import GL_ALWAYS */
/* unused concated harmony import GL_KEEP */
/* unused concated harmony import GL_REPLACE */
/* unused concated harmony import GL_INCR */
/* unused concated harmony import GL_DECR */
/* unused concated harmony import GL_INCR_WRAP */
/* unused concated harmony import GL_DECR_WRAP */
/* unused concated harmony import GL_INVERT */
/* unused concated harmony import GL_STREAM_DRAW */
/* unused concated harmony import GL_STATIC_DRAW */
/* unused concated harmony import GL_DYNAMIC_DRAW */
/* unused concated harmony import GL_ARRAY_BUFFER */
/* unused concated harmony import GL_ELEMENT_ARRAY_BUFFER */
/* unused concated harmony import GL_POINTS */
/* unused concated harmony import GL_LINES */
/* unused concated harmony import GL_LINE_LOOP */
/* unused concated harmony import GL_LINE_STRIP */
/* unused concated harmony import GL_TRIANGLES */
/* unused concated harmony import GL_TRIANGLE_STRIP */
/* unused concated harmony import GL_TRIANGLE_FAN */
/* unused concated harmony import GL_CW */
/* unused concated harmony import GL_CCW */
/* unused concated harmony import GL_CULL_FACE */
/* unused concated harmony import GL_DEPTH_TEST */
/* unused concated harmony import GL_BLEND */
/* unused concated harmony import RM_ANY */
/* unused concated harmony import RM_OPAQUE */
/* unused concated harmony import RM_DECAL */
/* unused concated harmony import RM_TRANSPARENT */
/* unused concated harmony import RM_ADDITIVE */
/* unused concated harmony import RM_DEPTH */
/* unused concated harmony import RM_FULLSCREEN */
/* unused concated harmony import RM_PICKABLE */
/* unused concated harmony import RM_DISTORTION */
/* unused concated harmony import RS_ZENABLE */
/* unused concated harmony import RS_FILLMODE */
/* unused concated harmony import RS_SHADEMODE */
/* unused concated harmony import RS_ZWRITEENABLE */
/* unused concated harmony import RS_ALPHATESTENABLE */
/* unused concated harmony import RS_LASTPIXEL */
/* unused concated harmony import RS_SRCBLEND */
/* unused concated harmony import RS_DESTBLEND */
/* unused concated harmony import RS_CULLMODE */
/* unused concated harmony import RS_ZFUNC */
/* unused concated harmony import RS_ALPHAREF */
/* unused concated harmony import RS_ALPHAFUNC */
/* unused concated harmony import RS_DITHERENABLE */
/* unused concated harmony import RS_ALPHABLENDENABLE */
/* unused concated harmony import RS_FOGENABLE */
/* unused concated harmony import RS_SPECULARENABLE */
/* unused concated harmony import RS_FOGCOLOR */
/* unused concated harmony import RS_FOGTABLEMODE */
/* unused concated harmony import RS_FOGSTART */
/* unused concated harmony import RS_FOGEND */
/* unused concated harmony import RS_FOGDENSITY */
/* unused concated harmony import RS_RANGEFOGENABLE */
/* unused concated harmony import RS_STENCILENABLE */
/* unused concated harmony import RS_STENCILFAIL */
/* unused concated harmony import RS_STENCILZFAIL */
/* unused concated harmony import RS_STENCILPASS */
/* unused concated harmony import RS_STENCILFUNC */
/* unused concated harmony import RS_STENCILREF */
/* unused concated harmony import RS_STENCILMASK */
/* unused concated harmony import RS_STENCILWRITEMASK */
/* unused concated harmony import RS_TEXTUREFACTOR */
/* unused concated harmony import RS_WRAP0 */
/* unused concated harmony import RS_WRAP1 */
/* unused concated harmony import RS_WRAP2 */
/* unused concated harmony import RS_WRAP3 */
/* unused concated harmony import RS_WRAP4 */
/* unused concated harmony import RS_WRAP5 */
/* unused concated harmony import RS_WRAP6 */
/* unused concated harmony import RS_WRAP7 */
/* unused concated harmony import RS_CLIPPING */
/* unused concated harmony import RS_LIGHTING */
/* unused concated harmony import RS_AMBIENT */
/* unused concated harmony import RS_FOGVERTEXMODE */
/* unused concated harmony import RS_COLORVERTEX */
/* unused concated harmony import RS_LOCALVIEWER */
/* unused concated harmony import RS_NORMALIZENORMALS */
/* unused concated harmony import RS_DIFFUSEMATERIALSOURCE */
/* unused concated harmony import RS_SPECULARMATERIALSOURCE */
/* unused concated harmony import RS_AMBIENTMATERIALSOURCE */
/* unused concated harmony import RS_EMISSIVEMATERIALSOURCE */
/* unused concated harmony import RS_VERTEXBLEND */
/* unused concated harmony import RS_CLIPPLANEENABLE */
/* unused concated harmony import RS_POINTSIZE */
/* unused concated harmony import RS_POINTSIZE_MIN */
/* unused concated harmony import RS_POINTSPRITEENABLE */
/* unused concated harmony import RS_POINTSCALEENABLE */
/* unused concated harmony import RS_POINTSCALE_A */
/* unused concated harmony import RS_POINTSCALE_B */
/* unused concated harmony import RS_POINTSCALE_C */
/* unused concated harmony import RS_MULTISAMPLEANTIALIAS */
/* unused concated harmony import RS_MULTISAMPLEMASK */
/* unused concated harmony import RS_PATCHEDGESTYLE */
/* unused concated harmony import RS_DEBUGMONITORTOKEN */
/* unused concated harmony import RS_POINTSIZE_MAX */
/* unused concated harmony import RS_INDEXEDVERTEXBLENDENABLE */
/* unused concated harmony import RS_COLORWRITEENABLE */
/* unused concated harmony import RS_TWEENFACTOR */
/* unused concated harmony import RS_BLENDOP */
/* unused concated harmony import RS_POSITIONDEGREE */
/* unused concated harmony import RS_NORMALDEGREE */
/* unused concated harmony import RS_SCISSORTESTENABLE */
/* unused concated harmony import RS_SLOPESCALEDEPTHBIAS */
/* unused concated harmony import RS_ANTIALIASEDLINEENABLE */
/* unused concated harmony import RS_TWOSIDEDSTENCILMODE */
/* unused concated harmony import RS_CCW_STENCILFAIL */
/* unused concated harmony import RS_CCW_STENCILZFAIL */
/* unused concated harmony import RS_CCW_STENCILPASS */
/* unused concated harmony import RS_CCW_STENCILFUNC */
/* unused concated harmony import RS_COLORWRITEENABLE1 */
/* unused concated harmony import RS_COLORWRITEENABLE2 */
/* unused concated harmony import RS_COLORWRITEENABLE3 */
/* unused concated harmony import RS_BLENDFACTOR */
/* unused concated harmony import RS_SRGBWRITEENABLE */
/* unused concated harmony import RS_DEPTHBIAS */
/* unused concated harmony import RS_SEPARATEALPHABLENDENABLE */
/* unused concated harmony import RS_SRCBLENDALPHA */
/* unused concated harmony import RS_DESTBLENDALPHA */
/* unused concated harmony import RS_BLENDOPALPHA */
/* unused concated harmony import CULL_NONE */
/* unused concated harmony import CULL_CW */
/* unused concated harmony import CULL_CCW */
/* unused concated harmony import CMP_NEVER */
/* unused concated harmony import CMP_LESS */
/* unused concated harmony import CMP_EQUAL */
/* unused concated harmony import CMP_LEQUAL */
/* unused concated harmony import CMP_GREATER */
/* unused concated harmony import CMP_NOTEQUAL */
/* unused concated harmony import CMP_GREATEREQUAL */
/* unused concated harmony import CMP_ALWAYS */
/* unused concated harmony import BLEND_ZERO */
/* unused concated harmony import BLEND_ONE */
/* unused concated harmony import BLEND_SRCCOLOR */
/* unused concated harmony import BLEND_INVSRCCOLOR */
/* unused concated harmony import BLEND_SRCALPHA */
/* unused concated harmony import BLEND_INVSRCALPHA */
/* unused concated harmony import BLEND_DESTALPHA */
/* unused concated harmony import BLEND_INVDESTALPHA */
/* unused concated harmony import BLEND_DESTCOLOR */
/* unused concated harmony import BLEND_INVDESTCOLOR */
/* unused concated harmony import BLEND_SRCALPHASAT */
/* unused concated harmony import BLEND_BOTHSRCALPHA */
/* unused concated harmony import BLEND_BOTHINVSRCALPHA */
/* unused concated harmony import BLEND_BLENDFACTOR */
/* unused concated harmony import BLEND_INVBLENDFACTOR */
/* unused concated harmony import BLENDOP_ADD */
/* unused concated harmony import BLENDOP_SUBTRACT */
/* unused concated harmony import BLENDOP_REVSUBTRACT */
/* unused concated harmony import BLENDOP_MIN */
/* unused concated harmony import BLENDOP_MAX */
/* unused concated harmony import TF_ALPHA */
/* unused concated harmony import TF_LUMINANCE */
/* unused concated harmony import TF_LUMINANCE_ALPHA */
/* unused concated harmony import TF_RGB */
/* unused concated harmony import TF_RGBA */
/* unused concated harmony import TF_RED */
/* unused concated harmony import TF_R */
/* unused concated harmony import TF_RG */
/* unused concated harmony import TF_RED_INTEGER */
/* unused concated harmony import TF_R_INTEGER */
/* unused concated harmony import TF_RG_INTEGER */
/* unused concated harmony import TF_RGB_INTEGER */
/* unused concated harmony import TF_RGBA_INTEGER */
/* unused concated harmony import TT_UNSIGNED_BYTE */
/* unused concated harmony import TT_UNSIGNED_INT */
/* unused concated harmony import TT_FLOAT */
/* unused concated harmony import TT_HALF_FLOAT */
/* unused concated harmony import TT_BYTE */
/* unused concated harmony import TT_SHORT */
/* unused concated harmony import TT_UNSIGNED_SHORT */
/* unused concated harmony import TT_INT */
/* unused concated harmony import TT_UNSIGNED_INTEGER */
/* unused concated harmony import TT_UNSIGNED_SHORT_4_4_4_4 */
/* unused concated harmony import TT_UNSIGNED_SHORT_5_5_5_1 */
/* unused concated harmony import TT_UNSIGNED_SHORT_5_6_5 */
/* unused concated harmony import TT_UNSIGNED_INT_2_10_10_10_REV */
/* unused concated harmony import TT_UNSIGNED_INT_24_8 */
/* unused concated harmony import TT_UNSIGNED_INT_10F_11F_11F_REV */
/* unused concated harmony import TT_UNSIGNED_INT_5_9_9_9_REV */
/* unused concated harmony import TT_FLOAT_32_UNSIGNED_INT_24_8_REV */
/* unused concated harmony import WrapModes */
/* unused concated harmony import BlendTable */
/* concated harmony reexport FilterMode */__webpack_require__.d(__webpack_exports__, "p", function() { return FilterMode; });
/* concated harmony reexport MipFilterMode */__webpack_require__.d(__webpack_exports__, "t", function() { return MipFilterMode; });
/* concated harmony reexport DDS_MAGIC */__webpack_require__.d(__webpack_exports__, "l", function() { return DDS_MAGIC; });
/* unused concated harmony import DDSD_CAPS */
/* unused concated harmony import DDSD_HEIGHT */
/* unused concated harmony import DDSD_WIDTH */
/* unused concated harmony import DDSD_PITCH */
/* unused concated harmony import DDSD_PIXELFORMAT */
/* concated harmony reexport DDSD_MIPMAPCOUNT */__webpack_require__.d(__webpack_exports__, "b", function() { return DDSD_MIPMAPCOUNT; });
/* unused concated harmony import DDSD_LINEARSIZE */
/* unused concated harmony import DDSD_DEPTH */
/* unused concated harmony import DDSCAPS_COMPLEX */
/* unused concated harmony import DDSCAPS_MIPMAP */
/* unused concated harmony import DDSCAPS_TEXTURE */
/* concated harmony reexport DDSCAPS2_CUBEMAP */__webpack_require__.d(__webpack_exports__, "a", function() { return DDSCAPS2_CUBEMAP; });
/* unused concated harmony import DDSCAPS2_CUBEMAP_POSITIVEX */
/* unused concated harmony import DDSCAPS2_CUBEMAP_NEGATIVEX */
/* unused concated harmony import DDSCAPS2_CUBEMAP_POSITIVEY */
/* unused concated harmony import DDSCAPS2_CUBEMAP_NEGATIVEY */
/* unused concated harmony import DDSCAPS2_CUBEMAP_POSITIVEZ */
/* unused concated harmony import DDSCAPS2_CUBEMAP_NEGATIVEZ */
/* unused concated harmony import DDSCAPS2_VOLUME */
/* unused concated harmony import DDPF_ALPHAPIXELS */
/* unused concated harmony import DDPF_ALPHA */
/* unused concated harmony import DDPF_FOURCC */
/* unused concated harmony import DDPF_RGB */
/* unused concated harmony import DDPF_YUV */
/* unused concated harmony import DDPF_LUMINANCE */
/* concated harmony reexport DDS_HEADER_LENGTH_INT */__webpack_require__.d(__webpack_exports__, "c", function() { return DDS_HEADER_LENGTH_INT; });
/* concated harmony reexport DDS_HEADER_OFFSET_MAGIC */__webpack_require__.d(__webpack_exports__, "g", function() { return DDS_HEADER_OFFSET_MAGIC; });
/* concated harmony reexport DDS_HEADER_OFFSET_SIZE */__webpack_require__.d(__webpack_exports__, "j", function() { return DDS_HEADER_OFFSET_SIZE; });
/* concated harmony reexport DDS_HEADER_OFFSET_FLAGS */__webpack_require__.d(__webpack_exports__, "e", function() { return DDS_HEADER_OFFSET_FLAGS; });
/* concated harmony reexport DDS_HEADER_OFFSET_HEIGHT */__webpack_require__.d(__webpack_exports__, "f", function() { return DDS_HEADER_OFFSET_HEIGHT; });
/* concated harmony reexport DDS_HEADER_OFFSET_WIDTH */__webpack_require__.d(__webpack_exports__, "k", function() { return DDS_HEADER_OFFSET_WIDTH; });
/* concated harmony reexport DDS_HEADER_OFFSET_MIPMAP_COUNT */__webpack_require__.d(__webpack_exports__, "h", function() { return DDS_HEADER_OFFSET_MIPMAP_COUNT; });
/* unused concated harmony import DDS_HEADER_OFFSET_PF_FLAGS */
/* concated harmony reexport DDS_HEADER_OFFSET_PF_FOURCC */__webpack_require__.d(__webpack_exports__, "i", function() { return DDS_HEADER_OFFSET_PF_FOURCC; });
/* unused concated harmony import DDS_HEADER_OFFSET_RGB_BPP */
/* unused concated harmony import DDS_HEADER_OFFSET_R_MASK */
/* unused concated harmony import DDS_HEADER_OFFSET_G_MASK */
/* unused concated harmony import DDS_HEADER_OFFSET_B_MASK */
/* unused concated harmony import DDS_HEADER_OFFSET_A_MASK */
/* unused concated harmony import DDS_HEADER_OFFSET_CAPS1 */
/* concated harmony reexport DDS_HEADER_OFFSET_CAPS2 */__webpack_require__.d(__webpack_exports__, "d", function() { return DDS_HEADER_OFFSET_CAPS2; });
/* unused concated harmony import DDS_HEADER_OFFSET_CAPS3 */
/* unused concated harmony import DDS_HEADER_OFFSET_CAPS4 */
/* unused concated harmony import DDS_HEADER_OFFSET_DXGI_FORMAT */
/* concated harmony reexport FOURCC_DXT1 */__webpack_require__.d(__webpack_exports__, "m", function() { return FOURCC_DXT1; });
/* concated harmony reexport FOURCC_DXT5 */__webpack_require__.d(__webpack_exports__, "o", function() { return FOURCC_DXT5; });
/* concated harmony reexport FOURCC_DXT3 */__webpack_require__.d(__webpack_exports__, "n", function() { return FOURCC_DXT3; });
/* unused concated harmony import FOURCC_DXT10 */
/* unused concated harmony import FOURCC_D3DFMT_R16G16B16A16F */
/* unused concated harmony import FOURCC_D3DFMT_R32G32B32A32F */
/* unused concated harmony import DXGI_FORMAT_R16G16B16A16_FLOAT */
/* unused concated harmony import DXGI_FORMAT_B8G8R8X8_UNORM */
/* unused concated harmony import VendorRequestAnimationFrame */
/* unused concated harmony import VendorCancelAnimationFrame */
/* unused concated harmony import VendorRequestFullScreen */
/* unused concated harmony import VendorExitFullScreen */
/* unused concated harmony import VendorGetFullScreenElement */
/* unused concated harmony import VendorWebglPrefixes */
/* unused concated harmony import WebglContextNames */
/* unused concated harmony import Webgl2ContextNames */
/* unused concated harmony import WebglVersion */
/* concated harmony reexport util */__webpack_require__.d(__webpack_exports__, "F", function() { return util; });
/* concated harmony reexport consts */__webpack_require__.d(__webpack_exports__, "u", function() { return Tw2Constant_namespaceObject; });






/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./core/batch/Tw2BatchAccumulator.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Accumulates render batches for rendering
 *
 * @property {Array.<Tw2RenderBatch>} batches - Accumulator render batches and/or child Tw2BatchAccumulators
 * @property {?function} _sortMethod          - An optional method to sort batches before rendering them
 * @class
 */

let Tw2BatchAccumulator_Tw2BatchAccumulator =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {?function} [sorting=null] - An optional function for sorting the collected render batches
   */
  function Tw2BatchAccumulator() {
    let sorting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, Tw2BatchAccumulator);

    _defineProperty(this, "batches", []);

    _defineProperty(this, "_sortMethod", null);

    this._sortMethod = sorting;
  }
  /**
   * Gets the batch count
   * @returns {number}
   */


  _createClass(Tw2BatchAccumulator, [{
    key: "Commit",

    /**
     * Commits a batch
     * @param {Tw2BatchAccumulator|Tw2RenderBatch} batch
     */
    value: function Commit(batch) {
      this.batches.push(batch);
    }
    /**
     * Clears any accumulated render batches
     */

  }, {
    key: "Clear",
    value: function Clear() {
      this.batches = [];
    }
    /**
     * Renders the accumulated render batches
     * @param {string} [technique] - technique name
     */

  }, {
    key: "Render",
    value: function Render() {
      let technique = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Main';

      if (this._sortMethod) {
        this.batches.sort(this._sortMethod);
      }

      for (let i = 0; i < this.batches.length; ++i) {
        if (this.batches[i] instanceof Tw2BatchAccumulator) {
          this.batches[i].Render(technique);
        } else {
          if (this.batches[i].renderMode !== global["w" /* device */].RM_ANY) {
            global["w" /* device */].SetStandardStates(this.batches[i].renderMode);
          }

          global["w" /* device */].perObjectData = this.batches[i].perObjectData;
          this.batches[i].Commit(technique);
        }
      }
    }
  }, {
    key: "length",
    get: function get() {
      return this.batches.length;
    }
  }]);

  return Tw2BatchAccumulator;
}();
// CONCATENATED MODULE: ./core/batch/Tw2RenderBatch.js
function Tw2RenderBatch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RenderBatch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RenderBatch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RenderBatch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RenderBatch_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RenderBatch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*eslint no-unused-vars:0*/

/**
 * Tw2RenderBatch base class
 *
 * @property {number} renderMode
 * @property {Tw2PerObjectData} perObjectData
 * @class
 */

let Tw2RenderBatch_Tw2RenderBatch =
/*#__PURE__*/
function () {
  function Tw2RenderBatch() {
    Tw2RenderBatch_classCallCheck(this, Tw2RenderBatch);

    Tw2RenderBatch_defineProperty(this, "renderMode", global["w" /* device */].RM_ANY);

    Tw2RenderBatch_defineProperty(this, "perObjectData", null);
  }

  Tw2RenderBatch_createClass(Tw2RenderBatch, [{
    key: "Commit",

    /**
     * Commits the batch
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {}
  }]);

  return Tw2RenderBatch;
}();
// CONCATENATED MODULE: ./core/batch/Tw2ForwardingRenderBatch.js
function Tw2ForwardingRenderBatch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ForwardingRenderBatch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ForwardingRenderBatch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ForwardingRenderBatch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ForwardingRenderBatch_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ForwardingRenderBatch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * A render batch that uses geometry provided from an external source
 *
 * @property {*} geometryProvider
 * @class
 */

let Tw2ForwardingRenderBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  _inherits(Tw2ForwardingRenderBatch, _Tw2RenderBatch);

  function Tw2ForwardingRenderBatch() {
    var _this;

    Tw2ForwardingRenderBatch_classCallCheck(this, Tw2ForwardingRenderBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2ForwardingRenderBatch).call(this, ...args));

    Tw2ForwardingRenderBatch_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "geometryProvider", null);

    return _this;
  }

  Tw2ForwardingRenderBatch_createClass(Tw2ForwardingRenderBatch, [{
    key: "Commit",

    /**
     * Commits the batch for rendering
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      if (this.geometryProvider) {
        this.geometryProvider.Render(this, technique);
      }
    }
  }]);

  return Tw2ForwardingRenderBatch;
}(Tw2RenderBatch_Tw2RenderBatch);
// CONCATENATED MODULE: ./core/batch/Tw2GeometryBatch.js
function Tw2GeometryBatch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryBatch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2GeometryBatch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2GeometryBatch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2GeometryBatch_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2GeometryBatch_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2GeometryBatch_assertThisInitialized(self); }

function Tw2GeometryBatch_getPrototypeOf(o) { Tw2GeometryBatch_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2GeometryBatch_getPrototypeOf(o); }

function Tw2GeometryBatch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2GeometryBatch_setPrototypeOf(subClass, superClass); }

function Tw2GeometryBatch_setPrototypeOf(o, p) { Tw2GeometryBatch_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2GeometryBatch_setPrototypeOf(o, p); }

function Tw2GeometryBatch_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2GeometryBatch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * A render batch for geometry
 *
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect} effect
 * @property {string} technique
 * @class
 */

let Tw2GeometryBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  Tw2GeometryBatch_inherits(Tw2GeometryBatch, _Tw2RenderBatch);

  function Tw2GeometryBatch() {
    var _this;

    Tw2GeometryBatch_classCallCheck(this, Tw2GeometryBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2GeometryBatch_possibleConstructorReturn(this, Tw2GeometryBatch_getPrototypeOf(Tw2GeometryBatch).call(this, ...args));

    Tw2GeometryBatch_defineProperty(Tw2GeometryBatch_assertThisInitialized(Tw2GeometryBatch_assertThisInitialized(_this)), "geometryRes", null);

    Tw2GeometryBatch_defineProperty(Tw2GeometryBatch_assertThisInitialized(Tw2GeometryBatch_assertThisInitialized(_this)), "meshIx", 0);

    Tw2GeometryBatch_defineProperty(Tw2GeometryBatch_assertThisInitialized(Tw2GeometryBatch_assertThisInitialized(_this)), "start", 0);

    Tw2GeometryBatch_defineProperty(Tw2GeometryBatch_assertThisInitialized(Tw2GeometryBatch_assertThisInitialized(_this)), "count", 1);

    Tw2GeometryBatch_defineProperty(Tw2GeometryBatch_assertThisInitialized(Tw2GeometryBatch_assertThisInitialized(_this)), "effect", null);

    return _this;
  }

  Tw2GeometryBatch_createClass(Tw2GeometryBatch, [{
    key: "Commit",

    /**
     * Commits the Tw2InstancedMeshBatch for rendering
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      if (this.geometryRes && this.effect) {
        this.geometryRes.RenderAreas(this.meshIx, this.start, this.count, this.effect, technique);
      }
    }
  }]);

  return Tw2GeometryBatch;
}(Tw2RenderBatch_Tw2RenderBatch);
// CONCATENATED MODULE: ./core/batch/Tw2GeometryLineBatch.js
function Tw2GeometryLineBatch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryLineBatch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2GeometryLineBatch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2GeometryLineBatch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2GeometryLineBatch_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2GeometryLineBatch_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2GeometryLineBatch_assertThisInitialized(self); }

function Tw2GeometryLineBatch_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2GeometryLineBatch_getPrototypeOf(o) { Tw2GeometryLineBatch_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2GeometryLineBatch_getPrototypeOf(o); }

function Tw2GeometryLineBatch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2GeometryLineBatch_setPrototypeOf(subClass, superClass); }

function Tw2GeometryLineBatch_setPrototypeOf(o, p) { Tw2GeometryLineBatch_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2GeometryLineBatch_setPrototypeOf(o, p); }


/**
 * A render batch for line geometry
 *
 * @class
 */

let Tw2GeometryLineBatch =
/*#__PURE__*/
function (_Tw2GeometryBatch) {
  Tw2GeometryLineBatch_inherits(Tw2GeometryLineBatch, _Tw2GeometryBatch);

  function Tw2GeometryLineBatch() {
    Tw2GeometryLineBatch_classCallCheck(this, Tw2GeometryLineBatch);

    return Tw2GeometryLineBatch_possibleConstructorReturn(this, Tw2GeometryLineBatch_getPrototypeOf(Tw2GeometryLineBatch).apply(this, arguments));
  }

  Tw2GeometryLineBatch_createClass(Tw2GeometryLineBatch, [{
    key: "Commit",

    /**
     * Commits the Geometry Line Batch for rendering
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      if (this.geometryRes && this.effect) {
        this.geometryRes.RenderLines(this.meshIx, this.start, this.count, this.effect, technique);
      }
    }
  }]);

  return Tw2GeometryLineBatch;
}(Tw2GeometryBatch);
// CONCATENATED MODULE: ./core/batch/Tw2InstancedMeshBatch.js
function Tw2InstancedMeshBatch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2InstancedMeshBatch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2InstancedMeshBatch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2InstancedMeshBatch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2InstancedMeshBatch_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2InstancedMeshBatch_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2InstancedMeshBatch_assertThisInitialized(self); }

function Tw2InstancedMeshBatch_getPrototypeOf(o) { Tw2InstancedMeshBatch_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2InstancedMeshBatch_getPrototypeOf(o); }

function Tw2InstancedMeshBatch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2InstancedMeshBatch_setPrototypeOf(subClass, superClass); }

function Tw2InstancedMeshBatch_setPrototypeOf(o, p) { Tw2InstancedMeshBatch_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2InstancedMeshBatch_setPrototypeOf(o, p); }

function Tw2InstancedMeshBatch_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2InstancedMeshBatch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * A render batch for Instanced geometry
 *
 * @property {Tw2InstancedMesh} instanceMesh
 * @class
 */

let Tw2InstancedMeshBatch =
/*#__PURE__*/
function (_Tw2GeometryBatch) {
  Tw2InstancedMeshBatch_inherits(Tw2InstancedMeshBatch, _Tw2GeometryBatch);

  function Tw2InstancedMeshBatch() {
    var _this;

    Tw2InstancedMeshBatch_classCallCheck(this, Tw2InstancedMeshBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2InstancedMeshBatch_possibleConstructorReturn(this, Tw2InstancedMeshBatch_getPrototypeOf(Tw2InstancedMeshBatch).call(this, ...args));

    Tw2InstancedMeshBatch_defineProperty(Tw2InstancedMeshBatch_assertThisInitialized(Tw2InstancedMeshBatch_assertThisInitialized(_this)), "instanceMesh", null);

    return _this;
  }

  Tw2InstancedMeshBatch_createClass(Tw2InstancedMeshBatch, [{
    key: "Commit",

    /**
     * Commits the Tw2InstancedMeshBatch for rendering
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      if (this.instanceMesh && this.effect) {
        this.instanceMesh.RenderAreas(this.meshIx, this.start, this.count, this.effect, technique);
      }
    }
  }]);

  return Tw2InstancedMeshBatch;
}(Tw2GeometryBatch);
// CONCATENATED MODULE: ./core/batch/index.js






// CONCATENATED MODULE: ./core/curve/Tw2CurveSet.js
function Tw2CurveSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2CurveSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2CurveSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2CurveSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2CurveSet_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2CurveSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2CurveSet
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {Array.<Tw2Curve|Tw2CurveSequencer>} curves
 * @property {Array} bindings
 * @property {number} scale
 * @property {boolean} playOnLoad
 * @property {boolean} isPlaying
 * @property {number} scaledTime
 */

let Tw2CurveSet_Tw2CurveSet =
/*#__PURE__*/
function () {
  function Tw2CurveSet() {
    Tw2CurveSet_classCallCheck(this, Tw2CurveSet);

    Tw2CurveSet_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2CurveSet_defineProperty(this, "name", '');

    Tw2CurveSet_defineProperty(this, "curves", []);

    Tw2CurveSet_defineProperty(this, "bindings", []);

    Tw2CurveSet_defineProperty(this, "scale", 1);

    Tw2CurveSet_defineProperty(this, "playOnLoad", true);

    Tw2CurveSet_defineProperty(this, "isPlaying", false);

    Tw2CurveSet_defineProperty(this, "scaledTime", 0);
  }

  Tw2CurveSet_createClass(Tw2CurveSet, [{
    key: "Initialize",

    /**
     * Initializes the Tw2CurveSet
     */
    value: function Initialize() {
      if (this.playOnLoad) this.Play();
    }
    /**
     * Plays the Tw2CurveSet
     */

  }, {
    key: "Play",
    value: function Play() {
      this.isPlaying = true;
      this.scaledTime = 0;
    }
    /**
     * Plays the Tw2CurveSet from a specific time
     * @param {number} [time=0]
     */

  }, {
    key: "PlayFrom",
    value: function PlayFrom() {
      let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.isPlaying = true;
      this.scaledTime = time;
    }
    /**
     * Stops the Tw2CurveSet from playing
     */

  }, {
    key: "Stop",
    value: function Stop() {
      this.isPlaying = false;
    }
    /**
     * Internal render/update function which is called every frame
     * @param {number} dt - Delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (this.isPlaying) {
        this.scaledTime += dt * this.scale;

        for (let i = 0; i < this.curves.length; ++i) {
          this.curves[i].UpdateValue(this.scaledTime);
        }

        for (let i = 0; i < this.bindings.length; ++i) {
          this.bindings[i].CopyValue();
        }
      }
    }
    /**
     * Gets the maximum curve duration
     *
     * @returns {number}
     */

  }, {
    key: "GetMaxCurveDuration",
    value: function GetMaxCurveDuration() {
      let length = 0;

      for (let i = 0; i < this.curves.length; ++i) {
        if ('GetLength' in this.curves[i]) {
          length = Math.max(length, this.curves[i].GetLength());
        }
      }

      return length;
    }
  }]);

  return Tw2CurveSet;
}();
// EXTERNAL MODULE: ./core/parameter/Tw2Parameter.js
var Tw2Parameter = __webpack_require__(6);

// CONCATENATED MODULE: ./core/parameter/Tw2FloatParameter.js
function Tw2FloatParameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2FloatParameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2FloatParameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2FloatParameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2FloatParameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2FloatParameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2FloatParameter_assertThisInitialized(self); }

function Tw2FloatParameter_getPrototypeOf(o) { Tw2FloatParameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2FloatParameter_getPrototypeOf(o); }

function Tw2FloatParameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2FloatParameter_setPrototypeOf(subClass, superClass); }

function Tw2FloatParameter_setPrototypeOf(o, p) { Tw2FloatParameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2FloatParameter_setPrototypeOf(o, p); }

function Tw2FloatParameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2FloatParameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2FloatParameter
 *
 * @property {string} name
 * @property {number} value
 * @property {?Float32Array} constantBuffer
 * @property {?number} offset
 * @class
 */

let Tw2FloatParameter_Tw2FloatParameter =
/*#__PURE__*/
function (_Tw2Parameter) {
  Tw2FloatParameter_inherits(Tw2FloatParameter, _Tw2Parameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {number} [value=1]
   */
  function Tw2FloatParameter() {
    var _this;

    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    Tw2FloatParameter_classCallCheck(this, Tw2FloatParameter);

    _this = Tw2FloatParameter_possibleConstructorReturn(this, Tw2FloatParameter_getPrototypeOf(Tw2FloatParameter).call(this, name));

    Tw2FloatParameter_defineProperty(Tw2FloatParameter_assertThisInitialized(Tw2FloatParameter_assertThisInitialized(_this)), "name", '');

    Tw2FloatParameter_defineProperty(Tw2FloatParameter_assertThisInitialized(Tw2FloatParameter_assertThisInitialized(_this)), "value", 1);

    Tw2FloatParameter_defineProperty(Tw2FloatParameter_assertThisInitialized(Tw2FloatParameter_assertThisInitialized(_this)), "constantBuffer", null);

    Tw2FloatParameter_defineProperty(Tw2FloatParameter_assertThisInitialized(Tw2FloatParameter_assertThisInitialized(_this)), "offset", null);

    _this.value = global["F" /* util */].isArrayLike(value) ? value[0] : value;
    return _this;
  }
  /**
   * Sets the parameter's value
   * @param {number} value
   * @returns {boolean} true if updated
   */


  Tw2FloatParameter_createClass(Tw2FloatParameter, [{
    key: "SetValue",
    value: function SetValue(value) {
      this.value = value;
      this.OnValueChanged();
    }
    /**
     * Gets the parameter's value
     * @returns {number}
     */

  }, {
    key: "GetValue",
    value: function GetValue() {
      return this.value;
    }
    /**
     * Applies the parameter's value to a constant buffer
     * @param {Float32Array} constantBuffer
     * @param {number} offset
     */

  }, {
    key: "Apply",
    value: function Apply(constantBuffer, offset) {
      constantBuffer[offset] = this.value;
    }
    /**
     * Checks if a value equals the parameter's value
     * @param {number} value
     * @returns {boolean}
     */

  }, {
    key: "EqualsValue",
    value: function EqualsValue(value) {
      return this.value === value;
    }
    /**
     * Copies another float parameter's value
     * @param {Tw2FloatParameter} parameter
     * @param {boolean} [includeName]
     */

  }, {
    key: "Copy",
    value: function Copy(parameter, includeName) {
      if (includeName) this.name = parameter.name;
      this.SetValue(parameter.GetValue());
    }
    /**
     * Checks if a value is a valid parameter value
     * @param {number} a
     * @returns {boolean}
     */

  }], [{
    key: "isValue",
    value: function isValue(a) {
      return global["F" /* util */].isNumber(a);
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2FloatParameter;
}(Tw2Parameter["a" /* Tw2Parameter */]);

Tw2FloatParameter_defineProperty(Tw2FloatParameter_Tw2FloatParameter, "constantBufferSize", 1);
// CONCATENATED MODULE: ./core/parameter/Tw2MatrixParameter.js
function Tw2MatrixParameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MatrixParameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MatrixParameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MatrixParameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MatrixParameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2MatrixParameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2MatrixParameter_assertThisInitialized(self); }

function Tw2MatrixParameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2MatrixParameter_getPrototypeOf(o) { Tw2MatrixParameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2MatrixParameter_getPrototypeOf(o); }

function Tw2MatrixParameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2MatrixParameter_setPrototypeOf(subClass, superClass); }

function Tw2MatrixParameter_setPrototypeOf(o, p) { Tw2MatrixParameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2MatrixParameter_setPrototypeOf(o, p); }

function Tw2MatrixParameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MatrixParameter
 *
 * @class
 */

let Tw2MatrixParameter_Tw2MatrixParameter =
/*#__PURE__*/
function (_Tw2VectorParameter) {
  Tw2MatrixParameter_inherits(Tw2MatrixParameter, _Tw2VectorParameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {mat4|Float32Array|Array} [value=mat4.create()]
   */
  function Tw2MatrixParameter() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : global["z" /* mat4 */].create();

    Tw2MatrixParameter_classCallCheck(this, Tw2MatrixParameter);

    return Tw2MatrixParameter_possibleConstructorReturn(this, Tw2MatrixParameter_getPrototypeOf(Tw2MatrixParameter).call(this, name, value));
  }
  /**
   * Composes the parameter's value from components
   * @param {Tw2Vector4Parameter|quat} rotation
   * @param {Tw2Vector3Parameter|vec3} translation
   * @param {Tw2Vector3Parameter|vec3} scaling
   */


  Tw2MatrixParameter_createClass(Tw2MatrixParameter, [{
    key: "Compose",
    value: function Compose(rotation, translation, scaling) {
      if ('value' in rotation) rotation = rotation['value'];
      if ('value' in translation) translation = translation['value'];
      if ('value' in scaling) scaling = scaling['value'];
      global["z" /* mat4 */].fromRotationTranslationScale(this.value, rotation, translation, scaling);
      this.OnValueChanged();
    }
    /**
     * Decomposes the parameter's value to components
     * @param {Tw2Vector4Parameter|quat} rotation
     * @param {Tw2Vector3Parameter|vec3} translation
     * @param {Tw2Vector3Parameter|vec3} scaling
     */

  }, {
    key: "Decompose",
    value: function Decompose(rotation, translation, scaling) {
      global["z" /* mat4 */].getRotation('value' in rotation ? rotation.value : rotation, this.value);
      global["z" /* mat4 */].getTranslation('value' in translation ? translation.value : translation, this.value);
      global["z" /* mat4 */].getScaling('value' in scaling ? scaling.value : scaling, this.value);
      if ('OnValueChanged' in rotation) rotation.OnValueChanged();
      if ('OnValueChanged' in translation) translation.OnValueChanged();
      if ('OnValueChanged' in scaling) scaling.OnValueChanged();
    }
    /**
     * Gets the matrices' translation x value
     * @returns {number}
     */

  }, {
    key: "x",
    get: function get() {
      return this.GetIndexValue(12);
    }
    /**
     * Sets the matrices' translation x value
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(12, val);
    }
    /**
     * Gets the matrices' translation y value
     * @returns {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this.GetIndexValue(13);
    }
    /**
     * Sets the matrices' translation y value
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(13, val);
    }
    /**
     * Gets the matrices' translation z value
     * @returns {number}
     */

  }, {
    key: "z",
    get: function get() {
      return this.GetIndexValue(14);
    }
    /**
     * Sets the matrices' translation z value
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(14, val);
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2MatrixParameter;
}(Tw2Parameter["b" /* Tw2VectorParameter */]);

Tw2MatrixParameter_defineProperty(Tw2MatrixParameter_Tw2MatrixParameter, "constantBufferSize", 16);
// CONCATENATED MODULE: ./core/parameter/Tw2TransformParameter.js
function Tw2TransformParameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2TransformParameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2TransformParameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2TransformParameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2TransformParameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2TransformParameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2TransformParameter_assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Tw2TransformParameter_getPrototypeOf(object); if (object === null) break; } return object; }

function Tw2TransformParameter_getPrototypeOf(o) { Tw2TransformParameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2TransformParameter_getPrototypeOf(o); }

function Tw2TransformParameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2TransformParameter_setPrototypeOf(subClass, superClass); }

function Tw2TransformParameter_setPrototypeOf(o, p) { Tw2TransformParameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2TransformParameter_setPrototypeOf(o, p); }

function Tw2TransformParameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2TransformParameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2TransformParameter
 *
 * @parameter {string} name
 * @parameter {vec3} scaling=[1,1,1]
 * @parameter {quat} rotation=[0,0,0,1]
 * @parameter {vec3} translation=[0,0,0]
 * @parameter {mat4} transform
 * @parameter {mat4} transformTranspose
 * @class
 */

let Tw2TransformParameter_Tw2TransformParameter =
/*#__PURE__*/
function (_Tw2Parameter) {
  Tw2TransformParameter_inherits(Tw2TransformParameter, _Tw2Parameter);

  function Tw2TransformParameter() {
    var _this;

    Tw2TransformParameter_classCallCheck(this, Tw2TransformParameter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2TransformParameter_possibleConstructorReturn(this, Tw2TransformParameter_getPrototypeOf(Tw2TransformParameter).call(this, ...args));

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "name", '');

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "rotationCenter", global["H" /* vec3 */].create());

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "rotation", global["C" /* quat */].create());

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "translation", global["H" /* vec3 */].create());

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "transform", global["z" /* mat4 */].create());

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "worldTransform", global["z" /* mat4 */].create());

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "constantBuffer", null);

    Tw2TransformParameter_defineProperty(Tw2TransformParameter_assertThisInitialized(Tw2TransformParameter_assertThisInitialized(_this)), "offset", null);

    return _this;
  }

  Tw2TransformParameter_createClass(Tw2TransformParameter, [{
    key: "Initialize",

    /**
     * Initializes the transform parameter
     */
    value: function Initialize() {
      this.OnValueChanged();
    }
    /**
     * Gets the parameter's value
     * @param {boolean} [serialize]
     * @returns {Array|Float32Array|mat4}
     */

  }, {
    key: "GetValue",
    value: function GetValue(serialize) {
      return serialize ? Array.from(this.transform) : new Float32Array(this.transform);
    }
    /**
     * Fire on value changes
     * @param {*} [controller]        - An optional argument to track the object that called this function
     * @param {string[]} [properties] - An option array containing the properties that were updated
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged(controller, properties) {
      global["z" /* mat4 */].fromRotationTranslationScaleOrigin(this.transform, this.rotation, this.translation, this.scaling, this.rotationCenter);
      global["z" /* mat4 */].transpose(this.worldTransform, this.transform);

      _get(Tw2TransformParameter_getPrototypeOf(Tw2TransformParameter.prototype), "OnValueChanged", this).call(this, controller, properties);
    }
    /**
     * Binds the parameter to a constant buffer
     * @param {Float32Array} constantBuffer
     * @param {number} offset
     * @param {number} size
     * @returns {boolean}
     */

  }, {
    key: "Bind",
    value: function Bind(constantBuffer, offset, size) {
      if (!this.constantBuffer && size >= this.size) {
        this.constantBuffer = constantBuffer;
        this.offset = offset;
        this.Apply(constantBuffer, offset, size);
        return true;
      }

      return false;
    }
    /**
     * Applies the parameter's value to a constant buffer
     * @param {Float32Array} constantBuffer
     * @param {number} offset
     * @param {number} size
     */

  }, {
    key: "Apply",
    value: function Apply(constantBuffer, offset, size) {
      if (size >= this.constructor.constantBufferSize) {
        constantBuffer.set(this.worldTransform, offset);
      } else {
        constantBuffer.set(this.worldTransform.subarray(0, size), offset);
      }
    }
    /**
     * Copies another transform parameter's values
     * @param {Tw2TransformParameter} parameter
     * @param {boolean} [includeName]
     */

  }, {
    key: "Copy",
    value: function Copy(parameter, includeName) {
      if (includeName) this.name = parameter.name;
      global["C" /* quat */].copy(this.rotation, parameter.rotation);
      global["H" /* vec3 */].copy(this.translation, parameter.translation);
      global["H" /* vec3 */].copy(this.scaling, parameter.scaling);
      global["H" /* vec3 */].copy(this.rotationCenter, parameter.rotationCenter);
      this.OnValueChanged();
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2TransformParameter;
}(Tw2Parameter["a" /* Tw2Parameter */]);

Tw2TransformParameter_defineProperty(Tw2TransformParameter_Tw2TransformParameter, "constantBufferSize", 16);
// CONCATENATED MODULE: ./core/parameter/Tw2VariableParameter.js
function Tw2VariableParameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2VariableParameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2VariableParameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2VariableParameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2VariableParameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2VariableParameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2VariableParameter_assertThisInitialized(self); }

function Tw2VariableParameter_getPrototypeOf(o) { Tw2VariableParameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2VariableParameter_getPrototypeOf(o); }

function Tw2VariableParameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2VariableParameter_setPrototypeOf(subClass, superClass); }

function Tw2VariableParameter_setPrototypeOf(o, p) { Tw2VariableParameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2VariableParameter_setPrototypeOf(o, p); }

function Tw2VariableParameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2VariableParameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2VariableParameter
 *
 * @property {string} variableName
 * @class
 */

let Tw2VariableParameter_Tw2VariableParameter =
/*#__PURE__*/
function (_Tw2Parameter) {
  Tw2VariableParameter_inherits(Tw2VariableParameter, _Tw2Parameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {string} [variableName='']
   */
  function Tw2VariableParameter() {
    var _this;

    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let variableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    Tw2VariableParameter_classCallCheck(this, Tw2VariableParameter);

    _this = Tw2VariableParameter_possibleConstructorReturn(this, Tw2VariableParameter_getPrototypeOf(Tw2VariableParameter).call(this, name));

    Tw2VariableParameter_defineProperty(Tw2VariableParameter_assertThisInitialized(Tw2VariableParameter_assertThisInitialized(_this)), "variableName", '');

    _this.variableName = variableName;
    return _this;
  }
  /**
   * Gets the linked variable
   * @returns {Tw2Parameter}
   */


  Tw2VariableParameter_createClass(Tw2VariableParameter, [{
    key: "GetValue",

    /**
     * Gets the variable's value
     * @param {boolean} [serialize]
     * @returns {?*}
     */
    value: function GetValue(serialize) {
      return global["E" /* store */].GetVariableValue(this.variableName, serialize);
    }
    /**
     * Apply
     * @param {*} a
     * @param {*} b
     * @param {*} c
     */

  }, {
    key: "Apply",
    value: function Apply(a, b, c) {
      if (this.variable) {
        this.variable.Apply(a, b, c);
      }
    }
    /**
     * Not implemented for Variable Parameters
     * @returns {boolean} true if successful
     */

  }, {
    key: "AddCallback",
    value: function AddCallback() {
      return false;
    }
    /**
     * Copies another variable parameter's value
     * @param {Tw2VariableParameter} parameter
     * @param {boolean} [includeName]
     */

  }, {
    key: "Copy",
    value: function Copy(parameter, includeName) {
      if (includeName) this.name = parameter.name;
      this.variableName = parameter.variableName;
    }
  }, {
    key: "variable",
    get: function get() {
      return global["E" /* store */].GetVariable(this.variableName);
    }
    /**
     * Gets the linked variable's size
     * @returns {number}
     */

  }, {
    key: "size",
    get: function get() {
      return this.variable ? this.variable.size : 0;
    }
  }]);

  return Tw2VariableParameter;
}(Tw2Parameter["a" /* Tw2Parameter */]);
// CONCATENATED MODULE: ./core/parameter/Tw2Vector2Parameter.js
function Tw2Vector2Parameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Vector2Parameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Vector2Parameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Vector2Parameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Vector2Parameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Vector2Parameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Vector2Parameter_assertThisInitialized(self); }

function Tw2Vector2Parameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Vector2Parameter_getPrototypeOf(o) { Tw2Vector2Parameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Vector2Parameter_getPrototypeOf(o); }

function Tw2Vector2Parameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Vector2Parameter_setPrototypeOf(subClass, superClass); }

function Tw2Vector2Parameter_setPrototypeOf(o, p) { Tw2Vector2Parameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Vector2Parameter_setPrototypeOf(o, p); }

function Tw2Vector2Parameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Vector2Parameter
 *
 * @class
 */

let Tw2Vector2Parameter_Tw2Vector2Parameter =
/*#__PURE__*/
function (_Tw2VectorParameter) {
  Tw2Vector2Parameter_inherits(Tw2Vector2Parameter, _Tw2VectorParameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {vec2|Array|Float32Array} [value=vec2.fromValues(1,1)]
   */
  function Tw2Vector2Parameter() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : global["G" /* vec2 */].fromValues(1, 1);

    Tw2Vector2Parameter_classCallCheck(this, Tw2Vector2Parameter);

    return Tw2Vector2Parameter_possibleConstructorReturn(this, Tw2Vector2Parameter_getPrototypeOf(Tw2Vector2Parameter).call(this, name, value));
  }
  /**
   * Gets the first value index
   * @returns {number}
   */


  Tw2Vector2Parameter_createClass(Tw2Vector2Parameter, [{
    key: "x",
    get: function get() {
      return this.GetIndexValue(0);
    }
    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }
    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this.GetIndexValue(1);
    }
    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2Vector2Parameter;
}(Tw2Parameter["b" /* Tw2VectorParameter */]);

Tw2Vector2Parameter_defineProperty(Tw2Vector2Parameter_Tw2Vector2Parameter, "constantBufferSize", 2);
// CONCATENATED MODULE: ./core/parameter/Tw2Vector3Parameter.js
function Tw2Vector3Parameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Vector3Parameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Vector3Parameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Vector3Parameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Vector3Parameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Vector3Parameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Vector3Parameter_assertThisInitialized(self); }

function Tw2Vector3Parameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Vector3Parameter_getPrototypeOf(o) { Tw2Vector3Parameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Vector3Parameter_getPrototypeOf(o); }

function Tw2Vector3Parameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Vector3Parameter_setPrototypeOf(subClass, superClass); }

function Tw2Vector3Parameter_setPrototypeOf(o, p) { Tw2Vector3Parameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Vector3Parameter_setPrototypeOf(o, p); }

function Tw2Vector3Parameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Vector3Parameter
 *
 * @class
 */

let Tw2Vector3Parameter_Tw2Vector3Parameter =
/*#__PURE__*/
function (_Tw2VectorParameter) {
  Tw2Vector3Parameter_inherits(Tw2Vector3Parameter, _Tw2VectorParameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {vec3|Array|Float32Array} [value=vec3.fromValues(1,1,1)]
   */
  function Tw2Vector3Parameter() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : global["H" /* vec3 */].fromValues(1, 1, 1);

    Tw2Vector3Parameter_classCallCheck(this, Tw2Vector3Parameter);

    return Tw2Vector3Parameter_possibleConstructorReturn(this, Tw2Vector3Parameter_getPrototypeOf(Tw2Vector3Parameter).call(this, name, value));
  }
  /**
   * Gets the first value index
   * @returns {number}
   */


  Tw2Vector3Parameter_createClass(Tw2Vector3Parameter, [{
    key: "x",
    get: function get() {
      return this.GetIndexValue(0);
    }
    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }
    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this.GetIndexValue(1);
    }
    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }
    /**
     * Gets the third value index
     * @returns {number}
     */

  }, {
    key: "z",
    get: function get() {
      return this.GetIndexValue(2);
    }
    /**
     * Sets the third value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(2, val);
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2Vector3Parameter;
}(Tw2Parameter["b" /* Tw2VectorParameter */]);

Tw2Vector3Parameter_defineProperty(Tw2Vector3Parameter_Tw2Vector3Parameter, "constantBufferSize", 3);
// CONCATENATED MODULE: ./core/parameter/Tw2Vector4Parameter.js
function Tw2Vector4Parameter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Vector4Parameter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Vector4Parameter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Vector4Parameter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Vector4Parameter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Vector4Parameter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Vector4Parameter_assertThisInitialized(self); }

function Tw2Vector4Parameter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Vector4Parameter_getPrototypeOf(o) { Tw2Vector4Parameter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Vector4Parameter_getPrototypeOf(o); }

function Tw2Vector4Parameter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Vector4Parameter_setPrototypeOf(subClass, superClass); }

function Tw2Vector4Parameter_setPrototypeOf(o, p) { Tw2Vector4Parameter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Vector4Parameter_setPrototypeOf(o, p); }

function Tw2Vector4Parameter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Vector4Parameter
 *
 * @class
 */

let Tw2Vector4Parameter_Tw2Vector4Parameter =
/*#__PURE__*/
function (_Tw2VectorParameter) {
  Tw2Vector4Parameter_inherits(Tw2Vector4Parameter, _Tw2VectorParameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {vec4|Array|Float32Array} [value=vec4.fromValues(1,1,1,1)]
   */
  function Tw2Vector4Parameter() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : global["I" /* vec4 */].fromValues(1, 1, 1, 1);

    Tw2Vector4Parameter_classCallCheck(this, Tw2Vector4Parameter);

    return Tw2Vector4Parameter_possibleConstructorReturn(this, Tw2Vector4Parameter_getPrototypeOf(Tw2Vector4Parameter).call(this, name, value));
  }
  /**
   * Gets the first value index
   * @returns {number}
   */


  Tw2Vector4Parameter_createClass(Tw2Vector4Parameter, [{
    key: "x",
    get: function get() {
      return this.GetIndexValue(0);
    }
    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }
    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: "y",
    get: function get() {
      return this.GetIndexValue(1);
    }
    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }
    /**
     * Gets the third value index
     * @returns {number}
     */

  }, {
    key: "z",
    get: function get() {
      return this.GetIndexValue(2);
    }
    /**
     * Sets the third value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(2, val);
    }
    /**
     * Gets the fourth value index
     * @returns {number}
     */

  }, {
    key: "w",
    get: function get() {
      return this.GetIndexValue(3);
    }
    /**
     * Sets the fourth value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(3, val);
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }]);

  return Tw2Vector4Parameter;
}(Tw2Parameter["b" /* Tw2VectorParameter */]);

Tw2Vector4Parameter_defineProperty(Tw2Vector4Parameter_Tw2Vector4Parameter, "constantBufferSize", 4);
// EXTERNAL MODULE: ./core/parameter/Tw2TextureParameter.js
var Tw2TextureParameter = __webpack_require__(9);

// CONCATENATED MODULE: ./core/parameter/index.js









// CONCATENATED MODULE: ./core/curve/Tw2ValueBinding.js
function Tw2ValueBinding_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ValueBinding_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ValueBinding_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ValueBinding_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ValueBinding_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ValueBinding_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ValueBinding
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {Object} sourceObject
 * @property {string} sourceAttribute
 * @property {?number} _sourceElement
 * @property {?boolean} sourceIsArray
 * @property {Object} destinationObject
 * @property {string} destinationAttribute
 * @property {?number} _destinationElement
 * @property {?boolean} destinationIsArray
 * @property {number} scale
 * @property {quat} offset
 * @property {null|Function} _copyFunc - The function to use when updating destination attributes
 */

let Tw2ValueBinding_Tw2ValueBinding =
/*#__PURE__*/
function () {
  function Tw2ValueBinding() {
    Tw2ValueBinding_classCallCheck(this, Tw2ValueBinding);

    Tw2ValueBinding_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2ValueBinding_defineProperty(this, "name", '');

    Tw2ValueBinding_defineProperty(this, "sourceObject", null);

    Tw2ValueBinding_defineProperty(this, "sourceAttribute", '');

    Tw2ValueBinding_defineProperty(this, "_sourceElement", null);

    Tw2ValueBinding_defineProperty(this, "sourceIsArray", null);

    Tw2ValueBinding_defineProperty(this, "destinationObject", null);

    Tw2ValueBinding_defineProperty(this, "destinationAttribute", '');

    Tw2ValueBinding_defineProperty(this, "_destinationElement", null);

    Tw2ValueBinding_defineProperty(this, "destinationIsArray", null);

    Tw2ValueBinding_defineProperty(this, "scale", 1);

    Tw2ValueBinding_defineProperty(this, "offset", global["C" /* quat */].create());

    Tw2ValueBinding_defineProperty(this, "_copyFunc", null);
  }

  Tw2ValueBinding_createClass(Tw2ValueBinding, [{
    key: "Initialize",

    /**
     * Initializes the Value Binding
     */
    value: function Initialize() {
      if (!this.sourceObject || this.sourceAttribute === '') return;
      if (!this.destinationObject || this.destinationAttribute === '') return;
      let srcSwizzled = false,
          destSwizzled = false,
          srcSwizzle = this.sourceAttribute.substr(-2);

      if (srcSwizzle === '.x' || srcSwizzle === '.r') {
        srcSwizzled = true;
        this._sourceElement = 0;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
      } else if (srcSwizzle === '.y' || srcSwizzle === '.g') {
        srcSwizzled = true;
        this._sourceElement = 1;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
      } else if (srcSwizzle === '.z' || srcSwizzle === '.b') {
        srcSwizzled = true;
        this._sourceElement = 2;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
      } else if (srcSwizzle === '.w' || srcSwizzle === '.a') {
        srcSwizzled = true;
        this._sourceElement = 3;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
      } else if (this.sourceObject instanceof Tw2Vector4Parameter_Tw2Vector4Parameter) {
        if (this.sourceAttribute === 'v1') {
          srcSwizzled = true;
          this._sourceElement = 0;
          this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v2') {
          srcSwizzled = true;
          this._sourceElement = 1;
          this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v3') {
          srcSwizzled = true;
          this._sourceElement = 2;
          this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v4') {
          srcSwizzled = true;
          this._sourceElement = 3;
          this.sourceAttribute = 'value';
        }
      }

      let destSwizzle = this.destinationAttribute.substr(-2);

      if (destSwizzle === '.x' || destSwizzle === '.r') {
        destSwizzled = true;
        this._destinationElement = 0;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
      } else if (destSwizzle === '.y' || destSwizzle === '.g') {
        destSwizzled = true;
        this._destinationElement = 1;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
      } else if (destSwizzle === '.z' || destSwizzle === '.b') {
        destSwizzled = true;
        this._destinationElement = 2;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
      } else if (destSwizzle === '.w' || destSwizzle === '.a') {
        destSwizzled = true;
        this._destinationElement = 3;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
      } else if (this.destinationObject instanceof Tw2Vector4Parameter_Tw2Vector4Parameter) {
        if (this.destinationAttribute === 'v1') {
          destSwizzled = true;
          this._destinationElement = 0;
          this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v2') {
          destSwizzled = true;
          this._destinationElement = 1;
          this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v3') {
          destSwizzled = true;
          this._destinationElement = 2;
          this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v4') {
          destSwizzled = true;
          this._destinationElement = 3;
          this.destinationAttribute = 'value';
        }
      }

      if (!(this.sourceAttribute in this.sourceObject) || !(this.destinationAttribute in this.destinationObject)) {
        return;
      }

      this.sourceIsArray = global["F" /* util */].isArrayLike(this.sourceObject[this.sourceAttribute]);
      this.destinationIsArray = global["F" /* util */].isArrayLike(this.destinationObject[this.destinationAttribute]);

      if (this.sourceIsArray === this.destinationIsArray && typeof this.sourceObject[this.sourceAttribute] === typeof this.destinationObject[this.destinationAttribute]) {
        if (this.sourceIsArray) {
          if (srcSwizzled) {
            if (destSwizzled) {
              this._copyFunc = Tw2ValueBinding.CopyElementToElement;
            } else {
              this._copyFunc = Tw2ValueBinding.ReplicateElement;
            }
          } else {
            if (this.sourceObject[this.sourceAttribute].length <= this.destinationObject[this.destinationAttribute].length) {
              this._copyFunc = Tw2ValueBinding.CopyArray;
            } else if (this.sourceObject[this.sourceAttribute].length === 16) {
              this._copyFunc = Tw2ValueBinding.ExtractPos;
            }
          }
        } else {
          this._copyFunc = Tw2ValueBinding.CopyValueToValue;
        }
      } else if (this.sourceIsArray && srcSwizzled && global["F" /* util */].isNumber(this.destinationObject[this.destinationAttribute])) {
        this._copyFunc = Tw2ValueBinding.CopyElementToValue;
      } else if (this.destinationIsArray && global["F" /* util */].isNumber(this.sourceObject[this.sourceAttribute])) {
        if (destSwizzled) {
          this._copyFunc = Tw2ValueBinding.CopyValueToElement;
        } else {
          this._copyFunc = Tw2ValueBinding.ReplicateValue;
        }
      } else if (global["F" /* util */].isNumber(this.sourceObject[this.sourceAttribute]) && global["F" /* util */].isBoolean(this.destinationObject[this.destinationAttribute])) {
        this._copyFunc = Tw2ValueBinding.CopyFloatToBoolean;
      }
    }
    /**
     * CopyValue
     * @param {*} [controller=this]
     */

  }, {
    key: "CopyValue",
    value: function CopyValue() {
      let controller = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

      if (this._copyFunc) {
        this._copyFunc.call(this);

        if ('OnValueChanged' in this.destinationObject) {
          this.destinationObject.OnValueChanged(controller, [this.destinationAttribute]);
        }
      }
    }
    /**
     * _CopyValueToValue
     */

  }], [{
    key: "CopyValueToValue",
    value: function CopyValueToValue() {
      this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
    }
    /**
     * _CopyArray
     */

  }, {
    key: "CopyArray",
    value: function CopyArray() {
      let count = Math.min(this.destinationObject[this.destinationAttribute].length, this.sourceObject[this.sourceAttribute].length);

      for (let i = 0; i < count; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i] * this.scale + this.offset[i];
      }
    }
    /**
     * _CopyElementToElement
     */

  }, {
    key: "CopyElementToElement",
    value: function CopyElementToElement() {
      this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
    }
    /**
     * _ReplicateValue
     */

  }, {
    key: "ReplicateValue",
    value: function ReplicateValue() {
      for (let i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[i];
      }
    }
    /**
     * _CopyArray
     */

  }, {
    key: "ReplicateElement",
    value: function ReplicateElement() {
      for (let i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[i];
      }
    }
    /**
     * _ExtractPos
     */

  }, {
    key: "ExtractPos",
    value: function ExtractPos() {
      for (let i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i + 12] * this.scale + this.offset[i];
      }
    }
    /**
     * _CopyElementToValue
     */

  }, {
    key: "CopyElementToValue",
    value: function CopyElementToValue() {
      this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
    }
    /**
     * _CopyValueToElement
     */

  }, {
    key: "CopyValueToElement",
    value: function CopyValueToElement() {
      this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
    }
    /**
     * _CopyFloatToBoolean
     */

  }, {
    key: "CopyFloatToBoolean",
    value: function CopyFloatToBoolean() {
      this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] !== 0;
    }
  }]);

  return Tw2ValueBinding;
}();
// CONCATENATED MODULE: ./core/curve/index.js


// EXTERNAL MODULE: ./core/Tw2Error.js
var Tw2Error = __webpack_require__(2);

// CONCATENATED MODULE: ./core/data/Tw2RawData.js
function Tw2RawData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RawData_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RawData_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RawData_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RawData_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RawData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Stores raw data for {@link Tw2PerObjectData}
 *
 * @property {number} nextOffset
 * @property {Float32Array} data
 * @property {*} elements
 * @class
 */

let Tw2RawData_Tw2RawData =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {Array} [declarations] An optional array containing raw data declarations
   */
  function Tw2RawData(declarations) {
    Tw2RawData_classCallCheck(this, Tw2RawData);

    Tw2RawData_defineProperty(this, "nextOffset", 0);

    Tw2RawData_defineProperty(this, "data", null);

    Tw2RawData_defineProperty(this, "elements", {});

    if (declarations) this.DeclareFromObject(declarations);
  }
  /**
   * Sets a element value
   * @param {string} name
   * @param {Float32Array|Array} value
   */


  Tw2RawData_createClass(Tw2RawData, [{
    key: "Set",
    value: function Set(name, value) {
      const el = this.elements[name],
            subarray = 'subarray' in value ? 'subarray' : 'slice';
      this.data.set(value.length > el.size ? value[subarray](0, el.size) : value, el.offset);
    }
    /**
     * Gets an element's array value
     * @param {string} name
     * @return {Float32Array}
     */

  }, {
    key: "Get",
    value: function Get(name) {
      return this.elements[name].array;
    }
    /**
     * Gets an element's array value from the share data array
     * @param {string} name
     * @return {Float32Array}
     */

  }, {
    key: "GetData",
    value: function GetData(name) {
      return this.data.subarray(this.elements[name].offset, this.elements[name].offset + this.elements[name].array.length);
    }
    /**
     * Creates the raw data element arrays
     */

  }, {
    key: "Create",
    value: function Create() {
      this.data = new Float32Array(this.nextOffset);

      for (let name in this.elements) {
        if (this.elements.hasOwnProperty(name)) {
          const el = this.elements[name];
          el.array = this.data.subarray(el.offset, el.offset + el.size);

          if (el.value !== null) {
            if (el.size === 1) {
              if (global["F" /* util */].isNumber(el.value)) {
                el.array[0] = el.value;
              } else {
                el.array[0] = el.value[0];
              }
            } else {
              for (let i = 0; i < el.size; i++) {
                el.array[i] = el.value[i];
              }
            }

            el.value = null;
          }
        }
      }
    }
    /**
     * Declares a raw data element
     * @param {String} name
     * @param {number} size
     * @param {!|number|Array|Float32Array} [value=null] optional value to set on raw data creation
     */

  }, {
    key: "Declare",
    value: function Declare(name, size) {
      let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (value !== null && !(global["F" /* util */].isArrayLike(value) || global["F" /* util */].isNumber(value))) {
        throw new Tw2Error["b" /* ErrDeclarationValueType */]({
          declaration: name,
          valueType: typeof value
        });
      }

      this.elements[name] = {
        offset: this.nextOffset,
        size: size,
        array: null,
        value: value
      };
      this.nextOffset += size;
    }
    /**
     * Declares raw data from an object and then creates the elements
     * @param {Array|Object} declarations
     */

  }, {
    key: "DeclareFromObject",
    value: function DeclareFromObject() {
      let declarations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < declarations.length; i++) {
        const decl = declarations[i];

        if (global["F" /* util */].isArray(decl)) {
          this.Declare(decl[0], decl[1], decl[2]);
        } else {
          this.Declare(decl.name, decl.size, decl.value);
        }
      }

      this.Create();
    }
  }]);

  return Tw2RawData;
}();
// CONCATENATED MODULE: ./core/data/Tw2PerObjectData.js
function Tw2PerObjectData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PerObjectData_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2PerObjectData_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2PerObjectData_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2PerObjectData_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2PerObjectData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2PerObjectData
 *
 * @property {?Tw2RawData} perObjectVSData - Per object vertex shader data
 * @property {?Tw2RawData} perObjectPSData - Per object pixel shader data
 * @class
 */

let Tw2PerObjectData_Tw2PerObjectData =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {RawDataObject} [rawDataObject]
   */
  function Tw2PerObjectData(rawDataObject) {
    Tw2PerObjectData_classCallCheck(this, Tw2PerObjectData);

    Tw2PerObjectData_defineProperty(this, "perObjectVSData", null);

    Tw2PerObjectData_defineProperty(this, "perObjectPSData", null);

    if (rawDataObject) this.DeclareFromObject(rawDataObject);
  }
  /**
   * Sets per object data to the device
   * @param constantBufferHandles
   */


  Tw2PerObjectData_createClass(Tw2PerObjectData, [{
    key: "SetPerObjectDataToDevice",
    value: function SetPerObjectDataToDevice(constantBufferHandles) {
      const gl = global["w" /* device */].gl;

      if (this.perObjectVSData && constantBufferHandles[3]) {
        gl.uniform4fv(constantBufferHandles[3], this.perObjectVSData.data);
      }

      if (this.perObjectPSData && constantBufferHandles[4]) {
        gl.uniform4fv(constantBufferHandles[4], this.perObjectPSData.data);
      }
    }
    /**
     * Defines and creates raw data from an object
     * @param {RawDataObject} [rawDataObject={}]
     */

  }, {
    key: "DeclareFromObject",
    value: function DeclareFromObject() {
      let rawDataObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (rawDataObject.VSData) {
        this.perObjectVSData = new Tw2RawData_Tw2RawData(rawDataObject.VSData);
      }

      if (rawDataObject.PSData) {
        this.perObjectPSData = new Tw2RawData_Tw2RawData(rawDataObject.PSData);
      }
    }
  }]);

  return Tw2PerObjectData;
}();
// CONCATENATED MODULE: ./core/data/Tw2BasicPerObjectData.js
function Tw2BasicPerObjectData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2BasicPerObjectData_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2BasicPerObjectData_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2BasicPerObjectData_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2BasicPerObjectData_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2BasicPerObjectData_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2BasicPerObjectData_assertThisInitialized(self); }

function Tw2BasicPerObjectData_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Tw2BasicPerObjectData_get = Reflect.get; } else { Tw2BasicPerObjectData_get = function _get(target, property, receiver) { var base = Tw2BasicPerObjectData_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Tw2BasicPerObjectData_get(target, property, receiver || target); }

function Tw2BasicPerObjectData_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Tw2BasicPerObjectData_getPrototypeOf(object); if (object === null) break; } return object; }

function Tw2BasicPerObjectData_getPrototypeOf(o) { Tw2BasicPerObjectData_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2BasicPerObjectData_getPrototypeOf(o); }

function Tw2BasicPerObjectData_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2BasicPerObjectData_setPrototypeOf(subClass, superClass); }

function Tw2BasicPerObjectData_setPrototypeOf(o, p) { Tw2BasicPerObjectData_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2BasicPerObjectData_setPrototypeOf(o, p); }

function Tw2BasicPerObjectData_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2BasicPerObjectData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2BasicPerObjectData
 *
 * @parameter {?Tw2RawData} perObjectFFEData - Fixed Function Emulation data
 * @class
 */

let Tw2BasicPerObjectData_Tw2BasicPerObjectData =
/*#__PURE__*/
function (_Tw2PerObjectData) {
  Tw2BasicPerObjectData_inherits(Tw2BasicPerObjectData, _Tw2PerObjectData);

  /**
   * Constructor
   * @param {RawDataObject} [rawDataObject] - An optional object containing raw data declarations
   */
  function Tw2BasicPerObjectData(rawDataObject) {
    var _this;

    Tw2BasicPerObjectData_classCallCheck(this, Tw2BasicPerObjectData);

    _this = Tw2BasicPerObjectData_possibleConstructorReturn(this, Tw2BasicPerObjectData_getPrototypeOf(Tw2BasicPerObjectData).call(this));

    Tw2BasicPerObjectData_defineProperty(Tw2BasicPerObjectData_assertThisInitialized(Tw2BasicPerObjectData_assertThisInitialized(_this)), "perObjectFFEData", null);

    if (rawDataObject) _this.DeclareFromObject(rawDataObject);
    return _this;
  }
  /**
   * Sets per object data to the device
   * @param constantBufferHandles
   */


  Tw2BasicPerObjectData_createClass(Tw2BasicPerObjectData, [{
    key: "SetPerObjectDataToDevice",
    value: function SetPerObjectDataToDevice(constantBufferHandles) {
      Tw2BasicPerObjectData_get(Tw2BasicPerObjectData_getPrototypeOf(Tw2BasicPerObjectData.prototype), "SetPerObjectDataToDevice", this).call(this, constantBufferHandles);

      if (this.perObjectFFEData && constantBufferHandles[5]) {
        global["w" /* device */].gl.uniform4fv(constantBufferHandles[5], this.perObjectFFEData.data);
      }
    }
    /**
     * Defines and creates raw data from an object
     * @param {RawDataObject} rawDataObject
     */

  }, {
    key: "DeclareFromObject",
    value: function DeclareFromObject() {
      let rawDataObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      Tw2BasicPerObjectData_get(Tw2BasicPerObjectData_getPrototypeOf(Tw2BasicPerObjectData.prototype), "DeclareFromObject", this).call(this, rawDataObject);

      if (rawDataObject.FFEData) {
        this.perObjectFFEData = new Tw2RawData_Tw2RawData(rawDataObject.FFEData);
      }
    }
  }]);

  return Tw2BasicPerObjectData;
}(Tw2PerObjectData_Tw2PerObjectData);

// CONCATENATED MODULE: ./core/data/index.js



/**
 * RawDataObject
 *
 * An object containing per object data declarations
 * @property {Array} [VSData] Vertex shader data
 * @property {Array} [PSData] Pixel shader data
 * @property {Array} [FFEData] Fixed function emulation data
 * @typedef {{}} RawDataObject
 */
// EXTERNAL MODULE: ./core/vertex/index.js + 2 modules
var vertex = __webpack_require__(7);

// CONCATENATED MODULE: ./core/geometry/Tw2BlendShapeData.js
function Tw2BlendShapeData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2BlendShapeData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2BlendShapeData
 *
 * @property {String} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array} buffers
 * @property indexes
 * @property weightProxy
 */

let Tw2BlendShapeData_Tw2BlendShapeData = function Tw2BlendShapeData() {
  Tw2BlendShapeData_classCallCheck(this, Tw2BlendShapeData);

  Tw2BlendShapeData_defineProperty(this, "name", '');

  Tw2BlendShapeData_defineProperty(this, "declaration", new vertex["a" /* Tw2VertexDeclaration */]());

  Tw2BlendShapeData_defineProperty(this, "buffers", []);

  Tw2BlendShapeData_defineProperty(this, "indexes", null);

  Tw2BlendShapeData_defineProperty(this, "weightProxy", null);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryAnimation.js
function Tw2GeometryAnimation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryAnimation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryAnimation
 *
 * @property {string} name
 * @property {number} duration
 * @property {Array.<Tw2GeometryTrackGroup>} trackGroups
 */
let Tw2GeometryAnimation = function Tw2GeometryAnimation() {
  Tw2GeometryAnimation_classCallCheck(this, Tw2GeometryAnimation);

  Tw2GeometryAnimation_defineProperty(this, "name", '');

  Tw2GeometryAnimation_defineProperty(this, "duration", 0);

  Tw2GeometryAnimation_defineProperty(this, "trackGroups", []);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryBone.js
function Tw2GeometryBone_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryBone_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2GeometryBone_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2GeometryBone_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2GeometryBone_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2GeometryBone_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2GeometryBone
 *
 * @property {string} name
 * @property {number} parentIndex
 * @property {vec3} position
 * @property {quat} orientation
 * @property {mat3} scaleShear
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformInv
 */

let Tw2GeometryBone_Tw2GeometryBone =
/*#__PURE__*/
function () {
  function Tw2GeometryBone() {
    Tw2GeometryBone_classCallCheck(this, Tw2GeometryBone);

    Tw2GeometryBone_defineProperty(this, "name", '');

    Tw2GeometryBone_defineProperty(this, "parentIndex", -1);

    Tw2GeometryBone_defineProperty(this, "position", global["H" /* vec3 */].create());

    Tw2GeometryBone_defineProperty(this, "orientation", global["C" /* quat */].create());

    Tw2GeometryBone_defineProperty(this, "scaleShear", global["y" /* mat3 */].create());

    Tw2GeometryBone_defineProperty(this, "localTransform", global["z" /* mat4 */].create());

    Tw2GeometryBone_defineProperty(this, "worldTransform", global["z" /* mat4 */].create());

    Tw2GeometryBone_defineProperty(this, "worldTransformInv", global["z" /* mat4 */].create());
  }

  Tw2GeometryBone_createClass(Tw2GeometryBone, [{
    key: "UpdateTransform",

    /**
     * Updates the Bone's transform
     * @returns {mat4}
     */
    value: function UpdateTransform() {
      global["z" /* mat4 */].fromMat3(this.localTransform, this.scaleShear);
      global["C" /* quat */].normalize(this.orientation, this.orientation);
      let rm = global["z" /* mat4 */].fromQuat(Tw2GeometryBone.global.mat4_0, this.orientation);
      global["z" /* mat4 */].multiply(this.localTransform, this.localTransform, rm);
      this.localTransform[12] = this.position[0];
      this.localTransform[13] = this.position[1];
      this.localTransform[14] = this.position[2];
      return this.localTransform;
    }
    /**
     * Global and scratch variables
     */

  }]);

  return Tw2GeometryBone;
}();

Tw2GeometryBone_defineProperty(Tw2GeometryBone_Tw2GeometryBone, "global", {
  mat4_0: global["z" /* mat4 */].create()
});
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryCurve.js
function Tw2GeometryCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryCurve
 *
 * @property {number} dimension
 * @property {number} degree
 * @property {Float32Array} knots
 * @property {Float32Array} controls
 */
let Tw2GeometryCurve = function Tw2GeometryCurve() {
  Tw2GeometryCurve_classCallCheck(this, Tw2GeometryCurve);

  Tw2GeometryCurve_defineProperty(this, "dimension", 0);

  Tw2GeometryCurve_defineProperty(this, "degree", 0);

  Tw2GeometryCurve_defineProperty(this, "knots", null);

  Tw2GeometryCurve_defineProperty(this, "controls", null);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryMesh.js
function Tw2GeometryMesh_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryMesh_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2GeometryMesh
 *
 * @property {string} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array.<Tw2GeometryMeshArea>} areas
 * @property {WebGLBuffer} buffer
 * @property {number} bufferLength
 * @property bufferData
 * @property {WebGLBuffer} indexes
 * @property indexData
 * @property {number} indexType
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 * @property {Array} bones
 * @property {Array.<string>} boneBindings
 */

let Tw2GeometryMesh_Tw2GeometryMesh = function Tw2GeometryMesh() {
  Tw2GeometryMesh_classCallCheck(this, Tw2GeometryMesh);

  Tw2GeometryMesh_defineProperty(this, "name", '');

  Tw2GeometryMesh_defineProperty(this, "declaration", new vertex["a" /* Tw2VertexDeclaration */]());

  Tw2GeometryMesh_defineProperty(this, "areas", []);

  Tw2GeometryMesh_defineProperty(this, "buffer", null);

  Tw2GeometryMesh_defineProperty(this, "bufferLength", 0);

  Tw2GeometryMesh_defineProperty(this, "bufferData", null);

  Tw2GeometryMesh_defineProperty(this, "indexes", null);

  Tw2GeometryMesh_defineProperty(this, "indexData", null);

  Tw2GeometryMesh_defineProperty(this, "indexType", 0);

  Tw2GeometryMesh_defineProperty(this, "minBounds", global["H" /* vec3 */].create());

  Tw2GeometryMesh_defineProperty(this, "maxBounds", global["H" /* vec3 */].create());

  Tw2GeometryMesh_defineProperty(this, "boundsSpherePosition", global["H" /* vec3 */].create());

  Tw2GeometryMesh_defineProperty(this, "boundsSphereRadius", 0);

  Tw2GeometryMesh_defineProperty(this, "bones", []);

  Tw2GeometryMesh_defineProperty(this, "boneBindings", []);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryMeshArea.js
function Tw2GeometryMeshArea_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryMeshArea_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2GeometryMeshArea
 *
 * @property {string} name
 * @property {number} start
 * @property {number} count
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 */

let Tw2GeometryMeshArea_Tw2GeometryMeshArea = function Tw2GeometryMeshArea() {
  Tw2GeometryMeshArea_classCallCheck(this, Tw2GeometryMeshArea);

  Tw2GeometryMeshArea_defineProperty(this, "name", '');

  Tw2GeometryMeshArea_defineProperty(this, "start", 0);

  Tw2GeometryMeshArea_defineProperty(this, "count", 0);

  Tw2GeometryMeshArea_defineProperty(this, "minBounds", global["H" /* vec3 */].create());

  Tw2GeometryMeshArea_defineProperty(this, "maxBounds", global["H" /* vec3 */].create());

  Tw2GeometryMeshArea_defineProperty(this, "boundsSpherePosition", global["H" /* vec3 */].create());

  Tw2GeometryMeshArea_defineProperty(this, "boundsSphereRadius", 0);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryMeshBinding.js
function Tw2GeometryMeshBinding_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryMeshBinding_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryMeshBinding
 *
 * @property {Tw2GeometryMesh} mesh
 * @property {Array.<Tw2GeometryBone>} bones
 */
let Tw2GeometryMeshBinding = function Tw2GeometryMeshBinding() {
  Tw2GeometryMeshBinding_classCallCheck(this, Tw2GeometryMeshBinding);

  Tw2GeometryMeshBinding_defineProperty(this, "mesh", null);

  Tw2GeometryMeshBinding_defineProperty(this, "bones", []);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryModel.js
function Tw2GeometryModel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryModel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2GeometryModel_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2GeometryModel_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2GeometryModel_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2GeometryModel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryModel
 *
 * @property {string} name
 * @property {Array.<Tw2GeometryMeshBinding>} meshBindings
 * @property {Tw2GeometrySkeleton} skeleton
 */
let Tw2GeometryModel =
/*#__PURE__*/
function () {
  function Tw2GeometryModel() {
    Tw2GeometryModel_classCallCheck(this, Tw2GeometryModel);

    Tw2GeometryModel_defineProperty(this, "name", '');

    Tw2GeometryModel_defineProperty(this, "meshBindings", []);

    Tw2GeometryModel_defineProperty(this, "skeleton", null);
  }

  Tw2GeometryModel_createClass(Tw2GeometryModel, [{
    key: "FindBoneByName",

    /**
     * Finds a bone by it's name
     * @param {string} name
     * @returns {Tw2GeometryBone|null}
     */
    value: function FindBoneByName(name) {
      if (!this.skeleton) {
        return null;
      }

      for (let i = 0; i < this.skeleton.bones.length; ++i) {
        if (this.skeleton.bones[i].name === name) {
          return this.skeleton.bones[i];
        }
      }

      return null;
    }
  }]);

  return Tw2GeometryModel;
}();
// CONCATENATED MODULE: ./core/geometry/Tw2GeometrySkeleton.js
function Tw2GeometrySkeleton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometrySkeleton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometrySkeleton
 *
 * @property {Array.<Tw2GeometryBone>} bones
 */
let Tw2GeometrySkeleton = function Tw2GeometrySkeleton() {
  Tw2GeometrySkeleton_classCallCheck(this, Tw2GeometrySkeleton);

  Tw2GeometrySkeleton_defineProperty(this, "bones", []);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryTrackGroup.js
function Tw2GeometryTrackGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryTrackGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryTrackGroup
 *
 * @property {string} name
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2GeometryTransformTrack>} transformTracks
 */
let Tw2GeometryTrackGroup = function Tw2GeometryTrackGroup() {
  Tw2GeometryTrackGroup_classCallCheck(this, Tw2GeometryTrackGroup);

  Tw2GeometryTrackGroup_defineProperty(this, "name", '');

  Tw2GeometryTrackGroup_defineProperty(this, "model", null);

  Tw2GeometryTrackGroup_defineProperty(this, "transformTracks", []);
};
// CONCATENATED MODULE: ./core/geometry/Tw2GeometryTransformTrack.js
function Tw2GeometryTransformTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryTransformTrack_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2GeometryTransformTrack
 *
 * @property {string} name
 * @property {Tw2GeometryCurve} position
 * @property {Tw2GeometryCurve} orientation
 * @property scaleShear
 */
let Tw2GeometryTransformTrack = function Tw2GeometryTransformTrack() {
  Tw2GeometryTransformTrack_classCallCheck(this, Tw2GeometryTransformTrack);

  Tw2GeometryTransformTrack_defineProperty(this, "name", '');

  Tw2GeometryTransformTrack_defineProperty(this, "position", null);

  Tw2GeometryTransformTrack_defineProperty(this, "orientation", null);

  Tw2GeometryTransformTrack_defineProperty(this, "scaleShear", null);
};
// CONCATENATED MODULE: ./core/geometry/index.js











// EXTERNAL MODULE: ./core/mesh/Tw2Effect.js
var Tw2Effect = __webpack_require__(13);

// CONCATENATED MODULE: ./core/mesh/Tw2Mesh.js
function Tw2Mesh_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Mesh_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Mesh_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Mesh_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Mesh_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Mesh_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2Mesh
 *
 * @property {string} name
 * @property {boolean} display                      - Enables/ disables all mesh batch accumulations
 * @parameter {{}} visible                          - Batch accumulation options for the mesh's elements
 * @property {boolean} visible.opaqueAreas          - Enables/ disables opaque area batch accumulation
 * @property {boolean} visible.transparentAreas     - Enables/ disables transparent area batch accumulation
 * @property {boolean} visible.additiveAreas        - Enables/ disables additive area batch accumulation
 * @property {boolean} visible.pickableAreas        - Enables/ disables pickable area batch accumulation
 * @property {boolean} visible.decalAreas           - Enables/ disables decal area batch accumulation
 * @property {boolean} visible.depthAreas           - Not supported
 * @property {Array.<Tw2MeshArea>} opaqueAreas
 * @property {Array.<Tw2MeshArea>} transparentAreas
 * @property {Array.<Tw2MeshArea>} additiveAreas
 * @property {Array.<Tw2MeshArea>} pickableAreas
 * @property {Array.<Tw2MeshArea>} decalAreas
 * @property {Array.<Tw2MeshArea>} depthAreas       - Not supported
 * @property {number} meshIndex
 * @property {string} geometryResPath
 * @property {string} lowDetailGeometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @class
 */

let Tw2Mesh_Tw2Mesh =
/*#__PURE__*/
function () {
  function Tw2Mesh() {
    Tw2Mesh_classCallCheck(this, Tw2Mesh);

    Tw2Mesh_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2Mesh_defineProperty(this, "name", '');

    Tw2Mesh_defineProperty(this, "display", true);

    Tw2Mesh_defineProperty(this, "visible", {
      opaqueAreas: true,
      transparentAreas: true,
      additiveAreas: true,
      pickableAreas: true,
      decalAreas: true,
      depthAreas: true
    });

    Tw2Mesh_defineProperty(this, "opaqueAreas", []);

    Tw2Mesh_defineProperty(this, "transparentAreas", []);

    Tw2Mesh_defineProperty(this, "additiveAreas", []);

    Tw2Mesh_defineProperty(this, "pickableAreas", []);

    Tw2Mesh_defineProperty(this, "decalAreas", []);

    Tw2Mesh_defineProperty(this, "depthAreas", []);

    Tw2Mesh_defineProperty(this, "meshIndex", 0);

    Tw2Mesh_defineProperty(this, "geometryResPath", '');

    Tw2Mesh_defineProperty(this, "lowDetailGeometryResPath", '');

    Tw2Mesh_defineProperty(this, "geometryResource", null);
  }

  Tw2Mesh_createClass(Tw2Mesh, [{
    key: "Initialize",

    /**
     * Initializes the Tw2Mesh
     */
    value: function Initialize() {
      if (this.geometryResPath !== '') {
        this.geometryResource = global["D" /* resMan */].GetResource(this.geometryResPath);
      }
    }
    /**
     * Checks if the mesh's resource is good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      return this.geometryResource && this.geometryResource.IsGood();
    }
    /**
     * Gets mesh resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (!out.includes(this.geometryResource)) {
        out.push(this.geometryResource);
      }

      global["F" /* util */].perArrayChild(this.opaqueAreas, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.transparentAreas, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.additiveAreas, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.pickableAreas, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.decalAreas, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.depthAreas, 'GetResources', out);
      return out;
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.IsGood() || !this.display) return false;
      const getBatches = this.constructor.GetAreaBatches;

      switch (mode) {
        case global["w" /* device */].RM_OPAQUE:
          if (this.visible.opaqueAreas) {
            getBatches(this, this.opaqueAreas, mode, accumulator, perObjectData);
          }

          return;

        case global["w" /* device */].RM_DECAL:
          if (this.visible.decalAreas) {
            getBatches(this, this.opaqueAreas, mode, accumulator, perObjectData);
          }

          return;

        case global["w" /* device */].RM_TRANSPARENT:
          if (this.visible.transparentAreas) {
            getBatches(this, this.transparentAreas, mode, accumulator, perObjectData);
          }

          return;

        case global["w" /* device */].RM_ADDITIVE:
          if (this.visible.transparentAreas) {
            getBatches(this, this.additiveAreas, mode, accumulator, perObjectData);
          }

          return;

        case global["w" /* device */].RM_PICKABLE:
          if (this.visible.pickableAreas) {
            getBatches(this, this.pickableAreas, mode, accumulator, perObjectData);
          }

          return;
      }
    }
    /**
     * Gets render batches from a mesh area array and commits them to an accumulator
     * @param {Tw2Mesh} mesh
     * @param {Array.<Tw2MeshArea>} areas
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }], [{
    key: "GetAreaBatches",
    value: function GetAreaBatches(mesh, areas, mode, accumulator, perObjectData) {
      for (let i = 0; i < areas.length; ++i) {
        const area = areas[i];

        if (area.effect && area.display) {
          const batch = new area.constructor.batchType();
          batch.renderMode = mode;
          batch.perObjectData = perObjectData;
          batch.geometryRes = mesh.geometryResource;
          batch.meshIx = mesh.meshIndex;
          batch.start = area.index;
          batch.count = area.count;
          batch.effect = area.effect;
          accumulator.Commit(batch);
        }
      }
    }
  }]);

  return Tw2Mesh;
}();
// CONCATENATED MODULE: ./core/mesh/Tw2InstancedMesh.js
function Tw2InstancedMesh_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2InstancedMesh_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2InstancedMesh_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2InstancedMesh_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2InstancedMesh_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2InstancedMesh_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2InstancedMesh_assertThisInitialized(self); }

function Tw2InstancedMesh_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Tw2InstancedMesh_get = Reflect.get; } else { Tw2InstancedMesh_get = function _get(target, property, receiver) { var base = Tw2InstancedMesh_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Tw2InstancedMesh_get(target, property, receiver || target); }

function Tw2InstancedMesh_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Tw2InstancedMesh_getPrototypeOf(object); if (object === null) break; } return object; }

function Tw2InstancedMesh_getPrototypeOf(o) { Tw2InstancedMesh_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2InstancedMesh_getPrototypeOf(o); }

function Tw2InstancedMesh_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2InstancedMesh_setPrototypeOf(subClass, superClass); }

function Tw2InstancedMesh_setPrototypeOf(o, p) { Tw2InstancedMesh_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2InstancedMesh_setPrototypeOf(o, p); }

function Tw2InstancedMesh_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2InstancedMesh_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2InstancedMesh
 *
 * @property instanceGeometryResource
 * @property {string} instanceGeometryResPath
 * @property {number} instanceMeshIndex
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @class
 */

let Tw2InstancedMesh_Tw2InstancedMesh =
/*#__PURE__*/
function (_Tw2Mesh) {
  Tw2InstancedMesh_inherits(Tw2InstancedMesh, _Tw2Mesh);

  function Tw2InstancedMesh() {
    var _this;

    Tw2InstancedMesh_classCallCheck(this, Tw2InstancedMesh);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2InstancedMesh_possibleConstructorReturn(this, Tw2InstancedMesh_getPrototypeOf(Tw2InstancedMesh).call(this, ...args));

    Tw2InstancedMesh_defineProperty(Tw2InstancedMesh_assertThisInitialized(Tw2InstancedMesh_assertThisInitialized(_this)), "instanceGeometryResource", null);

    Tw2InstancedMesh_defineProperty(Tw2InstancedMesh_assertThisInitialized(Tw2InstancedMesh_assertThisInitialized(_this)), "instanceGeometryResPath", '');

    Tw2InstancedMesh_defineProperty(Tw2InstancedMesh_assertThisInitialized(Tw2InstancedMesh_assertThisInitialized(_this)), "instanceMeshIndex", 0);

    Tw2InstancedMesh_defineProperty(Tw2InstancedMesh_assertThisInitialized(Tw2InstancedMesh_assertThisInitialized(_this)), "minBounds", global["H" /* vec3 */].create());

    Tw2InstancedMesh_defineProperty(Tw2InstancedMesh_assertThisInitialized(Tw2InstancedMesh_assertThisInitialized(_this)), "maxBounds", global["H" /* vec3 */].create());

    return _this;
  }

  Tw2InstancedMesh_createClass(Tw2InstancedMesh, [{
    key: "Initialize",

    /**
     * Initializes the instanced mesh
     */
    value: function Initialize() {
      Tw2InstancedMesh_get(Tw2InstancedMesh_getPrototypeOf(Tw2InstancedMesh.prototype), "Initialize", this).call(this);

      if (this.instanceGeometryResPath !== '') {
        this.instanceGeometryResource = global["D" /* resMan */].GetResource(this.instanceGeometryResPath);
      }
    }
    /**
     * Checks if the instances meshes' resources are good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      const instanced = this.instanceGeometryResource,
            isResGood = Tw2InstancedMesh_get(Tw2InstancedMesh_getPrototypeOf(Tw2InstancedMesh.prototype), "IsGood", this).call(this),
            isInstancedResGood = !instanced ? false : instanced.IsGood ? instanced.IsGood() : true;

      return isResGood && isInstancedResGood;
    }
    /**
     * Gets mesh resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      Tw2InstancedMesh_get(Tw2InstancedMesh_getPrototypeOf(Tw2InstancedMesh.prototype), "GetResources", this).call(this, out);

      if (this.instanceGeometryResource && 'GetResources' in this.instanceGeometryResource) {
        this.instanceGeometryResource.GetResources(out);
      }

      return out;
    }
    /**
     * RenderAreas
     * @param {number} meshIx
     * @param {number} start
     * @param {number} count
     * @param {Tw2Effect} effect
     * @param {string} technique
     */

  }, {
    key: "RenderAreas",
    value: function RenderAreas(meshIx, start, count, effect, technique) {
      if (!this.IsGood()) return;
      const buffer = this.instanceGeometryResource.GetInstanceBuffer(this.instanceMeshIndex);

      if (buffer) {
        this.geometryResource.RenderAreasInstanced(meshIx, start, count, effect, technique, buffer, this.instanceGeometryResource.GetInstanceDeclaration(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceStride(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceCount(this.instanceMeshIndex));
      }
    }
    /**
     * Gets area batches
     * @param {Tw2InstancedMesh} mesh
     * @param {Array.<Tw2MeshArea>} areas
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }], [{
    key: "GetAreaBatches",
    value: function GetAreaBatches(mesh, areas, mode, accumulator, perObjectData) {
      for (let i = 0; i < areas.length; ++i) {
        const area = areas[i];

        if (area.effect && area.display) {
          const batch = new Tw2InstancedMeshBatch();
          batch.renderMode = mode;
          batch.perObjectData = perObjectData;
          batch.instanceMesh = mesh;
          batch.meshIx = area.meshIndex;
          batch.start = area.index;
          batch.count = area.count;
          batch.effect = area.effect;
          accumulator.Commit(batch);
        }
      }
    }
  }]);

  return Tw2InstancedMesh;
}(Tw2Mesh_Tw2Mesh);
// CONCATENATED MODULE: ./core/mesh/Tw2MeshArea.js
function Tw2MeshArea_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MeshArea_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MeshArea
 *
 * @property {string} name
 * @property {Tw2Effect} effect
 * @property {number} meshIndex
 * @property {number} index
 * @property {number} count
 * @property {boolean} display
 * @class
 */

let Tw2MeshArea_Tw2MeshArea = function Tw2MeshArea() {
  Tw2MeshArea_classCallCheck(this, Tw2MeshArea);

  Tw2MeshArea_defineProperty(this, "_id", global["F" /* util */].generateID());

  Tw2MeshArea_defineProperty(this, "name", '');

  Tw2MeshArea_defineProperty(this, "effect", null);

  Tw2MeshArea_defineProperty(this, "meshIndex", 0);

  Tw2MeshArea_defineProperty(this, "index", 0);

  Tw2MeshArea_defineProperty(this, "count", 1);

  Tw2MeshArea_defineProperty(this, "display", true);
};

Tw2MeshArea_defineProperty(Tw2MeshArea_Tw2MeshArea, "batchType", Tw2GeometryBatch);
// CONCATENATED MODULE: ./core/mesh/Tw2MeshLineArea.js
function Tw2MeshLineArea_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MeshLineArea_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2MeshLineArea_assertThisInitialized(self); }

function Tw2MeshLineArea_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2MeshLineArea_getPrototypeOf(o) { Tw2MeshLineArea_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2MeshLineArea_getPrototypeOf(o); }

function Tw2MeshLineArea_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2MeshLineArea_setPrototypeOf(subClass, superClass); }

function Tw2MeshLineArea_setPrototypeOf(o, p) { Tw2MeshLineArea_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2MeshLineArea_setPrototypeOf(o, p); }

function Tw2MeshLineArea_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MeshLineArea
 *
 * @class
 */

let Tw2MeshLineArea =
/*#__PURE__*/
function (_Tw2MeshArea) {
  Tw2MeshLineArea_inherits(Tw2MeshLineArea, _Tw2MeshArea);

  function Tw2MeshLineArea() {
    Tw2MeshLineArea_classCallCheck(this, Tw2MeshLineArea);

    return Tw2MeshLineArea_possibleConstructorReturn(this, Tw2MeshLineArea_getPrototypeOf(Tw2MeshLineArea).apply(this, arguments));
  }

  return Tw2MeshLineArea;
}(Tw2MeshArea_Tw2MeshArea);

Tw2MeshLineArea_defineProperty(Tw2MeshLineArea, "batchType", Tw2GeometryLineBatch);
// CONCATENATED MODULE: ./core/mesh/index.js





// CONCATENATED MODULE: ./core/model/Tw2Animation.js
function Tw2Animation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Animation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Animation_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Animation_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Animation_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Animation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2Animation
 *
 * @property {Tw2GeometryAnimation} animationRes
 * @property {number} time
 * @property {number} timeScale
 * @property {boolean} cycle
 * @property {boolean} isPlaying
 * @property {Function} callback - Stores optional callback passed to prototypes
 * @property {Array} trackGroups - Array of {@link Tw2TrackGroup}
 * @class
 */
let Tw2Animation =
/*#__PURE__*/
function () {
  function Tw2Animation() {
    Tw2Animation_classCallCheck(this, Tw2Animation);

    Tw2Animation_defineProperty(this, "animationRes", null);

    Tw2Animation_defineProperty(this, "time", 0);

    Tw2Animation_defineProperty(this, "timeScale", 1.0);

    Tw2Animation_defineProperty(this, "cycle", false);

    Tw2Animation_defineProperty(this, "isPlaying", false);

    Tw2Animation_defineProperty(this, "callback", null);

    Tw2Animation_defineProperty(this, "trackGroups", []);
  }

  Tw2Animation_createClass(Tw2Animation, [{
    key: "IsFinished",

    /**
     * Checks to see if the animation has finished playing
     * @return {boolean}
     */
    value: function IsFinished() {
      return !this.cycle && this.time >= this.animationRes.duration;
    }
  }]);

  return Tw2Animation;
}();
// EXTERNAL MODULE: ./core/reader/Tw2BinaryReader.js
var Tw2BinaryReader = __webpack_require__(17);

// EXTERNAL MODULE: ./core/reader/Tw2ObjectReader.js
var Tw2ObjectReader = __webpack_require__(16);

// CONCATENATED MODULE: ./core/reader/index.js


// EXTERNAL MODULE: ./core/resource/Tw2Resource.js
var Tw2Resource = __webpack_require__(8);

// EXTERNAL MODULE: ./core/sampler/index.js + 2 modules
var core_sampler = __webpack_require__(14);

// CONCATENATED MODULE: ./core/resource/Tw2Shader.js
function Tw2Shader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Shader_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Shader_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Shader_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Shader_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Shader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * Tw2Shader
 *
 * @property {Object.<string, Object>} techniques
 * @property {Object.<string, Array>} annotations
 * @class
 */

let Tw2Shader_Tw2Shader =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param reader
   * @param version
   * @param stringTable
   * @param stringTableOffset
   * @param path
   */
  function Tw2Shader(reader, version, stringTable, stringTableOffset, path) {
    Tw2Shader_classCallCheck(this, Tw2Shader);

    Tw2Shader_defineProperty(this, "techniques", {});

    Tw2Shader_defineProperty(this, "annotations", {});

    /**
     * ReadString
     * @returns {string}
     * @private
     */
    function ReadString() {
      const offset = reader.ReadUInt32();
      let end = offset;

      while (stringTable.charCodeAt(end)) {
        ++end;
      }

      return stringTable.substr(offset, end - offset);
    }

    const wrapModes = global["w" /* device */].wrapModes,
          gl = global["w" /* device */].gl;
    let techniqueCount = 1;

    if (version > 6) {
      techniqueCount = reader.ReadUInt8();
    }

    for (let t = 0; t < techniqueCount; ++t) {
      let technique = {
        name: 'Main',
        passes: []
      };

      if (version > 6) {
        technique.name = ReadString();
      }

      this.techniques[technique.name] = technique;
      const passCount = reader.ReadUInt8();

      for (let passIx = 0; passIx < passCount; ++passIx) {
        const pass = {};
        pass.stages = [{}, {}];
        const stageCount = reader.ReadUInt8();
        let validShadowShader = true;

        for (let stageIx = 0; stageIx < stageCount; ++stageIx) {
          const stage = {};
          stage.inputDefinition = new vertex["a" /* Tw2VertexDeclaration */]();
          stage.constants = [];
          stage.textures = [];
          stage.samplers = [];
          const stageType = reader.ReadUInt8(),
                inputCount = reader.ReadUInt8();

          for (let inputIx = 0; inputIx < inputCount; ++inputIx) {
            const usage = reader.ReadUInt8();
            /* let registerIndex = */

            reader.ReadUInt8();
            const usageIndex = reader.ReadUInt8();
            /* let usedMask = */

            reader.ReadUInt8();
            stage.inputDefinition.elements[inputIx] = new vertex["b" /* Tw2VertexElement */](usage, usageIndex, 0);
          }

          stage.inputDefinition.RebuildHash();
          let shaderSize, shaderCode, shadowShaderSize, shadowShaderCode;

          if (version < 5) {
            shaderSize = reader.ReadUInt32();
            shaderCode = reader.data.subarray(reader.cursor, reader.cursor + shaderSize);
            reader.cursor += shaderSize;
            shadowShaderSize = reader.ReadUInt32();
            shadowShaderCode = reader.data.subarray(reader.cursor, reader.cursor + shadowShaderSize);
            reader.cursor += shadowShaderSize;
          } else {
            shaderSize = reader.ReadUInt32();
            let so = reader.ReadUInt32();
            shaderCode = stringTable.substr(so, shaderSize);
            shadowShaderSize = reader.ReadUInt32();
            so = reader.ReadUInt32();
            shadowShaderCode = stringTable.substr(so, shadowShaderSize);
          }

          stage.shader = Tw2Shader.CompileShader(stageType, '', shaderCode, path);

          if (validShadowShader) {
            if (shadowShaderSize === 0) {
              stage.shadowShader = Tw2Shader.CompileShader(stageType, '\n#define PS\n', shaderCode, path, true);
            } else {
              stage.shadowShader = Tw2Shader.CompileShader(stageType, '', shadowShaderCode, path, true);
            }

            if (stage.shadowShader === null) {
              validShadowShader = false;
            }
          } else {
            stage.shadowShader = null;
          }

          if (version >= 3) {
            reader.ReadUInt32();
            reader.ReadUInt32();
            reader.ReadUInt32();
          }

          stage.constantSize = 0;
          const constantCount = reader.ReadUInt32();

          for (let constantIx = 0; constantIx < constantCount; ++constantIx) {
            const constant = {};
            constant.name = ReadString();
            constant.offset = reader.ReadUInt32() / 4;
            constant.size = reader.ReadUInt32() / 4;
            constant.type = reader.ReadUInt8();
            constant.dimension = reader.ReadUInt8();
            constant.elements = reader.ReadUInt32();
            constant.isSRGB = reader.ReadUInt8();
            constant.isAutoregister = reader.ReadUInt8();
            stage.constants[constantIx] = constant;
            if (Tw2Shader.ConstantIgnore.includes(constant.name)) continue;
            const last = constant.offset + constant.size;
            if (last > stage.constantSize) stage.constantSize = last;
          }

          const constantValueSize = reader.ReadUInt32() / 4;
          stage.constantValues = new Float32Array(constantValueSize);

          if (version < 5) {
            for (let i = 0; i < constantValueSize; ++i) {
              stage.constantValues[i] = reader.ReadFloat32();
            }
          } else {
            const co = reader.ReadUInt32(),
                  bo = reader.cursor;
            reader.cursor = stringTableOffset + co;

            for (let i = 0; i < constantValueSize; ++i) {
              stage.constantValues[i] = reader.ReadFloat32();
            }

            reader.cursor = bo;
          }

          stage.constantSize = Math.max(stage.constantSize, constantValueSize);
          let textureCount = reader.ReadUInt8();

          for (let textureIx = 0; textureIx < textureCount; ++textureIx) {
            const texture = {};
            texture.registerIndex = reader.ReadUInt8();
            texture.name = ReadString();
            texture.type = reader.ReadUInt8();
            texture.isSRGB = reader.ReadUInt8();
            texture.isAutoregister = reader.ReadUInt8();
            stage.textures.push(texture);
          }

          const samplerCount = reader.ReadUInt8();

          for (let samplerIx = 0; samplerIx < samplerCount; ++samplerIx) {
            const registerIndex = reader.ReadUInt8(),
                  samplerName = version >= 4 ? ReadString() : '';
            reader.ReadUInt8(); // comparison

            const minFilter = reader.ReadUInt8(),
                  magFilter = reader.ReadUInt8(),
                  mipFilter = reader.ReadUInt8(),
                  addressU = reader.ReadUInt8(),
                  addressV = reader.ReadUInt8(),
                  addressW = reader.ReadUInt8();
            reader.ReadFloat32(); // mipLODBias

            const maxAnisotropy = reader.ReadUInt8();
            reader.ReadUInt8(); //comparisonFunc

            const borderColor = global["C" /* quat */].create();
            borderColor[0] = reader.ReadFloat32();
            borderColor[1] = reader.ReadFloat32();
            borderColor[2] = reader.ReadFloat32();
            borderColor[3] = reader.ReadFloat32();
            reader.ReadFloat32(); //minLOD

            reader.ReadFloat32(); //maxLOD

            if (version < 4) reader.ReadUInt8();
            const sampler = new core_sampler["b" /* Tw2SamplerState */]();
            sampler.registerIndex = registerIndex;
            sampler.name = samplerName;

            if (minFilter === 1) {
              switch (mipFilter) {
                case 0:
                  sampler.minFilter = gl.NEAREST;
                  break;

                case 1:
                  sampler.minFilter = gl.NEAREST_MIPMAP_NEAREST;
                  break;

                default:
                  sampler.minFilter = gl.NEAREST_MIPMAP_LINEAR;
              }

              sampler.minFilterNoMips = gl.NEAREST;
            } else {
              switch (mipFilter) {
                case 0:
                  sampler.minFilter = gl.LINEAR;
                  break;

                case 1:
                  sampler.minFilter = gl.LINEAR_MIPMAP_NEAREST;
                  break;

                default:
                  sampler.minFilter = gl.LINEAR_MIPMAP_LINEAR;
              }

              sampler.minFilterNoMips = gl.LINEAR;
            }

            sampler.magFilter = magFilter === 1 ? gl.NEAREST : gl.LINEAR;
            sampler.addressU = wrapModes[addressU];
            sampler.addressV = wrapModes[addressV];
            sampler.addressW = wrapModes[addressW];

            if (minFilter === 3 || magFilter === 3 || mipFilter === 3) {
              sampler.anisotropy = Math.max(maxAnisotropy, 1);
            }

            for (let n = 0; n < stage.textures.length; ++n) {
              if (stage.textures[n].registerIndex === sampler.registerIndex) {
                sampler.samplerType = stage.textures[n].type === 4 ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
                sampler.isVolume = stage.textures[n].type === 3;
                break;
              }
            }

            sampler.ComputeHash();
            stage.samplers.push(sampler);
          }

          if (version >= 3) reader.ReadUInt8();
          pass.stages[stageType] = stage;
        }

        pass.states = [];
        const stateCount = reader.ReadUInt8();

        for (let stateIx = 0; stateIx < stateCount; ++stateIx) {
          const state = reader.ReadUInt32(),
                value = reader.ReadUInt32();
          pass.states.push({
            'state': state,
            'value': value
          });
        }

        pass.shaderProgram = Tw2Shader.CreateProgram(pass.stages[0].shader, pass.stages[1].shader, pass, path);

        if (validShadowShader) {
          pass.shadowShaderProgram = Tw2Shader.CreateProgram(pass.stages[0].shadowShader, pass.stages[1].shadowShader, pass, path, true);

          if (pass.shadowShaderProgram === null) {
            pass.shadowShaderProgram = pass.shaderProgram;
          }
        } else {
          pass.shadowShaderProgram = pass.shaderProgram;
        }

        technique.passes[passIx] = pass;
      }
    }

    const parameterCount = reader.ReadUInt16();

    for (let paramIx = 0; paramIx < parameterCount; ++paramIx) {
      const name = ReadString(),
            annotations = [],
            annotationCount = reader.ReadUInt8();

      for (let annotationIx = 0; annotationIx < annotationCount; ++annotationIx) {
        annotations[annotationIx] = {};
        annotations[annotationIx].name = ReadString();
        annotations[annotationIx].type = reader.ReadUInt8();

        switch (annotations[annotationIx].type) {
          case 0:
            annotations[annotationIx].value = reader.ReadUInt32() !== 0;
            break;

          case 1:
            annotations[annotationIx].value = reader.ReadInt32();
            break;

          case 2:
            annotations[annotationIx].value = reader.ReadFloat32();
            break;

          default:
            annotations[annotationIx].value = ReadString();
        }
      }

      this.annotations[name] = annotations;
    }
  }
  /**
   * Applies an Effect Pass
   * @param {String} technique - technique name
   * @param {number} pass - effect.passes index
   */


  Tw2Shader_createClass(Tw2Shader, [{
    key: "ApplyPass",
    value: function ApplyPass(technique, pass) {
      const d = global["w" /* device */],
            gl = d.gl;
      pass = this.techniques[technique].passes[pass];

      for (let i = 0; i < pass.states.length; ++i) {
        d.SetRenderState(pass.states[i].state, pass.states[i].value);
      }

      if (d.IsAlphaTestEnabled()) {
        gl.useProgram(pass.shadowShaderProgram.program);
        d.shadowHandles = pass.shadowShaderProgram;
      } else {
        gl.useProgram(pass.shaderProgram.program);
        d.shadowHandles = null;
      }
    }
    /**
     * Checks if a constant is supported
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasConstant",
    value: function HasConstant(name) {
      return this.constructor.Has(this.techniques, 'constants', name);
    }
    /**
     * Checks if a texture is supported
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasTexture",
    value: function HasTexture(name) {
      return this.constructor.Has(this.techniques, 'textures', name);
    }
    /**
     * Checks if a sampler is supported
     * @param {string} name
     * @returns {boolean}
     */

  }, {
    key: "HasSampler",
    value: function HasSampler(name) {
      return this.constructor.Has(this.techniques, 'samplers', name);
    }
    /**
     * Checks if any techniques have a value with a given name for a specific type
     * @param {*} techniques
     * @param {string} type
     * @param {string} name
     * @returns {?*}
     */

  }], [{
    key: "Has",
    value: function Has(techniques, type, name) {
      for (const t in techniques) {
        if (techniques.hasOwnProperty(t)) {
          const technique = techniques[t];

          for (let p = 0; p < technique.passes.length; p++) {
            const pass = technique.passes[p];

            for (let s = 0; s < pass.stages.length; s++) {
              const stage = pass.stages[s];

              for (let i = 0; i < stage[type].length; i++) {
                if (stage[type][i].name === name) {
                  return true;
                }
              }
            }
          }
        }
      }

      return false;
    }
    /**
     * Compiles shader
     * @param {number} stageType
     * @param {string} prefix
     * @param shaderCode
     * @param {string} path
     * @param {boolean} [skipError]
     * @returns {*}
     */

  }, {
    key: "CompileShader",
    value: function CompileShader(stageType, prefix, shaderCode, path, skipError) {
      const ext = global["w" /* device */].ext,
            gl = global["w" /* device */].gl,
            shader = gl.createShader(stageType === 0 ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);

      if (ext.ShaderBinary) {
        ext.ShaderBinary['shaderBinary'](shader, shaderCode);
      } else {
        let source = prefix + (global["F" /* util */].isString(shaderCode) ? shaderCode : String.fromCharCode.apply(null, shaderCode));
        source = source.substr(0, source.length - 1);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
      }

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        if (!skipError) {
          throw new Tw2Error["t" /* ErrShaderCompile */]({
            path: path,
            shaderType: stageType === 0 ? 'vertex' : 'fragment',
            infoLog: gl.getShaderInfoLog(shader)
          });
        }

        return null;
      }

      return shader;
    }
    /**
     * Creates shader program
     * @param vertexShader
     * @param fragmentShader
     * @param pass
     * @param {string} path
     * @param {boolean} [skipError]
     * @returns {*}
     */

  }, {
    key: "CreateProgram",
    value: function CreateProgram(vertexShader, fragmentShader, pass, path, skipError) {
      const gl = global["w" /* device */].gl,
            program = {};
      program.program = gl.createProgram();
      gl.attachShader(program.program, vertexShader);
      gl.attachShader(program.program, fragmentShader);
      gl.linkProgram(program.program);

      if (!gl.getProgramParameter(program.program, gl.LINK_STATUS)) {
        if (!skipError) {
          throw new Tw2Error["v" /* ErrShaderLink */]({
            path: path,
            infoLog: gl.getProgramInfoLog(program.program)
          });
        }

        return null;
      }

      gl.useProgram(program.program);
      program.constantBufferHandles = [];

      for (let j = 0; j < 16; ++j) {
        program.constantBufferHandles[j] = gl.getUniformLocation(program.program, 'cb' + j);
      }

      program.samplerHandles = [];

      for (let j = 0; j < 16; ++j) {
        program.samplerHandles[j] = gl.getUniformLocation(program.program, 's' + j);
        gl.uniform1i(program.samplerHandles[j], j);
      }

      for (let j = 0; j < 16; ++j) {
        program.samplerHandles[j + 12] = gl.getUniformLocation(program.program, 'vs' + j);
        gl.uniform1i(program.samplerHandles[j + 12], j + 12);
      }

      program.input = new vertex["a" /* Tw2VertexDeclaration */]();

      for (let j = 0; j < pass.stages[0].inputDefinition.elements.length; ++j) {
        let location = gl.getAttribLocation(program.program, 'attr' + j);

        if (location >= 0) {
          const el = new vertex["b" /* Tw2VertexElement */](pass.stages[0].inputDefinition.elements[j].usage, pass.stages[0].inputDefinition.elements[j].usageIndex);
          el.location = location;
          program.input.elements.push(el);
        }
      }

      program.input.RebuildHash();
      program.shadowStateInt = gl.getUniformLocation(program.program, 'ssi');
      program.shadowStateFloat = gl.getUniformLocation(program.program, 'ssf');
      program.shadowStateYFlip = gl.getUniformLocation(program.program, 'ssyf');
      gl.uniform3f(program.shadowStateYFlip, 0, 0, 1);
      program.volumeSlices = [];

      for (let j = 0; j < pass.stages[1].samplers.length; ++j) {
        if (pass.stages[1].samplers[j].isVolume) {
          program.volumeSlices[pass.stages[1].samplers[j].registerIndex] = gl.getUniformLocation(program.program, 's' + pass.stages[1].samplers[j].registerIndex + 'sl');
        }
      }

      return program;
    }
    /**
     * Constant names that are ignored
     * @type {string[]}
     */

  }]);

  return Tw2Shader;
}();

Tw2Shader_defineProperty(Tw2Shader_Tw2Shader, "ConstantIgnore", ['PerFrameVS', 'PerObjectVS', 'PerFramePS', 'PerObjectPS']);
// CONCATENATED MODULE: ./core/resource/Tw2EffectRes.js
function Tw2EffectRes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2EffectRes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2EffectRes_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2EffectRes_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2EffectRes_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2EffectRes_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2EffectRes_assertThisInitialized(self); }

function Tw2EffectRes_getPrototypeOf(o) { Tw2EffectRes_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2EffectRes_getPrototypeOf(o); }

function Tw2EffectRes_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2EffectRes_setPrototypeOf(subClass, superClass); }

function Tw2EffectRes_setPrototypeOf(o, p) { Tw2EffectRes_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2EffectRes_setPrototypeOf(o, p); }

function Tw2EffectRes_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2EffectRes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * Tw2EffectRes
 *
 * @property {Array} passes
 * @property {*} annotation
 * @property {Array} permutations
 * @property {Array} offsets
 * @property {*} reader
 * @property {number} version
 * @property {string} stringTable
 * @property {*} shaders
 * @inherits Tw2Resource
 */

let Tw2EffectRes_Tw2EffectRes =
/*#__PURE__*/
function (_Tw2Resource) {
  Tw2EffectRes_inherits(Tw2EffectRes, _Tw2Resource);

  function Tw2EffectRes() {
    var _this;

    Tw2EffectRes_classCallCheck(this, Tw2EffectRes);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2EffectRes_possibleConstructorReturn(this, Tw2EffectRes_getPrototypeOf(Tw2EffectRes).call(this, ...args));

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "passes", []);

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "annotations", {});

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "permutations", []);

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "offsets", []);

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "reader", null);

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "version", 0);

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "stringTable", '');

    Tw2EffectRes_defineProperty(Tw2EffectRes_assertThisInitialized(Tw2EffectRes_assertThisInitialized(_this)), "shaders", {});

    return _this;
  }

  Tw2EffectRes_createClass(Tw2EffectRes, [{
    key: "Prepare",

    /**
     * Prepares the effect
     * - Creates Shaders
     * - Sets shadow states for shaders
     * - Parses Jessica shader annotations
     * @param data
     */
    value: function Prepare(data) {
      this.permutations = [];
      this.offsets = [];
      this.passes = [];
      this.annotations = {};
      this.reader = null;
      this.version = 0;
      this.stringTable = '';
      this.shaders = {};
      const reader = new Tw2BinaryReader["a" /* Tw2BinaryReader */](new Uint8Array(data));
      let stringTable = '';
      /**
       * ReadString
       * @returns {string}
       * @private
       */

      function ReadString() {
        const offset = reader.ReadUInt32();
        let end = offset;

        while (stringTable.charCodeAt(end)) {
          ++end;
        }

        return stringTable.substr(offset, end - offset);
      }

      const version = reader.ReadUInt32();

      if (version < 2 || version > 7) {
        this.OnError(new Tw2Error["x" /* ErrShaderVersion */]({
          path: this.path,
          version
        }));
        return;
      }

      let headerSize, stringTableSize;

      if (version < 5) {
        headerSize = reader.ReadUInt32();

        if (headerSize === 0) {
          this.OnError(new Tw2Error["u" /* ErrShaderHeaderSize */]({
            path: this.path
          }));
          return;
        }
        /* let permutation = */


        reader.ReadUInt32();
        const offset = reader.ReadUInt32();
        reader.cursor = 2 * 4 + headerSize * 3 * 4;
        stringTableSize = reader.ReadUInt32();
        this.stringTableOffset = reader.cursor;
        stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));
        reader.cursor = offset;
      } else {
        stringTableSize = reader.ReadUInt32();
        this.stringTableOffset = reader.cursor;
        stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));
        reader.cursor += stringTableSize;
        const permutationCount = reader.ReadUInt8();

        for (let perm = 0; perm < permutationCount; ++perm) {
          let permutation = {
            name: ReadString(),
            defaultOption: reader.ReadUInt8(),
            description: ReadString(),
            type: reader.ReadUInt8(),
            options: {},
            optionCount: reader.ReadUInt8()
          };

          for (let j = 0; j < permutation.optionCount; ++j) {
            permutation.options[ReadString()] = j;
          }

          this.permutations.push(permutation);
        }

        headerSize = reader.ReadUInt32();

        if (headerSize === 0) {
          this.OnError(new Tw2Error["u" /* ErrShaderHeaderSize */]({
            path: this.path
          }));
          return;
        }

        for (let i = 0; i < headerSize; ++i) {
          this.offsets.push({
            index: reader.ReadUInt32(),
            offset: reader.ReadUInt32(),
            size: reader.ReadUInt32()
          });
        }

        reader.ReadUInt32();
        reader.cursor = reader.ReadUInt32();
      }

      this.reader = reader;
      this.version = version;
      this.stringTable = stringTable;
      this.OnPrepared();
    }
    /**
     * Gets/creates a shader for the given permutation options
     *
     * @param {Object.<string, string>} options - Permutation options
     * @returns {Tw2Shader|null}
     */

  }, {
    key: "GetShader",
    value: function GetShader(options) {
      if (!this.IsGood()) {
        return null;
      }

      let index = 0;
      let multiplier = 1;

      for (let i = 0; i < this.permutations.length; ++i) {
        let permutation = this.permutations[i];
        let value = permutation.defaultOption;

        if (options.hasOwnProperty(permutation.name)) {
          let valueName = options[permutation.name];

          if (!permutation.options.hasOwnProperty(valueName)) {
            this.OnError(new Tw2Error["w" /* ErrShaderPermutationValue */]({
              path: this.path,
              permutation: permutation.name,
              valueName: valueName
            }));
            return null;
          }

          value = permutation.options[valueName];
        }

        index += value * multiplier;
        multiplier *= permutation.optionCount;
      }

      if (this.shaders.hasOwnProperty(index)) {
        return this.shaders[index];
      }

      this.reader.cursor = this.offsets[index].offset;
      let shader = null;

      try {
        shader = new Tw2Shader_Tw2Shader(this.reader, this.version, this.stringTable, this.stringTableOffset, this.path);
      } catch (error) {
        this.OnError(error);
        return null;
      }

      this.shaders[index] = shader;
      return shader;
    }
  }]);

  return Tw2EffectRes;
}(Tw2Resource["a" /* Tw2Resource */]);
/**
 * Request Response Type
 * @type {string}
 */

Tw2EffectRes_Tw2EffectRes.prototype.requestResponseType = 'arraybuffer';
// CONCATENATED MODULE: ./core/resource/Tw2GeometryRes.js
function Tw2GeometryRes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GeometryRes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2GeometryRes_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2GeometryRes_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2GeometryRes_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2GeometryRes_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2GeometryRes_assertThisInitialized(self); }

function Tw2GeometryRes_getPrototypeOf(o) { Tw2GeometryRes_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2GeometryRes_getPrototypeOf(o); }

function Tw2GeometryRes_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2GeometryRes_setPrototypeOf(subClass, superClass); }

function Tw2GeometryRes_setPrototypeOf(o, p) { Tw2GeometryRes_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2GeometryRes_setPrototypeOf(o, p); }

function Tw2GeometryRes_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2GeometryRes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/**
 * Tw2GeometryRes
 *
 * @property {Array} meshes
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 * @property {Array} models
 * @property {Array} animations
 * @property {Boolean} systemMirror
 * @inherit Tw2Resource
 */

let Tw2GeometryRes_Tw2GeometryRes =
/*#__PURE__*/
function (_Tw2Resource) {
  Tw2GeometryRes_inherits(Tw2GeometryRes, _Tw2Resource);

  function Tw2GeometryRes() {
    var _this;

    Tw2GeometryRes_classCallCheck(this, Tw2GeometryRes);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2GeometryRes_possibleConstructorReturn(this, Tw2GeometryRes_getPrototypeOf(Tw2GeometryRes).call(this, ...args));

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "meshes", []);

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "minBounds", global["H" /* vec3 */].create());

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "maxBounds", global["H" /* vec3 */].create());

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "boundsSpherePosition", global["H" /* vec3 */].create());

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "boundsSphereRadius", 0);

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "models", []);

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "animations", []);

    Tw2GeometryRes_defineProperty(Tw2GeometryRes_assertThisInitialized(Tw2GeometryRes_assertThisInitialized(_this)), "systemMirror", false);

    return _this;
  }

  Tw2GeometryRes_createClass(Tw2GeometryRes, [{
    key: "GetInstanceBuffer",

    /**
     * GetInstanceBuffer
     * @param {number} meshIndex
     * @returns {*}
     */
    value: function GetInstanceBuffer(meshIndex) {
      return meshIndex < this.meshes.length ? this.meshes[meshIndex].buffer : undefined;
    }
    /**
     * GetInstanceDeclaration
     * @param {number} meshIndex
     * @returns {Tw2VertexDeclaration}
     */

  }, {
    key: "GetInstanceDeclaration",
    value: function GetInstanceDeclaration(meshIndex) {
      return this.meshes[meshIndex].declaration;
    }
    /**
     * GetInstanceStride
     * @param {number} meshIndex
     * @returns {number}
     */

  }, {
    key: "GetInstanceStride",
    value: function GetInstanceStride(meshIndex) {
      return this.meshes[meshIndex].declaration.stride;
    }
    /**
     * GetInstanceCount
     * @param {number} meshIndex
     * @returns {number}
     */

  }, {
    key: "GetInstanceCount",
    value: function GetInstanceCount(meshIndex) {
      return this.meshes[meshIndex].bufferLength * 4 / this.meshes[meshIndex].declaration.stride;
    }
    /**
     * Prepare
     * @param data
     */

  }, {
    key: "Prepare",
    value: function Prepare(data) {
      const gl = global["w" /* device */].gl,
            reader = new Tw2BinaryReader["a" /* Tw2BinaryReader */](new Uint8Array(data));
      /* let fileVersion = */

      reader.ReadUInt8();
      const meshCount = reader.ReadUInt8();

      for (let meshIx = 0; meshIx < meshCount; ++meshIx) {
        const mesh = new Tw2GeometryMesh_Tw2GeometryMesh();
        mesh.name = reader.ReadString();
        const buffer = Tw2GeometryRes.ReadVertexBuffer(reader, mesh.declaration, this.path);

        if (buffer) {
          mesh.bufferLength = buffer.length;
          mesh.buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
        } else {
          mesh.buffer = null;
        }

        const indexes = Tw2GeometryRes.ReadIndexBuffer(reader);

        if (indexes) {
          mesh.indexes = gl.createBuffer();
          mesh.indexType = indexes.BYTES_PER_ELEMENT === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexes, gl.STATIC_DRAW);
        } else {
          mesh.indexes = null;
        }

        const areaCount = reader.ReadUInt8();

        for (let i = 0; i < areaCount; ++i) {
          mesh.areas[i] = new Tw2GeometryMeshArea_Tw2GeometryMeshArea();
          mesh.areas[i].name = reader.ReadString();
          mesh.areas[i].start = reader.ReadUInt32() * indexes.BYTES_PER_ELEMENT;
          mesh.areas[i].count = reader.ReadUInt32() * 3;
          mesh.areas[i].minBounds = global["H" /* vec3 */].fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
          mesh.areas[i].maxBounds = global["H" /* vec3 */].fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
        }

        const boneBindingCount = reader.ReadUInt8();
        mesh.boneBindings = [];

        for (let i = 0; i < boneBindingCount; ++i) {
          mesh.boneBindings[i] = reader.ReadString();
        }

        const annotationSetCount = reader.ReadUInt16();

        if (annotationSetCount || this.systemMirror) {
          mesh.bufferData = buffer;
          mesh.indexData = indexes;
        }

        if (annotationSetCount) {
          mesh.blendShapes = [];

          for (let i = 0; i < annotationSetCount; ++i) {
            mesh.blendShapes[i] = new Tw2BlendShapeData_Tw2BlendShapeData();
            mesh.blendShapes[i].name = reader.ReadString();
            mesh.blendShapes[i].buffer = Tw2GeometryRes.ReadVertexBuffer(reader, mesh.blendShapes[i].declaration, this.path);
            mesh.blendShapes[i].indexes = Tw2GeometryRes.ReadIndexBuffer(reader);
          }
        }

        this.meshes[meshIx] = mesh;
      }

      const modelCount = reader.ReadUInt8();

      for (let modelIx = 0; modelIx < modelCount; ++modelIx) {
        const model = new Tw2GeometryModel();
        model.name = reader.ReadString();
        model.skeleton = new Tw2GeometrySkeleton();
        const boneCount = reader.ReadUInt8();

        for (let i = 0; i < boneCount; ++i) {
          const bone = new Tw2GeometryBone_Tw2GeometryBone();
          bone.name = reader.ReadString();
          const flags = reader.ReadUInt8();
          bone.parentIndex = reader.ReadUInt8();
          if (bone.parentIndex === 255) bone.parentIndex = -1;

          if ((flags & 1) !== 0) {
            global["H" /* vec3 */].set(bone.position, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
          } else {
            global["H" /* vec3 */].set(bone.position, 0, 0, 0);
          }

          if ((flags & 2) !== 0) {
            global["C" /* quat */].set(bone.orientation, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
          } else {
            global["C" /* quat */].identity(bone.orientation);
          }

          if ((flags & 4) !== 0) {
            for (let k = 0; k < 9; ++k) {
              bone.scaleShear[k] = reader.ReadFloat32();
            }
          } else {
            global["y" /* mat3 */].identity(bone.scaleShear);
          }

          model.skeleton.bones[i] = bone;
        }

        for (let i = 0; i < model.skeleton.bones.length; ++i) {
          model.skeleton.bones[i].UpdateTransform();

          if (model.skeleton.bones[i].parentIndex !== -1) {
            global["z" /* mat4 */].multiply(model.skeleton.bones[i].worldTransform, model.skeleton.bones[model.skeleton.bones[i].parentIndex].worldTransform, model.skeleton.bones[i].localTransform);
          } else {
            global["z" /* mat4 */].copy(model.skeleton.bones[i].worldTransform, model.skeleton.bones[i].localTransform);
          }

          global["z" /* mat4 */].invert(model.skeleton.bones[i].worldTransformInv, model.skeleton.bones[i].worldTransform);
        }

        const meshBindingCount = reader.ReadUInt8();

        for (let i = 0; i < meshBindingCount; ++i) {
          const mesh = reader.ReadUInt8();

          if (mesh < this.meshes.length) {
            Tw2GeometryRes.BindMeshToModel(this.meshes[mesh], model, this);
          }
        }

        this.models[this.models.length] = model;
      }

      const animationCount = reader.ReadUInt8();

      for (let i = 0; i < animationCount; ++i) {
        const animation = new Tw2GeometryAnimation();
        animation.name = reader.ReadString();
        animation.duration = reader.ReadFloat32();
        const groupCount = reader.ReadUInt8();

        for (let j = 0; j < groupCount; ++j) {
          const group = new Tw2GeometryTrackGroup();
          group.name = reader.ReadString();

          for (let m = 0; m < this.models.length; ++m) {
            if (this.models[m].name === group.name) {
              group.model = this.models[m];
              break;
            }
          }

          const transformTrackCount = reader.ReadUInt8();

          for (let k = 0; k < transformTrackCount; ++k) {
            const track = new Tw2GeometryTransformTrack();
            track.name = reader.ReadString();
            track.orientation = Tw2GeometryRes.ReadCurve(reader);
            track.position = Tw2GeometryRes.ReadCurve(reader);
            track.scaleShear = Tw2GeometryRes.ReadCurve(reader);

            if (track.orientation) {
              let lastX = 0;
              let lastY = 0;
              let lastZ = 0;
              let lastW = 0;

              for (let n = 0; n < track.orientation.controls.length; n += 4) {
                let x = track.orientation.controls[n];
                let y = track.orientation.controls[n + 1];
                let z = track.orientation.controls[n + 2];
                let w = track.orientation.controls[n + 3];

                if (lastX * x + lastY * y + lastZ * z + lastW * w < 0) {
                  track.orientation.controls[n] = -x;
                  track.orientation.controls[n + 1] = -y;
                  track.orientation.controls[n + 2] = -z;
                  track.orientation.controls[n + 3] = -w;
                }

                lastX = x;
                lastY = y;
                lastZ = z;
                lastW = w;
              }
            }

            group.transformTracks[group.transformTracks.length] = track;
          }

          animation.trackGroups[animation.trackGroups.length] = group;
        }

        this.animations[this.animations.length] = animation;
      }

      this.OnPrepared();
    }
    /**
     * BindMeshToModel
     * @param {Tw2GeometryMesh} mesh
     * @param {Tw2GeometryModel} model
     * @param {Tw2GeometryRes} res
     */

  }, {
    key: "RenderAreasInstanced",

    /**
     * RenderAreasInstanced
     * @param {number} meshIx
     * @param {number} start
     * @param {number} count
     * @param {Tw2Effect} effect
     * @param {string} technique
     * @param instanceVB
     * @param instanceDecl
     * @param instanceStride
     * @param instanceCount
     * @returns {Boolean}
     */
    value: function RenderAreasInstanced(meshIx, start, count, effect, technique, instanceVB, instanceDecl, instanceStride, instanceCount) {
      this.KeepAlive();
      if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;
      const d = global["w" /* device */],
            ext = d.ext,
            gl = d.gl,
            mesh = this.meshes[meshIx],
            passCount = effect.GetPassCount(technique);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

      for (let pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(technique, pass);
        const passInput = effect.GetPassInput(technique, pass);
        if (passInput.elements.length === 0) continue;
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.buffer);
        mesh.declaration.SetPartialDeclaration(passInput, mesh.declaration.stride);
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceVB);
        const resetData = instanceDecl.SetPartialDeclaration(passInput, instanceStride, 8, 1);
        d.ApplyShadowState();

        for (let i = 0; i < count; ++i) {
          if (i + start < mesh.areas.length) {
            let area = mesh.areas[i + start],
                areaStart = area.start,
                acount = area.count;

            while (i + 1 < count) {
              area = mesh.areas[i + 1 + start];
              if (area.start !== areaStart + acount * 2) break;
              acount += area.count;
              ++i;
            }

            ext.drawElementsInstanced(gl.TRIANGLES, acount, mesh.indexType, areaStart, instanceCount);
          }
        }

        instanceDecl.ResetInstanceDivisors(resetData);
      }

      return true;
    }
    /**
     * RenderAreas
     * @param {number} meshIx
     * @param {number} start
     * @param {number} count
     * @param {Tw2Effect} effect
     * @param {string} technique
     * @returns {Boolean}
     */

  }, {
    key: "RenderAreas",
    value: function RenderAreas(meshIx, start, count, effect, technique) {
      this.KeepAlive();
      if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;
      const d = global["w" /* device */],
            gl = d.gl,
            mesh = this.meshes[meshIx] || this.meshes[0],
            passCount = effect.GetPassCount(technique);
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.buffer);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

      for (let pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(technique, pass);
        const passInput = effect.GetPassInput(technique, pass);

        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
          this.OnError(new Tw2Error["f" /* ErrGeometryMeshEffectBinding */]({
            path: this.path,
            pass: pass,
            passInput: passInput,
            meshStride: mesh.declaration.stride
          }));
          return false;
        }

        d.ApplyShadowState();

        for (let i = 0; i < count; ++i) {
          if (i + start < mesh.areas.length) {
            let area = mesh.areas[i + start],
                areaStart = area.start,
                acount = area.count;

            while (i + 1 < count) {
              area = mesh.areas[i + 1 + start];
              if (area.start !== areaStart + acount * 2) break;
              acount += area.count;
              ++i;
            }

            gl.drawElements(gl.TRIANGLES, acount, mesh.indexType, areaStart);
          }
        }
      }

      return true;
    }
    /**
     * RenderLines
     * @param {number} meshIx
     * @param {number} start
     * @param {number} count
     * @param {Tw2Effect} effect
     * @param {string} technique
     * @returns {Boolean}
     */

  }, {
    key: "RenderLines",
    value: function RenderLines(meshIx, start, count, effect, technique) {
      this.KeepAlive();
      if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;
      const d = global["w" /* device */],
            gl = d.gl,
            mesh = this.meshes[meshIx],
            passCount = effect.GetPassCount(technique);
      gl.bindBuffer(gl.ARRAY_BUFFER, mesh.buffer);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

      for (let pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(technique, pass);
        const passInput = effect.GetPassInput(technique, pass);

        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
          this.OnError(new Tw2Error["f" /* ErrGeometryMeshEffectBinding */]({
            path: this.path,
            pass: pass,
            passInput: passInput,
            meshStride: mesh.declaration.stride
          }));
          return false;
        }

        d.ApplyShadowState();

        for (let i = 0; i < count; ++i) {
          if (i + start < mesh.areas.length) {
            let area = mesh.areas[i + start],
                areaStart = area.start,
                acount = area.count;

            while (i + 1 < count) {
              area = mesh.areas[i + 1 + start];
              if (area.start !== areaStart + acount * 2) break;
              acount += area.count;
              ++i;
            }

            gl.drawElements(gl.LINES, acount, mesh.indexType, areaStart);
          }
        }
      }

      return true;
    }
    /**
     * RenderDebugInfo
     * @param {function} debugHelper
     * @returns {Boolean}
     */

  }, {
    key: "RenderDebugInfo",
    value: function RenderDebugInfo(debugHelper) {
      if (!this.IsGood()) return false;

      for (let i = 0; i < this.models.length; ++i) {
        if (this.models[i].skeleton) {
          for (let j = 0; j < this.models[i].skeleton.bones.length; ++j) {
            const b0 = this.models[i].skeleton.bones[j];

            if (b0.parentIndex >= 0) {
              const b1 = this.models[i].skeleton.bones[b0.parentIndex];
              debugHelper['AddLine']([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]], [0, 0.7, 0, 1], [0, 0.7, 0, 1]);
            }
          }
        }
      }
    }
    /**
     * Unloads webgl and javascript resources
     * @returns {Boolean}
     */

  }, {
    key: "Unload",
    value: function Unload() {
      for (let i = 0; i < this.meshes.length; ++i) {
        const gl = global["w" /* device */].gl;

        if (this.meshes[i].buffer) {
          gl.deleteBuffer(this.meshes[i].buffer);
          this.meshes[i].buffer = null;
        }

        if (this.meshes[i].indexes) {
          gl.deleteBuffer(this.meshes[i].indexes);
          this.meshes[i].indexes = null;
        }
      }

      this._isPurged = true;
      this._isGood = false;
      return true;
    }
    /**
     * ReadVertexBuffer
     * @param {Tw2BinaryReader} reader
     * @param {Tw2VertexDeclaration} declaration
     * @param {string} path
     * @returns {?Float32Array}
     */

  }], [{
    key: "BindMeshToModel",
    value: function BindMeshToModel(mesh, model, res) {
      const binding = new Tw2GeometryMeshBinding();
      binding.mesh = mesh;

      for (let b = 0; b < binding.mesh.boneBindings.length; ++b) {
        const name = binding.mesh.boneBindings[b],
              bone = model.FindBoneByName(name);

        if (!bone) {
          throw new Tw2Error["e" /* ErrGeometryMeshBoneNameInvalid */]({
            path: res.path,
            mesh: binding.mesh.name,
            bone: name,
            model: model.name
          });
        } else {
          binding.bones[binding.bones.length] = bone;
        }
      }

      model.meshBindings[model.meshBindings.length] = binding;
    }
  }, {
    key: "ReadVertexBuffer",
    value: function ReadVertexBuffer(reader, declaration, path) {
      const declCount = reader.ReadUInt8();
      let vertexSize = 0;

      for (let declIx = 0; declIx < declCount; ++declIx) {
        let element = new vertex["b" /* Tw2VertexElement */]();
        element.usage = reader.ReadUInt8();
        element.usageIndex = reader.ReadUInt8();
        element.fileType = reader.ReadUInt8();
        element.type = global["w" /* device */].gl.FLOAT;
        element.elements = (element.fileType >> 5) + 1;
        element.offset = vertexSize * 4;
        declaration.elements[declIx] = element;
        vertexSize += element.elements;
      }

      declaration.RebuildHash();
      declaration.stride = vertexSize * 4;
      const vertexCount = reader.ReadUInt32();
      if (vertexCount === 0) return null;
      const buffer = new Float32Array(vertexSize * vertexCount);
      let index = 0;

      for (let vtxIx = 0; vtxIx < vertexCount; ++vtxIx) {
        for (let declIx = 0; declIx < declCount; ++declIx) {
          let el = declaration.elements[declIx];

          switch (el.fileType & 0xf) {
            case 0:
              if ((el.fileType & 0x10) !== 0) {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadInt8() / 127.0;
                }
              } else {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadInt8();
                }
              }

              break;

            case 1:
              if ((el.fileType & 0x10) !== 0) {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadInt8() / 32767.0;
                }
              } else {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadInt16();
                }
              }

              break;

            case 2:
              for (let i = 0; i < el.elements; ++i) {
                buffer[index++] = reader.ReadInt32();
              }

              break;

            case 3:
              for (let i = 0; i < el.elements; ++i) {
                buffer[index++] = reader.ReadFloat16();
              }

              break;

            case 4:
              for (let i = 0; i < el.elements; ++i) {
                buffer[index++] = reader.ReadFloat32();
              }

              break;

            case 8:
              if ((el.fileType & 0x10) !== 0) {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadUInt8() / 255.0;
                }
              } else {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadUInt8();
                }
              }

              break;

            case 9:
              if ((el.fileType & 0x10) !== 0) {
                for (let i = 0; i < declaration.elements[declIx].elements; ++i) {
                  buffer[index++] = reader.ReadUInt8() / 65535.0;
                }
              } else {
                for (let i = 0; i < el.elements; ++i) {
                  buffer[index++] = reader.ReadUInt16();
                }
              }

              break;

            case 10:
              for (let i = 0; i < el.elements; ++i) {
                buffer[index++] = reader.ReadUInt32();
              }

              break;

            default:
              throw new Tw2Error["d" /* ErrGeometryFileType */]({
                path: path,
                key: 'fileType',
                value: el.fileType & 0xf
              });
          }
        }
      }

      return buffer;
    }
    /**
     * ReadIndexBuffer
     * @property {Tw2BinaryReader}
     * @returns {Uint16Array|Uint32Array}
     * @private
     */

  }, {
    key: "ReadIndexBuffer",
    value: function ReadIndexBuffer(reader) {
      const ibType = reader.ReadUInt8(),
            indexCount = reader.ReadUInt32();

      if (ibType === 0) {
        const indexes = new Uint16Array(indexCount);

        for (let i = 0; i < indexCount; ++i) {
          indexes[i] = reader.ReadUInt16();
        }

        return indexes;
      } else {
        const indexes = new Uint32Array(indexCount);

        for (let i = 0; i < indexCount; ++i) {
          indexes[i] = reader.ReadUInt32();
        }

        return indexes;
      }
    }
    /**
     * ReadCurve
     * @returns {Tw2GeometryCurve}
     */

  }, {
    key: "ReadCurve",
    value: function ReadCurve(reader) {
      const type = reader.ReadUInt8();
      if (type === 0) return null;
      const curve = new Tw2GeometryCurve();
      curve.dimension = reader.ReadUInt8();
      curve.degree = reader.ReadUInt8();
      const knotCount = reader.ReadUInt32();
      curve.knots = new Float32Array(knotCount);

      for (let i = 0; i < knotCount; ++i) {
        curve.knots[i] = reader.ReadFloat32();
      }

      const controlCount = reader.ReadUInt32();
      curve.controls = new Float32Array(controlCount);

      for (let i = 0; i < controlCount; ++i) {
        curve.controls[i] = reader.ReadFloat32();
      }

      return curve;
    }
  }]);

  return Tw2GeometryRes;
}(Tw2Resource["a" /* Tw2Resource */]);
/**
 * Request Response Type
 * @type {string}
 */

Tw2GeometryRes_Tw2GeometryRes.prototype.requestResponseType = 'arraybuffer';
// EXTERNAL MODULE: ./core/resource/Tw2LoadingObject.js
var Tw2LoadingObject = __webpack_require__(15);

// EXTERNAL MODULE: ./core/resource/Tw2TextureRes.js
var Tw2TextureRes = __webpack_require__(11);

// CONCATENATED MODULE: ./core/resource/Tw2VideoRes.js
function Tw2VideoRes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2VideoRes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2VideoRes_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2VideoRes_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2VideoRes_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2VideoRes_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2VideoRes_assertThisInitialized(self); }

function Tw2VideoRes_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Tw2VideoRes_get = Reflect.get; } else { Tw2VideoRes_get = function _get(target, property, receiver) { var base = Tw2VideoRes_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Tw2VideoRes_get(target, property, receiver || target); }

function Tw2VideoRes_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Tw2VideoRes_getPrototypeOf(object); if (object === null) break; } return object; }

function Tw2VideoRes_getPrototypeOf(o) { Tw2VideoRes_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2VideoRes_getPrototypeOf(o); }

function Tw2VideoRes_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2VideoRes_setPrototypeOf(subClass, superClass); }

function Tw2VideoRes_setPrototypeOf(o, p) { Tw2VideoRes_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2VideoRes_setPrototypeOf(o, p); }

function Tw2VideoRes_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2VideoRes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2VideoRes
 *
 * @property {?WebGLTexture} texture   - The video's webgl texture
 * @property {?HTMLVideoElement} video - The video
 * @property {number} width            - The texture's width
 * @property {number} height           - The texture's height
 * @property {boolean} cycle           - Enables video looping
 * @property {boolean} playOnLoad      - Plays the video as soon as it is able to
 * @property {number} _currentSampler  - The current sampler's hash
 * @property {number} _currentTime     - The video's current time
 * @property {boolean} _playable       - Identifies if the video is playable
 * @property {boolean} _isPlaying      - Identifies if the video is playing
 * @property {?Function} _onPlaying    - An optional callback which is fired when the video is playing
 * @property {?Function} _onPause      - An optional callback which is fired when the video is paused
 * @property {?Function} _onEnded      - An optional callback which is fired when the video has ended
 * @class
 */

let Tw2VideoRes_Tw2VideoRes =
/*#__PURE__*/
function (_Tw2Resource) {
  Tw2VideoRes_inherits(Tw2VideoRes, _Tw2Resource);

  function Tw2VideoRes() {
    var _this;

    Tw2VideoRes_classCallCheck(this, Tw2VideoRes);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2VideoRes_possibleConstructorReturn(this, Tw2VideoRes_getPrototypeOf(Tw2VideoRes).call(this, ...args));

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "texture", null);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "video", null);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "width", 0);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "height", 0);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "cycle", true);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "playOnLoad", true);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_currentSampler", 0);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_currentTime", -1);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_playable", false);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_isPlaying", false);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_onPlaying", null);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_onPause", null);

    Tw2VideoRes_defineProperty(Tw2VideoRes_assertThisInitialized(Tw2VideoRes_assertThisInitialized(_this)), "_onEnded", null);

    return _this;
  }

  Tw2VideoRes_createClass(Tw2VideoRes, [{
    key: "IsGood",

    /**
     * Checks if the resource is good
     * @returns {boolean}
     */
    value: function IsGood() {
      this.KeepAlive();
      return Tw2VideoRes_get(Tw2VideoRes_getPrototypeOf(Tw2VideoRes.prototype), "IsGood", this).call(this) && this.video && this._playable;
    }
    /**
     * Keeps the resource alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      this.activeFrame = global["D" /* resMan */].activeFrame;
    }
    /**
     * Plays the animation
     * @param {boolean} [cycle] Sets playing to loop
     * @param {Function|null} [onFinished=null] Optional callback to fire when the video has finished
     */

  }, {
    key: "Play",
    value: function Play() {
      let cycle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let onFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.cycle = cycle;
      this._onEnded = onFinished;

      if (this.video && this._playable) {
        this.video.loop = this.cycle;
        this.video.play();
      } else {
        this.playOnLoad = true;
      }
    }
    /**
     * Pauses the video
     */

  }, {
    key: "Pause",
    value: function Pause() {
      if (this.video) {
        this.video.pause();
      } else {
        this.playOnLoad = false;
      }
    }
    /**
     * Prepares the resource
     * @param {string} extension
     */

  }, {
    key: "Prepare",
    value: function Prepare(extension) {
      const gl = global["w" /* device */].gl;

      switch (extension) {
        case 'mp4':
        case 'webm':
        case 'ogg':
          this.texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.width = this.video.width;
          this.height = this.video.height;
          this.video.loop = this.cycle;
          if (this.playOnLoad) this.video.play();
          break;

        default:
          throw new Tw2Error["p" /* ErrResourceExtensionUnregistered */]({
            path: this.path,
            extension
          });
      }

      this.OnPrepared();
    }
    /**
     * Loads the resource from a path
     *
     * @param {string} path
     * @param {string} extension
     * @returns {boolean} returns true to tell the resMan not to handle http requests
     */

  }, {
    key: "DoCustomLoad",
    value: function DoCustomLoad(path, extension) {
      switch (extension) {
        case 'mp4':
        case 'webm':
        case 'ogg':
          break;

        default:
          throw new Tw2Error["p" /* ErrResourceExtensionUnregistered */]({
            path,
            extension
          });
      }

      this.OnRequested();
      global["D" /* resMan */]._pendingLoads++;
      this.video = document.createElement('video');
      this.video.crossOrigin = 'anonymous';
      this.video.muted = true;
      /**
       * Fires on errors
       */

      this.video.onerror = () => {
        global["D" /* resMan */]._pendingLoads--;
        this.video = null;
        this.OnError(new Tw2Error["k" /* ErrHTTPRequest */]({
          path
        }));
      };
      /**
       * Fires when the video is playable
       */


      this.video.oncanplay = () => {
        this._playable = true;
        this.video.oncanplay = null;
        global["D" /* resMan */]._pendingLoads--;

        global["D" /* resMan */]._prepareQueue.push([this, extension, null]);

        this.OnLoaded();
      };
      /**
       * Fires when the video has ended
       */


      this.video.onended = () => {
        this._isPlaying = false;
        if (this._onEnded) this._onEnded(this);
      };
      /**
       * Fires when the video is paused
       */


      this.video.onpause = () => {
        this._isPlaying = false;
        if (this._onPause) this._onPause(this);
      };
      /**
       * Fires when the video is playing
       */


      this.video.onplaying = () => {
        this._isPlaying = true;
        if (this._onPlaying) this._onPlaying(this);
      };

      this.video.src = path;
      return true;
    }
    /**
     * Unloads the video and texture from memory
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this.texture) {
        global["w" /* device */].gl.deleteTexture(this.texture);
        this.texture = null;
      }

      this._isPlaying = false;
      this._playable = false;
      this.playOnLoad = true;
      this.video = null;
      return true;
    }
    /**
     * Bind
     * @param {Tw2SamplerState} sampler
     */

  }, {
    key: "Bind",
    value: function Bind(sampler) {
      const d = global["w" /* device */],
            gl = d.gl;
      this.KeepAlive();
      const targetType = sampler.samplerType;
      if (targetType !== gl.TEXTURE_2D) return;

      if (!this.texture) {
        gl.bindTexture(gl.TEXTURE_2D, d.GetFallbackTexture());
        return;
      }

      this._currentTime = this.video.currentTime;
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindTexture(targetType, this.texture);

      if (sampler.hash !== this._currentSampler) {
        sampler.Apply(false);
        this._currentSampler = sampler.hash;
      }
    }
  }]);

  return Tw2VideoRes;
}(Tw2Resource["a" /* Tw2Resource */]);
// CONCATENATED MODULE: ./core/resource/index.js






// CONCATENATED MODULE: ./core/model/Tw2Bone.js
function Tw2Bone_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Bone_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2Bone
 *
 * @property {Tw2GeometryBone} boneRes
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} offsetTransform
 * @class
 */

let Tw2Bone_Tw2Bone = function Tw2Bone() {
  Tw2Bone_classCallCheck(this, Tw2Bone);

  Tw2Bone_defineProperty(this, "boneRes", null);

  Tw2Bone_defineProperty(this, "localTransform", global["z" /* mat4 */].create());

  Tw2Bone_defineProperty(this, "worldTransform", global["z" /* mat4 */].create());

  Tw2Bone_defineProperty(this, "offsetTransform", global["z" /* mat4 */].create());
};
// CONCATENATED MODULE: ./core/model/Tw2Model.js
function Tw2Model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Model_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2Model
 *
 * @property {Tw2GeometryModel} modelRes
 * @property {Array.<Tw2Bone>} bones
 * @property {Object.<string, Tw2Bone>} bonesByName - An object containing every Tw2Bone name and it's object
 * @class
 */
let Tw2Model = function Tw2Model() {
  Tw2Model_classCallCheck(this, Tw2Model);

  Tw2Model_defineProperty(this, "modelRes", null);

  Tw2Model_defineProperty(this, "bones", []);

  Tw2Model_defineProperty(this, "bonesByName", {});
};
// CONCATENATED MODULE: ./core/model/Tw2Track.js
function Tw2Track_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Track_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2Track
 *
 * @property {Tw2GeometryTransformTrack} trackRes
 * @property {Tw2Bone} bone
 * @class
 */
let Tw2Track = function Tw2Track() {
  Tw2Track_classCallCheck(this, Tw2Track);

  Tw2Track_defineProperty(this, "trackRes", null);

  Tw2Track_defineProperty(this, "bone", null);
};
// CONCATENATED MODULE: ./core/model/Tw2TrackGroup.js
function Tw2TrackGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2TrackGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2TrackGroup
 *
 * @property {Tw2GeometryTrackGroup} trackGroupRes
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2Track>} transformTracks
 * @class
 */
let Tw2TrackGroup = function Tw2TrackGroup() {
  Tw2TrackGroup_classCallCheck(this, Tw2TrackGroup);

  Tw2TrackGroup_defineProperty(this, "trackGroupRes", null);

  Tw2TrackGroup_defineProperty(this, "model", null);

  Tw2TrackGroup_defineProperty(this, "transformTracks", []);
};
// CONCATENATED MODULE: ./core/model/Tw2AnimationController.js
function Tw2AnimationController_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2AnimationController_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2AnimationController_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2AnimationController_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2AnimationController_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2AnimationController_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








/**
 * Tw2AnimationController
 *
 * @property {Array.<Tw2GeometryRes>} geometryResources
 * @property {Array.<Tw2Model>} models
 * @property {Array.<Tw2Animation>} animations
 * @property {Array} meshBindings
 * @property {boolean} loaded
 * @property {boolean} update
 * @property _geometryResource
 * @property {Array} pendingCommands
 * @property {Function} [onLoaded] an optional callback fired when any commands are cleared
 * @class
 */

let Tw2AnimationController_Tw2AnimationController =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {Tw2GeometryRes} [geometryResource]
   */
  function Tw2AnimationController(geometryResource) {
    Tw2AnimationController_classCallCheck(this, Tw2AnimationController);

    Tw2AnimationController_defineProperty(this, "geometryResources", []);

    Tw2AnimationController_defineProperty(this, "models", []);

    Tw2AnimationController_defineProperty(this, "animations", []);

    Tw2AnimationController_defineProperty(this, "meshBindings", []);

    Tw2AnimationController_defineProperty(this, "loaded", false);

    Tw2AnimationController_defineProperty(this, "update", true);

    Tw2AnimationController_defineProperty(this, "pendingCommands", []);

    Tw2AnimationController_defineProperty(this, "onPendingCleared", null);

    Tw2AnimationController_defineProperty(this, "_geometryResource", null);

    if (geometryResource) this.SetGeometryResource(geometryResource);
  }
  /**
   * Gets a loaded Tw2Animation by it's name
   * @returns {?{ string: Tw2Animation}} an object containing animation names and animations, or null if not loaded
   */


  Tw2AnimationController_createClass(Tw2AnimationController, [{
    key: "GetAnimationsByName",
    value: function GetAnimationsByName() {
      if (!this.loaded) return null;
      const animations = {};

      for (let i = 0; i < this.animations.length; i++) {
        animations[this.animations[i].animationRes.name] = this.animations[i];
      }

      return animations;
    }
    /**
     * Gets a loaded Tw2Animation by it's name
     * @param {String} name
     * @returns {?Tw2Animation} Returns the animation if found
     */

  }, {
    key: "GetAnimation",
    value: function GetAnimation(name) {
      for (let i = 0; i < this.animations.length; i++) {
        if (this.animations[i].animationRes.name === name) {
          return this.animations[i];
        }
      }

      return null;
    }
    /**
     * Resets a Tw2Animation by it's name
     * @param {String} name
     * @return {boolean}
     */

  }, {
    key: "ResetAnimation",
    value: function ResetAnimation(name) {
      const animation = this.GetAnimation(name);

      if (animation) {
        animation.time = 0;
        animation.isPlaying = false;
        animation.callback = null;
        return true;
      }
    }
    /**
     * Plays a specific animation by it's name
     * @param {string} name - Animation's Name
     * @param {boolean} [cycle]
     * @param {Function} [callback] - Optional callback which is fired once the animation has completed
     * @return {boolean}
     */

  }, {
    key: "PlayAnimation",
    value: function PlayAnimation(name, cycle, callback) {
      if (this.animations.length === 0) {
        this.pendingCommands.push({
          'func': this.PlayAnimation,
          'args': [name, cycle, callback]
        });
        return true;
      }

      const animation = this.GetAnimation(name);

      if (animation) {
        animation.time = 0;
        animation.isPlaying = true;

        if (!global["F" /* util */].isUndefined(cycle)) {
          animation.cycle = cycle;
        }

        if (callback) {
          animation.callback = callback;
        }

        return true;
      }
    }
    /**
     * Plays a specific animation from a specific time
     * @param {string} name - Animation's Name
     * @param {number} from - Time to play from
     * @param {boolean} [cycle]
     * @param {Function} [callback] - Optional callback which is fired once the animation has completed
     * @returns {boolean}
     */

  }, {
    key: "PlayAnimationFrom",
    value: function PlayAnimationFrom(name, from, cycle, callback) {
      if (this.animations.length === 0) {
        this.pendingCommands.push({
          'func': this.PlayAnimationFrom,
          'args': [name, from, cycle, callback]
        });
        return true;
      }

      const animation = this.GetAnimation(name);

      if (animation) {
        animation.time = Math.max(Math.min(from, animation.animationRes.duration), 0);
        animation.isPlaying = true;

        if (!global["F" /* util */].isUndefined(cycle)) {
          animation.cycle = cycle;
        }

        if (callback) {
          animation.callback = callback;
        }

        return true;
      }
    }
    /**
     * Gets an array of all the currently playing animations by name
     * @returns {Array}
     */

  }, {
    key: "GetPlayingAnimations",
    value: function GetPlayingAnimations() {
      const result = [];

      for (let i = 0; i < this.animations.length; i++) {
        if (this.animations[i].isPlaying) {
          result.push(this.animations[i].animationRes.name);
        }
      }

      return result;
    }
    /**
     * Stops an animation or an array of animations from playing
     * @param {String| Array.<string>} names - Animation Name, or Array of Animation Names
     */

  }, {
    key: "StopAnimation",
    value: function StopAnimation(names) {
      if (this.animations.length === 0) {
        this.pendingCommands.push({
          'func': this.StopAnimation,
          'args': names
        });
        return;
      }

      names = global["F" /* util */].toArray(names);
      const toStop = {};

      for (let n = 0; n < names.length; n++) {
        toStop[names[n]] = true;
      }

      for (let i = 0; i < this.animations.length; ++i) {
        if (this.animations[i].animationRes.name in toStop) {
          this.animations[i].isPlaying = false;
        }
      }
    }
    /**
     * Stops all animations from playing
     */

  }, {
    key: "StopAllAnimations",
    value: function StopAllAnimations() {
      if (this.animations.length === 0) {
        this.pendingCommands.push({
          'func': this.StopAllAnimations,
          'args': null
        });
        return;
      }

      for (let i = 0; i < this.animations.length; ++i) {
        this.animations[i].isPlaying = false;
      }
    }
    /**
     * Stops all but the supplied list of animations
     * @param {String| Array.<string>} names - Animation Names
     */

  }, {
    key: "StopAllAnimationsExcept",
    value: function StopAllAnimationsExcept(names) {
      if (this.animations.length === 0) {
        this.pendingCommands.push({
          'func': this.StopAllAnimationsExcept,
          'args': names
        });
        return;
      }

      global["F" /* util */].toArray(names);
      const keepAnimating = {};

      for (let n = 0; n < names.length; n++) {
        keepAnimating[names[n]] = true;
      }

      for (let i = 0; i < this.animations.length; ++i) {
        if (!(this.animations[i].animationRes.name in keepAnimating)) {
          this.animations[i].isPlaying = false;
        }
      }
    }
    /**
     * Clears any existing resources and loads the supplied geometry resource
     * @param {Tw2GeometryRes} geometryResource
     */

  }, {
    key: "SetGeometryResource",
    value: function SetGeometryResource(geometryResource) {
      this.models = [];
      this.animations = [];
      this.meshBindings = [];

      for (let i = 0; i < this.geometryResources.length; ++i) {
        this.geometryResources[i].UnregisterNotification(this);
      }

      this.loaded = false;
      this.geometryResources = [];

      if (geometryResource) {
        this.geometryResources.push(geometryResource);
        geometryResource.RegisterNotification(this);
      }
    }
    /**
     * Adds a Geometry Resource
     * @param {Tw2GeometryRes} geometryResource
     */

  }, {
    key: "AddGeometryResource",
    value: function AddGeometryResource(geometryResource) {
      for (let i = 0; i < this.geometryResources.length; ++i) {
        if (this.geometryResources[i] === geometryResource) {
          return;
        }
      }

      this.geometryResources.push(geometryResource);
      geometryResource.RegisterNotification(this);
    }
    /**
     * Adds animations from a resource
     * @param {Tw2GeometryRes} resource
     */

  }, {
    key: "AddAnimationsFromRes",
    value: function AddAnimationsFromRes(resource) {
      for (let i = 0; i < resource.animations.length; ++i) {
        let animation = null;

        for (let j = 0; j < this.animations.length; ++j) {
          if (this.animations[j].animationRes === resource.animations[i]) {
            animation = this.animations[i];
            break;
          }
        }

        if (!animation) {
          animation = new Tw2Animation();
          animation.animationRes = resource.animations[i];
          this.animations.push(animation);
        }

        for (let j = 0; j < animation.animationRes.trackGroups.length; ++j) {
          let found = false;

          for (let k = 0; k < animation.trackGroups.length; ++k) {
            if (animation.trackGroups[k].trackGroupRes === animation.animationRes.trackGroups[j]) {
              found = true;
              break;
            }
          }

          if (found) {
            continue;
          }

          let model = null;

          for (let k = 0; k < this.models.length; ++k) {
            if (this.models[k].modelRes.name === animation.animationRes.trackGroups[j].name) {
              model = this.models[k];
              break;
            }
          }

          if (model !== null) {
            const group = new Tw2TrackGroup();
            group.trackGroupRes = animation.animationRes.trackGroups[j];

            for (let k = 0; k < group.trackGroupRes.transformTracks.length; ++k) {
              for (let m = 0; m < model.bones.length; ++m) {
                if (model.bones[m].boneRes.name === group.trackGroupRes.transformTracks[k].name) {
                  const track = new Tw2Track();
                  track.trackRes = group.trackGroupRes.transformTracks[k];
                  track.bone = model.bones[m];
                  group.transformTracks.push(track);
                  break;
                }
              }
            }

            animation.trackGroups.push(group);
          }
        }
      }
    }
    /**
     * Resets the bone transforms
     */

  }, {
    key: "ResetBoneTransforms",
    value: function ResetBoneTransforms() {
      for (let i = 0; i < this.models.length; ++i) {
        for (let j = 0; j < this.models[i].bones.length; ++j) {
          const bone = this.models[i].bones[j],
                boneRes = bone.boneRes;
          global["z" /* mat4 */].copy(bone.localTransform, boneRes.localTransform);

          if (boneRes.parentIndex !== -1) {
            global["z" /* mat4 */].multiply(bone.worldTransform, bone.localTransform, this.models[i].bones[bone.boneRes.parentIndex].worldTransform);
          } else {
            global["z" /* mat4 */].set(bone.worldTransform, bone.localTransform);
          }

          global["z" /* mat4 */].identity(bone.offsetTransform);
        }
      }

      const id = global["z" /* mat4 */].identity(Tw2AnimationController.global.mat4_0);

      for (let i = 0; i < this.meshBindings.length; ++i) {
        for (let j = 0; j < this.meshBindings[i].length; ++j) {
          for (let k = 0; k * 16 < this.meshBindings[i][j].length; ++k) {
            for (let m = 0; m < 16; ++m) {
              this.meshBindings[i][j][k * 16 + m] = id[m];
            }
          }
        }
      }
    }
    /**
     * GetBoneMatrices
     * @param {number} meshIndex
     * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
     * @returns {Float32Array}
     */

  }, {
    key: "GetBoneMatrices",
    value: function GetBoneMatrices(meshIndex, geometryResource) {
      if (this.geometryResources.length === 0) {
        return new Float32Array();
      }

      if (!geometryResource) {
        geometryResource = this.geometryResources[0];
      }

      const meshBindings = Tw2AnimationController.FindMeshBindings(this, geometryResource);

      if (meshBindings && meshIndex < meshBindings.length) {
        return meshBindings[meshIndex];
      }

      return new Float32Array();
    }
    /**
     * FindModelForMesh
     * @param {number} meshIndex
     * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
     * @returns {Tw2Model|null} Returns the Tw2Model for the mesh if found and is good, else returns null
     */

  }, {
    key: "FindModelForMesh",
    value: function FindModelForMesh(meshIndex, geometryResource) {
      if (this.geometryResources.length === 0) {
        return null;
      }

      if (!geometryResource) {
        geometryResource = this.geometryResources[0];
      }

      if (!geometryResource.IsGood()) {
        return null;
      }

      const mesh = geometryResource.meshes[meshIndex];

      for (let i = 0; i < this.models.length; ++i) {
        for (let j = 0; j < this.models[i].modelRes.meshBindings.length; ++i) {
          if (this.models[i].modelRes.meshBindings[j].mesh === mesh) {
            return this.models[i];
          }
        }
      }

      return null;
    }
    /**
     * Gets all animation controller res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.geometryResources.length; i++) {
        if (!out.includes(this.geometryResources[i])) {
          out.push(this.geometryResources[i]);
        }
      }

      return out;
    }
    /**
     * Rebuilds the cached data for a resource (unless it doesn't exist or is already good)
     * @param {Tw2GeometryRes} resource
     */

  }, {
    key: "RebuildCachedData",
    value: function RebuildCachedData(resource) {
      let found = false;

      for (let i = 0; i < this.geometryResources.length; ++i) {
        if (this.geometryResources[i] === resource) {
          found = true;
          break;
        }
      }

      if (!found) {
        return;
      }

      for (let i = 0; i < this.geometryResources.length; ++i) {
        if (!this.geometryResources[i].IsGood()) {
          return;
        }
      }

      for (let i = 0; i < this.geometryResources.length; ++i) {
        Tw2AnimationController.DoRebuildCachedData(this, this.geometryResources[i]);
      }
    }
    /**
     * Internal render/update function which is called every frame
     * @param {number} dt - Delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (!this.models || !this.update) {
        return;
      }

      for (let i = 0; i < this.geometryResources.length; ++i) {
        this.geometryResources[i].KeepAlive();
      }

      const g = Tw2AnimationController.global,
            rotationMat = g.mat4_0,
            orientation = g.quat_0,
            position = g.vec3_0,
            scale = g.mat3_0; //var updateBones = false;

      for (let i = 0; i < this.animations.length; ++i) {
        const animation = this.animations[i];

        if (animation.isPlaying) {
          const res = animation.animationRes;
          animation.time += dt * animation.timeScale;

          if (animation.time > res.duration) {
            if (animation.callback) {
              animation.callback(this, animation);
            }

            if (animation.cycle) {
              animation.time = animation.time % res.duration;
            } else {
              animation.isPlaying = false;
              animation.time = res.duration;
            }
          }

          for (let j = 0; j < animation.trackGroups.length; ++j) {
            for (let k = 0; k < animation.trackGroups[j].transformTracks.length; ++k) {
              const track = animation.trackGroups[j].transformTracks[k];

              if (track.trackRes.position) {
                global["v" /* curve */].evaluate(track.trackRes.position, animation.time, position, animation.cycle, res.duration);
              } else {
                position[0] = position[1] = position[2] = 0;
              }

              if (track.trackRes.orientation) {
                global["v" /* curve */].evaluate(track.trackRes.orientation, animation.time, orientation, animation.cycle, res.duration);
                global["C" /* quat */].normalize(orientation, orientation);
              } else {
                global["C" /* quat */].identity(orientation);
              }

              if (track.trackRes.scaleShear) {
                global["v" /* curve */].evaluate(track.trackRes.scaleShear, animation.time, scale, animation.cycle, res.duration);
              } else {
                global["y" /* mat3 */].identity(scale);
              }

              global["z" /* mat4 */].fromMat3(track.bone.localTransform, scale);
              global["z" /* mat4 */].multiply(track.bone.localTransform, track.bone.localTransform, global["z" /* mat4 */].fromQuat(rotationMat, orientation));
              track.bone.localTransform[12] = position[0];
              track.bone.localTransform[13] = position[1];
              track.bone.localTransform[14] = position[2];
            }
          }
        }
      }

      for (let i = 0; i < this.models.length; ++i) {
        for (let j = 0; j < this.models[i].bones.length; ++j) {
          const bone = this.models[i].bones[j];

          if (bone.boneRes.parentIndex !== -1) {
            global["z" /* mat4 */].multiply(bone.worldTransform, this.models[i].bones[bone.boneRes.parentIndex].worldTransform, bone.localTransform);
          } else {
            global["z" /* mat4 */].copy(bone.worldTransform, bone.localTransform);
          }

          global["z" /* mat4 */].multiply(bone.offsetTransform, bone.worldTransform, bone.boneRes.worldTransformInv);

          if (bone.bindingArrays) {
            for (let a = 0; a < bone.bindingArrays.length; ++a) {
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 0] = bone.offsetTransform[0];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 1] = bone.offsetTransform[4];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 2] = bone.offsetTransform[8];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 3] = bone.offsetTransform[12];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 4] = bone.offsetTransform[1];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 5] = bone.offsetTransform[5];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 6] = bone.offsetTransform[9];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 7] = bone.offsetTransform[13];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 8] = bone.offsetTransform[2];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 9] = bone.offsetTransform[6];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 10] = bone.offsetTransform[10];
              bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 11] = bone.offsetTransform[14];
            }
          }
        }
      }
    }
    /**
     * RenderDebugInfo
     * TODO: Fix commented out code
     * @param {function} debugHelper
     */

  }, {
    key: "RenderDebugInfo",
    value: function RenderDebugInfo(debugHelper) {
      /*for (var i = 0; i < this.geometryResources.length; ++i)
       {
       this.geometryResources[i].RenderDebugInfo(debugHelper);
       }*/
      for (let i = 0; i < this.models.length; ++i) {
        for (let j = 0; j < this.models[i].bones.length; ++j) {
          const b0 = this.models[i].bones[j];

          if (b0.boneRes.parentIndex >= 0) {
            const b1 = this.models[i].bones[b0.boneRes.parentIndex];
            debugHelper['AddLine']([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]]);
          }
        }
      }
    }
    /**
     * Adds a model resource to an animation controller
     * @param {Tw2AnimationController} animationController
     * @param {Tw2GeometryModel} modelRes
     * @returns {null|Tw2Model} Returns a newly created Tw2Model if the model resource doesn't already exist, and null if it does
     */

  }], [{
    key: "AddModel",
    value: function AddModel(animationController, modelRes) {
      for (let i = 0; i < animationController.models.length; ++i) {
        if (animationController.models[i].modelRes.name === modelRes.name) {
          return null;
        }
      }

      const model = new Tw2Model();
      model.modelRes = modelRes;
      const skeleton = modelRes.skeleton;

      if (skeleton !== null) {
        for (let j = 0; j < skeleton.bones.length; ++j) {
          const bone = new Tw2Bone_Tw2Bone();
          bone.boneRes = skeleton.bones[j];
          model.bones.push(bone);
          model.bonesByName[bone.boneRes.name] = bone;
        }
      }

      animationController.models.push(model);
      return model;
    }
    /**
     * Finds a mesh binding for a supplied resource from an animation controller
     * @param {Tw2AnimationController} animationController
     * @param {Tw2GeometryRes} resource
     * @returns {Object|null} Returns the mesh binding of a resource if it exists, null if it doesn't
     * @private
     */

  }, {
    key: "FindMeshBindings",
    value: function FindMeshBindings(animationController, resource) {
      for (let i = 0; i < animationController.meshBindings.length; ++i) {
        if (animationController.meshBindings[i].resource === resource) {
          return animationController.meshBindings[i];
        }
      }

      return null;
    }
    /**
     * DoRebuildCachedData
     * @param {Tw2AnimationController) animationController
     * @param {Tw2GeometryRes} resource
     */

  }, {
    key: "DoRebuildCachedData",
    value: function DoRebuildCachedData(animationController, resource) {
      const newModels = [];

      if (resource.meshes.length) {
        for (let i = 0; i < resource.models.length; ++i) {
          const model = Tw2AnimationController.AddModel(animationController, resource.models[i]);

          if (model) {
            newModels.push(model);
          }
        }
      }

      for (let i = 0; i < animationController.geometryResources.length; ++i) {
        animationController.AddAnimationsFromRes(animationController.geometryResources[i]);
      }

      if (resource.models.length === 0) {
        for (let i = 0; i < resource.meshes.length; ++i) {
          Tw2GeometryRes_Tw2GeometryRes.BindMeshToModel(resource.meshes[i], animationController.geometryResources[0].models[0], resource);
        }

        resource.models.push(animationController.geometryResources[0].models[0]);
      }

      for (let i = 0; i < resource.models.length; ++i) {
        let model = null;

        for (let j = 0; j < animationController.models.length; ++j) {
          if (animationController.models[j].modelRes.name === resource.models[i].name) {
            model = animationController.models[j];
            break;
          }
        }

        if (model === null) {
          continue;
        }

        for (let j = 0; j < resource.models[i].meshBindings.length; ++j) {
          const meshIx = resource.meshes.indexOf(resource.models[i].meshBindings[j].mesh);
          let meshBindings = Tw2AnimationController.FindMeshBindings(animationController, resource);

          if (meshBindings === null) {
            meshBindings = [];
            meshBindings.resource = resource;
            animationController.meshBindings.push(meshBindings);
          }

          meshBindings[meshIx] = new Float32Array(resource.models[i].meshBindings[j].bones.length * 12);

          for (let k = 0; k < resource.models[i].meshBindings[j].bones.length; ++k) {
            for (let n = 0; n < model.bones.length; ++n) {
              if (model.bones[n].boneRes.name === resource.models[i].meshBindings[j].bones[k].name) {
                if (!model.bones[n].bindingArrays) {
                  model.bones[n].bindingArrays = [];
                }

                model.bones[n].bindingArrays[model.bones[n].bindingArrays.length] = {
                  'array': meshBindings[meshIx],
                  'offset': k * 12
                }; //meshBindings[meshIx][k] = model.bones[n].offsetTransform;

                break;
              }
            }
          }
        }
      }

      if (resource.meshes.length && resource.models.length) {
        animationController.ResetBoneTransforms();
      }

      animationController.loaded = true;

      if (animationController.animations.length) {
        if (animationController.pendingCommands.length) {
          for (let i = 0; i < animationController.pendingCommands.length; ++i) {
            if (!animationController.pendingCommands[i].args) {
              animationController.pendingCommands[i].func.apply(animationController);
            } else {
              animationController.pendingCommands[i].func.apply(animationController, animationController.pendingCommands[i].args);
            }
          }
        }

        animationController.pendingCommands = [];
        if (animationController.onPendingCleared) animationController.onPendingCleared(animationController);
      }
    }
    /**
     * Global and Scratch variables
     */

  }]);

  return Tw2AnimationController;
}();

Tw2AnimationController_defineProperty(Tw2AnimationController_Tw2AnimationController, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  quat_0: global["C" /* quat */].create(),
  mat3_0: global["y" /* mat3 */].create(),
  mat4_0: global["z" /* mat4 */].create()
});
// CONCATENATED MODULE: ./core/model/index.js






// EXTERNAL MODULE: ./global/util/index.js + 5 modules
var util = __webpack_require__(3);

// CONCATENATED MODULE: ./core/Tw2RenderTarget.js
function Tw2RenderTarget_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RenderTarget_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RenderTarget_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RenderTarget_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RenderTarget_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RenderTarget_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2RenderTarget
 *
 * @property {string|number} _id               - the render target's id
 * @property {string} name                     - the render target's name
 * @property {Tw2TextureRes} texture           - the render target's texture
 * @property {?number} width                   - width of the render target's texture
 * @property {?number} height                  - height of the render target's texture
 * @property {?boolean} hasDepth               - toggles depth
 * @property {WebGLFramebuffer} _frameBuffer   - the render target's webgl frame buffer
 * @property {WebGLRenderbuffer} _renderBuffer - the render target's webgl render buffer
 * @class
 */

let Tw2RenderTarget_Tw2RenderTarget =
/*#__PURE__*/
function () {
  function Tw2RenderTarget() {
    Tw2RenderTarget_classCallCheck(this, Tw2RenderTarget);

    Tw2RenderTarget_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2RenderTarget_defineProperty(this, "name", '');

    Tw2RenderTarget_defineProperty(this, "texture", null);

    Tw2RenderTarget_defineProperty(this, "width", null);

    Tw2RenderTarget_defineProperty(this, "height", null);

    Tw2RenderTarget_defineProperty(this, "hasDepth", null);

    Tw2RenderTarget_defineProperty(this, "_frameBuffer", null);

    Tw2RenderTarget_defineProperty(this, "_renderBuffer", null);
  }

  Tw2RenderTarget_createClass(Tw2RenderTarget, [{
    key: "Destroy",

    /**
     * Destroys the render target's webgl buffers and textures
     */
    value: function Destroy() {
      const gl = global["w" /* device */].gl;

      if (this.texture) {
        gl.deleteTexture(this.texture.texture);
        this.texture = null;
      }

      if (this._renderBuffer) {
        gl.deleteRenderbuffer(this._renderBuffer);
        this._renderBuffer = null;
      }

      if (this._frameBuffer) {
        gl.deleteFramebuffer(this._frameBuffer);
        this._frameBuffer = null;
      }
    }
    /**
     * Creates the render target's texture
     *
     * @param {number} width     - The resulting texture's width
     * @param {number} height    - The resulting texture's height
     * @param {boolean} hasDepth - Optional flag to enable a depth buffer
     */

  }, {
    key: "Create",
    value: function Create(width, height, hasDepth) {
      const gl = global["w" /* device */].gl;
      this.Destroy();
      this.texture = new Tw2TextureRes["a" /* Tw2TextureRes */]();
      this.texture.Attach(gl.createTexture());
      this._frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      gl.bindTexture(gl.TEXTURE_2D, this.texture.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, null);
      this._renderBuffer = null;

      if (hasDepth) {
        this._renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      }

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);

      if (hasDepth) {
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._renderBuffer);
      }

      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this.texture.width = this.width = width;
      this.texture.height = this.height = height;
      this.hasDepth = hasDepth;
    }
    /**
     * Sets the render target as the current frame buffer
     */

  }, {
    key: "Set",
    value: function Set() {
      global["w" /* device */].gl.bindFramebuffer(global["w" /* device */].gl.FRAMEBUFFER, this._frameBuffer);
      global["w" /* device */].gl.viewport(0, 0, this.width, this.height);
    }
    /**
     * Unsets the render target as the current frame buffer
     */

  }, {
    key: "Unset",
    value: function Unset() {
      global["w" /* device */].gl.bindFramebuffer(global["w" /* device */].gl.FRAMEBUFFER, null);
      global["w" /* device */].gl.viewport(0, 0, global["w" /* device */].viewportWidth, global["w" /* device */].viewportHeight);
    }
  }]);

  return Tw2RenderTarget;
}();
// CONCATENATED MODULE: ./core/post/Tw2PostEffectStep.js
function Tw2PostEffectStep_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PostEffectStep_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2PostEffectStep_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2PostEffectStep_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2PostEffectStep_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2PostEffectStep_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Post effect step
 *
 * @property {string|number| _id                - A unique id
 * @property {string} name                      - the step's name
 * @property {boolean} display                  - toggles rendering
 * @property {number} [index=-1]                - the step's render order (defaults to the order it was added)
 * @property {Tw2Effect} effect                 - the step's effect
 * @property {?string} [target]                 - the step's render target name
 * @property {{string:string}} inputs           - the step's input render targets
 * @property {?Tw2RenderTarget} [_renderTarget] - the step's render target (if none is defined the current target is used)
 * @property {boolean} _rebuildPending          - identifies if the post is pending a rebuild
 * @property {?Function} _onModified            - a function which is called when the step is modified
 */

let Tw2PostEffectStep_Tw2PostEffectStep =
/*#__PURE__*/
function () {
  function Tw2PostEffectStep() {
    Tw2PostEffectStep_classCallCheck(this, Tw2PostEffectStep);

    Tw2PostEffectStep_defineProperty(this, "_id", Object(util["generateID"])());

    Tw2PostEffectStep_defineProperty(this, "name", '');

    Tw2PostEffectStep_defineProperty(this, "index", -1);

    Tw2PostEffectStep_defineProperty(this, "display", true);

    Tw2PostEffectStep_defineProperty(this, "effect", null);

    Tw2PostEffectStep_defineProperty(this, "target", null);

    Tw2PostEffectStep_defineProperty(this, "inputs", {});

    Tw2PostEffectStep_defineProperty(this, "_renderTarget", null);

    Tw2PostEffectStep_defineProperty(this, "_rebuildPending", true);

    Tw2PostEffectStep_defineProperty(this, "_onModified", null);
  }

  Tw2PostEffectStep_createClass(Tw2PostEffectStep, [{
    key: "OnValueChanged",

    /**
     * Fires on value changes
     */
    value: function OnValueChanged() {
      this._rebuildPending = true;

      if (this._onModified) {
        this._onModified(this);
      }
    }
    /**
     * Checks if the step is good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      return this.effect ? this.effect.IsGood() : false;
    }
    /**
     * Keeps the step alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      if (this.effect) {
        this.effect.KeepAlive();
      }
    }
    /**
     * Gets resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.effect) {
        this.effect.GetResources(out);
      }

      return out;
    }
    /**
     * Creates a post effect step from an object
     * @param {*} [opt={}]
     * @returns {Tw2PostEffectStep}
     */

  }], [{
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      Object(util["assignIfExists"])(item, opt, ['name', 'display', 'target', 'index']);

      if (opt.inputs) {
        Object.assign(item.inputs, opt.inputs);
      }

      item.effect = Tw2Effect["a" /* Tw2Effect */].create({
        name: opt.name,
        autoParameter: true,
        effectFilePath: opt.effectFilePath,
        parameters: opt.parameters,
        textures: opt.textures,
        overrides: opt.overrides
      });
      return item;
    }
  }]);

  return Tw2PostEffectStep;
}();
// CONCATENATED MODULE: ./core/post/Tw2PostEffect.js
function Tw2PostEffect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PostEffect_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2PostEffect_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2PostEffect_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2PostEffect_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2PostEffect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







/**
 * Tw2PostEffect
 *
 * @property {string|number} _id                      - A unique id
 * @property {string} name                            - the post effect's name
 * @property {boolean} display                        - toggles rendering
 * @property {number} [index=-1]                      - the post effect's render order (defaults to the order the effect is added)
 * @property {number} width                           - the post effect's width
 * @property {number} height                          - the post effect's height
 * @property {Tw2TextureRes} texture                  - the output texture
 * @property {?Tw2CurveSet} curveSet                  - optional curve set
 * @property {{string:Tw2RenderTarget}} targets       - render targets
 * @property {Array<Tw2PostEffectStep>} steps         - post effect steps
 * @property {Array<Tw2PostEffectStep>} _visibleItems - visible and ordered post effect steps
 * @property {boolean} _rebuildPending                - identifies if the post is pending a rebuild
 * @property {Function} _onChildModified              - a function called when a child step is modified
 * @property {?Function} _onModified                  - a function which is called when the post effect is modified
 */

let Tw2PostEffect_Tw2PostEffect =
/*#__PURE__*/
function () {
  function Tw2PostEffect() {
    Tw2PostEffect_classCallCheck(this, Tw2PostEffect);

    Tw2PostEffect_defineProperty(this, "_id", Object(util["generateID"])());

    Tw2PostEffect_defineProperty(this, "name", '');

    Tw2PostEffect_defineProperty(this, "display", true);

    Tw2PostEffect_defineProperty(this, "index", -1);

    Tw2PostEffect_defineProperty(this, "width", 0);

    Tw2PostEffect_defineProperty(this, "height", 0);

    Tw2PostEffect_defineProperty(this, "texture", null);

    Tw2PostEffect_defineProperty(this, "curveSet", null);

    Tw2PostEffect_defineProperty(this, "targets", {});

    Tw2PostEffect_defineProperty(this, "items", []);

    Tw2PostEffect_defineProperty(this, "_visibleItems", []);

    Tw2PostEffect_defineProperty(this, "_rebuildPending", true);

    Tw2PostEffect_defineProperty(this, "_onChildModified", item => this.OnValueChanged(item));
  }

  Tw2PostEffect_createClass(Tw2PostEffect, [{
    key: "OnValueChanged",

    /**
     * Fires on value changes
     */
    value: function OnValueChanged() {
      this._rebuildPending = true;
    }
    /**
     * Checks if the post effect is good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      let isGood = 0;

      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].IsGood()) {
          isGood++;
        }
      }

      return isGood === this.items.length;
    }
    /**
     * Keeps the post effect alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      this.items.forEach(item => item.KeepAlive());
    }
    /**
     * Gets resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.items.length; i++) {
        this.items[i].GetResources(out);
      }

      return out;
    }
    /**
     * Creates an item
     * @param {*} [opt={}]
     * @returns {Tw2PostEffectStep}
     */

  }, {
    key: "CreateItem",
    value: function CreateItem() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = Tw2PostEffectStep_Tw2PostEffectStep.create(opt);
      this.AddItem(item);
      return item;
    }
    /**
     * Adds an item
     * @param {Tw2PostEffectStep} item
     */

  }, {
    key: "AddItem",
    value: function AddItem(item) {
      if (!this.items.includes(item)) {
        item._onModified = this._onChildModified;

        if (item.index === -1) {
          item.index = this.items.length;
        }

        this.items.push(item);
        this.OnValueChanged();
      }
    }
    /**
     * Removes an item
     * @param {Tw2PostEffectStep} item
     */

  }, {
    key: "RemoveItem",
    value: function RemoveItem(item) {
      const index = this.items.indexOf(item);

      if (index !== -1) {
        item._onModified = null;
        this.items.splice(index, 1);
        this.OnValueChanged();
      }
    }
    /**
     * Clears all items
     */

  }, {
    key: "ClearItems",
    value: function ClearItems() {
      for (let i = 0; i < this.items.length; i++) {
        this.items[i]._onModified = null;
      }

      this.items = [];
      this.OnValueChanged();
    }
    /**
     * Gets a render target by it's name
     * @param {?string} name
     * @returns {?Tw2RenderTarget}
     */

  }, {
    key: "GetTarget",
    value: function GetTarget(name) {
      return name && name in this.targets ? this.targets[name] : null;
    }
    /**
     * Checks if a render target exists
     * @param {string} name
     * @returns {boolean}
     * @constructor
     */

  }, {
    key: "HasTarget",
    value: function HasTarget(name) {
      return !!(name && this.targets[name]);
    }
    /**
     * Creates a render target
     * - If the render target doesn't exist it will be created
     * @param {string} name
     * @param {number} [width=device.viewportWidth]
     * @param {number} [height=device.viewportHeight]
     * @returns {Tw2RenderTarget}
     */

  }, {
    key: "CreateTarget",
    value: function CreateTarget(name) {
      let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : global["w" /* device */].viewportWidth;
      let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : global["w" /* device */].viewportHeight;

      if (!this.targets[name]) {
        this.targets[name] = new Tw2RenderTarget_Tw2RenderTarget();
        this.targets[name].name = name;
      }

      this.targets[name].Create(width, height, false);
      return this.targets[name];
    }
    /**
     * Per frame update
     * @param {number} dt
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (this.curveSet) {
        this.curveSet.Update(dt);
      }
    }
    /**
     * Per frame update
     * @returns {boolean}
     */

  }, {
    key: "Render",
    value: function Render() {
      const d = global["w" /* device */],
            gl = d.gl,
            width = d.viewportWidth,
            height = d.viewportHeight;

      if (!this.IsGood() || !this.display || width <= 0 || height <= 0) {
        return false;
      }

      if (width !== this.width || height !== this.height || this._rebuildPending || !this.texture) {
        if (!this.texture) {
          this.texture = new Tw2TextureRes["a" /* Tw2TextureRes */]();
          this.texture.Attach(gl.createTexture());
        }

        gl.bindTexture(gl.TEXTURE_2D, this.texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
        this.width = width;
        this.height = height; // Update targets (Defined on the effect)

        for (const name in this.targets) {
          if (this.targets.hasOwnProperty(name)) {
            this.CreateTarget(name, width, height);
          }
        } // Rebuild items


        this._visibleItems = [];

        for (let i = 0; i < this.items.length; ++i) {
          const item = this.items[i],
                inputs = item.inputs,
                effect = item.effect,
                shader = effect.shader,
                parameters = effect.parameters; // Auto create current blit

          if (shader.HasTexture( true && !parameters.BlitCurrent)) {
            parameters['BlitCurrent'] = new Tw2TextureParameter["a" /* Tw2TextureParameter */]('BlitCurrent', 'rgba:/0,0,0,255');
          } // Auto create original blit


          if (shader.HasTexture( true && !parameters.BlitOriginal)) {
            parameters['BlitOriginal'] = new Tw2TextureParameter["a" /* Tw2TextureParameter */]('BlitOriginal', 'rgba:/0,0,0,255');
          } // Setup step render target


          if (item.target) {
            // Auto create target (Defined on the step)
            if (!this.HasTarget(item.target)) {
              this.CreateTarget(item.target, width, height);
            }

            item._renderTarget = this.GetTarget(item.target);
          } else {
            item._renderTarget = null;
          } // Assign render targets to textures


          for (let texture in inputs) {
            if (inputs.hasOwnProperty(texture)) {
              // Ensure input is supported
              if (!shader.HasTexture(texture)) {
                console.warn(`Invalid input parameter ${texture}`);
                delete inputs[texture];
              } else {
                // Ensure step texture exists
                if (!parameters[texture]) {
                  parameters[texture] = new Tw2TextureParameter["a" /* Tw2TextureParameter */](texture);
                }

                const parameter = parameters[texture],
                      target = inputs[texture];

                if (target) {
                  // Auto create target
                  if (!this.HasTarget(target)) {
                    this.CreateTarget(target, width, height);
                  }

                  parameter.SetTextureRes(this.GetTarget(target).texture);
                } else {
                  parameter.SetTextureRes(this.texture);
                }
              }
            }
          } // Update texel size if required


          if ('BlitCurrent' in inputs && shader.HasConstant('g_texelSize')) {
            // Auto create parameter if required
            if (!parameters['g_texelSize']) {
              parameters['g_texelSize'] = new Tw2Vector4Parameter_Tw2Vector4Parameter('g_texelSize', [1, 1, 1, 1]);
            }

            const size = parameters['g_texelSize'],
                  renderTarget = this.GetTarget(inputs.BlitCurrent);

            if (renderTarget) {
              size.value[0] = 1.0 / renderTarget.width;
              size.value[1] = 1.0 / renderTarget.width;
            } else {
              size.value[0] = 1.0 / width;
              size.value[1] = 1.0 / width;
            }

            size.OnValueChanged();
          }

          if (item.display) {
            this._visibleItems.push(item);
          }

          item._rebuildPending = false;
        } // Update item sort order


        this._visibleItems.sort((a, b) => {
          return a.index - b.index;
        });

        this.rebuildPending = false;
      }

      gl.bindTexture(gl.TEXTURE_2D, this.texture.texture);
      gl.copyTexImage2D(gl.TEXTURE_2D, 0, d.alphaBlendBackBuffer ? gl.RGBA : gl.RGB, 0, 0, width, height, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
      d.SetStandardStates(global["w" /* device */].RM_OPAQUE);
      let didPost = 0;

      for (let i = 0; i < this._visibleItems.length; ++i) {
        const item = this._visibleItems[i];

        if (item.display) {
          if (item._renderTarget) {
            item._renderTarget.Set();
          } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, width, height);
          }

          d.RenderFullScreenQuad(item.effect);
          didPost++;
        }
      }

      return !!didPost;
    }
    /**
     * Creates a post effect from an object
     * @param {*} [opt={}]
     * @returns {Tw2PostEffect}
     */

  }, {
    key: "steps",

    /**
     * Alias for items
     * @returns {Array}
     */
    get: function get() {
      return this.items;
    }
  }], [{
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const postEffect = new this();
      Object(util["assignIfExists"])(postEffect, opt, ['name', 'display', 'index']);

      if (opt.targets) {
        for (let i = 0; i < opt.targets.length; i++) {
          postEffect.targets[opt.targets[i]] = null;
        }
      }

      if (opt.steps) {
        for (let i = 0; i < opt.steps.length; i++) {
          postEffect.CreateItem(opt.steps[i]);
        }
      }

      return postEffect;
    }
    /**
     * Child constructor
     * @type {Tw2PostEffectStep}
     */

  }]);

  return Tw2PostEffect;
}();

Tw2PostEffect_defineProperty(Tw2PostEffect_Tw2PostEffect, "Item", Tw2PostEffectStep_Tw2PostEffectStep);
// CONCATENATED MODULE: ./core/post/Tw2PostEffectManager.js
function Tw2PostEffectManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PostEffectManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2PostEffectManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2PostEffectManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2PostEffectManager_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2PostEffectManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2PostEffectManager
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {Array<Tw2PostEffect>} effects
 */

let Tw2PostEffectManager_Tw2PostEffectManager =
/*#__PURE__*/
function () {
  function Tw2PostEffectManager() {
    Tw2PostEffectManager_classCallCheck(this, Tw2PostEffectManager);

    Tw2PostEffectManager_defineProperty(this, "_id", Object(util["generateID"])());

    Tw2PostEffectManager_defineProperty(this, "name", 'Post manager');

    Tw2PostEffectManager_defineProperty(this, "display", true);

    Tw2PostEffectManager_defineProperty(this, "items", []);
  }

  Tw2PostEffectManager_createClass(Tw2PostEffectManager, [{
    key: "CreateItem",

    /**
     * Creates an item from an object
     * @param {*} [opt={}]
     * @returns {Tw2PostEffect}
     */
    value: function CreateItem() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const postEffect = Tw2PostEffect_Tw2PostEffect.create(opt);
      this.AddItem(postEffect);
      return postEffect;
    }
    /**
     * Adds a post effect
     * @param {Tw2PostEffect} postEffect
     */

  }, {
    key: "AddItem",
    value: function AddItem(postEffect) {
      if (!this.items.includes(postEffect)) {
        if (postEffect.index === -1) {
          postEffect.index = this.items.length;
        }

        this.items.push(postEffect);
      }
    }
    /**
     * Removes a post effect
     * @param {Tw2PostEffect} postEffect
     */

  }, {
    key: "RemoveItem",
    value: function RemoveItem(postEffect) {
      const index = this.items.indexOf(postEffect);

      if (index !== -1) {
        this.items.splice(index, 1);
      }
    }
    /**
     * Clears all post effects
     */

  }, {
    key: "ClearItems",
    value: function ClearItems() {
      for (let i = 0; i < this.items.length; i++) {
        this.items[i].ClearItems();
      }

      this.items = [];
    }
    /**
     * Checks if all post effects are good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      let isGood = 0;

      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].IsGood()) {
          isGood++;
        }
      }

      return isGood === this.items.length;
    }
    /**
     * Keeps the post effects alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      for (let i = 0; i < this.items.length; i++) {
        this.items[i].KeepAlive();
      }
    }
    /**
     * Gets resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.items.length; i++) {
        this.items[i].GetResources(out);
      }

      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      for (let i = 0; i < this.items.length; i++) {
        this.items[i].Update(dt);
      }
    }
    /**
     * Per frame update
     * @returns {boolean} true if post was rendered
     */

  }, {
    key: "Render",
    value: function Render() {
      if (!this.display) {
        this.KeepAlive();
        return false;
      }

      let rendered = 0;

      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].Render()) {
          rendered++;
        }
      }

      return !!rendered;
    }
    /**
     * Child constructor
     * @type {Tw2PostEffect}
     */

  }, {
    key: "effects",

    /**
     * Alias for items
     * @returns {Array}
     */
    get: function get() {
      return this.items;
    }
  }]);

  return Tw2PostEffectManager;
}();

Tw2PostEffectManager_defineProperty(Tw2PostEffectManager_Tw2PostEffectManager, "Item", Tw2PostEffect_Tw2PostEffect);
// CONCATENATED MODULE: ./core/post/Tw2PostProcess.js
function Tw2PostProcess_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PostProcess_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2PostProcess - Not implemented yet
 *
 * @parameter {Array<Tw2Effect>} stages
 */
let Tw2PostProcess = function Tw2PostProcess() {
  Tw2PostProcess_classCallCheck(this, Tw2PostProcess);

  Tw2PostProcess_defineProperty(this, "stages", []);
};

Tw2PostProcess_defineProperty(Tw2PostProcess, "partialImplementation", true);
// CONCATENATED MODULE: ./core/post/index.js




// EXTERNAL MODULE: ./core/Tw2EventEmitter.js
var Tw2EventEmitter = __webpack_require__(10);

// CONCATENATED MODULE: ./core/Tw2Float.js
function Tw2Float_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Float_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2Float
 *
 * @property {number} value
 * @class
 */
let Tw2Float = function Tw2Float() {
  Tw2Float_classCallCheck(this, Tw2Float);

  Tw2Float_defineProperty(this, "value", 0);
};
// CONCATENATED MODULE: ./core/Tw2Frustum.js
function Tw2Frustum_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Frustum_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Frustum_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Frustum_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Frustum_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Frustum_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2Frustum
 *
 * @property {Array.<vec4>} planes
 * @property {vec3} viewPos
 * @property {vec3} viewDir
 * @property {number} halfWidthProjection
 * @class
 */

let Tw2Frustum_Tw2Frustum =
/*#__PURE__*/
function () {
  function Tw2Frustum() {
    Tw2Frustum_classCallCheck(this, Tw2Frustum);

    Tw2Frustum_defineProperty(this, "planes", [global["I" /* vec4 */].create(), global["I" /* vec4 */].create(), global["I" /* vec4 */].create(), global["I" /* vec4 */].create(), global["I" /* vec4 */].create(), global["I" /* vec4 */].create()]);

    Tw2Frustum_defineProperty(this, "viewPos", global["H" /* vec3 */].create());

    Tw2Frustum_defineProperty(this, "viewDir", global["H" /* vec3 */].create());

    Tw2Frustum_defineProperty(this, "halfWidthProjection", 1);
  }

  Tw2Frustum_createClass(Tw2Frustum, [{
    key: "Initialize",

    /**
     * Initializes the Tw2Frustum
     *
     * @param {mat4} view - View Matrix
     * @param {mat4} proj - Projection Matrix
     * @param {number} viewportSize
     * @param {mat4} [viewInverse] Optional viewInverse matrix
     * @param {mat4} [viewProjection] Optional viewProjection matrix
     */
    value: function Initialize(view, proj, viewportSize, viewInverse, viewProjection) {
      const mat4_0 = Tw2Frustum.global.mat4_0;
      const viewInv = viewInverse ? viewInverse : global["z" /* mat4 */].invert(mat4_0, view);
      this.viewPos.set(viewInv.subarray(12, 14));
      this.viewDir.set(viewInv.subarray(8, 10));
      this.halfWidthProjection = proj[0] * viewportSize * 0.5;
      const viewProj = viewProjection ? viewProjection : global["z" /* mat4 */].multiply(mat4_0, proj, view);
      this.planes[0][0] = viewProj[2];
      this.planes[0][1] = viewProj[6];
      this.planes[0][2] = viewProj[10];
      this.planes[0][3] = viewProj[14];
      this.planes[1][0] = viewProj[3] + viewProj[0];
      this.planes[1][1] = viewProj[7] + viewProj[4];
      this.planes[1][2] = viewProj[11] + viewProj[8];
      this.planes[1][3] = viewProj[15] + viewProj[12];
      this.planes[2][0] = viewProj[3] - viewProj[1];
      this.planes[2][1] = viewProj[7] - viewProj[5];
      this.planes[2][2] = viewProj[11] - viewProj[9];
      this.planes[2][3] = viewProj[15] - viewProj[13];
      this.planes[3][0] = viewProj[3] - viewProj[0];
      this.planes[3][1] = viewProj[7] - viewProj[4];
      this.planes[3][2] = viewProj[11] - viewProj[8];
      this.planes[3][3] = viewProj[15] - viewProj[12];
      this.planes[4][0] = viewProj[3] + viewProj[1];
      this.planes[4][1] = viewProj[7] + viewProj[5];
      this.planes[4][2] = viewProj[11] + viewProj[9];
      this.planes[4][3] = viewProj[15] + viewProj[13];
      this.planes[5][0] = viewProj[3] - viewProj[2];
      this.planes[5][1] = viewProj[7] - viewProj[6];
      this.planes[5][2] = viewProj[11] - viewProj[10];
      this.planes[5][3] = viewProj[15] - viewProj[14];

      for (let i = 0; i < 6; ++i) {
        let len = global["H" /* vec3 */].length(this.planes[i]);
        this.planes[i][0] /= len;
        this.planes[i][1] /= len;
        this.planes[i][2] /= len;
        this.planes[i][3] /= len;
      }
    }
    /**
     * Checks to see if a sphere is visible within the frustum
     *
     * @param {vec3} center
     * @param {number} radius
     * @returns {boolean}
     */

  }, {
    key: "IsSphereVisible",
    value: function IsSphereVisible(center, radius) {
      for (let i = 0; i < 6; ++i) {
        if (this.planes[i][0] * center[0] + this.planes[i][1] * center[1] + this.planes[i][2] * center[2] + this.planes[i][3] < -radius) {
          return false;
        }
      }

      return true;
    }
    /**
     * GetPixelSizeAcross
     *
     * @param {vec3} center
     * @param {number} radius
     * @returns {number}
     */

  }, {
    key: "GetPixelSizeAcross",
    value: function GetPixelSizeAcross(center, radius) {
      const d = global["H" /* vec3 */].subtract(Tw2Frustum.global.vec3_0, this.viewPos, center);
      let depth = global["H" /* vec3 */].dot(this.viewDir, d),
          epsilon = 1e-5;
      if (depth < epsilon) depth = epsilon;
      if (radius < epsilon) return 0;
      let ratio = radius / depth;
      return ratio * this.halfWidthProjection * 2;
    }
    /**
     * Global and scratch variables
     */

  }]);

  return Tw2Frustum;
}();

Tw2Frustum_defineProperty(Tw2Frustum_Tw2Frustum, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  mat4_0: global["z" /* mat4 */].create()
});
// CONCATENATED MODULE: ./core/index.js
/* concated harmony reexport Tw2BatchAccumulator */__webpack_require__.d(__webpack_exports__, "Tw2BatchAccumulator", function() { return Tw2BatchAccumulator_Tw2BatchAccumulator; });
/* concated harmony reexport Tw2ForwardingRenderBatch */__webpack_require__.d(__webpack_exports__, "Tw2ForwardingRenderBatch", function() { return Tw2ForwardingRenderBatch; });
/* concated harmony reexport Tw2GeometryBatch */__webpack_require__.d(__webpack_exports__, "Tw2GeometryBatch", function() { return Tw2GeometryBatch; });
/* concated harmony reexport Tw2GeometryLineBatch */__webpack_require__.d(__webpack_exports__, "Tw2GeometryLineBatch", function() { return Tw2GeometryLineBatch; });
/* concated harmony reexport Tw2RenderBatch */__webpack_require__.d(__webpack_exports__, "Tw2RenderBatch", function() { return Tw2RenderBatch_Tw2RenderBatch; });
/* concated harmony reexport Tw2InstancedMeshBatch */__webpack_require__.d(__webpack_exports__, "Tw2InstancedMeshBatch", function() { return Tw2InstancedMeshBatch; });
/* concated harmony reexport Tw2CurveSet */__webpack_require__.d(__webpack_exports__, "Tw2CurveSet", function() { return Tw2CurveSet_Tw2CurveSet; });
/* concated harmony reexport Tw2ValueBinding */__webpack_require__.d(__webpack_exports__, "Tw2ValueBinding", function() { return Tw2ValueBinding_Tw2ValueBinding; });
/* concated harmony reexport Tw2BasicPerObjectData */__webpack_require__.d(__webpack_exports__, "Tw2BasicPerObjectData", function() { return Tw2BasicPerObjectData_Tw2BasicPerObjectData; });
/* concated harmony reexport EveBasicPerObjectData */__webpack_require__.d(__webpack_exports__, "EveBasicPerObjectData", function() { return Tw2BasicPerObjectData_Tw2BasicPerObjectData; });
/* concated harmony reexport Tw2PerObjectData */__webpack_require__.d(__webpack_exports__, "Tw2PerObjectData", function() { return Tw2PerObjectData_Tw2PerObjectData; });
/* concated harmony reexport Tw2RawData */__webpack_require__.d(__webpack_exports__, "Tw2RawData", function() { return Tw2RawData_Tw2RawData; });
/* concated harmony reexport Tw2BlendShapeData */__webpack_require__.d(__webpack_exports__, "Tw2BlendShapeData", function() { return Tw2BlendShapeData_Tw2BlendShapeData; });
/* concated harmony reexport Tw2GeometryAnimation */__webpack_require__.d(__webpack_exports__, "Tw2GeometryAnimation", function() { return Tw2GeometryAnimation; });
/* concated harmony reexport Tw2GeometryBone */__webpack_require__.d(__webpack_exports__, "Tw2GeometryBone", function() { return Tw2GeometryBone_Tw2GeometryBone; });
/* concated harmony reexport Tw2GeometryCurve */__webpack_require__.d(__webpack_exports__, "Tw2GeometryCurve", function() { return Tw2GeometryCurve; });
/* concated harmony reexport Tw2GeometryMesh */__webpack_require__.d(__webpack_exports__, "Tw2GeometryMesh", function() { return Tw2GeometryMesh_Tw2GeometryMesh; });
/* concated harmony reexport Tw2GeometryMeshArea */__webpack_require__.d(__webpack_exports__, "Tw2GeometryMeshArea", function() { return Tw2GeometryMeshArea_Tw2GeometryMeshArea; });
/* concated harmony reexport Tw2GeometryMeshBinding */__webpack_require__.d(__webpack_exports__, "Tw2GeometryMeshBinding", function() { return Tw2GeometryMeshBinding; });
/* concated harmony reexport Tw2GeometryModel */__webpack_require__.d(__webpack_exports__, "Tw2GeometryModel", function() { return Tw2GeometryModel; });
/* concated harmony reexport Tw2GeometrySkeleton */__webpack_require__.d(__webpack_exports__, "Tw2GeometrySkeleton", function() { return Tw2GeometrySkeleton; });
/* concated harmony reexport Tw2GeometryTrackGroup */__webpack_require__.d(__webpack_exports__, "Tw2GeometryTrackGroup", function() { return Tw2GeometryTrackGroup; });
/* concated harmony reexport Tw2GeometryTransformTrack */__webpack_require__.d(__webpack_exports__, "Tw2GeometryTransformTrack", function() { return Tw2GeometryTransformTrack; });
/* concated harmony reexport Tw2Effect */__webpack_require__.d(__webpack_exports__, "Tw2Effect", function() { return Tw2Effect["a" /* Tw2Effect */]; });
/* concated harmony reexport Tw2InstancedMesh */__webpack_require__.d(__webpack_exports__, "Tw2InstancedMesh", function() { return Tw2InstancedMesh_Tw2InstancedMesh; });
/* concated harmony reexport Tw2Mesh */__webpack_require__.d(__webpack_exports__, "Tw2Mesh", function() { return Tw2Mesh_Tw2Mesh; });
/* concated harmony reexport Tw2MeshArea */__webpack_require__.d(__webpack_exports__, "Tw2MeshArea", function() { return Tw2MeshArea_Tw2MeshArea; });
/* concated harmony reexport Tw2MeshLineArea */__webpack_require__.d(__webpack_exports__, "Tw2MeshLineArea", function() { return Tw2MeshLineArea; });
/* concated harmony reexport Tw2Animation */__webpack_require__.d(__webpack_exports__, "Tw2Animation", function() { return Tw2Animation; });
/* concated harmony reexport Tw2AnimationController */__webpack_require__.d(__webpack_exports__, "Tw2AnimationController", function() { return Tw2AnimationController_Tw2AnimationController; });
/* concated harmony reexport Tw2Bone */__webpack_require__.d(__webpack_exports__, "Tw2Bone", function() { return Tw2Bone_Tw2Bone; });
/* concated harmony reexport Tw2Model */__webpack_require__.d(__webpack_exports__, "Tw2Model", function() { return Tw2Model; });
/* concated harmony reexport Tw2Track */__webpack_require__.d(__webpack_exports__, "Tw2Track", function() { return Tw2Track; });
/* concated harmony reexport Tw2TrackGroup */__webpack_require__.d(__webpack_exports__, "Tw2TrackGroup", function() { return Tw2TrackGroup; });
/* concated harmony reexport Tw2Parameter */__webpack_require__.d(__webpack_exports__, "Tw2Parameter", function() { return Tw2Parameter["a" /* Tw2Parameter */]; });
/* concated harmony reexport Tw2VectorParameter */__webpack_require__.d(__webpack_exports__, "Tw2VectorParameter", function() { return Tw2Parameter["b" /* Tw2VectorParameter */]; });
/* concated harmony reexport Tw2FloatParameter */__webpack_require__.d(__webpack_exports__, "Tw2FloatParameter", function() { return Tw2FloatParameter_Tw2FloatParameter; });
/* concated harmony reexport Tw2MatrixParameter */__webpack_require__.d(__webpack_exports__, "Tw2MatrixParameter", function() { return Tw2MatrixParameter_Tw2MatrixParameter; });
/* concated harmony reexport Tw2TransformParameter */__webpack_require__.d(__webpack_exports__, "Tw2TransformParameter", function() { return Tw2TransformParameter_Tw2TransformParameter; });
/* concated harmony reexport Tw2VariableParameter */__webpack_require__.d(__webpack_exports__, "Tw2VariableParameter", function() { return Tw2VariableParameter_Tw2VariableParameter; });
/* concated harmony reexport Tw2Vector2Parameter */__webpack_require__.d(__webpack_exports__, "Tw2Vector2Parameter", function() { return Tw2Vector2Parameter_Tw2Vector2Parameter; });
/* concated harmony reexport Tw2Vector3Parameter */__webpack_require__.d(__webpack_exports__, "Tw2Vector3Parameter", function() { return Tw2Vector3Parameter_Tw2Vector3Parameter; });
/* concated harmony reexport Tw2Vector4Parameter */__webpack_require__.d(__webpack_exports__, "Tw2Vector4Parameter", function() { return Tw2Vector4Parameter_Tw2Vector4Parameter; });
/* concated harmony reexport Tw2TextureParameter */__webpack_require__.d(__webpack_exports__, "Tw2TextureParameter", function() { return Tw2TextureParameter["a" /* Tw2TextureParameter */]; });
/* concated harmony reexport Tw2PostEffect */__webpack_require__.d(__webpack_exports__, "Tw2PostEffect", function() { return Tw2PostEffect_Tw2PostEffect; });
/* concated harmony reexport Tw2PostEffectManager */__webpack_require__.d(__webpack_exports__, "Tw2PostEffectManager", function() { return Tw2PostEffectManager_Tw2PostEffectManager; });
/* concated harmony reexport Tw2PostEffectStep */__webpack_require__.d(__webpack_exports__, "Tw2PostEffectStep", function() { return Tw2PostEffectStep_Tw2PostEffectStep; });
/* concated harmony reexport Tw2PostProcess */__webpack_require__.d(__webpack_exports__, "Tw2PostProcess", function() { return Tw2PostProcess; });
/* concated harmony reexport Tw2BinaryReader */__webpack_require__.d(__webpack_exports__, "Tw2BinaryReader", function() { return Tw2BinaryReader["a" /* Tw2BinaryReader */]; });
/* concated harmony reexport Tw2ObjectReader */__webpack_require__.d(__webpack_exports__, "Tw2ObjectReader", function() { return Tw2ObjectReader["a" /* Tw2ObjectReader */]; });
/* concated harmony reexport Tw2EffectRes */__webpack_require__.d(__webpack_exports__, "Tw2EffectRes", function() { return Tw2EffectRes_Tw2EffectRes; });
/* concated harmony reexport Tw2GeometryRes */__webpack_require__.d(__webpack_exports__, "Tw2GeometryRes", function() { return Tw2GeometryRes_Tw2GeometryRes; });
/* concated harmony reexport Tw2LoadingObject */__webpack_require__.d(__webpack_exports__, "Tw2LoadingObject", function() { return Tw2LoadingObject["a" /* Tw2LoadingObject */]; });
/* concated harmony reexport Tw2Resource */__webpack_require__.d(__webpack_exports__, "Tw2Resource", function() { return Tw2Resource["a" /* Tw2Resource */]; });
/* concated harmony reexport Tw2TextureRes */__webpack_require__.d(__webpack_exports__, "Tw2TextureRes", function() { return Tw2TextureRes["a" /* Tw2TextureRes */]; });
/* concated harmony reexport Tw2VideoRes */__webpack_require__.d(__webpack_exports__, "Tw2VideoRes", function() { return Tw2VideoRes_Tw2VideoRes; });
/* concated harmony reexport Tw2SamplerState */__webpack_require__.d(__webpack_exports__, "Tw2SamplerState", function() { return core_sampler["b" /* Tw2SamplerState */]; });
/* concated harmony reexport Tw2SamplerOverride */__webpack_require__.d(__webpack_exports__, "Tw2SamplerOverride", function() { return core_sampler["a" /* Tw2SamplerOverride */]; });
/* concated harmony reexport Tw2VertexDeclaration */__webpack_require__.d(__webpack_exports__, "Tw2VertexDeclaration", function() { return vertex["a" /* Tw2VertexDeclaration */]; });
/* concated harmony reexport Tw2VertexElement */__webpack_require__.d(__webpack_exports__, "Tw2VertexElement", function() { return vertex["b" /* Tw2VertexElement */]; });
/* concated harmony reexport Tw2Error */__webpack_require__.d(__webpack_exports__, "Tw2Error", function() { return Tw2Error["B" /* Tw2Error */]; });
/* concated harmony reexport ErrHTTPRequest */__webpack_require__.d(__webpack_exports__, "ErrHTTPRequest", function() { return Tw2Error["k" /* ErrHTTPRequest */]; });
/* concated harmony reexport ErrHTTPRequestSend */__webpack_require__.d(__webpack_exports__, "ErrHTTPRequestSend", function() { return Tw2Error["l" /* ErrHTTPRequestSend */]; });
/* concated harmony reexport ErrHTTPInstance */__webpack_require__.d(__webpack_exports__, "ErrHTTPInstance", function() { return Tw2Error["i" /* ErrHTTPInstance */]; });
/* concated harmony reexport ErrHTTPStatus */__webpack_require__.d(__webpack_exports__, "ErrHTTPStatus", function() { return Tw2Error["m" /* ErrHTTPStatus */]; });
/* concated harmony reexport ErrHTTPReadyState */__webpack_require__.d(__webpack_exports__, "ErrHTTPReadyState", function() { return Tw2Error["j" /* ErrHTTPReadyState */]; });
/* concated harmony reexport ErrXMLBinaryFormat */__webpack_require__.d(__webpack_exports__, "ErrXMLBinaryFormat", function() { return Tw2Error["z" /* ErrXMLBinaryFormat */]; });
/* concated harmony reexport ErrXMLObjectTypeUndefined */__webpack_require__.d(__webpack_exports__, "ErrXMLObjectTypeUndefined", function() { return Tw2Error["A" /* ErrXMLObjectTypeUndefined */]; });
/* concated harmony reexport ErrGeometryMeshMissingParticleElement */__webpack_require__.d(__webpack_exports__, "ErrGeometryMeshMissingParticleElement", function() { return Tw2Error["h" /* ErrGeometryMeshMissingParticleElement */]; });
/* concated harmony reexport ErrGeometryMeshElementComponentsMissing */__webpack_require__.d(__webpack_exports__, "ErrGeometryMeshElementComponentsMissing", function() { return Tw2Error["g" /* ErrGeometryMeshElementComponentsMissing */]; });
/* concated harmony reexport ErrGeometryMeshBoneNameInvalid */__webpack_require__.d(__webpack_exports__, "ErrGeometryMeshBoneNameInvalid", function() { return Tw2Error["e" /* ErrGeometryMeshBoneNameInvalid */]; });
/* concated harmony reexport ErrGeometryMeshEffectBinding */__webpack_require__.d(__webpack_exports__, "ErrGeometryMeshEffectBinding", function() { return Tw2Error["f" /* ErrGeometryMeshEffectBinding */]; });
/* concated harmony reexport ErrGeometryFileType */__webpack_require__.d(__webpack_exports__, "ErrGeometryFileType", function() { return Tw2Error["d" /* ErrGeometryFileType */]; });
/* concated harmony reexport ErrResourcePrefixUnregistered */__webpack_require__.d(__webpack_exports__, "ErrResourcePrefixUnregistered", function() { return Tw2Error["s" /* ErrResourcePrefixUnregistered */]; });
/* concated harmony reexport ErrResourcePrefixUndefined */__webpack_require__.d(__webpack_exports__, "ErrResourcePrefixUndefined", function() { return Tw2Error["r" /* ErrResourcePrefixUndefined */]; });
/* concated harmony reexport ErrResourceExtensionUnregistered */__webpack_require__.d(__webpack_exports__, "ErrResourceExtensionUnregistered", function() { return Tw2Error["p" /* ErrResourceExtensionUnregistered */]; });
/* concated harmony reexport ErrResourceExtensionUndefined */__webpack_require__.d(__webpack_exports__, "ErrResourceExtensionUndefined", function() { return Tw2Error["o" /* ErrResourceExtensionUndefined */]; });
/* concated harmony reexport ErrResourceFormat */__webpack_require__.d(__webpack_exports__, "ErrResourceFormat", function() { return Tw2Error["q" /* ErrResourceFormat */]; });
/* concated harmony reexport ErrShaderVersion */__webpack_require__.d(__webpack_exports__, "ErrShaderVersion", function() { return Tw2Error["x" /* ErrShaderVersion */]; });
/* concated harmony reexport ErrShaderHeaderSize */__webpack_require__.d(__webpack_exports__, "ErrShaderHeaderSize", function() { return Tw2Error["u" /* ErrShaderHeaderSize */]; });
/* concated harmony reexport ErrShaderPermutationValue */__webpack_require__.d(__webpack_exports__, "ErrShaderPermutationValue", function() { return Tw2Error["w" /* ErrShaderPermutationValue */]; });
/* concated harmony reexport ErrShaderCompile */__webpack_require__.d(__webpack_exports__, "ErrShaderCompile", function() { return Tw2Error["t" /* ErrShaderCompile */]; });
/* concated harmony reexport ErrShaderLink */__webpack_require__.d(__webpack_exports__, "ErrShaderLink", function() { return Tw2Error["v" /* ErrShaderLink */]; });
/* concated harmony reexport ErrDeclarationValueType */__webpack_require__.d(__webpack_exports__, "ErrDeclarationValueType", function() { return Tw2Error["b" /* ErrDeclarationValueType */]; });
/* concated harmony reexport ErrSingletonInstantiation */__webpack_require__.d(__webpack_exports__, "ErrSingletonInstantiation", function() { return Tw2Error["y" /* ErrSingletonInstantiation */]; });
/* concated harmony reexport ErrAbstractClassMethod */__webpack_require__.d(__webpack_exports__, "ErrAbstractClassMethod", function() { return Tw2Error["a" /* ErrAbstractClassMethod */]; });
/* concated harmony reexport ErrFeatureNotImplemented */__webpack_require__.d(__webpack_exports__, "ErrFeatureNotImplemented", function() { return Tw2Error["c" /* ErrFeatureNotImplemented */]; });
/* concated harmony reexport ErrIndexBounds */__webpack_require__.d(__webpack_exports__, "ErrIndexBounds", function() { return Tw2Error["n" /* ErrIndexBounds */]; });
/* concated harmony reexport Tw2EventEmitter */__webpack_require__.d(__webpack_exports__, "Tw2EventEmitter", function() { return Tw2EventEmitter["a" /* Tw2EventEmitter */]; });
/* concated harmony reexport Tw2Float */__webpack_require__.d(__webpack_exports__, "Tw2Float", function() { return Tw2Float; });
/* concated harmony reexport Tw2Frustum */__webpack_require__.d(__webpack_exports__, "Tw2Frustum", function() { return Tw2Frustum_Tw2Frustum; });
/* concated harmony reexport Tw2RenderTarget */__webpack_require__.d(__webpack_exports__, "Tw2RenderTarget", function() { return Tw2RenderTarget_Tw2RenderTarget; });


















/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return Tw2Error; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ErrHTTPRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return ErrHTTPRequestSend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ErrHTTPInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return ErrHTTPStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return ErrHTTPReadyState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return ErrXMLBinaryFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return ErrXMLObjectTypeUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ErrGeometryMeshMissingParticleElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ErrGeometryMeshElementComponentsMissing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ErrGeometryMeshBoneNameInvalid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ErrGeometryMeshEffectBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ErrGeometryFileType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return ErrResourcePrefixUnregistered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return ErrResourcePrefixUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return ErrResourceExtensionUnregistered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ErrResourceExtensionUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return ErrResourceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return ErrShaderVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return ErrShaderHeaderSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return ErrShaderPermutationValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return ErrShaderCompile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return ErrShaderLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ErrDeclarationValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return ErrSingletonInstantiation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrAbstractClassMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ErrFeatureNotImplemented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return ErrIndexBounds; });
/* harmony import */ var _global_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const HAS_CAPTURE_STACK_TRACE = Object(_global_util__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(Error['captureStackTrace']);
/**
 * Tw2Error
 *
 * @property {string} name    - The error's name
 * @property {string} message - The error's message
 * @property {Object} data    - Optional error data
 * @class
 */

let Tw2Error =
/*#__PURE__*/
function (_Error) {
  _inherits(Tw2Error, _Error);

  /**
   * Constructor
   * @param {string|Object} [data={}]                   - Error message or an object containing relevant data
   * @param {string} [defaultMessage='Undefined Error'] - The default error message
   */
  function Tw2Error() {
    var _this;

    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let defaultMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Undefined error';

    _classCallCheck(this, Tw2Error);

    let message = defaultMessage;

    if (typeof data === 'string') {
      message = data;
      data = {};
    } else if (data.message) {
      message = data.message;
      delete data.message;
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2Error).call(this));
    _this.message = Object(_global_util__WEBPACK_IMPORTED_MODULE_0__["template"])(message, data);
    _this.name = _this.constructor.name;
    _this.data = data;

    if (HAS_CAPTURE_STACK_TRACE) {
      Error['captureStackTrace'](_assertThisInitialized(_assertThisInitialized(_this)), Tw2Error);
    } else {
      _this.stack = new Error(_this.message).stack;
    }

    return _this;
  }
  /**
   * Emits an event on a target emitter
   * @param {*} emitter
   * @param {String} [eventName='error']
   * @param {*} [e={}]
   * @returns {Tw2Error}
   */


  _createClass(Tw2Error, [{
    key: "emitOn",
    value: function emitOn(emitter) {
      let eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'error';
      let e = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (emitter && emitter.emit) {
        emitter.emit(eventName, Object.assign({
          err: this,
          log: {
            type: 'error',
            message: this.message,
            err: this
          }
        }, this.data, e));
      }

      return this;
    }
    /**
     * Class category
     * @type {string}
     */

  }]);

  return Tw2Error;
}(_wrapNativeSuper(Error));
/**
 * Throws on http request errors
 */

_defineProperty(Tw2Error, "category", 'error');

let ErrHTTPRequest =
/*#__PURE__*/
function (_Tw2Error) {
  _inherits(ErrHTTPRequest, _Tw2Error);

  function ErrHTTPRequest(data) {
    _classCallCheck(this, ErrHTTPRequest);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrHTTPRequest).call(this, data, 'Communication error while requesting resource'));
  }

  return ErrHTTPRequest;
}(Tw2Error);
/**
 * Throws on http request send errors
 */

let ErrHTTPRequestSend =
/*#__PURE__*/
function (_Tw2Error2) {
  _inherits(ErrHTTPRequestSend, _Tw2Error2);

  function ErrHTTPRequestSend(data) {
    _classCallCheck(this, ErrHTTPRequestSend);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrHTTPRequestSend).call(this, data, 'Communication send error while requesting resource'));
  }

  return ErrHTTPRequestSend;
}(Tw2Error);
/**
 * Throws when an xml http instance cannot be created
 */

let ErrHTTPInstance =
/*#__PURE__*/
function (_Tw2Error3) {
  _inherits(ErrHTTPInstance, _Tw2Error3);

  function ErrHTTPInstance(data) {
    _classCallCheck(this, ErrHTTPInstance);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrHTTPInstance).call(this, data, 'Could not create an XML HTTP instance'));
  }

  return ErrHTTPInstance;
}(Tw2Error);
/**
 * Throws on http status errors
 */

let ErrHTTPStatus =
/*#__PURE__*/
function (_Tw2Error4) {
  _inherits(ErrHTTPStatus, _Tw2Error4);

  function ErrHTTPStatus(data) {
    _classCallCheck(this, ErrHTTPStatus);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrHTTPStatus).call(this, data, 'Communication status error while loading resource (%status%)'));
  }

  return ErrHTTPStatus;
}(Tw2Error);
/**
 * Throws on http ready state errors
 */

let ErrHTTPReadyState =
/*#__PURE__*/
function (_Tw2Error5) {
  _inherits(ErrHTTPReadyState, _Tw2Error5);

  function ErrHTTPReadyState(data) {
    _classCallCheck(this, ErrHTTPReadyState);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrHTTPReadyState).call(this, data, 'Communication ready state error while loading resource'));
  }

  return ErrHTTPReadyState;
}(Tw2Error);
/**
 * Throws when xml is not a valid format
 */

let ErrXMLBinaryFormat =
/*#__PURE__*/
function (_Tw2Error6) {
  _inherits(ErrXMLBinaryFormat, _Tw2Error6);

  function ErrXMLBinaryFormat(data) {
    _classCallCheck(this, ErrXMLBinaryFormat);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrXMLBinaryFormat).call(this, data, 'Invalid binary format'));
  }

  return ErrXMLBinaryFormat;
}(Tw2Error);
/**
 * Throws when an xml object type is undefined
 */

let ErrXMLObjectTypeUndefined =
/*#__PURE__*/
function (_Tw2Error7) {
  _inherits(ErrXMLObjectTypeUndefined, _Tw2Error7);

  function ErrXMLObjectTypeUndefined(data) {
    _classCallCheck(this, ErrXMLObjectTypeUndefined);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrXMLObjectTypeUndefined).call(this, data, 'XML Object type "%type%" undefined type'));
  }

  return ErrXMLObjectTypeUndefined;
}(Tw2Error);
/**
 * Throws when a geometry mesh lacks an element required for a particle system
 */

let ErrGeometryMeshMissingParticleElement =
/*#__PURE__*/
function (_Tw2Error8) {
  _inherits(ErrGeometryMeshMissingParticleElement, _Tw2Error8);

  function ErrGeometryMeshMissingParticleElement(data) {
    _classCallCheck(this, ErrGeometryMeshMissingParticleElement);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrGeometryMeshMissingParticleElement).call(this, data, 'Input geometry mesh lacks element required by particle system'));
  }

  return ErrGeometryMeshMissingParticleElement;
}(Tw2Error);
/**
 * Throws when a geometry mesh element doesn't have the required number of components
 */

let ErrGeometryMeshElementComponentsMissing =
/*#__PURE__*/
function (_Tw2Error9) {
  _inherits(ErrGeometryMeshElementComponentsMissing, _Tw2Error9);

  function ErrGeometryMeshElementComponentsMissing(data) {
    _classCallCheck(this, ErrGeometryMeshElementComponentsMissing);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrGeometryMeshElementComponentsMissing).call(this, data, 'Input geometry mesh elements do not have the required number of components'));
  }

  return ErrGeometryMeshElementComponentsMissing;
}(Tw2Error);
/**
 * Throws when a geometry mesh has an invalid bone name for a model
 */

let ErrGeometryMeshBoneNameInvalid =
/*#__PURE__*/
function (_Tw2Error10) {
  _inherits(ErrGeometryMeshBoneNameInvalid, _Tw2Error10);

  function ErrGeometryMeshBoneNameInvalid(data) {
    _classCallCheck(this, ErrGeometryMeshBoneNameInvalid);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrGeometryMeshBoneNameInvalid).call(this, data, 'Geometry mesh has invalid bone name for model'));
  }

  return ErrGeometryMeshBoneNameInvalid;
}(Tw2Error);
/**
 * Throws when there is an error binding a geometry mesh to an effect
 */

let ErrGeometryMeshEffectBinding =
/*#__PURE__*/
function (_Tw2Error11) {
  _inherits(ErrGeometryMeshEffectBinding, _Tw2Error11);

  function ErrGeometryMeshEffectBinding(data) {
    _classCallCheck(this, ErrGeometryMeshEffectBinding);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrGeometryMeshEffectBinding).call(this, data, 'Error binding geometry mesh to effect'));
  }

  return ErrGeometryMeshEffectBinding;
}(Tw2Error);
/**
 * Throws when a geometry mesh has an invalid file type
 */

let ErrGeometryFileType =
/*#__PURE__*/
function (_Tw2Error12) {
  _inherits(ErrGeometryFileType, _Tw2Error12);

  function ErrGeometryFileType(data) {
    _classCallCheck(this, ErrGeometryFileType);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrGeometryFileType).call(this, data, 'Invalid geometry file type (%fileType%)'));
  }

  return ErrGeometryFileType;
}(Tw2Error);
/**
 * Throws when a resource path has an unregistered prefix
 */

let ErrResourcePrefixUnregistered =
/*#__PURE__*/
function (_Tw2Error13) {
  _inherits(ErrResourcePrefixUnregistered, _Tw2Error13);

  function ErrResourcePrefixUnregistered(data) {
    _classCallCheck(this, ErrResourcePrefixUnregistered);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrResourcePrefixUnregistered).call(this, data, 'Unregistered resource prefix (%prefix%)'));
  }

  return ErrResourcePrefixUnregistered;
}(Tw2Error);
/**
 * Throws when a resource path has no prefix
 */

let ErrResourcePrefixUndefined =
/*#__PURE__*/
function (_Tw2Error14) {
  _inherits(ErrResourcePrefixUndefined, _Tw2Error14);

  function ErrResourcePrefixUndefined(data) {
    _classCallCheck(this, ErrResourcePrefixUndefined);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrResourcePrefixUndefined).call(this, data, 'Undefined resource prefix'));
  }

  return ErrResourcePrefixUndefined;
}(Tw2Error);
/**
 * Throws when a resource path has an unregistered file extension
 */

let ErrResourceExtensionUnregistered =
/*#__PURE__*/
function (_Tw2Error15) {
  _inherits(ErrResourceExtensionUnregistered, _Tw2Error15);

  function ErrResourceExtensionUnregistered(data) {
    _classCallCheck(this, ErrResourceExtensionUnregistered);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrResourceExtensionUnregistered).call(this, data, 'Unregistered resource extension (%extension%)'));
  }

  return ErrResourceExtensionUnregistered;
}(Tw2Error);
/**
 * Throws when a resource path has no file extension
 */

let ErrResourceExtensionUndefined =
/*#__PURE__*/
function (_Tw2Error16) {
  _inherits(ErrResourceExtensionUndefined, _Tw2Error16);

  function ErrResourceExtensionUndefined(data) {
    _classCallCheck(this, ErrResourceExtensionUndefined);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrResourceExtensionUndefined).call(this, data, 'Undefined resource extension'));
  }

  return ErrResourceExtensionUndefined;
}(Tw2Error);
/**
 * Throws in invalid resource formats
 */

let ErrResourceFormat =
/*#__PURE__*/
function (_Tw2Error17) {
  _inherits(ErrResourceFormat, _Tw2Error17);

  function ErrResourceFormat(data) {
    _classCallCheck(this, ErrResourceFormat);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrResourceFormat).call(this, data, 'Invalid resource format'));
  }

  return ErrResourceFormat;
}(Tw2Error);
/**
 * Throws when an effect has an invalid shader version
 */

let ErrShaderVersion =
/*#__PURE__*/
function (_Tw2Error18) {
  _inherits(ErrShaderVersion, _Tw2Error18);

  function ErrShaderVersion(data) {
    _classCallCheck(this, ErrShaderVersion);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrShaderVersion).call(this, data, 'Invalid version of effect file (%version%)'));
  }

  return ErrShaderVersion;
}(Tw2Error);
/**
 * Throws when an effect has no header
 */

let ErrShaderHeaderSize =
/*#__PURE__*/
function (_Tw2Error19) {
  _inherits(ErrShaderHeaderSize, _Tw2Error19);

  function ErrShaderHeaderSize(data) {
    _classCallCheck(this, ErrShaderHeaderSize);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrShaderHeaderSize).call(this, data, 'Effect file contains no compiled effects'));
  }

  return ErrShaderHeaderSize;
}(Tw2Error);
/**
 * Throws when a shader has an invalid permutation value
 */

let ErrShaderPermutationValue =
/*#__PURE__*/
function (_Tw2Error20) {
  _inherits(ErrShaderPermutationValue, _Tw2Error20);

  function ErrShaderPermutationValue(data) {
    _classCallCheck(this, ErrShaderPermutationValue);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrShaderPermutationValue).call(this, data, 'Invalid shader permutation value'));
  }

  return ErrShaderPermutationValue;
}(Tw2Error);
/**
 * Throws when a shader cannot compile
 */

let ErrShaderCompile =
/*#__PURE__*/
function (_Tw2Error21) {
  _inherits(ErrShaderCompile, _Tw2Error21);

  function ErrShaderCompile(data) {
    _classCallCheck(this, ErrShaderCompile);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrShaderCompile).call(this, data, 'Error compiling %shaderType% shader (%infoLog%)'));
  }

  return ErrShaderCompile;
}(Tw2Error);
/**
 * Throws when unable to link a vertex shader and fragment shader
 */

let ErrShaderLink =
/*#__PURE__*/
function (_Tw2Error22) {
  _inherits(ErrShaderLink, _Tw2Error22);

  function ErrShaderLink(data) {
    _classCallCheck(this, ErrShaderLink);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrShaderLink).call(this, data, 'Error linking shaders'));
  }

  return ErrShaderLink;
}(Tw2Error);
/**
 * Throws on invalid raw data declaration types
 */

let ErrDeclarationValueType =
/*#__PURE__*/
function (_Tw2Error23) {
  _inherits(ErrDeclarationValueType, _Tw2Error23);

  function ErrDeclarationValueType(data) {
    _classCallCheck(this, ErrDeclarationValueType);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrDeclarationValueType).call(this, data, 'Invalid declaration value type (%declaration%:%valueType%)'));
  }

  return ErrDeclarationValueType;
}(Tw2Error);
/**
 * Throws when a class can only be instantiated once
 */

let ErrSingletonInstantiation =
/*#__PURE__*/
function (_Tw2Error24) {
  _inherits(ErrSingletonInstantiation, _Tw2Error24);

  function ErrSingletonInstantiation(data) {
    _classCallCheck(this, ErrSingletonInstantiation);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrSingletonInstantiation).call(this, data, 'Multiple class instantiations not yet supported'));
  }

  return ErrSingletonInstantiation;
}(Tw2Error);
/**
 * Throws when an abstract classes' method is not implemented directly on a child class
 */

let ErrAbstractClassMethod =
/*#__PURE__*/
function (_Tw2Error25) {
  _inherits(ErrAbstractClassMethod, _Tw2Error25);

  function ErrAbstractClassMethod(data) {
    _classCallCheck(this, ErrAbstractClassMethod);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrAbstractClassMethod).call(this, data, 'Abstract class method not implemented directly on child class'));
  }

  return ErrAbstractClassMethod;
}(Tw2Error);
/**
 * Throws when a feature is not implemented
 */

let ErrFeatureNotImplemented =
/*#__PURE__*/
function (_Tw2Error26) {
  _inherits(ErrFeatureNotImplemented, _Tw2Error26);

  function ErrFeatureNotImplemented(data) {
    _classCallCheck(this, ErrFeatureNotImplemented);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrFeatureNotImplemented).call(this, data, '%feature=Feature% not implemented'));
  }

  return ErrFeatureNotImplemented;
}(Tw2Error);
/**
 * Throws when an index is out of bounds
 */

let ErrIndexBounds =
/*#__PURE__*/
function (_Tw2Error27) {
  _inherits(ErrIndexBounds, _Tw2Error27);

  function ErrIndexBounds(data) {
    _classCallCheck(this, ErrIndexBounds);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrIndexBounds).call(this, data, 'Array index out of bounds'));
  }

  return ErrIndexBounds;
}(Tw2Error);

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./global/util/type.js
const type_toString = Object.prototype.toString;
/**
 * Checks if a value is an array
 * @param {*} a
 * @returns {boolean}
 */

const isArray = Array.isArray;
/**
 * Checks if a value is an array or a typed array
 * @param {*} a
 * @returns {boolean}
 */

function isArrayLike(a) {
  return a ? isArray(a) || isTyped(a) : false;
}
/**
 * Checks if a value is a boolean
 * @param {*} a
 * @returns {boolean}
 */

function isBoolean(a) {
  return isTag(a, '[object Boolean]');
}
/**
 * Checks if a value is an html canvas element
 * @param {*} a
 * @returns {boolean}
 */

function isCanvas(a) {
  return !!(a && a instanceof HTMLCanvasElement);
}
/**
 * Checks if a value is a descriptor
 * @author jay phelps
 * @param {*} a
 * @returns {boolean}
 */

function isDescriptor(a) {
  if (!a || !a.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (a.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}
/**
 * Checks if a value is a valid sof DNA string
 * @param {*} a
 */

function isDNA(a) {
  return isString(a) && a.match(/(\w|\d|[-_])+:(\w|\d|[-_])+:(\w|\d|[-_])+/);
}
/**
 * Checks if a value is an error
 * @param {*} a
 * @returns {boolean}
 */

function isError(a) {
  return !!(a && a instanceof Error || a.constructor.category === 'error');
}
/**
 * Checks if a value is a number
 * @param {*} a
 * @returns {boolean}
 */

function isNumber(a) {
  return isTag(a, '[object Number]');
}
/**
 * Checks if a value is a function
 * @param {*} a
 * @returns {boolean}
 */

function isFunction(a) {
  return typeof a === 'function';
}
/**
 * Checks if a value is null or undefined
 * @param {*} a
 * @returns {boolean}
 */

function isNoU(a) {
  return a == null;
}
/**
 * Checks if a value is null
 * @param {*} a
 * @returns {boolean}
 */

function isNull(a) {
  return a === null;
}
/**
 * Checks if a value is an object and not null
 * @param {*} a
 * @returns {boolean}
 */

function isObject(a) {
  const type = typeof a;
  return a !== null && (type === 'object' || type === 'function');
}
/**
 * Checks if a value has the type object, and is not null
 * @param {*} a
 * @returns {boolean}
 */

function isObjectLike(a) {
  return a !== null && typeof a === 'object';
}
/**
 * Checks if a value is a plain object
 * @author lodash
 * @param {*} a
 * @returns {boolean}
 */

function isPlain(a) {
  if (!isObject(a) || !isTag(a, '[object Object]')) {
    return false;
  }

  if (Object.getPrototypeOf(a) === null) {
    return true;
  }

  let proto = a;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(a) === proto;
}
/**
 * Checks if a value is a primary type
 * @param {*} a
 * @returns {boolean}
 */

function isPrimary(a) {
  return isBoolean(a) || isNumber(a) || isString(a);
}
/**
 * Checks if a value is a string
 * @param {*} a
 * @returns {boolean}
 */

function isString(a) {
  return isTag(a, '[object String]');
}
/**
 * Checks if a value is a symbol
 * @param {*} a
 * @returns {boolean}
 */

function isSymbol(a) {
  return typeof a === 'symbol' || isTag(a, '[object Symbol]');
}
/**
 * Checks if a value has a given tag
 * @param {*} a
 * @param {string} tag
 * @returns {boolean}
 */

function isTag(a, tag) {
  return type_toString.call(a) === tag;
}
/**
 * Checks if a value is a typed array
 * @param {*} a
 * @returns {boolean}
 */

function isTyped(a) {
  return a ? !!(a.buffer instanceof ArrayBuffer && a.BYTES_PER_ELEMENT) : false;
}
/**
 * Checks if a value is undefined
 * @param {*} a
 * @returns {boolean}
 */

function isUndefined(a) {
  return a === undefined;
}
/**
 * Checks if a value is arraylike and only contains numbers
 * @param {*} a
 * @returns {boolean}
 */

function isVector(a) {
  if (!a) {
    return false;
  }

  if (isTyped(a)) {
    return true;
  }

  if (isArray(a)) {
    for (let i = 0; i < a.length; i++) {
      if (!isNumber(a[i])) return false;
    }

    return true;
  }
}
// CONCATENATED MODULE: ./global/util/arr.js

/**
 * Adds arguments to an array if they don't already exist in it
 * @param {Array} arr
 * @param args
 * @returns {boolean} true if something was added
 */

function addToArray(arr) {
  let added = false;

  for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    if (arr.indexOf(i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]) === -1) {
      arr.push(i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);
      added = true;
    }
  }

  return added;
}
/**
 * Calls a function with arguments for each child in an array where that function exists
 * @param {Array} arr
 * @param {string} func
 * @param args
 */

function perArrayChild(arr, func) {
  const len = arr.length;

  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  for (let i = 0; i < len; i++) {
    if (func in arr) arr[i][func](...args);
  }
}
/**
 * Removes arguments from an array if they exist in it
 * @param {Array} arr
 * @param args
 * @returns {boolean} true if something was removed
 */

function removeFromArray(arr) {
  let removed = false;

  for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    const index = arr.indexOf(i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);

    if (index !== -1) {
      arr.splice(index, 1);
      removed = true;
    }
  }

  return removed;
}
/**
 * Returns a value if it is an array, or a new array with the object in it
 * @param {*} a
 * @returns {Array}
 */

function toArray(a) {
  return isArray(a) ? a : [a];
}
/**
 * Returns an array containing only unique numbers
 * @param {*} a
 * @returns {Array}
 */

function toUniqueArray(a) {
  return Array.from(new Set(toArray(a)));
}
// CONCATENATED MODULE: ./global/util/obj.js


/**
 * Assigns property values if they exist in a source object
 * - Typed arrays are cloned/ copied to ensure no pass-by-reference errors
 *
 * @param {*} dest
 * @param {*} src
 * @param {string|string[]} attrs
 */

function assignIfExists(dest, src, attrs) {
  if (!src) return;
  attrs = toArray(attrs);

  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];

    if (src[attr] !== undefined) {
      if (isArrayLike(dest[attr])) {
        if (isTyped(dest[attr])) {
          if (dest[attr].length !== src[attr].length) {
            const Constructor = dest[attr].constructor;
            dest[attr] = new Constructor(src[attr]);
          } else {
            dest[attr].set(src[attr]);
          }
        } else {
          dest[attr] = dest[attr].splice(dest[attr].length, 0);

          for (let i = 0; i < src[attr].length; i++) {
            dest[attr].push(src[attr][i]);
          }
        }
      } else if (isTyped(src[attr])) {
        const Constructor = src[attr].constructor;
        dest[attr] = new Constructor(src[attr]);
      } else {
        dest[attr] = src[attr];
      }
    }
  }
}
/**
 * Gets a source's property value if it exists else returns a default value
 * @param {*} src
 * @param {string|string[]} prop
 * @param {*} [defaultValue]
 * @returns {*}
 */

function get(src, prop, defaultValue) {
  if (!isArray(prop)) {
    return prop in src ? src[prop] : defaultValue;
  }

  for (let i = 0; i < prop.length; i++) {
    if (prop[i] in src) {
      return src[prop[i]];
    }
  }

  return defaultValue;
}
/**
 * Returns a string from a string template and a given object's properties
 * - templates are surrounded by %'s (ie. %propertyName%)
 * - default values are optionally identified with an = (ie. %propertyName=defaultValue%)
 * @param {string} str
 * @param {{}} [obj={}]
 * @returns {string}
 *
 * @example
 * const message = "%feature=Feature% not supported";
 * const message2 = "%feature% not supported";
 * let str1 = template(message, { feature: "Dynamic resource paths" })
 * let str2 = template(message);
 * let str3 = template(message2);
 * > str1 === "Dynamic resource paths not supported"
 * > str2 === "Feature not supported"
 * > str3 === "undefined not supported"
 */

function template(str) {
  let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const literals = str.match(/%([^%]+)?%/g) || [];

  for (let i = 0; i < literals.length; i++) {
    const literal = literals[i],
          split = literal.substring(1, literal.length - 1).split('='),
          value = split[0] in obj ? obj[split[0]] : split[1];
    str = str.replace(literal, value);
  }

  return str;
}
// CONCATENATED MODULE: ./global/util/uuid.js
/**
 * Identifies if UUIDs should be used for ID generation
 * @type {?boolean}
 */
let USE_UUID = null;
/**
 * Internal object count
 * @type {number}
 */

let OBJECT_COUNT = 0;
/**
 * Stores uuid scratch
 * @type {?Array}
 */

let LUT = null;
/**
 * Generates a UUID
 * @author Three.js
 * @returns {string}
 */

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0,
        d1 = Math.random() * 0xffffffff | 0,
        d2 = Math.random() * 0xffffffff | 0,
        d3 = Math.random() * 0xffffffff | 0;
  return LUT[d0 & 0xff] + LUT[d0 >> 8 & 0xff] + LUT[d0 >> 16 & 0xff] + LUT[d0 >> 24 & 0xff] + '-' + LUT[d1 & 0xff] + LUT[d1 >> 8 & 0xff] + '-' + LUT[d1 >> 16 & 0x0f | 0x40] + LUT[d1 >> 24 & 0xff] + '-' + LUT[d2 & 0x3f | 0x80] + LUT[d2 >> 8 & 0xff] + '-' + LUT[d2 >> 16 & 0xff] + LUT[d2 >> 24 & 0xff] + LUT[d3 & 0xff] + LUT[d3 >> 8 & 0xff] + LUT[d3 >> 16 & 0xff] + LUT[d3 >> 24 & 0xff];
}
/**
 * Enables UUID's for ID generation
 * @param {boolean} bool
 * @throws When generateID has already been used and trying to set a different ID type
 */


function enableUUID(bool) {
  if (bool === USE_UUID) {
    return;
  }

  if (USE_UUID !== null) {
    throw new Error('Cannot change id generation type once set');
  }

  if (bool) {
    LUT = [];

    for (let i = 0; i < 256; i++) {
      LUT[i] = (i < 16 ? '0' : '') + i.toString(16).toUpperCase();
    }
  }

  USE_UUID = bool;
}
/**
 * Generates an id
 * - Defaults to Object IDs
 * @returns {string|number}
 */

function generateID() {
  if (USE_UUID === null) {
    USE_UUID = false;
  }

  return USE_UUID ? generateUUID() : OBJECT_COUNT++;
}
// CONCATENATED MODULE: ./global/util/url.js
const url = {},
      query = window.location.search.substring(1),
      split = query.split('&');

for (let i = 0; i < split.length; i++) {
  const result = split[i].split('='),
        key = result[0].toLowerCase(),
        value = unescape(result[1]);

  if (key) {
    let v = value.toLowerCase();
    url[key] = v === 'true' ? true : v === 'false' ? false : value;
  }
}
/**
 * Gets the url as an object
 * @returns {*}
 */


function getURL() {
  return Object.assign({}, url);
}
/**
 * Gets a string from the url, returning a default value if not found
 * @param {string} key
 * @param {string} defaultValue
 * @returns {string}
 */

function getURLString(key, defaultValue) {
  key = key.toLowerCase();
  return key in url ? url[key] : defaultValue;
}
/**
 * Gets an integer from the url, returning a default value if not found
 * @param {string} key
 * @param {number} defaultValue
 * @returns {number}
 */

function getURLInteger(key, defaultValue) {
  key = key.toLowerCase();
  return key in url ? parseInt(url[key], 10) : defaultValue;
}
/**
 * Gets a float from the url, returning a default value if not found
 * @param {string} key
 * @param {number} defaultValue
 * @returns {number}
 */

function getURLFloat(key, defaultValue) {
  key = key.toLowerCase();
  return key in url ? parseFloat(url[key]) : defaultValue;
}
/**
 * Gets a boolean from the url, returning a default value if not found
 * @param {string} key
 * @param {boolean} defaultValue
 * @returns {boolean}
 */

function getURLBoolean(key, defaultValue) {
  key = key.toLowerCase();
  return key in url ? url[key] : defaultValue;
}
// CONCATENATED MODULE: ./global/util/index.js
/* concated harmony reexport addToArray */__webpack_require__.d(__webpack_exports__, "addToArray", function() { return addToArray; });
/* concated harmony reexport perArrayChild */__webpack_require__.d(__webpack_exports__, "perArrayChild", function() { return perArrayChild; });
/* concated harmony reexport removeFromArray */__webpack_require__.d(__webpack_exports__, "removeFromArray", function() { return removeFromArray; });
/* concated harmony reexport toArray */__webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* concated harmony reexport toUniqueArray */__webpack_require__.d(__webpack_exports__, "toUniqueArray", function() { return toUniqueArray; });
/* concated harmony reexport assignIfExists */__webpack_require__.d(__webpack_exports__, "assignIfExists", function() { return assignIfExists; });
/* concated harmony reexport get */__webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* concated harmony reexport template */__webpack_require__.d(__webpack_exports__, "template", function() { return template; });
/* concated harmony reexport isArray */__webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* concated harmony reexport isArrayLike */__webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/* concated harmony reexport isBoolean */__webpack_require__.d(__webpack_exports__, "isBoolean", function() { return isBoolean; });
/* concated harmony reexport isCanvas */__webpack_require__.d(__webpack_exports__, "isCanvas", function() { return isCanvas; });
/* concated harmony reexport isDescriptor */__webpack_require__.d(__webpack_exports__, "isDescriptor", function() { return isDescriptor; });
/* concated harmony reexport isDNA */__webpack_require__.d(__webpack_exports__, "isDNA", function() { return isDNA; });
/* concated harmony reexport isError */__webpack_require__.d(__webpack_exports__, "isError", function() { return isError; });
/* concated harmony reexport isNumber */__webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* concated harmony reexport isFunction */__webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* concated harmony reexport isNoU */__webpack_require__.d(__webpack_exports__, "isNoU", function() { return isNoU; });
/* concated harmony reexport isNull */__webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* concated harmony reexport isObject */__webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* concated harmony reexport isObjectLike */__webpack_require__.d(__webpack_exports__, "isObjectLike", function() { return isObjectLike; });
/* concated harmony reexport isPlain */__webpack_require__.d(__webpack_exports__, "isPlain", function() { return isPlain; });
/* concated harmony reexport isPrimary */__webpack_require__.d(__webpack_exports__, "isPrimary", function() { return isPrimary; });
/* concated harmony reexport isString */__webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* concated harmony reexport isSymbol */__webpack_require__.d(__webpack_exports__, "isSymbol", function() { return isSymbol; });
/* concated harmony reexport isTag */__webpack_require__.d(__webpack_exports__, "isTag", function() { return isTag; });
/* concated harmony reexport isTyped */__webpack_require__.d(__webpack_exports__, "isTyped", function() { return isTyped; });
/* concated harmony reexport isUndefined */__webpack_require__.d(__webpack_exports__, "isUndefined", function() { return isUndefined; });
/* concated harmony reexport isVector */__webpack_require__.d(__webpack_exports__, "isVector", function() { return isVector; });
/* concated harmony reexport enableUUID */__webpack_require__.d(__webpack_exports__, "enableUUID", function() { return enableUUID; });
/* concated harmony reexport generateID */__webpack_require__.d(__webpack_exports__, "generateID", function() { return generateID; });
/* concated harmony reexport getURL */__webpack_require__.d(__webpack_exports__, "getURL", function() { return getURL; });
/* concated harmony reexport getURLString */__webpack_require__.d(__webpack_exports__, "getURLString", function() { return getURLString; });
/* concated harmony reexport getURLInteger */__webpack_require__.d(__webpack_exports__, "getURLInteger", function() { return getURLInteger; });
/* concated harmony reexport getURLFloat */__webpack_require__.d(__webpack_exports__, "getURLFloat", function() { return getURLFloat; });
/* concated harmony reexport getURLBoolean */__webpack_require__.d(__webpack_exports__, "getURLBoolean", function() { return getURLBoolean; });






/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var mat3_namespaceObject = {};
__webpack_require__.r(mat3_namespaceObject);
__webpack_require__.d(mat3_namespaceObject, "create", function() { return create; });
__webpack_require__.d(mat3_namespaceObject, "fromMat4", function() { return fromMat4; });
__webpack_require__.d(mat3_namespaceObject, "clone", function() { return clone; });
__webpack_require__.d(mat3_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(mat3_namespaceObject, "fromValues", function() { return fromValues; });
__webpack_require__.d(mat3_namespaceObject, "set", function() { return set; });
__webpack_require__.d(mat3_namespaceObject, "identity", function() { return identity; });
__webpack_require__.d(mat3_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(mat3_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(mat3_namespaceObject, "adjoint", function() { return adjoint; });
__webpack_require__.d(mat3_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(mat3_namespaceObject, "multiply", function() { return multiply; });
__webpack_require__.d(mat3_namespaceObject, "translate", function() { return translate; });
__webpack_require__.d(mat3_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(mat3_namespaceObject, "scale", function() { return mat3_scale; });
__webpack_require__.d(mat3_namespaceObject, "fromTranslation", function() { return fromTranslation; });
__webpack_require__.d(mat3_namespaceObject, "fromRotation", function() { return fromRotation; });
__webpack_require__.d(mat3_namespaceObject, "fromScaling", function() { return fromScaling; });
__webpack_require__.d(mat3_namespaceObject, "fromMat2d", function() { return fromMat2d; });
__webpack_require__.d(mat3_namespaceObject, "fromQuat", function() { return fromQuat; });
__webpack_require__.d(mat3_namespaceObject, "normalFromMat4", function() { return normalFromMat4; });
__webpack_require__.d(mat3_namespaceObject, "projection", function() { return projection; });
__webpack_require__.d(mat3_namespaceObject, "str", function() { return str; });
__webpack_require__.d(mat3_namespaceObject, "frob", function() { return frob; });
__webpack_require__.d(mat3_namespaceObject, "add", function() { return add; });
__webpack_require__.d(mat3_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(mat3_namespaceObject, "multiplyScalar", function() { return multiplyScalar; });
__webpack_require__.d(mat3_namespaceObject, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
__webpack_require__.d(mat3_namespaceObject, "exactEquals", function() { return exactEquals; });
__webpack_require__.d(mat3_namespaceObject, "equals", function() { return mat3_equals; });
__webpack_require__.d(mat3_namespaceObject, "mul", function() { return mul; });
__webpack_require__.d(mat3_namespaceObject, "sub", function() { return sub; });
var mat4_namespaceObject = {};
__webpack_require__.r(mat4_namespaceObject);
__webpack_require__.d(mat4_namespaceObject, "create", function() { return mat4_create; });
__webpack_require__.d(mat4_namespaceObject, "clone", function() { return mat4_clone; });
__webpack_require__.d(mat4_namespaceObject, "copy", function() { return mat4_copy; });
__webpack_require__.d(mat4_namespaceObject, "fromValues", function() { return mat4_fromValues; });
__webpack_require__.d(mat4_namespaceObject, "set", function() { return mat4_set; });
__webpack_require__.d(mat4_namespaceObject, "identity", function() { return mat4_identity; });
__webpack_require__.d(mat4_namespaceObject, "transpose", function() { return mat4_transpose; });
__webpack_require__.d(mat4_namespaceObject, "invert", function() { return mat4_invert; });
__webpack_require__.d(mat4_namespaceObject, "adjoint", function() { return mat4_adjoint; });
__webpack_require__.d(mat4_namespaceObject, "determinant", function() { return mat4_determinant; });
__webpack_require__.d(mat4_namespaceObject, "multiply", function() { return mat4_multiply; });
__webpack_require__.d(mat4_namespaceObject, "translate", function() { return mat4_translate; });
__webpack_require__.d(mat4_namespaceObject, "scale", function() { return mat4_scale; });
__webpack_require__.d(mat4_namespaceObject, "rotate", function() { return mat4_rotate; });
__webpack_require__.d(mat4_namespaceObject, "rotateX", function() { return rotateX; });
__webpack_require__.d(mat4_namespaceObject, "rotateY", function() { return rotateY; });
__webpack_require__.d(mat4_namespaceObject, "rotateZ", function() { return rotateZ; });
__webpack_require__.d(mat4_namespaceObject, "fromTranslation", function() { return mat4_fromTranslation; });
__webpack_require__.d(mat4_namespaceObject, "fromScaling", function() { return mat4_fromScaling; });
__webpack_require__.d(mat4_namespaceObject, "fromRotation", function() { return mat4_fromRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromXRotation", function() { return fromXRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromYRotation", function() { return fromYRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromZRotation", function() { return fromZRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslation", function() { return fromRotationTranslation; });
__webpack_require__.d(mat4_namespaceObject, "fromQuat2", function() { return fromQuat2; });
__webpack_require__.d(mat4_namespaceObject, "getTranslation", function() { return getTranslation; });
__webpack_require__.d(mat4_namespaceObject, "getScaling", function() { return getScaling; });
__webpack_require__.d(mat4_namespaceObject, "getRotation", function() { return getRotation; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
__webpack_require__.d(mat4_namespaceObject, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
__webpack_require__.d(mat4_namespaceObject, "fromQuat", function() { return mat4_fromQuat; });
__webpack_require__.d(mat4_namespaceObject, "frustum", function() { return frustum; });
__webpack_require__.d(mat4_namespaceObject, "perspective", function() { return perspective; });
__webpack_require__.d(mat4_namespaceObject, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
__webpack_require__.d(mat4_namespaceObject, "ortho", function() { return ortho; });
__webpack_require__.d(mat4_namespaceObject, "lookAt", function() { return lookAt; });
__webpack_require__.d(mat4_namespaceObject, "targetTo", function() { return targetTo; });
__webpack_require__.d(mat4_namespaceObject, "str", function() { return mat4_str; });
__webpack_require__.d(mat4_namespaceObject, "frob", function() { return mat4_frob; });
__webpack_require__.d(mat4_namespaceObject, "add", function() { return mat4_add; });
__webpack_require__.d(mat4_namespaceObject, "subtract", function() { return mat4_subtract; });
__webpack_require__.d(mat4_namespaceObject, "multiplyScalar", function() { return mat4_multiplyScalar; });
__webpack_require__.d(mat4_namespaceObject, "multiplyScalarAndAdd", function() { return mat4_multiplyScalarAndAdd; });
__webpack_require__.d(mat4_namespaceObject, "exactEquals", function() { return mat4_exactEquals; });
__webpack_require__.d(mat4_namespaceObject, "equals", function() { return mat4_equals; });
__webpack_require__.d(mat4_namespaceObject, "mul", function() { return mat4_mul; });
__webpack_require__.d(mat4_namespaceObject, "sub", function() { return mat4_sub; });
var vec3_namespaceObject = {};
__webpack_require__.r(vec3_namespaceObject);
__webpack_require__.d(vec3_namespaceObject, "create", function() { return vec3_create; });
__webpack_require__.d(vec3_namespaceObject, "clone", function() { return vec3_clone; });
__webpack_require__.d(vec3_namespaceObject, "length", function() { return vec3_length; });
__webpack_require__.d(vec3_namespaceObject, "fromValues", function() { return vec3_fromValues; });
__webpack_require__.d(vec3_namespaceObject, "copy", function() { return vec3_copy; });
__webpack_require__.d(vec3_namespaceObject, "set", function() { return vec3_set; });
__webpack_require__.d(vec3_namespaceObject, "add", function() { return vec3_add; });
__webpack_require__.d(vec3_namespaceObject, "subtract", function() { return vec3_subtract; });
__webpack_require__.d(vec3_namespaceObject, "multiply", function() { return vec3_multiply; });
__webpack_require__.d(vec3_namespaceObject, "divide", function() { return divide; });
__webpack_require__.d(vec3_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vec3_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vec3_namespaceObject, "min", function() { return min; });
__webpack_require__.d(vec3_namespaceObject, "max", function() { return max; });
__webpack_require__.d(vec3_namespaceObject, "round", function() { return round; });
__webpack_require__.d(vec3_namespaceObject, "scale", function() { return vec3_scale; });
__webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function() { return scaleAndAdd; });
__webpack_require__.d(vec3_namespaceObject, "distance", function() { return distance; });
__webpack_require__.d(vec3_namespaceObject, "squaredDistance", function() { return squaredDistance; });
__webpack_require__.d(vec3_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vec3_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vec3_namespaceObject, "inverse", function() { return inverse; });
__webpack_require__.d(vec3_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vec3_namespaceObject, "dot", function() { return vec3_dot; });
__webpack_require__.d(vec3_namespaceObject, "cross", function() { return cross; });
__webpack_require__.d(vec3_namespaceObject, "lerp", function() { return lerp; });
__webpack_require__.d(vec3_namespaceObject, "hermite", function() { return hermite; });
__webpack_require__.d(vec3_namespaceObject, "bezier", function() { return bezier; });
__webpack_require__.d(vec3_namespaceObject, "random", function() { return random; });
__webpack_require__.d(vec3_namespaceObject, "transformMat4", function() { return transformMat4; });
__webpack_require__.d(vec3_namespaceObject, "transformMat3", function() { return transformMat3; });
__webpack_require__.d(vec3_namespaceObject, "transformQuat", function() { return transformQuat; });
__webpack_require__.d(vec3_namespaceObject, "rotateX", function() { return vec3_rotateX; });
__webpack_require__.d(vec3_namespaceObject, "rotateY", function() { return vec3_rotateY; });
__webpack_require__.d(vec3_namespaceObject, "rotateZ", function() { return vec3_rotateZ; });
__webpack_require__.d(vec3_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vec3_namespaceObject, "str", function() { return vec3_str; });
__webpack_require__.d(vec3_namespaceObject, "exactEquals", function() { return vec3_exactEquals; });
__webpack_require__.d(vec3_namespaceObject, "equals", function() { return vec3_equals; });
__webpack_require__.d(vec3_namespaceObject, "sub", function() { return vec3_sub; });
__webpack_require__.d(vec3_namespaceObject, "mul", function() { return vec3_mul; });
__webpack_require__.d(vec3_namespaceObject, "div", function() { return div; });
__webpack_require__.d(vec3_namespaceObject, "dist", function() { return dist; });
__webpack_require__.d(vec3_namespaceObject, "sqrDist", function() { return sqrDist; });
__webpack_require__.d(vec3_namespaceObject, "len", function() { return vec3_len; });
__webpack_require__.d(vec3_namespaceObject, "sqrLen", function() { return sqrLen; });
__webpack_require__.d(vec3_namespaceObject, "forEach", function() { return forEach; });
var vec4_namespaceObject = {};
__webpack_require__.r(vec4_namespaceObject);
__webpack_require__.d(vec4_namespaceObject, "create", function() { return vec4_create; });
__webpack_require__.d(vec4_namespaceObject, "clone", function() { return vec4_clone; });
__webpack_require__.d(vec4_namespaceObject, "fromValues", function() { return vec4_fromValues; });
__webpack_require__.d(vec4_namespaceObject, "copy", function() { return vec4_copy; });
__webpack_require__.d(vec4_namespaceObject, "set", function() { return vec4_set; });
__webpack_require__.d(vec4_namespaceObject, "add", function() { return vec4_add; });
__webpack_require__.d(vec4_namespaceObject, "subtract", function() { return vec4_subtract; });
__webpack_require__.d(vec4_namespaceObject, "multiply", function() { return vec4_multiply; });
__webpack_require__.d(vec4_namespaceObject, "divide", function() { return vec4_divide; });
__webpack_require__.d(vec4_namespaceObject, "ceil", function() { return vec4_ceil; });
__webpack_require__.d(vec4_namespaceObject, "floor", function() { return vec4_floor; });
__webpack_require__.d(vec4_namespaceObject, "min", function() { return vec4_min; });
__webpack_require__.d(vec4_namespaceObject, "max", function() { return vec4_max; });
__webpack_require__.d(vec4_namespaceObject, "round", function() { return vec4_round; });
__webpack_require__.d(vec4_namespaceObject, "scale", function() { return vec4_scale; });
__webpack_require__.d(vec4_namespaceObject, "scaleAndAdd", function() { return vec4_scaleAndAdd; });
__webpack_require__.d(vec4_namespaceObject, "distance", function() { return vec4_distance; });
__webpack_require__.d(vec4_namespaceObject, "squaredDistance", function() { return vec4_squaredDistance; });
__webpack_require__.d(vec4_namespaceObject, "length", function() { return vec4_length; });
__webpack_require__.d(vec4_namespaceObject, "squaredLength", function() { return vec4_squaredLength; });
__webpack_require__.d(vec4_namespaceObject, "negate", function() { return vec4_negate; });
__webpack_require__.d(vec4_namespaceObject, "inverse", function() { return vec4_inverse; });
__webpack_require__.d(vec4_namespaceObject, "normalize", function() { return vec4_normalize; });
__webpack_require__.d(vec4_namespaceObject, "dot", function() { return vec4_dot; });
__webpack_require__.d(vec4_namespaceObject, "lerp", function() { return vec4_lerp; });
__webpack_require__.d(vec4_namespaceObject, "random", function() { return vec4_random; });
__webpack_require__.d(vec4_namespaceObject, "transformMat4", function() { return vec4_transformMat4; });
__webpack_require__.d(vec4_namespaceObject, "transformQuat", function() { return vec4_transformQuat; });
__webpack_require__.d(vec4_namespaceObject, "str", function() { return vec4_str; });
__webpack_require__.d(vec4_namespaceObject, "exactEquals", function() { return vec4_exactEquals; });
__webpack_require__.d(vec4_namespaceObject, "equals", function() { return vec4_equals; });
__webpack_require__.d(vec4_namespaceObject, "sub", function() { return vec4_sub; });
__webpack_require__.d(vec4_namespaceObject, "mul", function() { return vec4_mul; });
__webpack_require__.d(vec4_namespaceObject, "div", function() { return vec4_div; });
__webpack_require__.d(vec4_namespaceObject, "dist", function() { return vec4_dist; });
__webpack_require__.d(vec4_namespaceObject, "sqrDist", function() { return vec4_sqrDist; });
__webpack_require__.d(vec4_namespaceObject, "len", function() { return vec4_len; });
__webpack_require__.d(vec4_namespaceObject, "sqrLen", function() { return vec4_sqrLen; });
__webpack_require__.d(vec4_namespaceObject, "forEach", function() { return vec4_forEach; });
var quat_namespaceObject = {};
__webpack_require__.r(quat_namespaceObject);
__webpack_require__.d(quat_namespaceObject, "create", function() { return quat_create; });
__webpack_require__.d(quat_namespaceObject, "identity", function() { return quat_identity; });
__webpack_require__.d(quat_namespaceObject, "setAxisAngle", function() { return setAxisAngle; });
__webpack_require__.d(quat_namespaceObject, "getAxisAngle", function() { return getAxisAngle; });
__webpack_require__.d(quat_namespaceObject, "multiply", function() { return quat_multiply; });
__webpack_require__.d(quat_namespaceObject, "rotateX", function() { return quat_rotateX; });
__webpack_require__.d(quat_namespaceObject, "rotateY", function() { return quat_rotateY; });
__webpack_require__.d(quat_namespaceObject, "rotateZ", function() { return quat_rotateZ; });
__webpack_require__.d(quat_namespaceObject, "calculateW", function() { return calculateW; });
__webpack_require__.d(quat_namespaceObject, "slerp", function() { return slerp; });
__webpack_require__.d(quat_namespaceObject, "random", function() { return quat_random; });
__webpack_require__.d(quat_namespaceObject, "invert", function() { return quat_invert; });
__webpack_require__.d(quat_namespaceObject, "conjugate", function() { return conjugate; });
__webpack_require__.d(quat_namespaceObject, "fromMat3", function() { return fromMat3; });
__webpack_require__.d(quat_namespaceObject, "fromEuler", function() { return fromEuler; });
__webpack_require__.d(quat_namespaceObject, "str", function() { return quat_str; });
__webpack_require__.d(quat_namespaceObject, "clone", function() { return quat_clone; });
__webpack_require__.d(quat_namespaceObject, "fromValues", function() { return quat_fromValues; });
__webpack_require__.d(quat_namespaceObject, "copy", function() { return quat_copy; });
__webpack_require__.d(quat_namespaceObject, "set", function() { return quat_set; });
__webpack_require__.d(quat_namespaceObject, "add", function() { return quat_add; });
__webpack_require__.d(quat_namespaceObject, "mul", function() { return quat_mul; });
__webpack_require__.d(quat_namespaceObject, "scale", function() { return quat_scale; });
__webpack_require__.d(quat_namespaceObject, "dot", function() { return quat_dot; });
__webpack_require__.d(quat_namespaceObject, "lerp", function() { return quat_lerp; });
__webpack_require__.d(quat_namespaceObject, "length", function() { return quat_length; });
__webpack_require__.d(quat_namespaceObject, "len", function() { return quat_len; });
__webpack_require__.d(quat_namespaceObject, "squaredLength", function() { return quat_squaredLength; });
__webpack_require__.d(quat_namespaceObject, "sqrLen", function() { return quat_sqrLen; });
__webpack_require__.d(quat_namespaceObject, "normalize", function() { return quat_normalize; });
__webpack_require__.d(quat_namespaceObject, "exactEquals", function() { return quat_exactEquals; });
__webpack_require__.d(quat_namespaceObject, "equals", function() { return quat_equals; });
__webpack_require__.d(quat_namespaceObject, "rotationTo", function() { return rotationTo; });
__webpack_require__.d(quat_namespaceObject, "sqlerp", function() { return sqlerp; });
__webpack_require__.d(quat_namespaceObject, "setAxes", function() { return setAxes; });
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, "create", function() { return vec2_create; });
__webpack_require__.d(vec2_namespaceObject, "clone", function() { return vec2_clone; });
__webpack_require__.d(vec2_namespaceObject, "fromValues", function() { return vec2_fromValues; });
__webpack_require__.d(vec2_namespaceObject, "copy", function() { return vec2_copy; });
__webpack_require__.d(vec2_namespaceObject, "set", function() { return vec2_set; });
__webpack_require__.d(vec2_namespaceObject, "add", function() { return vec2_add; });
__webpack_require__.d(vec2_namespaceObject, "subtract", function() { return vec2_subtract; });
__webpack_require__.d(vec2_namespaceObject, "multiply", function() { return vec2_multiply; });
__webpack_require__.d(vec2_namespaceObject, "divide", function() { return vec2_divide; });
__webpack_require__.d(vec2_namespaceObject, "ceil", function() { return vec2_ceil; });
__webpack_require__.d(vec2_namespaceObject, "floor", function() { return vec2_floor; });
__webpack_require__.d(vec2_namespaceObject, "min", function() { return vec2_min; });
__webpack_require__.d(vec2_namespaceObject, "max", function() { return vec2_max; });
__webpack_require__.d(vec2_namespaceObject, "round", function() { return vec2_round; });
__webpack_require__.d(vec2_namespaceObject, "scale", function() { return vec2_scale; });
__webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function() { return vec2_scaleAndAdd; });
__webpack_require__.d(vec2_namespaceObject, "distance", function() { return vec2_distance; });
__webpack_require__.d(vec2_namespaceObject, "squaredDistance", function() { return vec2_squaredDistance; });
__webpack_require__.d(vec2_namespaceObject, "length", function() { return vec2_length; });
__webpack_require__.d(vec2_namespaceObject, "squaredLength", function() { return vec2_squaredLength; });
__webpack_require__.d(vec2_namespaceObject, "negate", function() { return vec2_negate; });
__webpack_require__.d(vec2_namespaceObject, "inverse", function() { return vec2_inverse; });
__webpack_require__.d(vec2_namespaceObject, "normalize", function() { return vec2_normalize; });
__webpack_require__.d(vec2_namespaceObject, "dot", function() { return vec2_dot; });
__webpack_require__.d(vec2_namespaceObject, "cross", function() { return vec2_cross; });
__webpack_require__.d(vec2_namespaceObject, "lerp", function() { return vec2_lerp; });
__webpack_require__.d(vec2_namespaceObject, "random", function() { return vec2_random; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2", function() { return transformMat2; });
__webpack_require__.d(vec2_namespaceObject, "transformMat2d", function() { return transformMat2d; });
__webpack_require__.d(vec2_namespaceObject, "transformMat3", function() { return vec2_transformMat3; });
__webpack_require__.d(vec2_namespaceObject, "transformMat4", function() { return vec2_transformMat4; });
__webpack_require__.d(vec2_namespaceObject, "rotate", function() { return vec2_rotate; });
__webpack_require__.d(vec2_namespaceObject, "angle", function() { return vec2_angle; });
__webpack_require__.d(vec2_namespaceObject, "str", function() { return vec2_str; });
__webpack_require__.d(vec2_namespaceObject, "exactEquals", function() { return vec2_exactEquals; });
__webpack_require__.d(vec2_namespaceObject, "equals", function() { return vec2_equals; });
__webpack_require__.d(vec2_namespaceObject, "len", function() { return vec2_len; });
__webpack_require__.d(vec2_namespaceObject, "sub", function() { return vec2_sub; });
__webpack_require__.d(vec2_namespaceObject, "mul", function() { return vec2_mul; });
__webpack_require__.d(vec2_namespaceObject, "div", function() { return vec2_div; });
__webpack_require__.d(vec2_namespaceObject, "dist", function() { return vec2_dist; });
__webpack_require__.d(vec2_namespaceObject, "sqrDist", function() { return vec2_sqrDist; });
__webpack_require__.d(vec2_namespaceObject, "sqrLen", function() { return vec2_sqrLen; });
__webpack_require__.d(vec2_namespaceObject, "forEach", function() { return vec2_forEach; });

// CONCATENATED MODULE: ./global/math/num.js
const num = {};
/**
 * biCumulative
 *
 * @param {number} t
 * @param {number} order
 * @returns {number}
 */

num.biCumulative = function (t, order) {
  if (order === 1) {
    const some = 1.0 - t;
    return 1.0 - some * some * some;
  } else if (order === 2) {
    return 3.0 * t * t - 2.0 * t * t * t;
  } else {
    return t * t * t;
  }
};
/**
 * Converts a Dword to Float
 * @param value
 * @return {Number}
 */


num.dwordToFloat = function (value) {
  const b4 = value & 0xff,
        b3 = (value & 0xff00) >> 8,
        b2 = (value & 0xff0000) >> 16,
        b1 = (value & 0xff000000) >> 24,
        sign = 1 - 2 * (b1 >> 7),
        // sign = bit 0
  exp = (b1 << 1 & 0xff | b2 >> 7) - 127,
        // exponent = bits 1..8
  sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31

  if (sig === 0 && exp === -127) return 0.0;
  return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
};
/**
 * Exponential decay
 *
 * @param {number} omega0
 * @param {number} torque
 * @param {number} I - inertia
 * @param {number} d - drag
 * @param {number} time - time
 * @returns {number}
 */


num.exponentialDecay = function (omega0, torque, I, d, time) {
  return torque * time / d + I * (omega0 * d - torque) / (d * d) * (1.0 - Math.pow(Math.E, -d * time / I));
};
/**
 * Gets a value from a half float
 * @author Babylon
 * @param {number} a
 * @returns {number}
 */


num.fromHalfFloat = function (a) {
  const s = (a & 0x8000) >> 15,
        e = (a & 0x7C00) >> 10,
        f = a & 0x03FF;

  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e === 0x1F) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }

  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
};
/**
 * Gets long word order
 * @author Babylon
 * @param {number} a
 * @returns {number}
 */


num.getLongWordOrder = function (a) {
  return a === 0 || a === 255 || a === -16777216 ? 0 : 1 + num.getLongWordOrder(a >> 8);
};
/**
 * Gets the log2 of a number
 * @param {number} a
 * @returns {number}
 */


num.log2 = function (a) {
  return Math.log(a) * Math.LOG2E;
};
/**
 * Converts a number to a half float
 * @author http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript
 * @param {number} a
 * @returns {number}
 */


num.toHalfFloat = function () {
  let floatView, int32View;
  return function (a) {
    if (!floatView) {
      floatView = new Float32Array(1);
      int32View = new Int32Array(floatView.buffer);
    }

    floatView[0] = a;
    const x = int32View[0];
    let bits = x >> 16 & 0x8000;
    /* Get the sign */

    let m = x >> 12 & 0x07ff;
    /* Keep one extra bit for rounding */

    let e = x >> 23 & 0xff;
    /* Using int is faster here */

    /* If zero, or denormal, or exponent underflows too much for a denormal half, return signed zero. */

    if (e < 103) {
      return bits;
    }
    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */


    if (e > 142) {
      bits |= 0x7c00;
      /* If exponent was 0xff and one mantissa bit was set, it means NaN,
           * not Inf, so make sure we set one mantissa bit too. */

      bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
      return bits;
    }
    /* If exponent underflows but not too much, return a denormal */


    if (e < 113) {
      m |= 0x0800;
      /* Extra rounding may overflow and set mantissa to 0 and exponent to 1, which is OK. */

      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }

    bits |= e - 112 << 10 | m >> 1;
    /* Extra rounding. An overflow will set mantissa to 0 and increment the exponent, which is OK. */

    bits += m & 1;
    return bits;
  };
}();
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/common.js
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/mat3.js


/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function mat3_scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat3_equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = subtract;
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/mat4.js


/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function mat4_create() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function mat4_clone(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function mat4_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function mat4_fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function mat4_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function mat4_identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function mat4_transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function mat4_invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function mat4_adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function mat4_determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function mat4_multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  // Cache only the current line of the second matrix
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function mat4_translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function mat4_scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function mat4_rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;
  var b00 = void 0,
      b01 = void 0,
      b02 = void 0;
  var b10 = void 0,
      b11 = void 0,
      b12 = void 0;
  var b20 = void 0,
      b21 = void 0,
      b22 = void 0;

  if (len < EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function mat4_fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function mat4_fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function mat4_fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;

  if (len < EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];

  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  //Only scale if it makes sense
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  var ox = o[0];
  var oy = o[1];
  var oz = o[2];

  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;

  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function mat4_fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf = void 0;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  var x0 = void 0,
      x1 = void 0,
      x2 = void 0,
      y0 = void 0,
      y1 = void 0,
      y2 = void 0,
      z0 = void 0,
      z1 = void 0,
      z2 = void 0,
      len = void 0;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return mat4_identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function mat4_str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function mat4_frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function mat4_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function mat4_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function mat4_multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function mat4_multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat4_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function mat4_equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
var mat4_mul = mat4_multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
var mat4_sub = mat4_subtract;
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/vec3.js


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function vec3_create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function vec3_clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec3_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function vec3_fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function vec3_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function vec3_set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function vec3_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function vec3_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec3_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = RANDOM() * 2.0 * Math.PI;
  var z = RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2];
  // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x;
  // var uuv = vec3.cross([], qvec, uv);
  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx;
  // vec3.scale(uv, uv, 2 * w);
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  // vec3.scale(uuv, uuv, 2);
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  // return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function vec3_rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = vec3_fromValues(a[0], a[1], a[2]);
  var tempB = vec3_fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = vec3_dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec3_str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec3_equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var vec3_sub = vec3_subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var vec3_mul = vec3_multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var vec3_len = vec3_length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = vec3_create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/vec4.js


/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function vec4_create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function vec4_clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function vec4_fromValues(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function vec4_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function vec4_set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function vec4_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function vec4_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function vec4_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function vec4_round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function vec4_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function vec4_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function vec4_distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec4_squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec4_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec4_squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function vec4_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function vec4_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function vec4_normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec4_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */
function vec4_lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function vec4_random(out, scale) {
  scale = scale || 1.0;

  // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function vec4_transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function vec4_transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec4_str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec4_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec4_equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
var vec4_sub = vec4_subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
var vec4_mul = vec4_multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
var vec4_div = vec4_divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
var vec4_dist = vec4_distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
var vec4_sqrDist = vec4_squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
var vec4_len = vec4_length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
var vec4_sqrLen = vec4_squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var vec4_forEach = function () {
  var vec = vec4_create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
    }

    return a;
  };
}();
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/quat.js





/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function quat_create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function quat_identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function quat_multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateX(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateY(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function quat_rotateZ(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  var omega = void 0,
      cosom = void 0,
      sinom = void 0,
      scale0 = void 0,
      scale1 = void 0;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function quat_random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();

  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);

  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function quat_invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot = void 0;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);

  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;

  return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function quat_str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
var quat_clone = vec4_clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
var quat_fromValues = vec4_fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
var quat_copy = vec4_copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
var quat_set = vec4_set;

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
var quat_add = vec4_add;

/**
 * Alias for {@link quat.multiply}
 * @function
 */
var quat_mul = quat_multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
var quat_scale = vec4_scale;

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var quat_dot = vec4_dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
var quat_lerp = vec4_lerp;

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
var quat_length = vec4_length;

/**
 * Alias for {@link quat.length}
 * @function
 */
var quat_len = quat_length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var quat_squaredLength = vec4_squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
var quat_sqrLen = quat_squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
var quat_normalize = vec4_normalize;

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var quat_exactEquals = vec4_exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var quat_equals = vec4_equals;

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
var rotationTo = function () {
  var tmpvec3 = vec3_create();
  var xUnitVec3 = vec3_fromValues(1, 0, 0);
  var yUnitVec3 = vec3_fromValues(0, 1, 0);

  return function (out, a, b) {
    var dot = vec3_dot(a, b);
    if (dot < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (vec3_len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return quat_normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
var sqlerp = function () {
  var temp1 = quat_create();
  var temp2 = quat_create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
var setAxes = function () {
  var matr = create();

  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return quat_normalize(out, fromMat3(out, matr));
  };
}();
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix/vec2.js


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function vec2_create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function vec2_clone(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function vec2_fromValues(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function vec2_copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function vec2_set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function vec2_ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function vec2_floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function vec2_max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function vec2_round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function vec2_scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function vec2_scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function vec2_distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function vec2_squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function vec2_length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function vec2_squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function vec2_negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function vec2_inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function vec2_normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function vec2_dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function vec2_cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function vec2_lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function vec2_random(out, scale) {
  scale = scale || 1.0;
  var r = RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function vec2_transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function vec2_transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */
function vec2_rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];

  return out;
}

/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */
function vec2_angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];

  var len1 = x1 * x1 + y1 * y1;
  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function vec2_str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function vec2_equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var vec2_len = vec2_length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var vec2_sub = vec2_subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var vec2_mul = vec2_multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var vec2_div = vec2_divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var vec2_dist = vec2_distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var vec2_sqrDist = vec2_squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var vec2_sqrLen = vec2_squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var vec2_forEach = function () {
  var vec = vec2_create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();
// CONCATENATED MODULE: ../node_modules/gl-matrix/lib/gl-matrix.js












// CONCATENATED MODULE: ./global/math/vec2.js


// CONCATENATED MODULE: ./global/math/vec3.js



/**
 * Sets a vec3 with cartesian coordinates from spherical coordinates and an optional center point
 * @param {vec3} out       - receiving vec3
 * @param {vec3} spherical - source vec3 with spherical coordinates (phi, theta, radius)
 * @param {vec3} [center]  - Optional center
 * @returns {vec3} out     - receiving vec3
 */

vec3_namespaceObject.fromSpherical = function (out, spherical, center) {
  const phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];
  out[0] = radius * Math.sin(phi) * Math.sin(theta);
  out[1] = radius * Math.cos(theta);
  out[2] = radius * Math.cos(phi) * Math.sin(theta);

  if (center) {
    out[0] += center[0];
    out[1] += center[1];
    out[2] += center[2];
  }

  return out;
};
/**
 * Gets spherical coordinates from a vector
 * @param {vec3} out
 * @param {vec3} a
 * @returns {vec3} out
 */


vec3_namespaceObject.getSpherical = function (out, a) {
  let phi = 0,
      theta = 0,
      radius = vec3_namespaceObject.length(a);

  if (radius !== 0) {
    phi = Math.acos(Math.max(a[1] / radius, Math.min(-1, 1)));
    theta = Math.atan2(a[0], a[2]);
  }

  out[0] = phi;
  out[1] = theta;
  out[2] = radius;
  return out;
};
/**
 * Exponential decay
 *
 * @param {vec3} out
 * @param {vec3} omega0
 * @param {vec3} torque
 * @param {number} I
 * @param {number} drag
 * @param {number} time
 * @returns {vec3} out
 */


vec3_namespaceObject.exponentialDecay = function (out, omega0, torque, I, drag, time) {
  out[0] = num.exponentialDecay(omega0[0], torque[0], I, drag, time);
  out[1] = num.exponentialDecay(omega0[1], torque[1], I, drag, time);
  out[2] = num.exponentialDecay(omega0[2], torque[2], I, drag, time);
  return out;
};
/**
 * Projects a local vec3 to screen space with viewport settings
 * @param {vec3} out           - receiving vec3
 * @param {vec3} a             - local vec3
 * @param {mat4} m             - model view projection matrix
 * @param {vec4} viewport      - view port settings (x, y, width, height)
 * @returns {vec3} out         - receiving vec3 (x, y, perspectiveDivide)
 */


vec3_namespaceObject.project = function (out, a, m, viewport) {
  let x = a[0],
      y = a[1],
      z = a[2];
  let outX = m[0] * x + m[4] * y + m[8] * z + m[12],
      outY = m[1] * x + m[5] * y + m[9] * z + m[13],
      perD = m[3] * x + m[7] * y + m[11] * z + m[15];
  let projectionX = (outX / perD + 1) / 2;
  let projectionY = 1 - (outY / perD + 1) / 2;
  out[0] = projectionX * viewport[2] + viewport[0];
  out[1] = projectionY * viewport[3] + viewport[1];
  out[2] = perD;
  return out;
};
/**
 * Unprojects a vec3 with canvas coordinates to world space
 * @param {vec3} out            - receiving vec3
 * @param {vec3} a              - vec3 to unproject
 * @param {mat4} invViewProj    - inverse view projection matrix
 * @param {vec4|Array} viewport - [ x, y, width, height ]
 * @returns {vec3} out
 * @throw On perspective divide error
 */


vec3_namespaceObject.unproject = function () {
  let vec4_0;
  return function unProject(out, a, invViewProj, viewport) {
    if (!vec4_0) vec4_0 = vec4_namespaceObject.create();
    let x = a[0],
        y = a[1],
        z = a[2];
    vec4_0[0] = (x - viewport[0]) * 2.0 / viewport[2] - 1.0;
    vec4_0[1] = (y - viewport[1]) * 2.0 / viewport[3] - 1.0;
    vec4_0[2] = 2.0 * z - 1.0;
    vec4_0[3] = 1.0;
    vec4_namespaceObject.transformMat4(vec4_0, vec4_0, invViewProj);

    if (vec4_0[3] === 0.0) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      throw new Error('Perspective divide error');
    }

    out[0] = vec4_0[0] / vec4_0[3];
    out[1] = vec4_0[1] / vec4_0[3];
    out[2] = vec4_0[2] / vec4_0[3];
    return out;
  };
}();
// CONCATENATED MODULE: ./global/math/vec4.js


// CONCATENATED MODULE: ./global/math/quat.js


/**
 * QuaternionExp
 *
 * @param {quat} out
 * @param {quat|vec3} a
 * @returns {quat}
 */

quat_namespaceObject.exp = function (out, a) {
  let norm = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);

  if (norm) {
    out[0] = Math.sin(norm) * a[0] / norm;
    out[1] = Math.sin(norm) * a[1] / norm;
    out[2] = Math.sin(norm) * a[2] / norm;
    out[3] = Math.cos(norm);
  } else {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 1.0;
  }

  return out;
};
/**
 * QuaternionLn
 *
 * @param {quat} out
 * @param {quat} q
 * @returns {quat}
 */


quat_namespaceObject.ln = function (out, q) {
  let norm = quat_namespaceObject.length(q);

  if (norm > 1.0001 || norm < 0.99999) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = 0.0;
  } else {
    norm = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]);

    if (norm) {
      let theta = Math.atan2(norm, q[3]) / norm;
      out[0] = theta * q[0];
      out[1] = theta * q[1];
      out[2] = theta * q[2];
      out[3] = 0.0;
    } else {
      out[0] = 0.0;
      out[1] = 0.0;
      out[2] = 0.0;
      out[3] = 0.0;
    }
  }

  return out;
};
/**
 * QuaternionPow
 *
 * @param {quat} out
 * @param {quat} inq
 * @param {number} exponent
 * @returns {quat}
 */


quat_namespaceObject.pow = function (out, inq, exponent) {
  if (exponent === 1) {
    return quat_namespaceObject.copy(out, inq);
  }

  quat_namespaceObject.ln(out, inq);
  out[0] *= exponent;
  out[1] *= exponent;
  out[2] *= exponent;
  out[3] *= exponent;
  quat_namespaceObject.exp(out, out);
  return out;
};
// CONCATENATED MODULE: ./global/math/mat3.js


// CONCATENATED MODULE: ./global/math/mat4.js


/**
 * arcFromForward
 * @param {mat4} out
 * @param {vec3} v
 * @return {mat4} out
 */

mat4_namespaceObject.arcFromForward = function () {
  let vec3_0;
  return function arcFromForward(out, v) {
    if (!vec3_0) vec3_0 = vec3_namespaceObject.create();
    const norm = vec3_namespaceObject.normalize(vec3_0, v);
    mat4_namespaceObject.identity(out);

    if (norm[2] < -0.99999) {
      return out;
    }

    if (norm[2] > 0.99999) {
      out[5] = -1.0;
      out[10] = -1.0;
      return out;
    }

    const h = (1 + norm[2]) / (norm[0] * norm[0] + norm[1] * norm[1]);
    out[0] = h * norm[1] * norm[1] - norm[2];
    out[1] = -h * norm[0] * norm[1];
    out[2] = norm[0];
    out[4] = out[1];
    out[5] = h * norm[0] * norm[0] - norm[2];
    out[6] = norm[1];
    out[8] = -norm[0];
    out[9] = -norm[1];
    out[10] = -norm[2];
    return out;
  };
}();
/**
 * Copies the translation component from one mat4 to another
 * @param {mat4} out
 * @param {mat4} a
 * @returns {mat4} out
 */


mat4_namespaceObject.copyTranslation = function (out, a) {
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  return out;
};
/**
 * Sets a mat4 from a mat4
 * @param {mat4} out
 * @param {mat3} m
 * @returns {mat4} out
 */


mat4_namespaceObject.fromMat3 = function (out, m) {
  out[0] = m[0];
  out[1] = m[1];
  out[2] = m[2];
  out[4] = m[3];
  out[5] = m[4];
  out[6] = m[5];
  out[8] = m[6];
  out[9] = m[7];
  out[10] = m[8];
  out[3] = out[7] = out[11] = out[12] = out[13] = out[14] = 0;
  out[15] = 1;
  return out;
};
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis from a left handed coordinate system
 *
 * @param {mat4} out - mat4 frustum matrix will be written into
 * @param {vec3} eye - Position of the viewer
 * @param {vec3} center - Point the viewer is looking at
 * @param {vec3} up - vec3 pointing up
 * @returns {mat4} out
 */


mat4_namespaceObject.lookAtGL = function () {
  let vec3_0, vec3_1, vec3_2;
  return function lookAtGL(out, eye, center, up) {
    if (!vec3_0) {
      vec3_0 = vec3_namespaceObject.create();
      vec3_1 = vec3_namespaceObject.create();
      vec3_2 = vec3_namespaceObject.create();
    }

    vec3_namespaceObject.subtract(vec3_2, eye, center);

    if (vec3_namespaceObject.squaredLength(vec3_2) === 0) {
      vec3_2[2] = 1;
    }

    vec3_namespaceObject.normalize(vec3_2, vec3_2);
    vec3_namespaceObject.cross(vec3_0, up, vec3_2);

    if (vec3_namespaceObject.squaredLength(vec3_0) === 0) {
      vec3_2[2] += 0.0001;
      vec3_namespaceObject.cross(vec3_0, up, vec3_2);
    }

    vec3_namespaceObject.normalize(vec3_0, vec3_0);
    vec3_namespaceObject.cross(vec3_1, vec3_2, vec3_0);
    out[0] = vec3_0[0];
    out[1] = vec3_0[1];
    out[2] = vec3_0[2];
    out[4] = vec3_1[0];
    out[5] = vec3_1[1];
    out[6] = vec3_1[2];
    out[8] = vec3_2[0];
    out[9] = vec3_2[1];
    out[10] = vec3_2[2];
    return out;
  };
}();
/**
 * Sets a left handed co-ordinate system perspective from a right handed co-ordinate system
 * @param {mat4} out        - receiving mat4
 * @param {number} fovY     - Vertical field of view in radians
 * @param {number} aspect   - Aspect ratio. typically viewport width/height
 * @param {number} near     - Near bound of the frustum
 * @param {number} far      - Far bound of the frustum
 * @returns {mat4} out      - receiving mat4
 */


mat4_namespaceObject.perspectiveGL = function (out, fovY, aspect, near, far) {
  let fH = Math.tan(fovY / 360 * Math.PI) * near;
  let fW = fH * aspect;
  mat4_namespaceObject.frustum(out, -fW, fW, -fH, fH, near, far);
  return out;
};
/**
 * Sets the translation component of a mat4 from a vec3
 * @param {mat4} out
 * @param {vec3} v
 * @returns {mat4} out
 */


mat4_namespaceObject.setTranslation = function (out, v) {
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  return out;
};
/**
 * Sets the translation component of a mat4 from values
 * @param {mat4} out
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @returns {mat4} out
 */


mat4_namespaceObject.setTranslationFromValues = function (out, x, y, z) {
  out[12] = x;
  out[13] = y;
  out[14] = z;
  return out;
};
// CONCATENATED MODULE: ./global/math/noise.js


const noise = {};
/**
 * Generates turbulent noise
 *
 * @param {vec4} out
 * @param {number} pos_0
 * @param {number} pos_1
 * @param {number} pos_2
 * @param {number} pos_3
 * @param {number} power
 * @returns {vec4} out
 */

noise.turbulence = function () {
  const s_noiseLookup = [],
        s_permutations = [],
        s_globalNoiseTemps = [];
  let s_initialized = false;
  /**
   * Initializes noise
   */

  function initialize() {
    for (let i = 0; i < 256; i++) {
      s_noiseLookup[i] = vec4_namespaceObject.fromValues(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
      s_permutations[i] = i;
    }

    let i = 256;

    while (--i) {
      const tmp = s_permutations[i],
            index = Math.floor(Math.random() * 256);
      s_permutations[i] = s_permutations[index];
      s_permutations[index] = tmp;
    }

    for (let i = 0; i < 256; i++) {
      s_permutations[256 + i] = s_permutations[i];
      s_noiseLookup[256 + i] = s_noiseLookup[i];
      s_noiseLookup[256 * 2 + i] = s_noiseLookup[i];
    }

    for (let i = 0; i < 15; ++i) {
      s_globalNoiseTemps[i] = vec3_namespaceObject.create();
    }

    s_initialized = true;
  }

  return function turbulence(out, pos_0, pos_1, pos_2, pos_3, power) {
    if (!s_initialized) initialize();
    pos_0 += 4096;
    pos_1 += 4096;
    pos_2 += 4096;
    pos_3 += 4096;
    let a_0 = Math.floor(pos_0),
        a_1 = Math.floor(pos_1),
        a_2 = Math.floor(pos_2),
        a_3 = Math.floor(pos_3);
    const t_0 = pos_0 - a_0,
          t_1 = pos_1 - a_1,
          t_2 = pos_2 - a_2,
          t_3 = pos_3 - a_3;
    a_0 &= 255;
    a_1 &= 255;
    a_2 &= 255;
    a_3 &= 255;
    const b_0 = a_0 + 1,
          b_1 = a_1 + 1,
          b_2 = a_2 + 1,
          b_3 = a_3 + 1;
    const i = s_permutations[a_0],
          j = s_permutations[b_0];
    const b00 = s_permutations[i + a_1],
          b10 = s_permutations[j + a_1],
          b01 = s_permutations[i + b_1],
          b11 = s_permutations[j + b_1];
    let c00 = vec3_namespaceObject.lerp(s_globalNoiseTemps[0], s_noiseLookup[b00 + a_2 + a_3], s_noiseLookup[b10 + a_2 + a_3], t_0);
    let c10 = vec3_namespaceObject.lerp(s_globalNoiseTemps[1], s_noiseLookup[b01 + a_2 + a_3], s_noiseLookup[b11 + a_2 + a_3], t_0);
    let c01 = vec3_namespaceObject.lerp(s_globalNoiseTemps[2], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
    let c11 = vec3_namespaceObject.lerp(s_globalNoiseTemps[3], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
    let c0 = vec3_namespaceObject.lerp(s_globalNoiseTemps[4], c00, c10, t_1);
    let c1 = vec3_namespaceObject.lerp(s_globalNoiseTemps[5], c01, c11, t_1);
    const c = vec3_namespaceObject.lerp(s_globalNoiseTemps[6], c0, c1, t_2);
    c00 = vec3_namespaceObject.lerp(s_globalNoiseTemps[7], s_noiseLookup[b00 + a_2 + b_3], s_noiseLookup[b10 + a_2 + b_3], t_0);
    c10 = vec3_namespaceObject.lerp(s_globalNoiseTemps[8], s_noiseLookup[b01 + a_2 + b_3], s_noiseLookup[b11 + a_2 + b_3], t_0);
    c01 = vec3_namespaceObject.lerp(s_globalNoiseTemps[9], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
    c11 = vec3_namespaceObject.lerp(s_globalNoiseTemps[10], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
    c0 = vec3_namespaceObject.lerp(s_globalNoiseTemps[11], c00, c10, t_1);
    c1 = vec3_namespaceObject.lerp(s_globalNoiseTemps[12], c01, c11, t_1);
    const d = vec3_namespaceObject.lerp(s_globalNoiseTemps[13], c0, c1, t_2);
    const r = vec3_namespaceObject.lerp(s_globalNoiseTemps[14], c, d, t_3);
    out[0] += r[0] * power;
    out[1] += r[1] * power;
    out[2] += r[2] * power;
    return out;
  };
}();
/**
 * Perlin_noise1
 *
 * @param {number} a
 * @returns {number}
 */


noise.perlin1 = function () {
  let p_initialized = false,
      p_B = 0x100,
      p_BM = 0xff,
      p_N = 0x1000,
      p_p = null,
      p_g1 = null;
  /**
   * Initializes Perlin Noise
   */

  function initialize() {
    p_p = new Array(p_B + p_B + 2);
    p_g1 = new Array(p_B + p_B + 2);
    let i = 0,
        j = 0,
        k = 0;

    for (i = 0; i < p_B; i++) {
      p_p[i] = i;
      p_g1[i] = Math.random() * 2 - 1;
    }

    while (--i) {
      k = p_p[i];
      p_p[i] = p_p[j = Math.floor(Math.random() * p_B)];
      p_p[j] = k;
    }

    for (i = 0; i < p_B + 2; i++) {
      p_p[p_B + i] = p_p[i];
      p_g1[p_B + i] = p_g1[i];
    }

    p_initialized = true;
  }

  return function perlin1(a) {
    if (!p_initialized) initialize();
    let t = a + p_N,
        bx0 = Math.floor(t) & p_BM,
        bx1 = bx0 + 1 & p_BM,
        rx0 = t - Math.floor(t),
        rx1 = rx0 - 1;
    let sx = rx0 * rx0 * (3.0 - 2.0 * rx0),
        u = rx0 * p_g1[p_p[bx0]],
        v = rx1 * p_g1[p_p[bx1]];
    return u + sx * (v - u);
  };
}();
/**
 * PerlinNoise1D
 *
 * @param x
 * @param alpha
 * @param beta
 * @param n
 * @returns {number}
 */


noise.perlin1D = function (x, alpha, beta, n) {
  let sum = 0,
      p = x,
      scale = 1;

  for (let i = 0; i < n; ++i) {
    sum += noise.perlin1(p) / scale;
    scale *= alpha;
    p *= beta;
  }

  return sum;
};
// CONCATENATED MODULE: ./global/math/curve.js
const curve = {};
/**
 * Evaluates a curve
 *
 * @param {{}|Tw2GeometryCurve} curve
 * @param {Array} curve.knots
 * @param {number} curve.degree
 * @param {Array} curve.controls
 * @param {number} curve.dimension
 * @param {number} time
 * @param {*} value
 * @param {boolean} cycle
 * @param {number} duration
 */

curve.evaluate = function (curve, time, value, cycle, duration) {
  let count = curve.knots.length;
  let knot = count - 1;
  let t = 0;

  for (let i = 0; i < curve.knots.length; ++i) {
    if (curve.knots[i] > time) {
      knot = i;
      break;
    }
  }

  if (curve.degree === 0) {
    for (let i = 0; i < curve.dimension; ++i) {
      value[i] = curve.controls[knot * curve.dimension + i];
    }
  } else if (curve.degree === 1) {
    let knot0 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;
    let dt = curve.knots[knot] - curve.knots[knot0];

    if (dt < 0) {
      dt += duration;
    }

    if (dt > 0) {
      t = (time - curve.knots[curve.knots.length - 1]) / dt;
    }

    for (let i = 0; i < curve.dimension; ++i) {
      value[i] = curve.controls[knot0 * curve.dimension + i] * (1 - t) + curve.controls[knot * curve.dimension + i] * t;
    }
  } else {
    let k_2 = cycle ? (knot + count - 2) % count : knot === 0 ? 0 : knot - 2;
    let k_1 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;
    let p1 = k_2 * curve.dimension;
    let p2 = k_1 * curve.dimension;
    let p3 = knot * curve.dimension;
    let ti_2 = curve.knots[k_2];
    let ti_1 = curve.knots[k_1];
    let ti = curve.knots[knot];
    let ti1 = curve.knots[(knot + 1) % count];

    if (ti_2 > ti) {
      ti += duration;
      ti1 += duration;
      time += duration;
    }

    if (ti_1 > ti) {
      ti += duration;
      ti1 += duration;
      time += duration;
    }

    if (ti1 < ti) {
      ti1 += duration;
    }

    let tmti_1 = time - ti_1;
    let tmti_2 = time - ti_2;
    let dL0 = ti - ti_1;
    let dL1_1 = ti - ti_2;
    let dL1_2 = ti1 - ti_1;
    let L0 = tmti_1 / dL0;
    let L1_1 = tmti_2 / dL1_1;
    let L1_2 = tmti_1 / dL1_2;
    let ci_2 = L1_1 + L0 - L0 * L1_1;
    let ci = L0 * L1_2;
    let ci_1 = ci_2 - ci;
    ci_2 = 1 - ci_2;

    for (let i = 0; i < curve.dimension; ++i) {
      value[i] = ci_2 * curve.controls[p1 + i] + ci_1 * curve.controls[p2 + i] + ci * curve.controls[p3 + i];
    }
  }
};
/**
 * ag_horner1
 *
 * @param P
 * @param deg
 * @param s
 * @returns {*}
 */


curve.ag_horner1 = function (P, deg, s) {
  let h = P[deg];

  while (--deg >= 0) h = s * h + P[deg];

  return h;
};
/**
 * ag_zeroin2
 *
 * @param a
 * @param b
 * @param fa
 * @param fb
 * @param tol
 * @param pars
 * @returns {*}
 */


curve.ag_zeroin2 = function (a, b, fa, fb, tol, pars) {
  let test;
  let c, d, e, fc, del, m, machtol, p, q, r, s;
  /* initialization */

  machtol = 1.192092896e-07;
  let label1 = true;
  /* start iteration */

  while (true) {
    if (label1) {
      c = a;
      fc = fa;
      d = b - a;
      e = d;
    }

    if (Math.abs(fc) < Math.abs(fb)) {
      a = b;
      b = c;
      c = a;
      fa = fb;
      fb = fc;
      fc = fa;
    }

    label1 = false;
    /* convergence test */

    del = 2.0 * machtol * Math.abs(b) + 0.5 * tol;
    m = 0.5 * (c - b);
    test = Math.abs(m) > del && fb !== 0.0;

    if (test) {
      if (Math.abs(e) < del || Math.abs(fa) <= Math.abs(fb)) {
        /* bisection */
        d = m;
        e = d;
      } else {
        s = fb / fa;

        if (a === c) {
          /* linear interpolation */
          p = 2.0 * m * s;
          q = 1.0 - s;
        } else {
          /* inverse quadratic interpolation */
          q = fa / fc;
          r = fb / fc;
          p = s * (2.0 * m * q * (q - r) - (b - a) * (r - 1.0));
          q = (q - 1.0) * (r - 1.0) * (s - 1.0);
        }
        /* adjust the sign */


        if (p > 0.0) q = -q;else p = -p;
        /* check if interpolation is acceptable */

        s = e;
        e = d;

        if (2.0 * p < 3.0 * m * q - Math.abs(del * q) && p < Math.abs(0.5 * s * q)) {
          d = p / q;
        } else {
          d = m;
          e = d;
        }
      }
      /* complete step */


      a = b;
      fa = fb;
      if (Math.abs(d) > del) b += d;else if (m > 0.0) b += del;else b -= del;
      fb = curve.ag_horner1(pars.p, pars.deg, b);

      if (fb * (fc / Math.abs(fc)) > 0.0) {
        label1 = true;
      }
    } else {
      break;
    }
  }

  return b;
};
/**
 * ag_zeroin
 *
 * @param a
 * @param b
 * @param tol
 * @param pars
 * @returns {*}
 */


curve.ag_zeroin = function (a, b, tol, pars) {
  let fa, fb;
  fa = curve.ag_horner1(pars.p, pars.deg, a);
  if (Math.abs(fa) < 1.192092896e-07) return a;
  fb = curve.ag_horner1(pars.p, pars.deg, b);
  if (Math.abs(fb) < 1.192092896e-07) return b;
  return curve.ag_zeroin2(a, b, fa, fb, tol, pars);
};
/**
 * polyZeroes
 *
 * @param Poly
 * @param deg
 * @param a
 * @param a_closed
 * @param b
 * @param b_closed
 * @param Roots
 * @returns {*}
 */


curve.polyZeroes = function (Poly, deg, a, a_closed, b, b_closed, Roots) {
  let i, left_ok, right_ok, nr, ndr, skip;
  let e,
      f,
      s,
      pe,
      ps,
      tol,
      p,
      p_x = new Array(22),
      d,
      d_x = new Array(22),
      dr,
      dr_x = new Array(22);
  let ply = {
    p: [],
    deg: 0
  };
  e = pe = 0.0;
  f = 0.0;

  for (i = 0; i < deg + 1; ++i) {
    f += Math.abs(Poly[i]);
  }

  tol = (Math.abs(a) + Math.abs(b)) * (deg + 1) * 1.192092896e-07;
  /* Zero polynomial to tolerance? */

  if (f <= tol) return -1;
  p = p_x;
  d = d_x;
  dr = dr_x;

  for (i = 0; i < deg + 1; ++i) {
    p[i] = 1.0 / f * Poly[i];
  }
  /* determine true degree */


  while (Math.abs(p[deg]) < tol) deg--;
  /* Identically zero poly already caught so constant fn !== 0 */


  nr = 0;
  if (deg === 0) return nr;
  /* check for linear case */

  if (deg === 1) {
    Roots[0] = -p[0] / p[1];
    left_ok = a_closed ? a < Roots[0] + tol : a < Roots[0] - tol;
    right_ok = b_closed ? b > Roots[0] - tol : b > Roots[0] + tol;
    nr = left_ok && right_ok ? 1 : 0;

    if (nr) {
      if (a_closed && Roots[0] < a) Roots[0] = a;else if (b_closed && Roots[0] > b) Roots[0] = b;
    }

    return nr;
  }
  /* handle non-linear case */
  else {
      ply.p = p;
      ply.deg = deg;
      /* compute derivative */

      for (i = 1; i <= deg; i++) d[i - 1] = i * p[i];
      /* find roots of derivative */


      ndr = curve.polyZeroes(d, deg - 1, a, 0, b, 0, dr);
      if (ndr.length === 0) return 0;
      /* find roots between roots of the derivative */

      for (i = skip = 0; i <= ndr; i++) {
        if (nr > deg) return nr;

        if (i === 0) {
          s = a;
          ps = curve.ag_horner1(p, deg, s);
          if (Math.abs(ps) <= tol && a_closed) Roots[nr++] = a;
        } else {
          s = e;
          ps = pe;
        }

        if (i === ndr) {
          e = b;
          skip = 0;
        } else e = dr[i];

        pe = curve.ag_horner1(p, deg, e);
        if (skip) skip = 0;else {
          if (Math.abs(pe) < tol) {
            if (i !== ndr || b_closed) {
              Roots[nr++] = e;
              skip = 1;
            }
          } else if (ps < 0 && pe > 0 || ps > 0 && pe < 0) {
            Roots[nr++] = curve.ag_zeroin(s, e, 0.0, ply);

            if (nr > 1 && Roots[nr - 2] >= Roots[nr - 1] - tol) {
              Roots[nr - 2] = (Roots[nr - 2] + Roots[nr - 1]) * 0.5;
              nr--;
            }
          }
        }
      }
    }

  return nr;
};
// CONCATENATED MODULE: ./global/math/index.js
/* concated harmony reexport num */__webpack_require__.d(__webpack_exports__, "num", function() { return num; });
/* concated harmony reexport vec2 */__webpack_require__.d(__webpack_exports__, "vec2", function() { return vec2_namespaceObject; });
/* concated harmony reexport vec3 */__webpack_require__.d(__webpack_exports__, "vec3", function() { return vec3_namespaceObject; });
/* concated harmony reexport vec4 */__webpack_require__.d(__webpack_exports__, "vec4", function() { return vec4_namespaceObject; });
/* concated harmony reexport quat */__webpack_require__.d(__webpack_exports__, "quat", function() { return quat_namespaceObject; });
/* concated harmony reexport mat3 */__webpack_require__.d(__webpack_exports__, "mat3", function() { return mat3_namespaceObject; });
/* concated harmony reexport mat4 */__webpack_require__.d(__webpack_exports__, "mat4", function() { return mat4_namespaceObject; });
/* concated harmony reexport noise */__webpack_require__.d(__webpack_exports__, "noise", function() { return noise; });
/* concated harmony reexport curve */__webpack_require__.d(__webpack_exports__, "curve", function() { return curve; });









/**
 * TypedArray
 * @typedef {Float64Array|Float32Array|Uint32Array|Uint16Array|Uint8Array|Uint8ClampedArray|Int32Array|Int16Array|Int8Array} TypedArray
 */

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2ParticleElementDeclaration; });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleElementDeclaration
 *
 * @property {number} elementType=4
 * @property {string} customName
 * @property {number} dimension=1
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @class
 */

let Tw2ParticleElementDeclaration =
/*#__PURE__*/
function () {
  function Tw2ParticleElementDeclaration() {
    _classCallCheck(this, Tw2ParticleElementDeclaration);

    _defineProperty(this, "elementType", 4);

    _defineProperty(this, "customName", '');

    _defineProperty(this, "dimension", 1);

    _defineProperty(this, "usageIndex", 0);

    _defineProperty(this, "usedByGPU", true);
  }

  _createClass(Tw2ParticleElementDeclaration, [{
    key: "GetDimension",

    /**
     * Gets the dimension of an element type
     * @returns {number}
     */
    value: function GetDimension() {
      switch (this.elementType) {
        case Tw2ParticleElementDeclaration.Type.LIFETIME:
          return 2;

        case Tw2ParticleElementDeclaration.Type.POSITION:
          return 3;

        case Tw2ParticleElementDeclaration.Type.VELOCITY:
          return 3;

        case Tw2ParticleElementDeclaration.Type.MASS:
          return 1;
      }

      return this.dimension;
    }
    /**
     * GetDeclaration
     * @returns {Tw2VertexElement}
     */

  }, {
    key: "GetDeclaration",
    value: function GetDeclaration() {
      let usage;

      switch (this.elementType) {
        case Tw2ParticleElementDeclaration.Type.LIFETIME:
          usage = _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexDeclaration"].Type.TANGENT;
          break;

        case Tw2ParticleElementDeclaration.Type.POSITION:
          usage = _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexDeclaration"].Type.POSITION;
          break;

        case Tw2ParticleElementDeclaration.Type.VELOCITY:
          usage = _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexDeclaration"].Type.NORMAL;
          break;

        case Tw2ParticleElementDeclaration.Type.MASS:
          usage = _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexDeclaration"].Type.BINORMAL;
          break;

        default:
          usage = _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexDeclaration"].Type.TEXCOORD;
      }

      return new _core__WEBPACK_IMPORTED_MODULE_0__["Tw2VertexElement"](usage, this.usageIndex, _global__WEBPACK_IMPORTED_MODULE_1__[/* device */ "w"].gl.FLOAT, this.GetDimension());
    }
    /**
     * Particle element declaration types
     * @type {{LIFETIME: number, POSITION: number, VELOCITY: number, MASS: number, CUSTOM: number}}
     */

  }]);

  return Tw2ParticleElementDeclaration;
}();

_defineProperty(Tw2ParticleElementDeclaration, "Type", {
  LIFETIME: 0,
  POSITION: 1,
  VELOCITY: 2,
  MASS: 3,
  CUSTOM: 4
});

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2Parameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Tw2VectorParameter; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _Tw2Error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */


/**
 * Tw2Parameter base class
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {Array<Function>} _onModified
 */

let Tw2Parameter =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {string} [name='']
   */
  function Tw2Parameter() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, Tw2Parameter);

    _defineProperty(this, "_id", _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].generateID());

    _defineProperty(this, "name", '');

    _defineProperty(this, "_onModified", []);

    this.name = name;
  }
  /**
   * Gets the parameter's constant buffer size
   * @returns {number} 0 if invalid
   */


  _createClass(Tw2Parameter, [{
    key: "OnValueChanged",

    /**
     * Fire on value changes
     * @property {*} [controller]        - An optional object which changed the parameter's value
     * @property {string[]} [properties] - An optional array for tracking the parameters that were updated
     */
    value: function OnValueChanged(controller, properties) {
      for (let i = 0; i < this._onModified.length; i++) {
        this._onModified[i](this, controller, properties);
      }
    }
    /**
     * Adds a callback which is fired when the parameter's OnValueChanged method is called
     * @param {function} func
     * @returns {boolean} true if successful
     */

  }, {
    key: "AddCallback",
    value: function AddCallback(func) {
      if (!this._onModified.includes(func)) {
        this._onModified.push(func);
      }

      return true;
    }
    /**
     * Removes a callback
     * @param {Function} func
     */

  }, {
    key: "RemoveCallback",
    value: function RemoveCallback(func) {
      const index = this._onModified.indexOf(func);

      if (index !== -1) {
        this._onModified.splice(index, 1);
      }
    }
    /**
     * Gets the parameter's value
     * @param {boolean} [serialize] - forces serialized result
     * @returns {*}
     */

  }, {
    key: "GetValue",
    value: function GetValue(serialize) {}
    /**
     * Binds the parameter
     * @param {*} a
     * @param {*} b
     * @param {*} c
     * @returns {boolean} false if not bound
     */

  }, {
    key: "Bind",
    value: function Bind(a, b, c) {
      return false;
    }
    /**
     * Unbinds the parameter
     */

  }, {
    key: "UnBind",
    value: function UnBind() {}
    /**
     * Applies the parameter to a constant buffer
     * @param {*} a
     * @param {*} b
     * @param {*} c
     */

  }, {
    key: "Apply",
    value: function Apply(a, b, c) {}
    /**
     * Copies another parameter's value
     * @param {*} parameter
     */

  }, {
    key: "Copy",
    value: function Copy(parameter) {}
    /**
     * Clones the parameter
     * @returns {Tw2Parameter}
     */

  }, {
    key: "Clone",
    value: function Clone() {
      const parameter = new this.constructor();
      parameter.Copy(this, true);
      return parameter;
    }
    /**
     * The parameter's constant buffer size
     * @type {number}
     */

  }, {
    key: "size",
    get: function get() {
      return this.constructor.constantBufferSize;
    }
  }]);

  return Tw2Parameter;
}();
/**
 * Tw2VectorParameter base class
 *
 * @property {Float32Array} value
 * @property {?Float32Array} constantBuffer
 * @property {?number} offset
 * @class
 */

_defineProperty(Tw2Parameter, "constantBufferSize", 0);

let Tw2VectorParameter =
/*#__PURE__*/
function (_Tw2Parameter) {
  _inherits(Tw2VectorParameter, _Tw2Parameter);

  /**
   * Constructor
   * @param {string} [name='']
   * @param {Float32Array|Array} [value]
   */
  function Tw2VectorParameter(name, value) {
    var _this;

    _classCallCheck(this, Tw2VectorParameter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2VectorParameter).call(this, name));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "constantBuffer", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "offset", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "value", new Float32Array(_this.size));

    if (value) _this.value.set(value);
    return _this;
  }
  /**
   * Sets the parameter's value
   * @param {Float32Array} value
   */


  _createClass(Tw2VectorParameter, [{
    key: "SetValue",
    value: function SetValue(value) {
      this.value.set(value);
      this.OnValueChanged();
    }
    /**
     * Sets a parameter's value at a given index
     * @param {number} index   - the parameter's value index to change
     * @param {number} value   - the value to set
     * @throw Index Error
     */

  }, {
    key: "SetIndexValue",
    value: function SetIndexValue(index, value) {
      if (this.value[index] !== undefined) {
        if (this.value[index] !== value) {
          this.value[index] = value;
          this.OnValueChanged();
        }

        return;
      }

      throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrIndexBounds */ "n"]();
    }
    /**
     * Gets the parameter's value
     * @param {boolean} [serialize] - An optional parameter to force a serialized result
     * @returns {Array|Float32Array}
     */

  }, {
    key: "GetValue",
    value: function GetValue(serialize) {
      const value = this.constantBuffer ? this.constantBuffer.subarray(this.offset, this.offset + this.size) : this.value;
      return serialize ? Array.from(value) : new Float32Array(value);
    }
    /**
     * Gets a parameter's value at a given index
     * @param index
     * @returns {number}
     * @throw Index Error
     */

  }, {
    key: "GetIndexValue",
    value: function GetIndexValue(index) {
      if (this.value[index] !== undefined) {
        return this.value[index];
      }

      throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrIndexBounds */ "n"]();
    }
    /**
     * Fire on value changes
     * @param {*} [controller]        - An optional parameter for tracking the object that called the function
     * @param {string[]} [properties] - An optional array for tracking the parameters that were updated
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged(controller, properties) {
      if (this.constantBuffer) {
        this.Apply(this.constantBuffer, this.offset);
      }

      _get(_getPrototypeOf(Tw2VectorParameter.prototype), "OnValueChanged", this).call(this, controller, properties);
    }
    /**
     * Binds the parameter to a constant buffer
     * @param {Float32Array} constantBuffer
     * @param {number} offset
     * @param {number} size
     * @returns {boolean} true if bound
     */

  }, {
    key: "Bind",
    value: function Bind(constantBuffer, offset, size) {
      if (!this.constantBuffer && size >= this.size) {
        this.constantBuffer = constantBuffer;
        this.offset = offset;
        this.Apply(constantBuffer, offset, size);
        return true;
      }

      return false;
    }
    /**
     * Unbinds the parameter from a constant buffer
     */

  }, {
    key: "Unbind",
    value: function Unbind() {
      this.constantBuffer = null;
    }
    /**
     * Applies the parameter's value to it's constant buffer
     * @param {Float32Array} constantBuffer
     * @param {number} offset
     * @param {number} [size]
     */

  }, {
    key: "Apply",
    value: function Apply(constantBuffer, offset, size) {
      constantBuffer.set(this.value, offset);
    }
    /**
     * Checks if a value equals the parameter's value
     * - Assumes the correct length array or typed array is passed
     * @param {Array|Float32Array} value
     * @returns {boolean}
     */

  }, {
    key: "EqualsValue",
    value: function EqualsValue(value) {
      for (let i = 0; i < this.size; i++) {
        if (this.value[i] !== value[i]) {
          return false;
        }
      }

      return true;
    }
    /**
     * Copies another parameter's value
     * @param {Tw2VectorParameter|*} parameter
     * @param {boolean} [includeName]
     */

  }, {
    key: "Copy",
    value: function Copy(parameter, includeName) {
      if (includeName) this.name = parameter.name;
      this.SetValue(parameter.GetValue());
    }
    /**
     * Checks if a value is a valid parameter input
     * @param {Float32Array|Array} value
     * @returns {boolean}
     */

  }], [{
    key: "isValue",
    value: function isValue(value) {
      return _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].isArrayLike(value) && value.length === this.constantBufferSize;
    }
  }]);

  return Tw2VectorParameter;
}(Tw2Parameter);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./core/vertex/Tw2VertexElement.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2VertexElement
 *
 * @property {number} usage
 * @property {number} usageIndex
 * @property {number} type
 * @property {number} elements
 * @property {number} offset
 * @property location
 * @property customSetter
 * @class
 */
let Tw2VertexElement =
/**
 * Constructor
 * @param {number} usage
 * @param {number} usageIndex
 * @param {number} type
 * @param {number} elements
 * @param {number} [offset=0]
 */
function Tw2VertexElement(usage, usageIndex, type, elements) {
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  _classCallCheck(this, Tw2VertexElement);

  _defineProperty(this, "usage", null);

  _defineProperty(this, "usageIndex", null);

  _defineProperty(this, "type", null);

  _defineProperty(this, "elements", null);

  _defineProperty(this, "offset", 0);

  _defineProperty(this, "location", null);

  _defineProperty(this, "customSetter", null);

  this.usage = usage;
  this.usageIndex = usageIndex;
  this.type = type;
  this.elements = elements;
  this.offset = offset;
};
// CONCATENATED MODULE: ./core/vertex/Tw2VertexDeclaration.js
function Tw2VertexDeclaration_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function Tw2VertexDeclaration_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2VertexDeclaration
 *
 * @property {Array.<Tw2VertexElement>} elements
 * @property {Array.<Tw2VertexElement>} _elementsSorted
 * @class
 */

let Tw2VertexDeclaration_Tw2VertexDeclaration =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {Array<Array|Object>} [declarations]
   * @param {number} [stride]
   */
  function Tw2VertexDeclaration(declarations, stride) {
    Tw2VertexDeclaration_classCallCheck(this, Tw2VertexDeclaration);

    Tw2VertexDeclaration_defineProperty(this, "elements", []);

    Tw2VertexDeclaration_defineProperty(this, "_elementsSorted", []);

    Tw2VertexDeclaration_defineProperty(this, "stride", null);

    if (stride !== undefined) {
      this.stride = stride;
    }

    if (declarations) {
      this.DeclareFromObject(declarations);
    }
  }
  /**
   * Re-sorts elements
   */


  _createClass(Tw2VertexDeclaration, [{
    key: "RebuildHash",
    value: function RebuildHash() {
      this._elementsSorted = [];

      for (let i = 0; i < this.elements.length; ++i) {
        this._elementsSorted[i] = this.elements[i];
      }

      this._elementsSorted.sort(Tw2VertexDeclaration.CompareDeclarationElements);
    }
    /**
     * Finds an element by it's usage type and usage index
     * @param {number} usage
     * @param {number} usageIndex
     * @returns {Tw2VertexElement|null}
     */

  }, {
    key: "FindUsage",
    value: function FindUsage(usage, usageIndex) {
      for (let i = 0; i < this._elementsSorted.length; ++i) {
        const e = this._elementsSorted[i];

        if (e.usage === usage) {
          if (e.usageIndex === usageIndex) {
            return e;
          } else if (e.usageIndex > usageIndex) {
            return null;
          }
        }

        if (e.usage > usage) {
          return null;
        }
      }

      return null;
    }
    /**
     * SetDeclaration
     * @param {Tw2VertexDeclaration} inputDecl
     * @param {number} stride
     * @returns {boolean}
     */

  }, {
    key: "SetDeclaration",
    value: function SetDeclaration(inputDecl, stride) {
      const gl = global["w" /* device */].gl;
      let index = 0;

      for (let i = 0; i < inputDecl._elementsSorted.length; ++i) {
        const el = inputDecl._elementsSorted[i];
        if (el.location < 0) continue;

        while (true) {
          if (index >= this._elementsSorted.length) {
            gl.disableVertexAttribArray(el.location);
            gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
            break;
          }

          const input = this._elementsSorted[index],
                cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el);

          if (cmp > 0) {
            gl.disableVertexAttribArray(el.location);
            gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
            break;
          }

          if (cmp === 0) {
            if (input.customSetter) {
              input.customSetter(el);
            } else {
              gl.enableVertexAttribArray(el.location);
              gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
            }

            break;
          }

          index++;
        }
      }

      return true;
    }
    /**
     * SetPartialDeclaration
     * @param {Tw2VertexDeclaration} inputDecl
     * @param {number} stride
     * @param {number} [usageOffset=0]
     * @param {number} [divisor=0]
     * @returns {Array} ResetData
     */

  }, {
    key: "SetPartialDeclaration",
    value: function SetPartialDeclaration(inputDecl, stride) {
      let usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let divisor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      const ext = global["w" /* device */].ext,
            gl = global["w" /* device */].gl,
            resetData = [];
      let index = 0;

      for (let i = 0; i < inputDecl._elementsSorted.length; ++i) {
        const el = inputDecl._elementsSorted[i];
        if (el.location < 0) continue;

        while (true) {
          const input = this._elementsSorted[index],
                cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el, usageOffset);

          if (cmp === 0) {
            if (input.customSetter) {
              input.customSetter(el);
            } else {
              gl.enableVertexAttribArray(el.location);
              gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
              ext.vertexAttribDivisor(el.location, divisor);

              if (divisor) {
                resetData.push(el.location);
              }
            }

            break;
          } else if (cmp > 0) {
            if (!divisor) {
              gl.disableVertexAttribArray(el.location);
              gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
            }

            break;
          }

          index++;

          if (index >= this._elementsSorted.length) {
            if (!divisor) {
              gl.disableVertexAttribArray(el.location);
              gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
            }

            return resetData;
          }
        }
      }

      return resetData;
    }
    /**
     * ResetInstanceDivisors
     * @param {Array} resetData
     */

  }, {
    key: "ResetInstanceDivisors",
    value: function ResetInstanceDivisors(resetData) {
      if (resetData) {
        for (let i = 0; i < resetData.length; ++i) {
          global["w" /* device */].ext.vertexAttribDivisor(resetData[i], 0);
        }
      }
    }
    /**
     * Sets vertex declarations from an array of arrays, or an array of objects
     * @param {Array<Array>|Array<Object>} declarations
     * @param {number} [stride]
     */

  }, {
    key: "DeclareFromObject",
    value: function DeclareFromObject(declarations, stride) {
      this.elements.splice(0, this.elements.length);
      let currentOffset = 0;

      for (let i = 0; i < declarations.length; i++) {
        const decl = declarations[i];
        let usage, usageIndex, type, elements, offset;

        if (global["F" /* util */].isArray(decl)) {
          usage = decl[0];
          usageIndex = decl[1];
          elements = decl[2];
          type = decl[3];
          offset = decl[4];
        } else {
          usage = decl.usage;
          usageIndex = decl.usageIndex;
          elements = decl.elements;
          type = decl.type;
          offset = decl.offset;
        }

        if (global["F" /* util */].isString(usage)) {
          usage = Tw2VertexDeclaration.Type[usage.toUpperCase()];
        }

        if (global["F" /* util */].isNoU(type)) {
          type = 'FLOAT';
        }

        if (global["F" /* util */].isString(type)) {
          type = global["w" /* device */].gl[type.toUpperCase()];
        }

        if (global["F" /* util */].isNoU(offset)) {
          offset = currentOffset;
        }

        this.elements.push(new Tw2VertexElement(usage, usageIndex, type, elements, offset));
        currentOffset += elements * 4;
      }

      if (stride !== undefined) {
        this.stride = stride;
      }

      this.RebuildHash();
    }
    /**
     * CompareDeclarationElements
     * @param {Tw2VertexElement} a
     * @param {Tw2VertexElement} b
     * @param {number} [usageOffset=0]
     * @returns {number}
     * @function
     */

  }], [{
    key: "CompareDeclarationElements",
    value: function CompareDeclarationElements(a, b) {
      let usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (a.usage < b.usage) return -1;
      if (a.usage > b.usage) return 1;
      if (a.usageIndex + usageOffset < b.usageIndex) return -1;
      if (a.usageIndex + usageOffset > b.usageIndex) return 1;
      return 0;
    }
    /**
     * Vertex Declaration Types
     * @type {*}
     */

  }]);

  return Tw2VertexDeclaration;
}();

Tw2VertexDeclaration_defineProperty(Tw2VertexDeclaration_Tw2VertexDeclaration, "Type", {
  POSITION: 0,
  COLOR: 1,
  NORMAL: 2,
  TANGENT: 3,
  BINORMAL: 4,
  TEXCOORD: 5,
  BLENDWEIGHT: 6,
  BLENDINDICES: 7
});
// CONCATENATED MODULE: ./core/vertex/index.js
/* concated harmony reexport Tw2VertexDeclaration */__webpack_require__.d(__webpack_exports__, "a", function() { return Tw2VertexDeclaration_Tw2VertexDeclaration; });
/* concated harmony reexport Tw2VertexElement */__webpack_require__.d(__webpack_exports__, "b", function() { return Tw2VertexElement; });



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2Resource; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _Tw2Error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Resource base class
 *
 * @param {string} [path='']
 * @property {string} path
 * @property {boolean} _isLoading
 * @property {boolean} _isGood
 * @property {boolean} _isPurged
 * @property {Array} _notifications
 * @property {number} activeFrame
 * @property {number} doNotPurge
 * @class
 */

let Tw2Resource =
/*#__PURE__*/
function () {
  function Tw2Resource() {
    _classCallCheck(this, Tw2Resource);

    _defineProperty(this, "path", '');

    _defineProperty(this, "_isLoading", false);

    _defineProperty(this, "_isGood", false);

    _defineProperty(this, "_isPurged", false);

    _defineProperty(this, "_notifications", []);

    _defineProperty(this, "activeFrame", 0);

    _defineProperty(this, "doNotPurge", 0);
  }

  _createClass(Tw2Resource, [{
    key: "IsLoading",

    /**
     * Checks to see if the resource is loading
     * @returns {boolean}
     */
    value: function IsLoading() {
      this.KeepAlive();
      return this._isLoading;
    }
    /**
     * Checks to see if the resource is good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      this.KeepAlive();
      return this._isGood;
    }
    /**
     * Checks to see if the resource has been purged
     * @returns {boolean}
     */

  }, {
    key: "IsPurged",
    value: function IsPurged() {
      return this._isPurged;
    }
    /**
     * Unloads the resource
     */

  }, {
    key: "Unload",
    value: function Unload() {}
    /**
     * Reloads the resource
     */

  }, {
    key: "Reload",
    value: function Reload() {
      this.Unload();
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].ReloadResource(this);
    }
    /**
     * Keeps the resource from being purged
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      this.activeFrame = _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].activeFrame;

      if (this.IsPurged()) {
        this.Reload();
      }
    }
    /**
     * Gets an array of resource errors, or an empty array if there are none
     * @returns {Array.<Tw2Error|Error>}
     */

  }, {
    key: "GetErrors",
    value: function GetErrors() {
      return _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].motherLode.GetErrors(this.path);
    }
    /**
     * Checks if the resource has errors
     * @returns {boolean}
     */

  }, {
    key: "HasErrors",
    value: function HasErrors() {
      return _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].motherLode.HasErrors(this.path);
    }
    /**
     * Fires on errors
     * @param {Error} err
     * @returns {Error}
     */

  }, {
    key: "OnError",
    value: function OnError() {
      let err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* Tw2Error */ "B"]();
      this._isGood = false;
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent('error', this.path, {
        type: 'error',
        message: err.message,
        err
      });
      this.UpdateNotifications('OnResError');
      return err;
    }
    /**
     * Fires on warnings
     * @param {*} [eventLog]
     */

  }, {
    key: "OnWarning",
    value: function OnWarning(eventLog) {
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent('warning', this.path, eventLog);
    }
    /**
     * Fires on debugs
     * @param {*} eventLog
     */

  }, {
    key: "OnDebug",
    value: function OnDebug(eventLog) {
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent('debug', this.path, eventLog);
    }
    /**
     * LoadStarted
     * @param {*} [eventLog]
     */

  }, {
    key: "OnRequested",
    value: function OnRequested(eventLog) {
      this._isLoading = true;
      this._isPurged = false;
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent(this.IsPurged() ? 'reloading' : 'requested', this.path, eventLog);
      this.UpdateNotifications('ReleaseCachedData');
    }
    /**
     * LoadFinished
     * @param {*} [eventLog]
     */

  }, {
    key: "OnLoaded",
    value: function OnLoaded(eventLog) {
      this._isLoading = false;

      if (!this.HasErrors()) {
        _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent('loaded', this.path, eventLog);
      }
    }
    /**
     * PrepareFinished
     * @param {*} [eventLog]
     */

  }, {
    key: "OnPrepared",
    value: function OnPrepared(eventLog) {
      this._isLoading = false;

      if (!this.HasErrors()) {
        this._isGood = true;
        _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent('prepared', this.path, eventLog);
        this.UpdateNotifications('RebuildCachedData');
      }
    }
    /**
     * Fires when the resource has been unloads
     * @param {*} [eventLog]
     */

  }, {
    key: "OnUnloaded",
    value: function OnUnloaded(eventLog) {
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].OnResEvent(this.IsPurged() ? 'purged' : 'unloaded', this.path, eventLog);
    }
    /**
     * Registers a notification
     * @param {*} notification
     */

  }, {
    key: "RegisterNotification",
    value: function RegisterNotification(notification) {
      if (!this._notifications.includes(notification)) {
        this._notifications.push(notification);

        if (this.HasErrors()) {
          if ('OnResError' in notification) {
            notification['OnResError'](this);
          }
        } else if (this.IsGood() && 'RebuildCachedData' in notification) {
          notification.RebuildCachedData(this);
        }
      }
    }
    /**
     * Deregisters a notification
     * @param {*} notification
     */

  }, {
    key: "UnregisterNotification",
    value: function UnregisterNotification(notification) {
      this._notifications.splice(this._notifications.indexOf(notification), 1);
    }
    /**
     * Updates a notification
     * @param {string} funcName - The function name to call
     */

  }, {
    key: "UpdateNotifications",
    value: function UpdateNotifications(funcName) {
      for (let i = 0; i < this._notifications.length; i++) {
        if (funcName in this._notifications[i]) {
          this._notifications[i][funcName](this);
        }
      }
    }
  }]);

  return Tw2Resource;
}();
/**
 * An optional function for when the resource handles it's own loading
 * -  If the method returns false then the resource manager will handle the http request
 * @type {?Function}
 * @returns {boolean}
 */

Tw2Resource.prototype.DoCustomLoad = null;
/**
 * HTTP request response type
 * @type {null}
 */

Tw2Resource.prototype.requestResponseType = null;

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2TextureParameter; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _sampler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _Tw2Parameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _resource_Tw2TextureRes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * Tw2TextureParameter
 *
 * @property {string} name
 * @property {boolean} useAllOverrides
 * @property {number} addressUMode
 * @property {number} addressVMode
 * @property {number} addressWMode
 * @property {number} filterMode
 * @property {number} mapFilterMode
 * @property {number} maxAnisotropy
 * @property {Tw2TextureRes} textureRes
 * @property {Tw2SamplerState} _sampler
 * @class
 */

let Tw2TextureParameter =
/*#__PURE__*/
function (_Tw2Parameter) {
  _inherits(Tw2TextureParameter, _Tw2Parameter);

  /**
   * Constructor
   * @param {string} [name]        - Name of the texture parameter
   * @param {string} [texturePath] - The texture's resource path
   */
  function Tw2TextureParameter(name, texturePath) {
    var _this;

    _classCallCheck(this, Tw2TextureParameter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2TextureParameter).call(this, name));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "resourcePath", '');

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "useAllOverrides", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addressUMode", 1);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addressVMode", 1);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "addressWMode", 1);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "filterMode", 2);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "mipFilterMode", 2);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "maxAnisotropy", 4);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "textureRes", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_sampler", null);

    if (texturePath) {
      _this.resourcePath = texturePath;

      _this.Initialize();
    }

    return _this;
  }
  /**
   * Checks if the parameter has a texture that was attached
   * @returns {boolean}
   */


  _createClass(Tw2TextureParameter, [{
    key: "Initialize",

    /**
     * Initializes the texture
     */
    value: function Initialize() {
      this.OnValueChanged();
    }
    /**
     * Sets the texture path
     * @param {string} value
     * @returns {boolean} true if changed
     */

  }, {
    key: "SetTexturePath",
    value: function SetTexturePath(value) {
      this.resourcePath = value;
      this.OnValueChanged();
    }
    /**
     * Returns the texture's resource path
     * @returns {?string}
     */

  }, {
    key: "GetValue",
    value: function GetValue() {
      return this.isTextureAttached ? null : this.resourcePath;
    }
    /**
     * Sets the texture's resource manually
     * @param {Tw2TextureRes} res
     * @returns {boolean}
     */

  }, {
    key: "SetTextureRes",
    value: function SetTextureRes(res) {
      if (this.textureRes === res) return false;
      this.resourcePath = '';
      this.textureRes = res;
      if (this.textureRes) this.textureRes._isAttached = true;
      return true;
    }
    /**
     * Fire on value changes
     * @param {*} [controller]        - An optional parameter for tracking the object that called this function
     * @param {string[]} [properties] - An optional array for tracking the properties that were modified
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged(controller, properties) {
      if (this.resourcePath !== '') {
        if (this.resourcePath.indexOf('rgba:/') === 0) {
          if (!this.textureRes || this.textureRes.path !== this.resourcePath) {
            const color = this.resourcePath.replace('rgba:/', '').split(','),
                  texture = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].CreateSolidTexture([parseFloat(color[0]), parseFloat(color[1]), parseFloat(color[2]), color[3] !== undefined ? parseFloat(color[3]) : 255]);
            this.textureRes = new _resource_Tw2TextureRes__WEBPACK_IMPORTED_MODULE_3__[/* Tw2TextureRes */ "a"]();
            this.textureRes.path = this.resourcePath;
            this.textureRes.Attach(texture);
          }
        } else {
          this.resourcePath = this.resourcePath.toLowerCase();
          this.textureRes = this.resourcePath !== '' ? _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].GetResource(this.resourcePath) : null;
        }
      }

      this.UpdateOverrides();

      _get(_getPrototypeOf(Tw2TextureParameter.prototype), "OnValueChanged", this).call(this, controller, properties);
    }
    /**
     * Apply
     * @param {number} stage
     * @param {Tw2SamplerState} sampler
     * @param {number} slices
     */

  }, {
    key: "Apply",
    value: function Apply(stage, sampler, slices) {
      if (this.textureRes) {
        if (this.useAllOverrides && this._sampler) {
          this._sampler.samplerType = sampler.samplerType;
          this._sampler.isVolume = sampler.isVolume;
          this._sampler.registerIndex = sampler.registerIndex;
          sampler = this._sampler;
        }

        _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].gl.activeTexture(_global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].gl.TEXTURE0 + stage);
        this.textureRes.Bind(sampler, slices);
      }
    }
    /**
     * Sets the textures overrides
     * @param {{}} [opt={}] - An object containing the override options to set
     */

  }, {
    key: "SetOverrides",
    value: function SetOverrides() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].assignIfExists(this, opt, Tw2TextureParameter.overrideProperties);
      this.OnValueChanged();
    }
    /**
     * Gets the texture's overrides
     * @returns {{}}
     */

  }, {
    key: "GetOverrides",
    value: function GetOverrides() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].assignIfExists(out, this, Tw2TextureParameter.overrideProperties);
      return out;
    }
    /**
     * Updates the parameter's overrides
     */

  }, {
    key: "UpdateOverrides",
    value: function UpdateOverrides() {
      if (this.useAllOverrides) {
        this._sampler = this._sampler || new _sampler__WEBPACK_IMPORTED_MODULE_1__[/* Tw2SamplerState */ "b"]();
        const wrapModes = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].wrapModes,
              gl = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].gl,
              sampler = this._sampler;

        if (this.filterMode === 1) {
          switch (this.mipFilterMode) {
            case 0:
              sampler.minFilter = gl.NEAREST;
              break;

            case 1:
              sampler.minFilter = gl.NEAREST_MIPMAP_NEAREST;
              break;

            default:
              sampler.minFilter = gl.NEAREST_MIPMAP_LINEAR;
          }

          sampler.minFilterNoMips = gl.NEAREST;
          sampler.magFilter = gl.NEAREST;
        } else {
          switch (this.mipFilterMode) {
            case 0:
              sampler.minFilter = gl.LINEAR;
              break;

            case 1:
              sampler.minFilter = gl.LINEAR_MIPMAP_NEAREST;
              break;

            default:
              sampler.minFilter = gl.LINEAR_MIPMAP_LINEAR;
          }

          sampler.minFilterNoMips = gl.LINEAR;
          sampler.magFilter = gl.LINEAR;
        }

        sampler.addressU = wrapModes[this.addressUMode];
        sampler.addressV = wrapModes[this.addressVMode];
        sampler.addressW = wrapModes[this.addressWMode];
        sampler.anisotropy = this.maxAnisotropy;
        sampler.ComputeHash();
      } else if (this._sampler) {
        this._sampler = null;
      }
    }
    /**
     * Checks if a value is equal to the parameter's resource path
     * @param {*} value
     * @returns {boolean}
     */

  }, {
    key: "EqualsValue",
    value: function EqualsValue(value) {
      return value.toLowerCase() === this.GetValue();
    }
    /**
     * Copies another texture parameter's values
     * @param {Tw2TextureParameter} parameter
     * @param {boolean} [includeName]
     */

  }, {
    key: "Copy",
    value: function Copy(parameter, includeName) {
      if (includeName) this.name = parameter.name;
      this.resourcePath = parameter.resourcePath;
      this.SetOverrides(parameter.GetOverrides);
    }
    /**
     * Clones the texture parameter
     * @returns {Tw2TextureParameter}
     */

  }, {
    key: "Clone",
    value: function Clone() {
      const parameter = new Tw2TextureParameter();
      parameter.Copy(this, true);
      return parameter;
    }
    /**
     * Gets the texture's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>}
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.textureRes && !out.includes(this.textureRes)) {
        out.push(this.textureRes);
      }

      return out;
    }
    /**
     * Checks if a value is a valid parameter value
     * @param {*} a
     * @returns {boolean}
     */

  }, {
    key: "isTextureAttached",
    get: function get() {
      return this.textureRes && this.textureRes._isAttached;
    }
  }], [{
    key: "isValue",
    value: function isValue(a) {
      return _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].isString(a);
    }
    /**
     * The texture parameter's override properties
     * @type {string[]}
     */

  }]);

  return Tw2TextureParameter;
}(_Tw2Parameter__WEBPACK_IMPORTED_MODULE_2__[/* Tw2Parameter */ "a"]);
/**
 * Alias for {@link Tw2TextureParameter.SetTexturePath}
 * @type {Tw2TextureParameter.SetTexturePath}
 */

_defineProperty(Tw2TextureParameter, "overrideProperties", ['useAllOverrides', 'addressUMode', 'addressVMode', 'addressWMode', 'filterMode', 'mipFilterMode', 'maxAnisotropy']);

Tw2TextureParameter.prototype.SetValue = Tw2TextureParameter.prototype.SetTexturePath;

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2EventEmitter; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Emitter privates
 * @type {WeakMap<object, *>}
 */
const PRIVATE = new WeakMap();
/**
 * Tw2EventEmitter
 * @class
 */

let Tw2EventEmitter =
/*#__PURE__*/
function () {
  function Tw2EventEmitter() {
    _classCallCheck(this, Tw2EventEmitter);
  }

  _createClass(Tw2EventEmitter, [{
    key: "emit",

    /**
     * Emits an event
     * @param {string} eventName
     * @param {*} [e={}]
     * @returns {Tw2EventEmitter}
     */
    value: function emit(eventName) {
      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Short cut to creating a log output
      if (e.log && !e.log._logged) {
        e.log = this.log(e.log);
      }

      const events = PRIVATE.get(this);
      if (!events) return this;
      eventName = eventName.toLowerCase();

      if (eventName in events) {
        events[eventName].forEach(function (value, key) {
          key.call(value.context, e);
          if (value.once) events[eventName].delete(key);
        });
      }

      return this;
    }
    /**
     * Adds a listener to an event
     * @param {Array|string} eventName
     * @param {Function} listener
     * @param {*} [context=undefined]
     * @param {boolean} [once=false]
     * @returns {Tw2EventEmitter}
     */

  }, {
    key: "on",
    value: function on(eventName, listener) {
      let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      let events = PRIVATE.get(this);

      if (!events) {
        events = {};
        PRIVATE.set(this, events);
      }

      eventName = eventName.toLowerCase();
      if (!events[eventName]) events[eventName] = new Set();
      events[eventName].add(listener, {
        context: context,
        once: once
      });
      return this;
    }
    /**
     * Adds a listener to an event, and clears it after it's first emit
     * @param {string} eventName
     * @param {Function} listener
     * @param {*} [context]
     * @returns {Tw2EventEmitter}
     */

  }, {
    key: "once",
    value: function once(eventName, listener, context) {
      return this.on(eventName, listener, context, true);
    }
    /**
     * Removes a listener from a specific event or from all by passing '*' as the eventName
     * @param {string} eventName
     * @param {Function} listener
     * @returns {Tw2EventEmitter}
     */

  }, {
    key: "off",
    value: function off(eventName, listener) {
      const events = PRIVATE.get(this);
      if (!events) return this;
      eventName = eventName.toLowerCase();

      if (eventName === '*') {
        for (const name in events) {
          if (events.hasOwnProperty(name)) {
            events[name].delete(listener);
          }
        }
      } else if (eventName in events) {
        events[eventName].delete(listener);
      }

      return this;
    }
    /**
     * Deletes an event and it's listeners
     * @param {string} eventName
     * @returns {Tw2EventEmitter}
     */

  }, {
    key: "del",
    value: function del(eventName) {
      const events = PRIVATE.get(this);
      if (!events) return this;
      eventName = eventName.toLowerCase();
      if (eventName in events) delete events[eventName];
      return this;
    }
    /**
     * Clears a listener from all events
     * @param {Function} listener
     * @returns {Tw2EventEmitter}
     */

  }, {
    key: "clr",
    value: function clr(listener) {
      const events = PRIVATE.get(this);
      if (!events) return this;

      for (let eventName in events) {
        if (events.hasOwnProperty(eventName) && events[eventName].has(listener)) {
          events[eventName].delete(listener);
        }
      }

      return this;
    }
    /**
     * Kills all events and listeners from the emitter
     * @returns {Tw2EventEmitter}
     * @emit event_kill
     */

  }, {
    key: "kill",
    value: function kill() {
      if (PRIVATE.has(this)) {
        this.emit('kill');
        PRIVATE.delete(this);
      }

      return this;
    }
    /**
     * Logs an event log
     * @param {eventLog|Error} eventLog
     * @returns {eventLog}
     */

  }, {
    key: "log",
    value: function log(eventLog) {
      if (!eventLog.name) {
        eventLog.name = this.constructor.category || this.constructor.name;
      }

      if (!this.constructor.defaultLogger) {
        return eventLog;
      }

      return this.constructor.defaultLogger.log(eventLog, this);
    }
    /**
     * Global logger
     * @type {*}
     */

  }]);

  return Tw2EventEmitter;
}();

_defineProperty(Tw2EventEmitter, "defaultLogger", null);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2TextureRes; });
/* harmony import */ var _Tw2Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _Tw2Error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2TextureRes
 *
 * @property {WebGLTexture} texture
 * @property {boolean} isCube
 * @property {number} width
 * @property {number} height
 * @property {boolean} hasMipMaps
 * @property {boolean} enableMipMaps
 * @property {?string} requestResponseType
 * @property {number} _currentSampler
 * @property {boolean} _isAttached    - identifies if the texture was attached rather than loaded
 * @property {?string} _extension     - loading file extension
 * @inherit Tw2Resource
 */

let Tw2TextureRes =
/*#__PURE__*/
function (_Tw2Resource) {
  _inherits(Tw2TextureRes, _Tw2Resource);

  function Tw2TextureRes() {
    var _this;

    _classCallCheck(this, Tw2TextureRes);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2TextureRes).call(this, ...args));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "texture", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isCube", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "width", 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "height", 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "hasMipMaps", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "requestResponseType", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_currentSampler", 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_isAttached", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_extension", null);

    return _this;
  }

  _createClass(Tw2TextureRes, [{
    key: "Prepare",

    /**
     * Prepares the resource
     * @param {*|Image|arrayBuffer} data
     */
    value: function Prepare(data) {
      const gl = _global__WEBPACK_IMPORTED_MODULE_2__[/* device */ "w"].gl;
      const format = 'ccpGLFormat' in data ? data['ccpGLFormat'] : gl.RGBA;

      switch (this._extension) {
        case 'cube':
          this.texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = data.height;
          const ctx = canvas.getContext('2d');

          for (let j = 0; j < 6; ++j) {
            ctx.drawImage(data, j * canvas.width, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, format, format, gl.UNSIGNED_BYTE, canvas);
          }

          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
          this.width = canvas.width;
          this.height = canvas.height;
          this.hasMipMaps = true;
          break;

        case 'png':
          this.texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, format, format, gl.UNSIGNED_BYTE, data);
          this.hasMipMaps = Tw2TextureRes.IsPowerOfTwo(data.width) && Tw2TextureRes.IsPowerOfTwo(data.height);
          if (this.hasMipMaps) gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.width = data.width;
          this.height = data.height;
          break;

        /*
          DDS methods based off work by Brandon Jones and Babylon
        -----------------------------------------------------------------------
        Copyright (c) 2012 Brandon Jones
          This software is provided 'as-is', without any express or implied
        warranty. In no event will the authors be held liable for any damages
        arising from the use of this software.
          Permission is granted to anyone to use this software for any purpose,
        including commercial applications, and to alter it and redistribute it
        freely, subject to the following restrictions:
          1. The origin of this software must not be misrepresented; you must not
        claim that you wrote the original software. If you use this software
        in a product, an acknowledgment in the product documentation would be
        appreciated but is not required.
          2. Altered source versions must be plainly marked as such, and must not
        be misrepresented as being the original software.
          3. This notice may not be removed or altered from any source
        distribution.
          */

        case 'dds':
          const ext = _global__WEBPACK_IMPORTED_MODULE_2__[/* device */ "w"].ext.CompressedTextureS3TC,
                header = new Int32Array(data, 0, _global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_LENGTH_INT */ "c"]),
                isFourCC = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_PF_FOURCC */ "i"]],
                isMagic = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_MAGIC */ "g"]] === _global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_MAGIC */ "l"],
                isCube = (header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_CAPS2 */ "d"]] & _global__WEBPACK_IMPORTED_MODULE_2__[/* DDSCAPS2_CUBEMAP */ "a"]) === _global__WEBPACK_IMPORTED_MODULE_2__[/* DDSCAPS2_CUBEMAP */ "a"],
                fourCC = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_PF_FOURCC */ "i"]],
                mipmaps = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_FLAGS */ "e"]] & _global__WEBPACK_IMPORTED_MODULE_2__[/* DDSD_MIPMAPCOUNT */ "b"] ? Math.max(1, header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_MIPMAP_COUNT */ "h"]]) : 1; // Check compatibility

          if (!ext) throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceFormat */ "q"]('Compressed textures not supported by your device');
          if (!isMagic) throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceFormat */ "q"]('Invalid DDS, missing magic number');
          if (!isFourCC) throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceFormat */ "q"]('Invalid DDS, missing FourCC code');
          let width = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_WIDTH */ "k"]],
              height = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_HEIGHT */ "f"]],
              dataOffset = header[_global__WEBPACK_IMPORTED_MODULE_2__[/* DDS_HEADER_OFFSET_SIZE */ "j"]] + 4,
              blockBytes,
              internalFormat;

          switch (fourCC) {
            case _global__WEBPACK_IMPORTED_MODULE_2__[/* FOURCC_DXT1 */ "m"]:
              blockBytes = 8;
              internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              break;

            case _global__WEBPACK_IMPORTED_MODULE_2__[/* FOURCC_DXT3 */ "n"]:
              blockBytes = 16;
              internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              break;

            case _global__WEBPACK_IMPORTED_MODULE_2__[/* FOURCC_DXT5 */ "o"]:
              blockBytes = 16;
              internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              break;

            default:
              const code = Tw2TextureRes.Int32ToFourCC(fourCC);
              throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceFormat */ "q"](`Invalid DDS, ${code} unsupported`);
          }

          this.hasMipMaps = mipmaps > 1;
          this.isCube = isCube;
          this.width = width;
          this.height = height;

          if (this.isCube) {
            // TODO: Add dds cube map support
            throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrFeatureNotImplemented */ "c"]({
              feature: 'DDS cube maps'
            });
          } else {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);

            for (let i = 0; i < mipmaps; ++i) {
              const dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
              const byteArray = new Uint8Array(data, dataOffset, dataLength);
              gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, byteArray);
              dataOffset += dataLength;
              width *= 0.5;
              height *= 0.5;
            }

            gl.bindTexture(gl.TEXTURE_2D, null);
          }

          break;

        default:
          throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceFormat */ "q"](`Invalid format, ${this._extension} unsupported`);
      }

      this._extension = null;
      this._isAttached = false;
      this.OnPrepared();
    }
    /**
     * An optional method resources can have that allows them to take over loading their resources
     * @param {string} path - texture resource path
     * @param {string} extension - the texture extension
     * @returns {boolean} returns true to tell the resMan not to handle http requests
     */

  }, {
    key: "DoCustomLoad",
    value: function DoCustomLoad(path, extension) {
      this._extension = extension;

      switch (this._extension) {
        case 'cube':
          this.isCube = true;
          path = path.substr(0, path.length - 5) + '.png';
          break;

        case 'png':
          this.isCube = false;
          break;

        case 'dds':
          // Pass back to the ResMan to load
          this._extension = extension;
          this.requestResponseType = 'arraybuffer';
          return false;

        default:
          this._extension = null;
          throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrResourceExtensionUnregistered */ "p"]({
            path,
            extension
          });
      }

      this.OnRequested();
      _global__WEBPACK_IMPORTED_MODULE_2__[/* resMan */ "D"]._pendingLoads++;
      const image = new Image();
      image.crossOrigin = 'anonymous';
      /**
       * Fires on errors
       */

      image.onerror = () => {
        _global__WEBPACK_IMPORTED_MODULE_2__[/* resMan */ "D"]._pendingLoads--;
        this._extension = null;
        this.OnError(new _Tw2Error__WEBPACK_IMPORTED_MODULE_1__[/* ErrHTTPRequest */ "k"]({
          path
        }));
      };
      /**
       * Fires when loaded
       */


      image.onload = () => {
        _global__WEBPACK_IMPORTED_MODULE_2__[/* resMan */ "D"]._pendingLoads--;

        _global__WEBPACK_IMPORTED_MODULE_2__[/* resMan */ "D"]._prepareQueue.push([this, image, null]);

        this.OnLoaded();
      };

      image.src = Tw2TextureRes.AddMipLevelSkipCount(path);
      return true;
    }
    /**
     * Unloads the texture from memory
     * @returns {boolean}
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this.texture) {
        _global__WEBPACK_IMPORTED_MODULE_2__[/* device */ "w"].gl.deleteTexture(this.texture);
        this.texture = null;
      }

      this._isPurged = true;
      this._isGood = false;
      this._isAttached = false;
      this._extension = null;
      this.requestResponseType = null;
      return true;
    }
    /**
     * Attaches a texture
     * @param {WebGLTexture} texture
     */

  }, {
    key: "Attach",
    value: function Attach(texture) {
      this.path = '';
      this.texture = texture;
      this._isPurged = false;
      this._isAttached = true;
      this._extension = null;
      this.requestResponseType = null;
      this.OnLoaded({
        hide: true,
        data: {
          isAttachment: true
        }
      });
      this.OnPrepared({
        hide: true,
        data: {
          isAttachment: true
        }
      });
    }
    /**
     * Reloads the texture
     */

  }, {
    key: "Reload",
    value: function Reload() {
      if (!this._isAttached) {
        return _get(_getPrototypeOf(Tw2TextureRes.prototype), "Reload", this).call(this);
      }
    }
    /**
     * Bind
     * @param sampler
     * @param slices
     */

  }, {
    key: "Bind",
    value: function Bind(sampler, slices) {
      const d = _global__WEBPACK_IMPORTED_MODULE_2__[/* device */ "w"],
            gl = d.gl;
      this.KeepAlive();
      let targetType = sampler.samplerType;
      if (targetType !== (this.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D)) return;

      if (!this.texture) {
        const texture = targetType === gl.TEXTURE_2D ? d.GetFallbackTexture() : d.GetFallbackCubeMap();
        gl.bindTexture(targetType, texture);
        return;
      }

      if (sampler.isVolume) {
        gl.uniform1f(slices, this.height / this.width);
      }

      gl.bindTexture(targetType, this.texture);

      if (sampler.hash !== this._currentSampler || this._updateSampler) {
        sampler.Apply(this.hasMipMaps);
        this._currentSampler = sampler.hash;
        this._updateSampler = false;
      }
    }
    /**
     * Finds out if a number is to the power of 2
     * @param {number} a
     * @returns {boolean}
     */

  }], [{
    key: "IsPowerOfTwo",
    value: function IsPowerOfTwo(a) {
      return (a & a - 1) === 0;
    }
    /**
     * Adds mip levels to a path
     * @param {string} path
     * @returns {string}}
     */

  }, {
    key: "AddMipLevelSkipCount",
    value: function AddMipLevelSkipCount(path) {
      const d = _global__WEBPACK_IMPORTED_MODULE_2__[/* device */ "w"],
            mipExt = d.mipLevelSkipCount > 0 ? '.' + d.mipLevelSkipCount.toString() : '';

      if (d.mipLevelSkipCount > 0) {
        const index = path.lastIndexOf('.');

        if (index >= 0) {
          path = path.substr(0, index - 2) + mipExt + path.substr(index);
        }
      }

      return path;
    }
    /**
     * Converts an int32 into FourCC format
     * @param {number} value
     * @returns {string}
     */

  }, {
    key: "Int32ToFourCC",
    value: function Int32ToFourCC(value) {
      return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);
    }
  }]);

  return Tw2TextureRes;
}(_Tw2Resource__WEBPACK_IMPORTED_MODULE_0__[/* Tw2Resource */ "a"]);

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./curve/curves/Tw2Curve.js
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * Tw2CurveKey base class
 *
 * @property {number|string} id
 * @property {string} name
 * @property {number} time
 * @class
 */

let Tw2Curve_Tw2CurveKey = function Tw2CurveKey() {
  _classCallCheck(this, Tw2CurveKey);

  _defineProperty(this, "_id", global["F" /* util */].generateID());

  _defineProperty(this, "name", '');

  _defineProperty(this, "time", 0);
};
/**
 * Tw2Curve base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */

let Tw2Curve_Tw2Curve =
/*#__PURE__*/
function () {
  function Tw2Curve() {
    _classCallCheck(this, Tw2Curve);

    _defineProperty(this, "_id", global["F" /* util */].generateID());

    _defineProperty(this, "name", '');
  }

  _createClass(Tw2Curve, [{
    key: "Initialize",

    /**
     * Initializes the Curve
     */
    value: function Initialize() {
      this.Sort();
    }
    /**
     * Sorts the curve
     */

  }, {
    key: "Sort",
    value: function Sort() {}
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return 0;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {}
    /**
     * Compares curve keys
     * @param {Tw2CurveKey} a
     * @param {Tw2CurveKey} b
     * @returns {number}
     */

  }], [{
    key: "Compare",
    value: function Compare(a, b) {
      if (a.time < b.time) return -1;
      if (a.time > b.time) return 1;
      return 0;
    }
    /**
     * Sorts legacy curve keys
     * @param {*} curve
     * @param {Array.<Tw2CurveKey>} [keys=curve.keys] - Optional keys override
     */

  }, {
    key: "Sort",
    value: function Sort(curve) {
      let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : curve.keys;

      if (keys && keys.length) {
        keys.sort(Tw2Curve.Compare);
        curve.length = keys[keys.length - 1].time;
      }
    }
    /**
     * Sorts curve keys
     * @param {*} curve
     */

  }, {
    key: "Sort2",
    value: function Sort2(curve) {
      if (curve.keys && curve.keys.length) {
        curve.keys.sort(Tw2Curve.Compare);
        const back = curve.keys[curve.keys.length - 1];

        if (back.time > curve.length) {
          const preLength = curve.length,
                endValue = curve.endValue,
                endTangent = curve.endTangent;
          curve.length = back.time;
          curve.endValue = back.value;
          curve.endTangent = back.leftTangent;

          if (preLength > 0) {
            back.time = preLength;
            back.value = endValue;
            back.leftTangent = endTangent;
          }
        }
      }
    }
    /**
     * The curve's key dimension
     * @type {?number}
     */

  }]);

  return Tw2Curve;
}();

_defineProperty(Tw2Curve_Tw2Curve, "inputDimension", null);

_defineProperty(Tw2Curve_Tw2Curve, "outputDimension", null);

_defineProperty(Tw2Curve_Tw2Curve, "valueProperty", null);

_defineProperty(Tw2Curve_Tw2Curve, "curveType", null);

_defineProperty(Tw2Curve_Tw2Curve, "Key", null);

_defineProperty(Tw2Curve_Tw2Curve, "Interpolation", null);

_defineProperty(Tw2Curve_Tw2Curve, "Extrapolation", null);

_defineProperty(Tw2Curve_Tw2Curve, "Type", {
  CURVE: 1,
  CURVE2: 2,
  CURVE_MAYA: 3,
  CURVE_NO_KEYS: 4,
  SEQUENCER: 100,
  SEQUENCER2: 101
});

_defineProperty(Tw2Curve_Tw2Curve, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  vec4_0: global["I" /* vec4 */].create(),
  quat_0: global["C" /* quat */].create(),
  quat_1: global["C" /* quat */].create()
});
// CONCATENATED MODULE: ./curve/curves/Tw2ColorCurve.js
function Tw2ColorCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ColorCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ColorCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ColorCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ColorCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ColorCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ColorKey
 *
 * @property {vec4} value
 * @property {vec4} left
 * @property {vec4} right
 * @property {number} interpolation
 * @class
 */

let Tw2ColorCurve_Tw2ColorKey =
/*#__PURE__*/
function (_Tw2CurveKey) {
  _inherits(Tw2ColorKey, _Tw2CurveKey);

  function Tw2ColorKey() {
    var _this;

    Tw2ColorCurve_classCallCheck(this, Tw2ColorKey);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2ColorKey).call(this, ...args));

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "value", global["I" /* vec4 */].create());

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "left", global["I" /* vec4 */].create());

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "right", global["I" /* vec4 */].create());

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "interpolation", 0);

    return _this;
  }

  return Tw2ColorKey;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2ColorCurve
 *
 * @property {number} start
 * @property {vec4} currentValue
 * @property {number} extrapolation
 * @property {Array.<Tw2ColorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */

let Tw2ColorCurve_Tw2ColorCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  _inherits(Tw2ColorCurve, _Tw2Curve);

  function Tw2ColorCurve() {
    var _this2;

    Tw2ColorCurve_classCallCheck(this, Tw2ColorCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Tw2ColorCurve).call(this, ...args));

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "start", 0);

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "value", global["I" /* vec4 */].create());

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "extrapolation", 0);

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "keys", []);

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "_currentKey", 1);

    Tw2ColorCurve_defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2ColorCurve_createClass(Tw2ColorCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4} value
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      if (this.length === 0) {
        return global["I" /* vec4 */].copy(value, this.value);
      }

      const firstKey = this.keys[0],
            lastKey = this.keys[this.keys.length - 1];

      if (time >= lastKey.time) {
        switch (this.extrapolation) {
          case Tw2ColorCurve.Extrapolation.NONE:
            return global["I" /* vec4 */].copy(value, this.value);

          case Tw2ColorCurve.Extrapolation.CONSTANT:
            return global["I" /* vec4 */].copy(value, lastKey.value);

          case Tw2ColorCurve.Extrapolation.GRADIENT:
            return global["I" /* vec4 */].scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

          default:
            time = time % lastKey.time;
        }
      } else if (time < 0 || time < firstKey.time) {
        switch (this.extrapolation) {
          case Tw2ColorCurve.Extrapolation.NONE:
            return global["I" /* vec4 */].copy(value, this.value);

          case Tw2ColorCurve.Extrapolation.GRADIENT:
            return global["I" /* vec4 */].scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

          default:
            return global["I" /* vec4 */].copy(value, firstKey.value);
        }
      }

      let ck = this.keys[this._currentKey],
          ck_1 = this.keys[this._currentKey - 1];

      while (time >= ck.time || time < ck_1.time) {
        if (time < ck_1.time) this._currentKey = 0;
        this._currentKey++;
        ck = this.keys[this._currentKey];
        ck_1 = this.keys[this._currentKey - 1];
      }

      const nt = (time - ck_1.time) / (ck.time - ck_1.time);

      switch (ck_1.interpolation) {
        case Tw2ColorCurve.Interpolation.CONSTANT:
          return global["I" /* vec4 */].copy(value, ck_1.value);

        default:
          value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
          value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
          value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
          value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2ColorCurve;
}(Tw2Curve_Tw2Curve);

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "inputDimension", 4);

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "ouputDimension", 4);

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "valueProperty", 'value');

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "Key", Tw2ColorCurve_Tw2ColorKey);

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "Extrapolation", {
  NONE: 0,
  CONSTANT: 1,
  GRADIENT: 2,
  CYCLE: 3
});

Tw2ColorCurve_defineProperty(Tw2ColorCurve_Tw2ColorCurve, "Interpolation", {
  NONE: 0,
  CONSTANT: 1,
  LINEAR: 2
});
// CONCATENATED MODULE: ./curve/curves/Tw2ColorCurve2.js
function Tw2ColorCurve2_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ColorCurve2_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ColorCurve2_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ColorCurve2_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ColorCurve2_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ColorCurve2_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ColorCurve2_assertThisInitialized(self); }

function Tw2ColorCurve2_getPrototypeOf(o) { Tw2ColorCurve2_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ColorCurve2_getPrototypeOf(o); }

function Tw2ColorCurve2_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ColorCurve2_setPrototypeOf(subClass, superClass); }

function Tw2ColorCurve2_setPrototypeOf(o, p) { Tw2ColorCurve2_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ColorCurve2_setPrototypeOf(o, p); }

function Tw2ColorCurve2_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ColorCurve2_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ColorKey2
 *
 * @property {number} time
 * @property {vec4} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2ColorCurve2_Tw2ColorKey2 =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2ColorCurve2_inherits(Tw2ColorKey2, _Tw2CurveKey);

  function Tw2ColorKey2() {
    var _this;

    Tw2ColorCurve2_classCallCheck(this, Tw2ColorKey2);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ColorCurve2_possibleConstructorReturn(this, Tw2ColorCurve2_getPrototypeOf(Tw2ColorKey2).call(this, ...args));

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this)), "value", global["I" /* vec4 */].create());

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this)), "leftTangent", global["I" /* vec4 */].create());

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this)), "rightTangent", global["I" /* vec4 */].create());

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this)), "interpolation", 1);

    return _this;
  }

  return Tw2ColorKey2;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2ColorCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec4} startValue=[0,0,0,1]
 * @property {vec4} currentValue=[0,0,0,1]
 * @property {vec4} endValue=[0,0,0,1]
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ColorKey2>} keys
 * @class
 */

let Tw2ColorCurve2_Tw2ColorCurve2 =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2ColorCurve2_inherits(Tw2ColorCurve2, _Tw2Curve);

  function Tw2ColorCurve2() {
    var _this2;

    Tw2ColorCurve2_classCallCheck(this, Tw2ColorCurve2);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2ColorCurve2_possibleConstructorReturn(this, Tw2ColorCurve2_getPrototypeOf(Tw2ColorCurve2).call(this, ...args));

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "cycle", false);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "reversed", false);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "startValue", global["I" /* vec4 */].fromValues(0, 0, 0, 1));

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "currentValue", global["I" /* vec4 */].fromValues(0, 0, 0, 1));

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "endValue", global["I" /* vec4 */].fromValues(0, 0, 0, 1));

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "startTangent", global["I" /* vec4 */].create());

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "endTangent", global["I" /* vec4 */].create());

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "interpolation", 1);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "keys", []);

    Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_assertThisInitialized(Tw2ColorCurve2_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2ColorCurve2_createClass(Tw2ColorCurve2, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort2(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      time = time / this.timeScale + this.timeOffset;

      if (this.length <= 0 || time <= 0) {
        return global["I" /* vec4 */].copy(value, this.startValue);
      }

      if (time > this.length) {
        if (this.cycle) {
          time = time % this.length;
        } else if (this.reversed) {
          return global["I" /* vec4 */].copy(value, this.startValue);
        } else {
          return global["I" /* vec4 */].copy(value, this.endValue);
        }
      }

      if (this.reversed) {
        time = this.length - time;
      }

      if (this.keys.length === 0) {
        return this.Interpolate(time, null, null, value);
      }

      let startKey = this.keys[0],
          endKey = this.keys[this.keys.length - 1];

      if (time <= startKey.time) {
        return this.Interpolate(time, null, startKey, value);
      } else if (time >= endKey.time) {
        return this.Interpolate(time, endKey, null, value);
      }

      for (let i = 0; i + 1 < this.keys.length; ++i) {
        startKey = this.keys[i];
        endKey = this.keys[i + 1];
        if (startKey.time <= time && endKey.time > time) break;
      }

      return this.Interpolate(time, startKey, endKey, value);
    }
    /**
     * Interpolate
     * @param {number} time
     * @param {Tw2ColorKey2} lastKey
     * @param {Tw2ColorKey2} nextKey
     * @param {vec4} value
     * @returns {vec4} value
     */

  }, {
    key: "Interpolate",
    value: function Interpolate(time, lastKey, nextKey, value) {
      global["I" /* vec4 */].copy(value, this.startValue);
      let startValue = this.startValue,
          endValue = this.endValue,
          interp = this.interpolation,
          deltaTime = this.length;

      if (lastKey !== null) {
        interp = lastKey.interpolation;
        time -= lastKey.time;
      }

      switch (interp) {
        case Tw2ColorCurve2.Interpolation.LINEAR:
          if (lastKey && nextKey) {
            startValue = lastKey.value;
            endValue = nextKey.value;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            deltaTime = this.length - lastKey.time;
          }

          value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
          value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
          value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
          value[3] = startValue[3] + (endValue[3] - startValue[3]) * (time / deltaTime);
          return value;

        default:
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2ColorCurve2;
}(Tw2Curve_Tw2Curve);

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "inputDimension", 4);

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "outputDimension", 4);

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "valueProperty", 'currentValue');

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "curveType", Tw2Curve_Tw2Curve.Type.CURVE2);

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "Key", Tw2ColorCurve2_Tw2ColorKey2);

Tw2ColorCurve2_defineProperty(Tw2ColorCurve2_Tw2ColorCurve2, "Interpolation", {
  CONSTANT: 0,
  LINEAR: 1
});
// CONCATENATED MODULE: ./curve/curves/Tw2EventCurve.js
function Tw2EventCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2EventCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2EventCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2EventCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2EventCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2EventCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2EventCurve_assertThisInitialized(self); }

function Tw2EventCurve_getPrototypeOf(o) { Tw2EventCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2EventCurve_getPrototypeOf(o); }

function Tw2EventCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2EventCurve_setPrototypeOf(subClass, superClass); }

function Tw2EventCurve_setPrototypeOf(o, p) { Tw2EventCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2EventCurve_setPrototypeOf(o, p); }

function Tw2EventCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2EventCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2EventKey
 *
 * @property {string} value
 * @class
 */

let Tw2EventKey =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2EventCurve_inherits(Tw2EventKey, _Tw2CurveKey);

  function Tw2EventKey() {
    var _this;

    Tw2EventCurve_classCallCheck(this, Tw2EventKey);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2EventCurve_possibleConstructorReturn(this, Tw2EventCurve_getPrototypeOf(Tw2EventKey).call(this, ...args));

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this)), "value", '');

    return _this;
  }

  return Tw2EventKey;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2EventCurve
 *
 * @property {string} value
 * @property {Array.<Tw2EventKey>} keys
 * @property {number} extrapolation
 * @property {number} _time
 * @property {number} _currentKey
 * @property {number} _length
 * @class
 */

let Tw2EventCurve_Tw2EventCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2EventCurve_inherits(Tw2EventCurve, _Tw2Curve);

  function Tw2EventCurve() {
    var _this2;

    Tw2EventCurve_classCallCheck(this, Tw2EventCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2EventCurve_possibleConstructorReturn(this, Tw2EventCurve_getPrototypeOf(Tw2EventCurve).call(this, ...args));

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "value", '');

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "keys", []);

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "extrapolation", 0);

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "_time", 0);

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "_currentKey", 0);

    Tw2EventCurve_defineProperty(Tw2EventCurve_assertThisInitialized(Tw2EventCurve_assertThisInitialized(_this2)), "_length", 0);

    return _this2;
  }

  Tw2EventCurve_createClass(Tw2EventCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      if (this.keys.length) {
        this.keys.sort(Tw2Curve_Tw2Curve.Compare);
        this._length = this.keys[this.keys.length - 1].time;
      }
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this._length;
    }
    /**
     * Gets a value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      if (this._length <= 0) {
        return this.value;
      }

      let before = this._time;
      this._time = time;

      if (this._time < before) {
        this._currentKey = 0;
      }

      if (this.extrapolation === Tw2EventCurve.Extrapolation.CYCLE) {
        let now = this._time % this._length;
        if (now < before) this._currentKey = 0;
        this._time = now;
      }

      while (this._currentKey < this.keys.length && this._time >= this.keys[this._currentKey].time) {
        this.value = this.keys[this._currentKey].value;
        ++this._currentKey;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2EventCurve;
}(Tw2Curve_Tw2Curve);

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "dimension", 1);

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "outputDimension", 1);

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "valueProperty", 'value');

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "Key", Tw2EventKey);

Tw2EventCurve_defineProperty(Tw2EventCurve_Tw2EventCurve, "Extrapolation", {
  NONE: 0,
  CYCLE: 3
});
// CONCATENATED MODULE: ./curve/curves/Tw2PerlinCurve.js
function Tw2PerlinCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2PerlinCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2PerlinCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2PerlinCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2PerlinCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2PerlinCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2PerlinCurve_assertThisInitialized(self); }

function Tw2PerlinCurve_getPrototypeOf(o) { Tw2PerlinCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2PerlinCurve_getPrototypeOf(o); }

function Tw2PerlinCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2PerlinCurve_setPrototypeOf(subClass, superClass); }

function Tw2PerlinCurve_setPrototypeOf(o, p) { Tw2PerlinCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2PerlinCurve_setPrototypeOf(o, p); }

function Tw2PerlinCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2PerlinCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2PerlinCurve
 *
 * @property {number} start
 * @property {number} speed
 * @property {number} alpha
 * @property {number} beta
 * @property {number} offset
 * @property {number} scale
 * @property {number} N
 * @property {number} _startOffset
 * @class
 */

let Tw2PerlinCurve_Tw2PerlinCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2PerlinCurve_inherits(Tw2PerlinCurve, _Tw2Curve);

  function Tw2PerlinCurve() {
    var _this;

    Tw2PerlinCurve_classCallCheck(this, Tw2PerlinCurve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2PerlinCurve_possibleConstructorReturn(this, Tw2PerlinCurve_getPrototypeOf(Tw2PerlinCurve).call(this, ...args));

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "value", 0);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "start", 0);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "speed", 1);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "alpha", 1.1);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "beta", 2);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "offset", 0);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "scale", 1);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "N", 3);

    Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_assertThisInitialized(Tw2PerlinCurve_assertThisInitialized(_this)), "_startOffset", Math.random() * 100);

    return _this;
  }

  Tw2PerlinCurve_createClass(Tw2PerlinCurve, [{
    key: "UpdateValue",

    /**
     * Updates the current value at the given time
     * @param {number} time
     */
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time) {
      time -= this._startOffset;
      return (global["A" /* noise */].perlin1D(time * this.speed, this.alpha, this.beta, this.N) + 1) / 2 * this.scale + this.offset;
    }
    /**
     * The curve's dimension
     * @type {number}
     */

  }]);

  return Tw2PerlinCurve;
}(Tw2Curve_Tw2Curve);

Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_Tw2PerlinCurve, "outputDimension", 1);

Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_Tw2PerlinCurve, "valueProperty", 'value');

Tw2PerlinCurve_defineProperty(Tw2PerlinCurve_Tw2PerlinCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_NO_KEYS);
// CONCATENATED MODULE: ./curve/curves/Tw2QuaternionCurve.js
function Tw2QuaternionCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2QuaternionCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2QuaternionCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2QuaternionCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2QuaternionCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2QuaternionCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2QuaternionCurve_assertThisInitialized(self); }

function Tw2QuaternionCurve_getPrototypeOf(o) { Tw2QuaternionCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2QuaternionCurve_getPrototypeOf(o); }

function Tw2QuaternionCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2QuaternionCurve_setPrototypeOf(subClass, superClass); }

function Tw2QuaternionCurve_setPrototypeOf(o, p) { Tw2QuaternionCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2QuaternionCurve_setPrototypeOf(o, p); }

function Tw2QuaternionCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2QuaternionCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2QuaternionKey2
 *
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2QuaternionCurve_Tw2QuaternionKey2 =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2QuaternionCurve_inherits(Tw2QuaternionKey2, _Tw2CurveKey);

  function Tw2QuaternionKey2() {
    var _this;

    Tw2QuaternionCurve_classCallCheck(this, Tw2QuaternionKey2);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2QuaternionCurve_possibleConstructorReturn(this, Tw2QuaternionCurve_getPrototypeOf(Tw2QuaternionKey2).call(this, ...args));

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this)), "value", global["C" /* quat */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this)), "leftTangent", global["I" /* vec4 */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this)), "rightTangent", global["I" /* vec4 */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this)), "interpolation", 1);

    return _this;
  }

  return Tw2QuaternionKey2;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2QuaternionCurve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {quat} startValue
 * @property {quat} currentValue
 * @property {quat} endValue
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} length
 * @class
 */

let Tw2QuaternionCurve_Tw2QuaternionCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2QuaternionCurve_inherits(Tw2QuaternionCurve, _Tw2Curve);

  function Tw2QuaternionCurve() {
    var _this2;

    Tw2QuaternionCurve_classCallCheck(this, Tw2QuaternionCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2QuaternionCurve_possibleConstructorReturn(this, Tw2QuaternionCurve_getPrototypeOf(Tw2QuaternionCurve).call(this, ...args));

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "cycle", false);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "reversed", false);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "startValue", global["C" /* quat */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "currentValue", global["C" /* quat */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "endValue", global["C" /* quat */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "startTangent", global["I" /* vec4 */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "endTangent", global["I" /* vec4 */].create());

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "interpolation", 1);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "keys", []);

    Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_assertThisInitialized(Tw2QuaternionCurve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2QuaternionCurve_createClass(Tw2QuaternionCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort2(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      time = time / this.timeScale + this.timeOffset;

      if (this.length <= 0 || time <= 0) {
        value[0] = this.startValue[0];
        value[1] = this.startValue[1];
        value[2] = this.startValue[2];
        return value;
      }

      if (time > this.length) {
        if (this.cycle) {
          time = time % this.length;
        } else if (this.reversed) {
          value[0] = this.startValue[0];
          value[1] = this.startValue[1];
          value[2] = this.startValue[2];
          return value;
        } else {
          value[0] = this.endValue[0];
          value[1] = this.endValue[1];
          value[2] = this.endValue[2];
          return value;
        }
      }

      if (this.reversed) {
        time = this.length - time;
      }

      if (this.keys.length === 0) {
        return this.Interpolate(time, null, null, value);
      }

      let startKey = this.keys[0],
          endKey = this.keys[this.keys.length - 1];

      if (time <= startKey.time) {
        return this.Interpolate(time, null, startKey, value);
      } else if (time >= endKey.time) {
        return this.Interpolate(time, endKey, null, value);
      }

      for (let i = 0; i + 1 < this.keys.length; ++i) {
        startKey = this.keys[i];
        endKey = this.keys[i + 1];
        if (startKey.time <= time && endKey.time > time) break;
      }

      return this.Interpolate(time, startKey, endKey, value);
    }
    /**
     * Interpolate
     * @param {number} time
     * @param {null|Tw2QuaternionKey} lastKey
     * @param {null|Tw2QuaternionKey} nextKey
     * @param {quat} value
     * @returns {*}
     */

  }, {
    key: "Interpolate",
    value: function Interpolate(time, lastKey, nextKey, value) {
      value[0] = this.startValue[0];
      value[1] = this.startValue[1];
      value[2] = this.startValue[2];
      let startValue = this.startValue,
          endValue = this.endValue,
          interp = this.interpolation,
          deltaTime = this.length;

      if (lastKey !== null) {
        interp = lastKey.interpolation;
        time -= lastKey.time;
      }

      switch (interp) {
        case Tw2QuaternionCurve.Interpolation.SPHERICAL_LINEAR:
          if (lastKey && nextKey) {
            startValue = lastKey.value;
            endValue = nextKey.value;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            deltaTime = this.length - lastKey.time;
          }

          global["C" /* quat */].slerp(value, startValue, endValue, time / deltaTime);
          return value;

        default:
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2QuaternionCurve;
}(Tw2Curve_Tw2Curve);

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "inputDimension", 4);

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "outputDimension", 4);

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "valueProperty", 'currentValue');

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE2);

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "Key", Tw2QuaternionCurve_Tw2QuaternionKey2);

Tw2QuaternionCurve_defineProperty(Tw2QuaternionCurve_Tw2QuaternionCurve, "Interpolation", {
  CONSTANT: 0,
  SPHERICAL_LINEAR: 4
});
// CONCATENATED MODULE: ./curve/curves/Tw2RandomConstantCurve.js
function Tw2RandomConstantCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RandomConstantCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RandomConstantCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RandomConstantCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RandomConstantCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RandomConstantCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2RandomConstantCurve_assertThisInitialized(self); }

function Tw2RandomConstantCurve_getPrototypeOf(o) { Tw2RandomConstantCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2RandomConstantCurve_getPrototypeOf(o); }

function Tw2RandomConstantCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2RandomConstantCurve_setPrototypeOf(subClass, superClass); }

function Tw2RandomConstantCurve_setPrototypeOf(o, p) { Tw2RandomConstantCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2RandomConstantCurve_setPrototypeOf(o, p); }

function Tw2RandomConstantCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RandomConstantCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2RandomConstantCurve
 *
 * @property {number} currentValue
 * @property {number} min
 * @property {number} max
 * @property {boolean} hold
 * @class
 */

let Tw2RandomConstantCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2RandomConstantCurve_inherits(Tw2RandomConstantCurve, _Tw2Curve);

  function Tw2RandomConstantCurve() {
    var _this;

    Tw2RandomConstantCurve_classCallCheck(this, Tw2RandomConstantCurve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2RandomConstantCurve_possibleConstructorReturn(this, Tw2RandomConstantCurve_getPrototypeOf(Tw2RandomConstantCurve).call(this, ...args));

    Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve_assertThisInitialized(Tw2RandomConstantCurve_assertThisInitialized(_this)), "value", 0);

    Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve_assertThisInitialized(Tw2RandomConstantCurve_assertThisInitialized(_this)), "min", 0);

    Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve_assertThisInitialized(Tw2RandomConstantCurve_assertThisInitialized(_this)), "max", 1);

    Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve_assertThisInitialized(Tw2RandomConstantCurve_assertThisInitialized(_this)), "hold", true);

    return _this;
  }

  Tw2RandomConstantCurve_createClass(Tw2RandomConstantCurve, [{
    key: "UpdateValue",

    /**
     * Updates the current value at the given time
     */
    value: function UpdateValue() {
      this.value = this.GetValueAt();
    }
    /**
     * Gets a value at a specific time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt() {
      return this.hold ? this.value : this.min + (this.max - this.min) * Math.random();
    }
    /**
     * The curve's dimension
     * @type {number}
     */

  }]);

  return Tw2RandomConstantCurve;
}(Tw2Curve_Tw2Curve);

Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve, "outputDimension", 1);

Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve, "valueProperty", 'value');

Tw2RandomConstantCurve_defineProperty(Tw2RandomConstantCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_NO_KEYS);
// CONCATENATED MODULE: ./curve/curves/Tw2RigidOrientation.js
function Tw2RigidOrientation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RigidOrientation_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RigidOrientation_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RigidOrientation_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RigidOrientation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RigidOrientation_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2RigidOrientation_assertThisInitialized(self); }

function Tw2RigidOrientation_getPrototypeOf(o) { Tw2RigidOrientation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2RigidOrientation_getPrototypeOf(o); }

function Tw2RigidOrientation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2RigidOrientation_setPrototypeOf(subClass, superClass); }

function Tw2RigidOrientation_setPrototypeOf(o, p) { Tw2RigidOrientation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2RigidOrientation_setPrototypeOf(o, p); }

function Tw2RigidOrientation_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RigidOrientation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Torque
 *
 * @property {quat} rot0
 * @property {vec3} omega0
 * @property {vec3} torque
 * @class
 */

let Tw2RigidOrientation_Tw2Torque =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2RigidOrientation_inherits(Tw2Torque, _Tw2CurveKey);

  function Tw2Torque() {
    var _this;

    Tw2RigidOrientation_classCallCheck(this, Tw2Torque);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2RigidOrientation_possibleConstructorReturn(this, Tw2RigidOrientation_getPrototypeOf(Tw2Torque).call(this, ...args));

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this)), "rot0", global["C" /* quat */].create());

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this)), "omega0", global["H" /* vec3 */].create());

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this)), "torque", global["H" /* vec3 */].create());

    return _this;
  }

  return Tw2Torque;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2RigidOrientation
 *
 * @property {string} name
 * @property {number} I
 * @property {number} drag
 * @property {quat} value
 * @property {number} start
 * @property {Array.<Tw2Torque>} states
 * @property {number} length
 * @class
 */

let Tw2RigidOrientation_Tw2RigidOrientation =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2RigidOrientation_inherits(Tw2RigidOrientation, _Tw2Curve);

  function Tw2RigidOrientation() {
    var _this2;

    Tw2RigidOrientation_classCallCheck(this, Tw2RigidOrientation);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2RigidOrientation_possibleConstructorReturn(this, Tw2RigidOrientation_getPrototypeOf(Tw2RigidOrientation).call(this, ...args));

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "name", '');

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "I", 1);

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "drag", 1);

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "value", global["C" /* quat */].create());

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "start", 0);

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "states", []);

    Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_assertThisInitialized(Tw2RigidOrientation_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2RigidOrientation_createClass(Tw2RigidOrientation, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort(this, this.states);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      if (this.states.length === 0 || time < 0 || time < this.states[0].time) {
        return global["C" /* quat */].copy(value, this.value);
      }

      let key = 0;

      if (time >= this.states[this.states.length - 1].time) {
        key = this.states.length - 1;
      } else {
        for (; key + 1 < this.states.length; ++key) {
          if (time >= this.states[key].time && time < this.states[key + 1].time) {
            break;
          }
        }
      }

      const vec3_0 = Tw2Curve_Tw2Curve.global.vec3_0,
            quat_0 = Tw2Curve_Tw2Curve.global.quat_0;
      const ck = this.states[key];
      global["H" /* vec3 */].exponentialDecay(vec3_0, ck.omega0, ck.torque, this.I, this.drag, time - ck.time);
      global["C" /* quat */].exp(quat_0, vec3_0);
      global["C" /* quat */].multiply(value, this.states[key].rot0, quat_0);
      return value;
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2RigidOrientation;
}(Tw2Curve_Tw2Curve);

Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_Tw2RigidOrientation, "inputDimension", 4);

Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_Tw2RigidOrientation, "outputDimension", 4);

Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_Tw2RigidOrientation, "valueProperty", 'value');

Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_Tw2RigidOrientation, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2RigidOrientation_defineProperty(Tw2RigidOrientation_Tw2RigidOrientation, "Key", Tw2RigidOrientation_Tw2Torque);
// CONCATENATED MODULE: ./curve/curves/Tw2RotationCurve.js
function Tw2RotationCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RotationCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RotationCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RotationCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RotationCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RotationCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2RotationCurve_assertThisInitialized(self); }

function Tw2RotationCurve_getPrototypeOf(o) { Tw2RotationCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2RotationCurve_getPrototypeOf(o); }

function Tw2RotationCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2RotationCurve_setPrototypeOf(subClass, superClass); }

function Tw2RotationCurve_setPrototypeOf(o, p) { Tw2RotationCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2RotationCurve_setPrototypeOf(o, p); }

function Tw2RotationCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RotationCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2QuaternionKey
 *
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2RotationCurve_Tw2QuaternionKey =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2RotationCurve_inherits(Tw2QuaternionKey, _Tw2CurveKey);

  function Tw2QuaternionKey() {
    var _this;

    Tw2RotationCurve_classCallCheck(this, Tw2QuaternionKey);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2RotationCurve_possibleConstructorReturn(this, Tw2RotationCurve_getPrototypeOf(Tw2QuaternionKey).call(this, ...args));

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this)), "value", global["C" /* quat */].create());

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this)), "left", global["I" /* vec4 */].create());

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this)), "right", global["I" /* vec4 */].create());

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this)), "interpolation", 5);

    return _this;
  }

  return Tw2QuaternionKey;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2RotationCurve
 *
 * @property {number} start
 * @property {quat} value
 * @property {number} extrapolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class`
 */

let Tw2RotationCurve_Tw2RotationCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2RotationCurve_inherits(Tw2RotationCurve, _Tw2Curve);

  function Tw2RotationCurve() {
    var _this2;

    Tw2RotationCurve_classCallCheck(this, Tw2RotationCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2RotationCurve_possibleConstructorReturn(this, Tw2RotationCurve_getPrototypeOf(Tw2RotationCurve).call(this, ...args));

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "start", 0);

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "value", global["C" /* quat */].create());

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "extrapolation", 0);

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "keys", []);

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "_currentKey", 1);

    Tw2RotationCurve_defineProperty(Tw2RotationCurve_assertThisInitialized(Tw2RotationCurve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2RotationCurve_createClass(Tw2RotationCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's children
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      if (this.length === 0) {
        return global["C" /* quat */].copy(value, this.value);
      }

      const scratch = Tw2Curve_Tw2Curve.global,
            firstKey = this.keys[0],
            lastKey = this.keys[this.keys.length - 1];

      if (time >= lastKey.time) {
        switch (this.extrapolation) {
          case Tw2RotationCurve.Extrapolation.NONE:
            return global["C" /* quat */].copy(value, this.value);

          case Tw2RotationCurve.Extrapolation.CONSTANT:
            return global["C" /* quat */].copy(value, lastKey.value);

          default:
            time = time % lastKey.time;
        }
      } else if (time < 0 || time < firstKey.time) {
        switch (this.extrapolation) {
          case Tw2RotationCurve.Extrapolation.NONE:
            return global["C" /* quat */].copy(value, this.value);

          default:
            return global["C" /* quat */].copy(value, firstKey.value);
        }
      }

      let ck = this.keys[this._currentKey],
          ck_1 = this.keys[this._currentKey - 1];

      while (time >= ck.time || time < ck_1.time) {
        if (time < ck_1.time) this._currentKey = 0;
        this._currentKey++;
        ck = this.keys[this._currentKey];
        ck_1 = this.keys[this._currentKey - 1];
      }

      const nt = (time - ck_1.time) / (ck.time - ck_1.time);

      switch (ck_1.interpolation) {
        case Tw2RotationCurve.Interpolation.CONSTANT:
          return global["C" /* quat */].copy(value, ck_1.value);

        case Tw2RotationCurve.Interpolation.LINEAR:
          value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
          value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
          value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
          value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
          return value;

        case Tw2RotationCurve.Interpolation.HERMITE:
          const collect = global["C" /* quat */].identity(scratch.quat_0),
                arr = [ck_1.value, ck_1.right, ck.left, ck.value];

          for (let i = 3; i > 0; i--) {
            const power = global["B" /* num */].biCumulative(nt, i);
            if (power > 1) global["C" /* quat */].multiply(value, collect, arr[i]);
            value[0] = -arr[i - 1][0];
            value[1] = -arr[i - 1][1];
            value[2] = -arr[i - 1][2];
            value[3] = arr[i - 1][3];
            global["C" /* quat */].multiply(value, value, arr[i]);
            global["C" /* quat */].pow(value, value, power);
            global["C" /* quat */].multiply(collect, collect, value);
          }

          return global["C" /* quat */].multiply(value, collect, ck_1.value);

        case Tw2RotationCurve.Interpolation.SLERP:
          return global["C" /* quat */].slerp(value, ck_1.value, ck.value, nt);

        default:
          return global["C" /* quat */].sqlerp(value, ck_1.value, ck_1.right, ck.left, ck.value, nt);
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2RotationCurve;
}(Tw2Curve_Tw2Curve);

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "outputDimention", 4);

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "inputDimension", 4);

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "valueProperty", 'value');

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "Child", Tw2RotationCurve_Tw2QuaternionKey);

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "Extrapolation", {
  NONE: 0,
  CONSTANT: 1,
  GRADIENT: 2,
  CYCLE: 3
});

Tw2RotationCurve_defineProperty(Tw2RotationCurve_Tw2RotationCurve, "Interpolation", {
  NONE: 0,
  CONSTANT: 1,
  LINEAR: 2,
  HERMITE: 3,
  SLERP: 5,
  SQUAD: 6
});
// CONCATENATED MODULE: ./curve/curves/Tw2ScalarCurve.js
function Tw2ScalarCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ScalarCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ScalarCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ScalarCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ScalarCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ScalarCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ScalarCurve_assertThisInitialized(self); }

function Tw2ScalarCurve_getPrototypeOf(o) { Tw2ScalarCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ScalarCurve_getPrototypeOf(o); }

function Tw2ScalarCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ScalarCurve_setPrototypeOf(subClass, superClass); }

function Tw2ScalarCurve_setPrototypeOf(o, p) { Tw2ScalarCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ScalarCurve_setPrototypeOf(o, p); }

function Tw2ScalarCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ScalarCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2ScalarKey
 *
 * @property {number} value
 * @property {number} left
 * @property {number} right
 * @property {number} interpolation
 * @class
 */

let Tw2ScalarKey =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2ScalarCurve_inherits(Tw2ScalarKey, _Tw2CurveKey);

  function Tw2ScalarKey() {
    var _this;

    Tw2ScalarCurve_classCallCheck(this, Tw2ScalarKey);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ScalarCurve_possibleConstructorReturn(this, Tw2ScalarCurve_getPrototypeOf(Tw2ScalarKey).call(this, ...args));

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this)), "value", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this)), "left", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this)), "right", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this)), "interpolation", 0);

    return _this;
  }

  return Tw2ScalarKey;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2ScalarCurve
 *
 * @property {number} start
 * @property {number} timeScale
 * @property {number} timeOffset
 * @property {number} value
 * @property {number} extrapolation
 * @property {Array.<Tw2ScalarKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */

let Tw2ScalarCurve_Tw2ScalarCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2ScalarCurve_inherits(Tw2ScalarCurve, _Tw2Curve);

  function Tw2ScalarCurve() {
    var _this2;

    Tw2ScalarCurve_classCallCheck(this, Tw2ScalarCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2ScalarCurve_possibleConstructorReturn(this, Tw2ScalarCurve_getPrototypeOf(Tw2ScalarCurve).call(this, ...args));

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "start", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "value", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "extrapolation", 0);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "keys", []);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "_currentKey", 1);

    Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_assertThisInitialized(Tw2ScalarCurve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2ScalarCurve_createClass(Tw2ScalarCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time) {
      time = time / this.timeScale - this.timeOffset;

      if (this.length === 0) {
        return this.value;
      }

      const firstKey = this.keys[0],
            lastKey = this.keys[this.keys.length - 1];

      if (time >= lastKey.time) {
        switch (this.extrapolation) {
          case Tw2ScalarCurve.Extrapolation.NONE:
            return this.value;

          case Tw2ScalarCurve.Extrapolation.CONSTANT:
            return lastKey.value;

          case Tw2ScalarCurve.Extrapolation.GRADIENT:
            return lastKey.value + (time - lastKey.time) * lastKey.right;

          default:
            time = time % lastKey.time;
        }
      } else if (time < 0 || time < firstKey.time) {
        switch (this.extrapolation) {
          case Tw2ScalarCurve.Extrapolation.NONE:
            return this.value;

          case Tw2ScalarCurve.Extrapolation.GRADIENT:
            return firstKey.value + (time * this.length - lastKey.time) * firstKey.left;

          default:
            return firstKey.value;
        }
      }

      let ck = this.keys[this._currentKey],
          ck_1 = this.keys[this._currentKey - 1];

      while (time >= ck.time || time < ck_1.time) {
        if (time < ck_1.time) this._currentKey = 0;
        this._currentKey++;
        ck = this.keys[this._currentKey];
        ck_1 = this.keys[this._currentKey - 1];
      }

      const nt = (time - ck_1.time) / (ck.time - ck_1.time);

      switch (ck_1.interpolation) {
        case Tw2ScalarCurve.Interpolation.CONSTANT:
          return ck_1.value;

        case Tw2ScalarCurve.Interpolation.LINEAR:
          return ck_1.value * (1 - nt) + ck.value * nt;

        case Tw2ScalarCurve.Interpolation.HERMITE:
          const k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                k2 = -2 * nt * nt * nt + 3 * nt * nt,
                k1 = nt * nt * nt - 2 * nt * nt + nt,
                k0 = nt * nt * nt - nt * nt;
          return k3 * ck_1.value + k2 * ck.value + k1 * ck_1.right + k0 * ck.left;

        default:
          const sq = Math.sqrt(ck_1.value / ck.value),
                exponent = Math.exp(-time / ck_1.right),
                ret = 1.0 + (sq - 1.0) * exponent;
          return ret * ret * ck.value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2ScalarCurve;
}(Tw2Curve_Tw2Curve);

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "inputDimension", 1);

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "outputDimension", 1);

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "valueProperty", 'value');

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "Key", Tw2ScalarKey);

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "Extrapolation", {
  NONE: 0,
  CONSTANT: 1,
  GRADIENT: 2,
  CYCLE: 3
});

Tw2ScalarCurve_defineProperty(Tw2ScalarCurve_Tw2ScalarCurve, "Interpolation", {
  NONE: 0,
  CONSTANT: 1,
  LINEAR: 2,
  HERMITE: 3,
  CATMULROM: 4
});
// CONCATENATED MODULE: ./curve/curves/Tw2ScalarCurve2.js
function Tw2ScalarCurve2_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ScalarCurve2_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ScalarCurve2_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ScalarCurve2_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ScalarCurve2_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ScalarCurve2_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ScalarCurve2_assertThisInitialized(self); }

function Tw2ScalarCurve2_getPrototypeOf(o) { Tw2ScalarCurve2_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ScalarCurve2_getPrototypeOf(o); }

function Tw2ScalarCurve2_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ScalarCurve2_setPrototypeOf(subClass, superClass); }

function Tw2ScalarCurve2_setPrototypeOf(o, p) { Tw2ScalarCurve2_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ScalarCurve2_setPrototypeOf(o, p); }

function Tw2ScalarCurve2_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ScalarCurve2_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2ScalarKey2
 *
 * @property {number} value
 * @property {number} leftTangent
 * @property {number} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2ScalarKey2 =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2ScalarCurve2_inherits(Tw2ScalarKey2, _Tw2CurveKey);

  function Tw2ScalarKey2() {
    var _this;

    Tw2ScalarCurve2_classCallCheck(this, Tw2ScalarKey2);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ScalarCurve2_possibleConstructorReturn(this, Tw2ScalarCurve2_getPrototypeOf(Tw2ScalarKey2).call(this, ...args));

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this)), "value", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this)), "leftTangent", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this)), "rightTangent", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this)), "interpolation", 1);

    return _this;
  }

  return Tw2ScalarKey2;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2ScalarCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {number} startValue
 * @property {number} currentValue
 * @property {number} endValue
 * @property {number} startTangent
 * @property {number} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ScalarKey2>} keys
 * @property {number} length
 * @class
 */

let Tw2ScalarCurve2_Tw2ScalarCurve2 =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2ScalarCurve2_inherits(Tw2ScalarCurve2, _Tw2Curve);

  function Tw2ScalarCurve2() {
    var _this2;

    Tw2ScalarCurve2_classCallCheck(this, Tw2ScalarCurve2);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2ScalarCurve2_possibleConstructorReturn(this, Tw2ScalarCurve2_getPrototypeOf(Tw2ScalarCurve2).call(this, ...args));

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "cycle", false);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "reversed", false);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "startValue", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "currentValue", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "endValue", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "startTangent", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "endTangent", 0);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "interpolation", 1);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "keys", []);

    Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_assertThisInitialized(Tw2ScalarCurve2_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2ScalarCurve2_createClass(Tw2ScalarCurve2, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort2(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.currentValue = this.GetValueAt(time);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time) {
      time = time / this.timeScale + this.timeOffset;

      if (this.length <= 0 || time <= 0) {
        return this.startValue;
      }

      if (time > this.length) {
        if (this.cycle) {
          time = time % this.length;
        } else if (this.reversed) {
          return this.startValue;
        } else {
          return this.endValue;
        }
      }

      if (this.reversed) {
        time = this.length - time;
      }

      if (this.keys.length === 0) {
        return this.Interpolate(time, null, null);
      }

      let startKey = this.keys[0],
          endKey = this.keys[this.keys.length - 1];

      if (time <= startKey.time) {
        return this.Interpolate(time, null, startKey);
      } else if (time >= endKey.time) {
        return this.Interpolate(time, endKey, null);
      }

      for (let i = 0; i + 1 < this.keys.length; ++i) {
        startKey = this.keys[i];
        endKey = this.keys[i + 1];
        if (startKey.time <= time && endKey.time > time) break;
      }

      return this.Interpolate(time, startKey, endKey);
    }
    /**
     * Interpolate
     * @param {number} time
     * @param {Tw2ScalarKey2} lastKey
     * @param {Tw2ScalarKey2} nextKey
     * @returns {number}
     */

  }, {
    key: "Interpolate",
    value: function Interpolate(time, lastKey, nextKey) {
      let startValue = this.startValue,
          endValue = this.endValue,
          interp = this.interpolation,
          deltaTime = this.length;

      if (lastKey !== null) {
        interp = lastKey.interpolation;
        time -= lastKey.time;
      }

      switch (interp) {
        case Tw2ScalarCurve2.Interpolation.LINEAR:
          if (lastKey && nextKey) {
            startValue = lastKey.value;
            endValue = nextKey.value;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            deltaTime = this.length - lastKey.time;
          }

          return startValue + (endValue - startValue) * (time / deltaTime);

        case Tw2ScalarCurve2.Interpolation.HERMITE:
          let inTangent = this.startTangent,
              outTangent = this.endTangent;

          if (lastKey && nextKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            deltaTime = this.length - lastKey.time;
          }

          const s = time / deltaTime,
                s2 = s * s,
                s3 = s2 * s;
          const c2 = -2.0 * s3 + 3.0 * s2,
                c1 = 1.0 - c2,
                c4 = s3 - s2,
                c3 = s + c4 - s2;
          return startValue * c1 + endValue * c2 + inTangent * c3 + outTangent * c4;

        default:
          return this.startValue;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2ScalarCurve2;
}(Tw2Curve_Tw2Curve);

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "inputDimension", 1);

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "outputDimension", 1);

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "valueProperty", 'currentValue');

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "curveType", Tw2Curve_Tw2Curve.Type.CURVE2);

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "Key", Tw2ScalarKey2);

Tw2ScalarCurve2_defineProperty(Tw2ScalarCurve2_Tw2ScalarCurve2, "Interpolation", {
  CONSTANT: 0,
  LINEAR: 1,
  HERMITE: 2
});
// CONCATENATED MODULE: ./curve/curves/Tw2SineCurve.js
function Tw2SineCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2SineCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2SineCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2SineCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2SineCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2SineCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2SineCurve_assertThisInitialized(self); }

function Tw2SineCurve_getPrototypeOf(o) { Tw2SineCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2SineCurve_getPrototypeOf(o); }

function Tw2SineCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2SineCurve_setPrototypeOf(subClass, superClass); }

function Tw2SineCurve_setPrototypeOf(o, p) { Tw2SineCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2SineCurve_setPrototypeOf(o, p); }

function Tw2SineCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2SineCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2SineCurve
 *
 * @property {string} name
 * @property {number} value
 * @property {number} offset
 * @property {number} scale
 * @property {number} speed
 */

let Tw2SineCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2SineCurve_inherits(Tw2SineCurve, _Tw2Curve);

  function Tw2SineCurve() {
    var _this;

    Tw2SineCurve_classCallCheck(this, Tw2SineCurve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2SineCurve_possibleConstructorReturn(this, Tw2SineCurve_getPrototypeOf(Tw2SineCurve).call(this, ...args));

    Tw2SineCurve_defineProperty(Tw2SineCurve_assertThisInitialized(Tw2SineCurve_assertThisInitialized(_this)), "value", 0);

    Tw2SineCurve_defineProperty(Tw2SineCurve_assertThisInitialized(Tw2SineCurve_assertThisInitialized(_this)), "offset", 0);

    Tw2SineCurve_defineProperty(Tw2SineCurve_assertThisInitialized(Tw2SineCurve_assertThisInitialized(_this)), "scale", 1);

    Tw2SineCurve_defineProperty(Tw2SineCurve_assertThisInitialized(Tw2SineCurve_assertThisInitialized(_this)), "speed", 1);

    return _this;
  }

  Tw2SineCurve_createClass(Tw2SineCurve, [{
    key: "UpdateValue",

    /**
     * Updates the current value at the given time
     * @param {number} time
     */
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time) {
      return Math.sin(time * Math.PI * 2 * this.speed) * this.scale + this.offset;
    }
    /**
     * THe curve's dimension
     * @type {number}
     */

  }]);

  return Tw2SineCurve;
}(Tw2Curve_Tw2Curve);

Tw2SineCurve_defineProperty(Tw2SineCurve, "outputDimension", 1);

Tw2SineCurve_defineProperty(Tw2SineCurve, "valueProperty", 'value');

Tw2SineCurve_defineProperty(Tw2SineCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_NO_KEYS);
// CONCATENATED MODULE: ./curve/curves/Tw2Vector2Curve.js
function Tw2Vector2Curve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Vector2Curve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Vector2Curve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Vector2Curve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Vector2Curve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Vector2Curve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Vector2Curve_assertThisInitialized(self); }

function Tw2Vector2Curve_getPrototypeOf(o) { Tw2Vector2Curve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Vector2Curve_getPrototypeOf(o); }

function Tw2Vector2Curve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Vector2Curve_setPrototypeOf(subClass, superClass); }

function Tw2Vector2Curve_setPrototypeOf(o, p) { Tw2Vector2Curve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Vector2Curve_setPrototypeOf(o, p); }

function Tw2Vector2Curve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Vector2Curve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Vector2Key
 *
 * @property {vec2} value
 * @property {vec2} leftTangent
 * @property {vec2} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2Vector2Curve_Tw2Vector2Key =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2Vector2Curve_inherits(Tw2Vector2Key, _Tw2CurveKey);

  function Tw2Vector2Key() {
    var _this;

    Tw2Vector2Curve_classCallCheck(this, Tw2Vector2Key);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2Vector2Curve_possibleConstructorReturn(this, Tw2Vector2Curve_getPrototypeOf(Tw2Vector2Key).call(this, ...args));

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this)), "value", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this)), "leftTangent", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this)), "rightTangent", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this)), "interpolation", 1);

    return _this;
  }

  return Tw2Vector2Key;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2Vector2Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec2} startValue - vec2 array
 * @property {vec2} currentValue - vec2 array
 * @property {vec2} endValue - vec2 array
 * @property {vec2} startTangent - vec2 array
 * @property {vec2} endTangent - vec2 array
 * @property {number} interpolation
 * @property {Array.<Tw2Vector2Key>} keys
 * @property {number} length
 * @class
 */

let Tw2Vector2Curve_Tw2Vector2Curve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2Vector2Curve_inherits(Tw2Vector2Curve, _Tw2Curve);

  function Tw2Vector2Curve() {
    var _this2;

    Tw2Vector2Curve_classCallCheck(this, Tw2Vector2Curve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2Vector2Curve_possibleConstructorReturn(this, Tw2Vector2Curve_getPrototypeOf(Tw2Vector2Curve).call(this, ...args));

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "cycle", false);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "reversed", false);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "startValue", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "currentValue", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "endValue", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "startTangent", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "endTangent", global["G" /* vec2 */].create());

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "interpolation", 1);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "keys", []);

    Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_assertThisInitialized(Tw2Vector2Curve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2Vector2Curve_createClass(Tw2Vector2Curve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort2(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec2} value - vec2 array
     * @returns {vec2} vec2 array
     * @prototype
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      time = time / this.timeScale + this.timeOffset;

      if (this.length <= 0 || time <= 0) {
        return global["G" /* vec2 */].copy(value, this.startValue);
      }

      if (time > this.length) {
        if (this.cycle) {
          time = time % this.length;
        } else if (this.reversed) {
          return global["G" /* vec2 */].copy(value, this.startValue);
        } else {
          return global["G" /* vec2 */].copy(value, this.endValue);
        }
      }

      if (this.reversed) {
        time = this.length - time;
      }

      if (this.keys.length === 0) {
        return this.Interpolate(time, null, null, value);
      }

      let startKey = this.keys[0],
          endKey = this.keys[this.keys.length - 1];

      if (time <= startKey.time) {
        return this.Interpolate(time, null, startKey, value);
      } else if (time >= endKey.time) {
        return this.Interpolate(time, endKey, null, value);
      }

      for (let i = 0; i + 1 < this.keys.length; ++i) {
        startKey = this.keys[i];
        endKey = this.keys[i + 1];
        if (startKey.time <= time && endKey.time > time) break;
      }

      return this.Interpolate(time, startKey, endKey, value);
    }
    /**
     * Interpolate
     * @param {number} time
     * @param {Tw2Vector2Key} lastKey
     * @param {Tw2Vector2Key} nextKey
     * @param {vec2} value - vec2 array
     * @returns {vec2} vec2 array
     */

  }, {
    key: "Interpolate",
    value: function Interpolate(time, lastKey, nextKey, value) {
      global["G" /* vec2 */].copy(value, this.startValue);
      let startValue = this.startValue,
          endValue = this.endValue,
          interp = this.interpolation,
          deltaTime = this.length;

      if (lastKey !== null) {
        interp = lastKey.interpolation;
        time -= lastKey.time;
      }

      switch (interp) {
        case Tw2Vector2Curve.Interpolation.LINEAR:
          if (lastKey && nextKey) {
            startValue = lastKey.value;
            endValue = nextKey.value;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            deltaTime = this.length - lastKey.time;
          }

          value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
          value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
          return value;

        case Tw2Vector2Curve.Interpolation.HERMITE:
          let inTangent = this.startTangent,
              outTangent = this.endTangent;

          if (lastKey && nextKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            deltaTime = this.length - lastKey.time;
          }

          const s = time / deltaTime,
                s2 = s * s,
                s3 = s2 * s;
          const c2 = -2.0 * s3 + 3.0 * s2,
                c1 = 1.0 - c2,
                c4 = s3 - s2,
                c3 = s + c4 - s2;
          value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
          value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
          return value;

        default:
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2Vector2Curve;
}(Tw2Curve_Tw2Curve);

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "inputDimension", 2);

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "outputDimension", 2);

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "valueProperty", 'value');

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE2);

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "Key", Tw2Vector2Curve_Tw2Vector2Key);

Tw2Vector2Curve_defineProperty(Tw2Vector2Curve_Tw2Vector2Curve, "Interpolation", {
  CONSTANT: 0,
  LINEAR: 1,
  HERMITE: 2
});
// CONCATENATED MODULE: ./curve/curves/Tw2Vector3Curve.js
function Tw2Vector3Curve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2Vector3Curve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2Vector3Curve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2Vector3Curve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2Vector3Curve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2Vector3Curve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2Vector3Curve_assertThisInitialized(self); }

function Tw2Vector3Curve_getPrototypeOf(o) { Tw2Vector3Curve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2Vector3Curve_getPrototypeOf(o); }

function Tw2Vector3Curve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2Vector3Curve_setPrototypeOf(subClass, superClass); }

function Tw2Vector3Curve_setPrototypeOf(o, p) { Tw2Vector3Curve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2Vector3Curve_setPrototypeOf(o, p); }

function Tw2Vector3Curve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2Vector3Curve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Vector3Key
 *
 * @property {number} time
 * @property {vec3} value
 * @property {vec3} leftTangent
 * @property {vec3} rightTangent
 * @property {number} interpolation
 * @class
 */

let Tw2Vector3Curve_Tw2Vector3Key =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2Vector3Curve_inherits(Tw2Vector3Key, _Tw2CurveKey);

  function Tw2Vector3Key() {
    var _this;

    Tw2Vector3Curve_classCallCheck(this, Tw2Vector3Key);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2Vector3Curve_possibleConstructorReturn(this, Tw2Vector3Curve_getPrototypeOf(Tw2Vector3Key).call(this, ...args));

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this)), "value", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this)), "leftTangent", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this)), "rightTangent", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this)), "interpolation", 1);

    return _this;
  }

  return Tw2Vector3Key;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2Vector3Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec3} startValue
 * @property {vec3} currentValue
 * @property {vec3} endValue
 * @property {vec3} startTangent
 * @property {vec3} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2Vector3Key>} keys
 * @property {number} length
 * @class
 */

let Tw2Vector3Curve_Tw2Vector3Curve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2Vector3Curve_inherits(Tw2Vector3Curve, _Tw2Curve);

  function Tw2Vector3Curve() {
    var _this2;

    Tw2Vector3Curve_classCallCheck(this, Tw2Vector3Curve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2Vector3Curve_possibleConstructorReturn(this, Tw2Vector3Curve_getPrototypeOf(Tw2Vector3Curve).call(this, ...args));

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "cycle", false);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "reversed", false);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "timeOffset", 0);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "timeScale", 1);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "startValue", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "currentValue", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "endValue", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "startTangent", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "endTangent", global["H" /* vec3 */].create());

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "interpolation", 1);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "keys", []);

    Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_assertThisInitialized(Tw2Vector3Curve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2Vector3Curve_createClass(Tw2Vector3Curve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort2(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      time = time / this.timeScale + this.timeOffset;

      if (this.length <= 0 || time <= 0) {
        return global["H" /* vec3 */].copy(value, this.startValue);
      }

      if (time > this.length) {
        if (this.cycle) {
          time = time % this.length;
        } else if (this.reversed) {
          return global["H" /* vec3 */].copy(value, this.startValue);
        } else {
          return global["H" /* vec3 */].copy(value, this.endValue);
        }
      }

      if (this.reversed) {
        time = this.length - time;
      }

      if (this.keys.length === 0) {
        return this.Interpolate(time, null, null, value);
      }

      let startKey = this.keys[0],
          endKey = this.keys[this.keys.length - 1];

      if (time <= startKey.time) {
        return this.Interpolate(time, null, startKey, value);
      } else if (time >= endKey.time) {
        return this.Interpolate(time, endKey, null, value);
      }

      for (let i = 0; i + 1 < this.keys.length; ++i) {
        startKey = this.keys[i];
        endKey = this.keys[i + 1];
        if (startKey.time <= time && endKey.time > time) break;
      }

      return this.Interpolate(time, startKey, endKey, value);
    }
    /**
     * Interpolate
     * @param {number} time
     * @param {Tw2Vector3Key} lastKey
     * @param {Tw2Vector3Key} nextKey
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: "Interpolate",
    value: function Interpolate(time, lastKey, nextKey, value) {
      global["H" /* vec3 */].copy(value, this.startValue);
      let startValue = this.startValue,
          endValue = this.endValue,
          interp = this.interpolation,
          deltaTime = this.length;

      if (lastKey !== null) {
        interp = lastKey.interpolation;
        time -= lastKey.time;
      }

      switch (interp) {
        case Tw2Vector3Curve.Interpolation.LINEAR:
          if (lastKey && nextKey) {
            startValue = lastKey.value;
            endValue = nextKey.value;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            deltaTime = this.length - lastKey.time;
          }

          value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
          value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
          value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
          return value;

        case Tw2Vector3Curve.Interpolation.HERMITE:
          let inTangent = this.startTangent,
              outTangent = this.endTangent;

          if (lastKey && nextKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time - lastKey.time;
          } else if (nextKey) {
            endValue = nextKey.value;
            outTangent = nextKey.leftTangent;
            deltaTime = nextKey.time;
          } else if (lastKey) {
            startValue = lastKey.value;
            inTangent = lastKey.rightTangent;
            deltaTime = this.length - lastKey.time;
          }

          const s = time / deltaTime,
                s2 = s * s,
                s3 = s2 * s;
          const c2 = -2.0 * s3 + 3.0 * s2,
                c1 = 1.0 - c2,
                c4 = s3 - s2,
                c3 = s + c4 - s2;
          value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
          value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
          value[2] = startValue[2] * c1 + endValue[2] * c2 + inTangent[2] * c3 + outTangent[2] * c4;
          return value;

        default:
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2Vector3Curve;
}(Tw2Curve_Tw2Curve);

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "inputDimension", 3);

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "outputDimension", 3);

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "valueProperty", 'currentValue');

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE2);

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "Key", Tw2Vector3Curve_Tw2Vector3Key);

Tw2Vector3Curve_defineProperty(Tw2Vector3Curve_Tw2Vector3Curve, "Interpolation", {
  CONSTANT: 0,
  LINEAR: 1,
  HERMITE: 2
});
// CONCATENATED MODULE: ./curve/curves/Tw2VectorCurve.js
function Tw2VectorCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2VectorCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2VectorCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2VectorCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2VectorCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2VectorCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2VectorCurve_assertThisInitialized(self); }

function Tw2VectorCurve_getPrototypeOf(o) { Tw2VectorCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2VectorCurve_getPrototypeOf(o); }

function Tw2VectorCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2VectorCurve_setPrototypeOf(subClass, superClass); }

function Tw2VectorCurve_setPrototypeOf(o, p) { Tw2VectorCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2VectorCurve_setPrototypeOf(o, p); }

function Tw2VectorCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2VectorCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2VectorKey
 *
 * @property {vec3} value
 * @property {vec3} left
 * @property {vec3} right
 * @property {number} interpolation
 * @inherits Tw2CurveKey
 * @class
 */

let Tw2VectorCurve_Tw2VectorKey =
/*#__PURE__*/
function (_Tw2CurveKey) {
  Tw2VectorCurve_inherits(Tw2VectorKey, _Tw2CurveKey);

  function Tw2VectorKey() {
    var _this;

    Tw2VectorCurve_classCallCheck(this, Tw2VectorKey);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2VectorCurve_possibleConstructorReturn(this, Tw2VectorCurve_getPrototypeOf(Tw2VectorKey).call(this, ...args));

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this)), "value", global["H" /* vec3 */].create());

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this)), "left", global["H" /* vec3 */].create());

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this)), "right", global["H" /* vec3 */].create());

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this)), "interpolation", 0);

    return _this;
  }

  return Tw2VectorKey;
}(Tw2Curve_Tw2CurveKey);
/**
 * Tw2Vector3Curve
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} extrapolation
 * @property {Array.<Tw2VectorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */

let Tw2VectorCurve_Tw2VectorCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2VectorCurve_inherits(Tw2VectorCurve, _Tw2Curve);

  function Tw2VectorCurve() {
    var _this2;

    Tw2VectorCurve_classCallCheck(this, Tw2VectorCurve);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = Tw2VectorCurve_possibleConstructorReturn(this, Tw2VectorCurve_getPrototypeOf(Tw2VectorCurve).call(this, ...args));

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "start", 0);

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "value", global["H" /* vec3 */].create());

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "extrapolation", 0);

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "keys", []);

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "_currentKey", 1);

    Tw2VectorCurve_defineProperty(Tw2VectorCurve_assertThisInitialized(Tw2VectorCurve_assertThisInitialized(_this2)), "length", 0);

    return _this2;
  }

  Tw2VectorCurve_createClass(Tw2VectorCurve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      Tw2Curve_Tw2Curve.Sort(this);
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      if (this.length === 0) {
        return global["H" /* vec3 */].copy(value, this.value);
      }

      const firstKey = this.keys[0],
            lastKey = this.keys[this.keys.length - 1];

      if (time >= lastKey.time) {
        switch (this.extrapolation) {
          case Tw2VectorCurve.Extrapolation.NONE:
            return global["H" /* vec3 */].copy(value, this.value);

          case Tw2VectorCurve.Extrapolation.CONSTANT:
            return global["H" /* vec3 */].copy(value, lastKey.value);

          case Tw2VectorCurve.Extrapolation.GRADIENT:
            return global["H" /* vec3 */].scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

          default:
            time = time % lastKey.time;
        }
      } else if (time < 0 || time < firstKey.time) {
        switch (this.extrapolation) {
          case Tw2VectorCurve.Extrapolation.NONE:
            return global["H" /* vec3 */].copy(value, this.value);

          case Tw2VectorCurve.Extrapolation.GRADIENT:
            return global["H" /* vec3 */].scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

          default:
            return global["H" /* vec3 */].copy(value, firstKey.value);
        }
      }

      let ck = this.keys[this._currentKey],
          ck_1 = this.keys[this._currentKey - 1];

      while (time >= ck.time || time < ck_1.time) {
        if (time < ck_1.time) this._currentKey = 0;
        this._currentKey++;
        ck = this.keys[this._currentKey];
        ck_1 = this.keys[this._currentKey - 1];
      }

      const nt = (time - ck_1.time) / (ck.time - ck_1.time);

      switch (ck_1.interpolation) {
        case Tw2VectorCurve.Interpolation.CONSTANT:
          return global["H" /* vec3 */].copy(value, ck_1.value);

        case Tw2VectorCurve.Interpolation.LINEAR:
          value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
          value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
          value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
          return value;

        case Tw2VectorCurve.Interpolation.HERMITE:
          const k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                k2 = -2 * nt * nt * nt + 3 * nt * nt,
                k1 = nt * nt * nt - 2 * nt * nt + nt,
                k0 = nt * nt * nt - nt * nt;
          value[0] = k3 * ck_1.value[0] + k2 * ck.value[0] + k1 * ck_1.right[0] + k0 * ck.left[0];
          value[1] = k3 * ck_1.value[1] + k2 * ck.value[1] + k1 * ck_1.right[1] + k0 * ck.left[1];
          value[2] = k3 * ck_1.value[2] + k2 * ck.value[2] + k1 * ck_1.right[2] + k0 * ck.left[2];
          return value;

        default:
          return value;
      }
    }
    /**
     * The curve's key dimension
     * @type {number}
     */

  }]);

  return Tw2VectorCurve;
}(Tw2Curve_Tw2Curve);

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "inputDimension", 3);

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "outputDimension", 3);

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "valueProperty", 'value');

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE);

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "Key", Tw2VectorCurve_Tw2VectorKey);

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "Extrapolation", {
  NONE: 0,
  CONSTANT: 1,
  GRADIENT: 2,
  CYCLE: 3
});

Tw2VectorCurve_defineProperty(Tw2VectorCurve_Tw2VectorCurve, "Interpolation", {
  NONE: 0,
  CONSTANT: 1,
  LINEAR: 2,
  HERMITE: 3
});
// CONCATENATED MODULE: ./curve/curves/index.js















// CONCATENATED MODULE: ./curve/sequencers/Tw2CurveSequencer.js
function Tw2CurveSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2CurveSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2CurveSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2CurveSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2CurveSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2CurveSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2CurveSequencer_assertThisInitialized(self); }

function Tw2CurveSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2CurveSequencer_getPrototypeOf(o) { Tw2CurveSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2CurveSequencer_getPrototypeOf(o); }

function Tw2CurveSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2CurveSequencer_setPrototypeOf(subClass, superClass); }

function Tw2CurveSequencer_setPrototypeOf(o, p) { Tw2CurveSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2CurveSequencer_setPrototypeOf(o, p); }

function Tw2CurveSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2CurveSequencer base class
 *
 * @class
 */

let Tw2CurveSequencer =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2CurveSequencer_inherits(Tw2CurveSequencer, _Tw2Curve);

  function Tw2CurveSequencer() {
    Tw2CurveSequencer_classCallCheck(this, Tw2CurveSequencer);

    return Tw2CurveSequencer_possibleConstructorReturn(this, Tw2CurveSequencer_getPrototypeOf(Tw2CurveSequencer).apply(this, arguments));
  }

  Tw2CurveSequencer_createClass(Tw2CurveSequencer, null, [{
    key: "Sort",

    /**
     * Legacy sequencer sorting
     * @param {Tw2CurveSequencer} sequencer
     */
    value: function Sort(sequencer) {
      let curves = sequencer['functions'];

      if (curves && curves.length) {
        for (let i = 0; i < curves.length; i++) {
          if (curves[i] && 'Sort' in curves[i]) curves[i].Sort();
        }
      }
    }
    /**
     * Standard sequencer sorting
     * @param {Tw2CurveSequencer} sequencer
     */

  }, {
    key: "Sort2",
    value: function Sort2(sequencer) {
      const names = sequencer.constructor.childProperties;

      if (names) {
        for (let i = 0; i < names.length; i++) {
          let curve = sequencer[names[i]];
          if (curve && 'Sort' in curve) curve.Sort();
        }
      }
    }
    /**
     * The sequencer's curve property names
     * @type {?Array.<string>}
     */

  }]);

  return Tw2CurveSequencer;
}(Tw2Curve_Tw2Curve);

Tw2CurveSequencer_defineProperty(Tw2CurveSequencer, "childProperties", null);

Tw2CurveSequencer_defineProperty(Tw2CurveSequencer, "childArray", null);

Tw2CurveSequencer_defineProperty(Tw2CurveSequencer, "Operator", null);
// CONCATENATED MODULE: ./curve/sequencers/Tw2ColorSequencer.js
function Tw2ColorSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ColorSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ColorSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ColorSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ColorSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ColorSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ColorSequencer_assertThisInitialized(self); }

function Tw2ColorSequencer_getPrototypeOf(o) { Tw2ColorSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ColorSequencer_getPrototypeOf(o); }

function Tw2ColorSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ColorSequencer_setPrototypeOf(subClass, superClass); }

function Tw2ColorSequencer_setPrototypeOf(o, p) { Tw2ColorSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ColorSequencer_setPrototypeOf(o, p); }

function Tw2ColorSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ColorSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ColorSequencer
 *
 * @property {number} start
 * @property {vec4} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @class
 */

let Tw2ColorSequencer_Tw2ColorSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2ColorSequencer_inherits(Tw2ColorSequencer, _Tw2CurveSequencer);

  function Tw2ColorSequencer() {
    var _this;

    Tw2ColorSequencer_classCallCheck(this, Tw2ColorSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ColorSequencer_possibleConstructorReturn(this, Tw2ColorSequencer_getPrototypeOf(Tw2ColorSequencer).call(this, ...args));

    Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_assertThisInitialized(Tw2ColorSequencer_assertThisInitialized(_this)), "start", 0);

    Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_assertThisInitialized(Tw2ColorSequencer_assertThisInitialized(_this)), "value", global["I" /* vec4 */].create());

    Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_assertThisInitialized(Tw2ColorSequencer_assertThisInitialized(_this)), "operator", 0);

    Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_assertThisInitialized(Tw2ColorSequencer_assertThisInitialized(_this)), "functions", []);

    return _this;
  }

  Tw2ColorSequencer_createClass(Tw2ColorSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;

      for (let i = 0; i < this.functions.length; ++i) {
        if ('GetLength' in this.functions[i]) {
          len = Math.max(len, this.functions[i].GetLength());
        }
      }

      return len;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      const vec4_0 = Tw2CurveSequencer.global.vec4_0;

      switch (this.operator) {
        case Tw2ColorSequencer.Operator.MULTIPLY:
          global["I" /* vec4 */].set(value, 1, 1, 1, 1);

          for (let i = 0; i < this.functions.length; ++i) {
            this.functions[i].GetValueAt(time, vec4_0);
            global["I" /* vec4 */].multiply(value, value, vec4_0);
          }

          return value;

        default:
          global["I" /* vec4 */].set(value, 0, 0, 0, 0);

          for (let i = 0; i < this.functions.length; ++i) {
            this.functions[i].GetValueAt(time, vec4_0);
            global["I" /* vec4 */].add(value, value, vec4_0);
          }

          return value;
      }
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2ColorSequencer;
}(Tw2CurveSequencer);

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "inputDimension", 4);

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "outputDimension", 4);

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "valueProperty", 'value');

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER);

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "childArray", 'functions');

Tw2ColorSequencer_defineProperty(Tw2ColorSequencer_Tw2ColorSequencer, "Operator", {
  MULTIPLY: 0,
  ADD: 1
});
// CONCATENATED MODULE: ./curve/sequencers/Tw2EulerRotation.js
function Tw2EulerRotation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2EulerRotation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2EulerRotation_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2EulerRotation_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2EulerRotation_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2EulerRotation_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2EulerRotation_assertThisInitialized(self); }

function Tw2EulerRotation_getPrototypeOf(o) { Tw2EulerRotation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2EulerRotation_getPrototypeOf(o); }

function Tw2EulerRotation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2EulerRotation_setPrototypeOf(subClass, superClass); }

function Tw2EulerRotation_setPrototypeOf(o, p) { Tw2EulerRotation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2EulerRotation_setPrototypeOf(o, p); }

function Tw2EulerRotation_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2EulerRotation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2EulerRotation
 *
 * @property {string} name
 * @property {Tw2Curve} [yawCurve]
 * @property {Tw2Curve} [pitchCurve]
 * @property {Tw2Curve} [rollCurve]
 * @property {quat} currentValue=[0,0,0,1]
 * @class
 */

let Tw2EulerRotation_Tw2EulerRotation =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2EulerRotation_inherits(Tw2EulerRotation, _Tw2CurveSequencer);

  function Tw2EulerRotation() {
    var _this;

    Tw2EulerRotation_classCallCheck(this, Tw2EulerRotation);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2EulerRotation_possibleConstructorReturn(this, Tw2EulerRotation_getPrototypeOf(Tw2EulerRotation).call(this, ...args));

    Tw2EulerRotation_defineProperty(Tw2EulerRotation_assertThisInitialized(Tw2EulerRotation_assertThisInitialized(_this)), "yawCurve", null);

    Tw2EulerRotation_defineProperty(Tw2EulerRotation_assertThisInitialized(Tw2EulerRotation_assertThisInitialized(_this)), "pitchCurve", null);

    Tw2EulerRotation_defineProperty(Tw2EulerRotation_assertThisInitialized(Tw2EulerRotation_assertThisInitialized(_this)), "rollCurve", null);

    Tw2EulerRotation_defineProperty(Tw2EulerRotation_assertThisInitialized(Tw2EulerRotation_assertThisInitialized(_this)), "currentValue", global["C" /* quat */].create());

    return _this;
  }

  Tw2EulerRotation_createClass(Tw2EulerRotation, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort2(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;
      if (this.yawCurve && 'GetLength' in this.yawCurve) len = this.yawCurve.GetLength();
      if (this.pitchCurve && 'GetLength' in this.pitchCurve) len = Math.max(len, this.pitchCurve.GetLength());
      if (this.rollCurve && 'GetLength' in this.rollCurve) len = Math.max(len, this.rollCurve.GetLength());
      return len;
    }
    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      const yaw = this.yawCurve ? this.yawCurve.GetValueAt(time) : 0.0,
            pitch = this.pitchCurve ? this.pitchCurve.GetValueAt(time) : 0.0,
            roll = this.rollCurve ? this.rollCurve.GetValueAt(time) : 0.0;
      const sinYaw = Math.sin(yaw / 2.0),
            cosYaw = Math.cos(yaw / 2.0),
            sinPitch = Math.sin(pitch / 2.0),
            cosPitch = Math.cos(pitch / 2.0),
            sinRoll = Math.sin(roll / 2.0),
            cosRoll = Math.cos(roll / 2.0);
      value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
      value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
      value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2EulerRotation;
}(Tw2CurveSequencer);

Tw2EulerRotation_defineProperty(Tw2EulerRotation_Tw2EulerRotation, "inputDimension", 1);

Tw2EulerRotation_defineProperty(Tw2EulerRotation_Tw2EulerRotation, "outputDimension", 3);

Tw2EulerRotation_defineProperty(Tw2EulerRotation_Tw2EulerRotation, "valueProperty", 'currentValue');

Tw2EulerRotation_defineProperty(Tw2EulerRotation_Tw2EulerRotation, "curveType", Tw2CurveSequencer.Type.SEQUENCER2);

Tw2EulerRotation_defineProperty(Tw2EulerRotation_Tw2EulerRotation, "childProperties", ['yawCurve', 'pitchCurve', 'rollCurve']);
// CONCATENATED MODULE: ./curve/sequencers/Tw2QuaternionSequencer.js
function Tw2QuaternionSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2QuaternionSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2QuaternionSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2QuaternionSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2QuaternionSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2QuaternionSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2QuaternionSequencer_assertThisInitialized(self); }

function Tw2QuaternionSequencer_getPrototypeOf(o) { Tw2QuaternionSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2QuaternionSequencer_getPrototypeOf(o); }

function Tw2QuaternionSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2QuaternionSequencer_setPrototypeOf(subClass, superClass); }

function Tw2QuaternionSequencer_setPrototypeOf(o, p) { Tw2QuaternionSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2QuaternionSequencer_setPrototypeOf(o, p); }

function Tw2QuaternionSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2QuaternionSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2QuaternionSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {quat} value
 * @property {Array<Tw2Curve>} functions
 * @class
 */

let Tw2QuaternionSequencer_Tw2QuaternionSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2QuaternionSequencer_inherits(Tw2QuaternionSequencer, _Tw2CurveSequencer);

  function Tw2QuaternionSequencer() {
    var _this;

    Tw2QuaternionSequencer_classCallCheck(this, Tw2QuaternionSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2QuaternionSequencer_possibleConstructorReturn(this, Tw2QuaternionSequencer_getPrototypeOf(Tw2QuaternionSequencer).call(this, ...args));

    Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_assertThisInitialized(Tw2QuaternionSequencer_assertThisInitialized(_this)), "start", 0);

    Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_assertThisInitialized(Tw2QuaternionSequencer_assertThisInitialized(_this)), "value", global["C" /* quat */].create());

    Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_assertThisInitialized(Tw2QuaternionSequencer_assertThisInitialized(_this)), "functions", []);

    return _this;
  }

  Tw2QuaternionSequencer_createClass(Tw2QuaternionSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;

      for (let i = 0; i < this.functions.length; ++i) {
        if ('GetLength' in this.functions[i]) {
          len = Math.max(len, this.functions[i].GetLength());
        }
      }

      return len;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      global["C" /* quat */].identity(value);
      const quat_0 = Tw2CurveSequencer.global.quat_0;

      for (let i = 0; i < this.functions.length; ++i) {
        this.functions[i].GetValueAt(time, quat_0);
        global["C" /* quat */].multiply(value, value, quat_0);
      }

      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2QuaternionSequencer;
}(Tw2CurveSequencer);

Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_Tw2QuaternionSequencer, "inputDimension", 4);

Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_Tw2QuaternionSequencer, "outputDimension", 4);

Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_Tw2QuaternionSequencer, "valueProperty", 'value');

Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_Tw2QuaternionSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER);

Tw2QuaternionSequencer_defineProperty(Tw2QuaternionSequencer_Tw2QuaternionSequencer, "childArray", 'functions');
// CONCATENATED MODULE: ./curve/sequencers/Tw2RGBAScalarSequencer.js
function Tw2RGBAScalarSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RGBAScalarSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RGBAScalarSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RGBAScalarSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RGBAScalarSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RGBAScalarSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2RGBAScalarSequencer_assertThisInitialized(self); }

function Tw2RGBAScalarSequencer_getPrototypeOf(o) { Tw2RGBAScalarSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2RGBAScalarSequencer_getPrototypeOf(o); }

function Tw2RGBAScalarSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2RGBAScalarSequencer_setPrototypeOf(subClass, superClass); }

function Tw2RGBAScalarSequencer_setPrototypeOf(o, p) { Tw2RGBAScalarSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2RGBAScalarSequencer_setPrototypeOf(o, p); }

function Tw2RGBAScalarSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RGBAScalarSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2RGBAScalarSequencer
 *
 * @property {vec4} value
 * @property {Tw2Curve} RedCurve
 * @property {Tw2Curve} GreenCurve
 * @property {Tw2Curve} BlueCurve
 * @property {Tw2Curve} AlphaCurve
 * @class
 */

let Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2RGBAScalarSequencer_inherits(Tw2RGBAScalarSequencer, _Tw2CurveSequencer);

  function Tw2RGBAScalarSequencer() {
    var _this;

    Tw2RGBAScalarSequencer_classCallCheck(this, Tw2RGBAScalarSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2RGBAScalarSequencer_possibleConstructorReturn(this, Tw2RGBAScalarSequencer_getPrototypeOf(Tw2RGBAScalarSequencer).call(this, ...args));

    Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_assertThisInitialized(Tw2RGBAScalarSequencer_assertThisInitialized(_this)), "value", global["I" /* vec4 */].create());

    Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_assertThisInitialized(Tw2RGBAScalarSequencer_assertThisInitialized(_this)), "RedCurve", null);

    Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_assertThisInitialized(Tw2RGBAScalarSequencer_assertThisInitialized(_this)), "GreenCurve", null);

    Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_assertThisInitialized(Tw2RGBAScalarSequencer_assertThisInitialized(_this)), "BlueCurve", null);

    Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_assertThisInitialized(Tw2RGBAScalarSequencer_assertThisInitialized(_this)), "AlphaCurve", null);

    return _this;
  }

  Tw2RGBAScalarSequencer_createClass(Tw2RGBAScalarSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort2(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;
      if (this.RedCurve && 'GetLength' in this.RedCurve) len = this.RedCurve.GetLength();
      if (this.GreenCurve && 'GetLength' in this.GreenCurve) len = Math.max(len, this.GreenCurve.GetLength());
      if (this.BlueCurve && 'GetLength' in this.BlueCurve) len = Math.max(len, this.BlueCurve.GetLength());
      if (this.AlphaCurve && 'GetLength' in this.AlphaCurve) len = Math.max(len, this.AlphaCurve.GetLength());
      return len;
    }
    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      value[0] = this.RedCurve ? this.RedCurve.GetValueAt(time) : 0;
      value[1] = this.GreenCurve ? this.GreenCurve.GetValueAt(time) : 0;
      value[2] = this.BlueCurve ? this.BlueCurve.GetValueAt(time) : 0;
      value[3] = this.AlphaCurve ? this.AlphaCurve.GetValueAt(time) : 0;
      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2RGBAScalarSequencer;
}(Tw2CurveSequencer);

Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer, "inputDimension", 1);

Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer, "outputDimension", 4);

Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer, "valueProperty", 'value');

Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER2);

Tw2RGBAScalarSequencer_defineProperty(Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer, "childProperties", ['RedCurve', 'GreenCurve', 'BlueCurve', 'AlphaCurve']);
// CONCATENATED MODULE: ./curve/sequencers/Tw2ScalarSequencer.js
function Tw2ScalarSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ScalarSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ScalarSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ScalarSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ScalarSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ScalarSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ScalarSequencer_assertThisInitialized(self); }

function Tw2ScalarSequencer_getPrototypeOf(o) { Tw2ScalarSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ScalarSequencer_getPrototypeOf(o); }

function Tw2ScalarSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ScalarSequencer_setPrototypeOf(subClass, superClass); }

function Tw2ScalarSequencer_setPrototypeOf(o, p) { Tw2ScalarSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ScalarSequencer_setPrototypeOf(o, p); }

function Tw2ScalarSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ScalarSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2ScalarSequencer
 *
 * @property {string} name
 * @property {number} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @property {number} inMinClamp
 * @property {number} inMaxClamp
 * @property {number} outMinClamp
 * @property {number} outMaxClamp
 * @property {boolean} clamping
 * @class
 */

let Tw2ScalarSequencer_Tw2ScalarSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2ScalarSequencer_inherits(Tw2ScalarSequencer, _Tw2CurveSequencer);

  function Tw2ScalarSequencer() {
    var _this;

    Tw2ScalarSequencer_classCallCheck(this, Tw2ScalarSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ScalarSequencer_possibleConstructorReturn(this, Tw2ScalarSequencer_getPrototypeOf(Tw2ScalarSequencer).call(this, ...args));

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "value", 0);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "operator", 0);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "functions", []);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "inMinClamp", 0);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "inMaxClamp", 1);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "outMinClamp", 0);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "outMaxClamp", 1);

    Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_assertThisInitialized(Tw2ScalarSequencer_assertThisInitialized(_this)), "clamping", false);

    return _this;
  }

  Tw2ScalarSequencer_createClass(Tw2ScalarSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;

      for (let i = 0; i < this.functions.length; ++i) {
        if ('GetLength' in this.functions[i]) {
          len = Math.max(len, this.functions[i].GetLength());
        }
      }

      return len;
    }
    /**
     * Updates a value at a specific time
     *
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }
    /**
     * Gets a value at a specific time
     *
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time) {
      let value;

      switch (this.operator) {
        case Tw2ScalarSequencer.Operator.MULTIPLY:
          value = 1;

          for (let i = 0; i < this.functions.length; ++i) {
            let v = this.functions[i].GetValueAt(time);

            if (this.clamping) {
              v = Math.min(Math.max(v, this.inMinClamp), this.inMaxClamp);
            }

            value *= v;
          }

          break;

        default:
          value = 0;

          for (let i = 0; i < this.functions.length; ++i) {
            let v = this.functions[i].GetValueAt(time);

            if (this.clamping) {
              v = Math.min(Math.max(v, this.inMinClamp), this.inMaxClamp);
            }

            value += v;
          }

      }

      if (this.clamping) {
        value = Math.min(Math.max(value, this.outMinClamp), this.outMaxClamp);
      }

      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2ScalarSequencer;
}(Tw2CurveSequencer);

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "inputDimension", 1);

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "outputDimension", 1);

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "valueProperty", 'value');

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER);

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "childArray", 'functions');

Tw2ScalarSequencer_defineProperty(Tw2ScalarSequencer_Tw2ScalarSequencer, "Operator", {
  MULTIPLY: 0,
  ADD: 1
});
// CONCATENATED MODULE: ./curve/sequencers/Tw2VectorSequencer.js
function Tw2VectorSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2VectorSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2VectorSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2VectorSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2VectorSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2VectorSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2VectorSequencer_assertThisInitialized(self); }

function Tw2VectorSequencer_getPrototypeOf(o) { Tw2VectorSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2VectorSequencer_getPrototypeOf(o); }

function Tw2VectorSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2VectorSequencer_setPrototypeOf(subClass, superClass); }

function Tw2VectorSequencer_setPrototypeOf(o, p) { Tw2VectorSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2VectorSequencer_setPrototypeOf(o, p); }

function Tw2VectorSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2VectorSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2VectorSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} operator
 * @property {Array.<Tw2Curve>} functions
 * @class
 */

let Tw2VectorSequencer_Tw2VectorSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2VectorSequencer_inherits(Tw2VectorSequencer, _Tw2CurveSequencer);

  function Tw2VectorSequencer() {
    var _this;

    Tw2VectorSequencer_classCallCheck(this, Tw2VectorSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2VectorSequencer_possibleConstructorReturn(this, Tw2VectorSequencer_getPrototypeOf(Tw2VectorSequencer).call(this, ...args));

    Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_assertThisInitialized(Tw2VectorSequencer_assertThisInitialized(_this)), "start", 0);

    Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_assertThisInitialized(Tw2VectorSequencer_assertThisInitialized(_this)), "value", global["H" /* vec3 */].create());

    Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_assertThisInitialized(Tw2VectorSequencer_assertThisInitialized(_this)), "operator", 0);

    Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_assertThisInitialized(Tw2VectorSequencer_assertThisInitialized(_this)), "functions", []);

    return _this;
  }

  Tw2VectorSequencer_createClass(Tw2VectorSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;

      for (let i = 0; i < this.functions.length; ++i) {
        if ('GetLength' in this.functions[i]) {
          len = Math.max(len, this.functions[i].GetLength());
        }
      }

      return len;
    }
    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      const vec3_0 = Tw2CurveSequencer.global.vec3_0;

      switch (this.operator) {
        case Tw2VectorSequencer.Operator.MULTIPLY:
          global["H" /* vec3 */].set(value, 1, 1, 1);

          for (let i = 0; i < this.functions.length; ++i) {
            this.functions[i].GetValueAt(time, vec3_0);
            global["H" /* vec3 */].multiply(value, value, vec3_0);
          }

          return value;

        default:
          global["H" /* vec3 */].set(value, 0, 0, 0);

          for (let i = 0; i < this.functions.length; ++i) {
            this.functions[i].GetValueAt(time, vec3_0);
            global["H" /* vec3 */].add(value, value, vec3_0);
          }

          return value;
      }
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2VectorSequencer;
}(Tw2CurveSequencer);

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "inputDimension", 3);

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "outputDimension", 3);

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "valueProperty", 'value');

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER);

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "childArray", 'functions');

Tw2VectorSequencer_defineProperty(Tw2VectorSequencer_Tw2VectorSequencer, "Operator", {
  MULTIPLY: 0,
  ADD: 1
});
// CONCATENATED MODULE: ./curve/sequencers/Tw2XYZScalarSequencer.js
function Tw2XYZScalarSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2XYZScalarSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2XYZScalarSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2XYZScalarSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2XYZScalarSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2XYZScalarSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2XYZScalarSequencer_assertThisInitialized(self); }

function Tw2XYZScalarSequencer_getPrototypeOf(o) { Tw2XYZScalarSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2XYZScalarSequencer_getPrototypeOf(o); }

function Tw2XYZScalarSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2XYZScalarSequencer_setPrototypeOf(subClass, superClass); }

function Tw2XYZScalarSequencer_setPrototypeOf(o, p) { Tw2XYZScalarSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2XYZScalarSequencer_setPrototypeOf(o, p); }

function Tw2XYZScalarSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2XYZScalarSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2XYZScalarSequencer
 *
 * @property {string} name
 * @property {vec3} value
 * @property {Tw2CurveSequencer} XCurve
 * @property {Tw2CurveSequencer} YCurve
 * @property {Tw2CurveSequencer} ZCurve
 * @class
 */

let Tw2XYZScalarSequencer_Tw2XYZScalarSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2XYZScalarSequencer_inherits(Tw2XYZScalarSequencer, _Tw2CurveSequencer);

  function Tw2XYZScalarSequencer() {
    var _this;

    Tw2XYZScalarSequencer_classCallCheck(this, Tw2XYZScalarSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2XYZScalarSequencer_possibleConstructorReturn(this, Tw2XYZScalarSequencer_getPrototypeOf(Tw2XYZScalarSequencer).call(this, ...args));

    Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_assertThisInitialized(Tw2XYZScalarSequencer_assertThisInitialized(_this)), "value", global["H" /* vec3 */].create());

    Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_assertThisInitialized(Tw2XYZScalarSequencer_assertThisInitialized(_this)), "XCurve", null);

    Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_assertThisInitialized(Tw2XYZScalarSequencer_assertThisInitialized(_this)), "YCurve", null);

    Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_assertThisInitialized(Tw2XYZScalarSequencer_assertThisInitialized(_this)), "ZCurve", null);

    return _this;
  }

  Tw2XYZScalarSequencer_createClass(Tw2XYZScalarSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort2(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;
      if (this.XCurve && 'GetLength' in this.XCurve) len = this.XCurve.GetLength();
      if (this.YCurve && 'GetLength' in this.YCurve) len = Math.max(len, this.YCurve.GetLength());
      if (this.ZCurve && 'GetLength' in this.ZCurve) len = Math.max(len, this.ZCurve.GetLength());
      return len;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      value[0] = this.XCurve ? this.XCurve.GetValueAt(time) : 0;
      value[1] = this.YCurve ? this.YCurve.GetValueAt(time) : 0;
      value[2] = this.ZCurve ? this.ZCurve.GetValueAt(time) : 0;
      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2XYZScalarSequencer;
}(Tw2CurveSequencer);

Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_Tw2XYZScalarSequencer, "inputDimension", 1);

Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_Tw2XYZScalarSequencer, "outputDimension", 3);

Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_Tw2XYZScalarSequencer, "valueProperty", 'value');

Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_Tw2XYZScalarSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER2);

Tw2XYZScalarSequencer_defineProperty(Tw2XYZScalarSequencer_Tw2XYZScalarSequencer, "childProperties", ['XCurve', 'YCurve', 'ZCurve']);
// CONCATENATED MODULE: ./curve/sequencers/Tw2YPRSequencer.js
function Tw2YPRSequencer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2YPRSequencer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2YPRSequencer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2YPRSequencer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2YPRSequencer_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2YPRSequencer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2YPRSequencer_assertThisInitialized(self); }

function Tw2YPRSequencer_getPrototypeOf(o) { Tw2YPRSequencer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2YPRSequencer_getPrototypeOf(o); }

function Tw2YPRSequencer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2YPRSequencer_setPrototypeOf(subClass, superClass); }

function Tw2YPRSequencer_setPrototypeOf(o, p) { Tw2YPRSequencer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2YPRSequencer_setPrototypeOf(o, p); }

function Tw2YPRSequencer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2YPRSequencer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2YPRSequencer
 *
 * @property {quat} value
 * @property {vec3} YawPitchRoll
 * @property {Tw2Curve} YawCurve
 * @property {Tw2Curve} PitchCurve
 * @property {Tw2Curve} RollCurve
 * @class
 */

let Tw2YPRSequencer_Tw2YPRSequencer =
/*#__PURE__*/
function (_Tw2CurveSequencer) {
  Tw2YPRSequencer_inherits(Tw2YPRSequencer, _Tw2CurveSequencer);

  function Tw2YPRSequencer() {
    var _this;

    Tw2YPRSequencer_classCallCheck(this, Tw2YPRSequencer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2YPRSequencer_possibleConstructorReturn(this, Tw2YPRSequencer_getPrototypeOf(Tw2YPRSequencer).call(this, ...args));

    Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_assertThisInitialized(Tw2YPRSequencer_assertThisInitialized(_this)), "value", global["C" /* quat */].create());

    Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_assertThisInitialized(Tw2YPRSequencer_assertThisInitialized(_this)), "YawPitchRoll", global["H" /* vec3 */].create());

    Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_assertThisInitialized(Tw2YPRSequencer_assertThisInitialized(_this)), "YawCurve", null);

    Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_assertThisInitialized(Tw2YPRSequencer_assertThisInitialized(_this)), "PitchCurve", null);

    Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_assertThisInitialized(Tw2YPRSequencer_assertThisInitialized(_this)), "RollCurve", null);

    return _this;
  }

  Tw2YPRSequencer_createClass(Tw2YPRSequencer, [{
    key: "Sort",

    /**
     * Sorts the sequencer
     */
    value: function Sort() {
      Tw2CurveSequencer.Sort2(this);
    }
    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      let len = 0;
      if (this.YawCurve && 'GetLength' in this.YawCurve) len = this.YawCurve.GetLength();
      if (this.PitchCurve && 'GetLength' in this.PitchCurve) len = Math.max(len, this.PitchCurve.GetLength());
      if (this.RollCurve && 'GetLength' in this.RollCurve) len = Math.max(len, this.RollCurve.GetLength());
      return len;
    }
    /**
     * Updates a value at a specific time
     *
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }
    /**
     * Gets a value at a specific time
     *
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: "GetValueAt",
    value: function GetValueAt(time, value) {
      if (this.YawCurve) this.YawPitchRoll[0] = this.YawCurve.GetValueAt(time);
      if (this.PitchCurve) this.YawPitchRoll[1] = this.PitchCurve.GetValueAt(time);
      if (this.RollCurve) this.YawPitchRoll[2] = this.RollCurve.GetValueAt(time);
      const sinYaw = Math.sin(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
            cosYaw = Math.cos(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
            sinPitch = Math.sin(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
            cosPitch = Math.cos(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
            sinRoll = Math.sin(this.YawPitchRoll[2] / 180 * Math.PI / 2.0),
            cosRoll = Math.cos(this.YawPitchRoll[2] / 180 * Math.PI / 2.0);
      value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
      value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
      value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
      return value;
    }
    /**
     * The sequencer's curve dimension
     * @type {number}
     */

  }]);

  return Tw2YPRSequencer;
}(Tw2CurveSequencer);

Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_Tw2YPRSequencer, "inputDimension", 1);

Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_Tw2YPRSequencer, "outputDimension", 4);

Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_Tw2YPRSequencer, "valueProperty", 'value');

Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_Tw2YPRSequencer, "curveType", Tw2CurveSequencer.Type.SEQUENCER2);

Tw2YPRSequencer_defineProperty(Tw2YPRSequencer_Tw2YPRSequencer, "childProperties", ['YawCurve', 'PitchCurve', 'RollCurve']);
// CONCATENATED MODULE: ./curve/sequencers/index.js








// CONCATENATED MODULE: ./curve/tracks/Tw2WbgTrack.js

/**
 * Tw2WbgTrack
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} geometryResPath
 * @property {Object} geometryRes
 * @property {string} group
 * @property {number} duration
 * @property {boolean} cycle
 */

function Tw2WbgTrack() {
  this._id = global["F" /* util */].generateID();
  this.name = '';
  this.geometryResPath = '';
  this.geometryRes = null;
  this.group = '';
  this.duration = 0;
  this.cycle = false;
  /**
   * SetCurves
   * @param self
   * @private
   */

  function SetCurves(self) {
    if (!self.name || !self.group || !self.geometryRes) {
      return;
    }

    for (let i = 0; i < self.geometryRes.animations.length; ++i) {
      let animation = self.geometryRes.animations[i];

      for (let j = 0; j < animation.trackGroups.length; ++j) {
        if (animation.trackGroups[j].name === self.group) {
          self._ApplyTracks(animation.trackGroups[j], animation.duration);
        }
      }
    }
  }
  /**
   * Initialize
   * @method
   */


  this.Initialize = function () {
    if (this.geometryResPath) {
      this.geometryRes = global["D" /* resMan */].GetResource(this.geometryResPath);
      const self = this;
      let notification = {
        OnResPrepared: function OnResPrepared() {
          SetCurves(self);
        }
      };
      this.geometryRes.RegisterNotification(notification);
    }
  };
  /**
   * Updates a value at a specific time
   * @param {number} time
   * @prototype
   */


  this.UpdateValue = function (time) {
    if (!this._TracksReady()) return;
    if (this.cycle) time = time % this.duration;
    if (time <= this.duration && time >= 0) this._UpdateValue(time);
  };
}
/**
 * Tw2WbgTransformTrack
 *
 * @property {string|number} _id
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @variable {*} positionCurve
 * @variable {*} rotationCurve
 * @variable {*} scaleCurve
 * @variable {mat4} scaleShear
 */

function Tw2WbgTransformTrack() {
  this._id = global["F" /* util */].generateID();
  this.translation = global["H" /* vec3 */].create();
  this.rotation = global["C" /* quat */].create();
  this.rotation[3] = 1;
  this.scale = global["H" /* vec3 */].create();
  let positionCurve = null;
  let rotationCurve = null;
  let scaleCurve = null;
  let scaleShear = global["z" /* mat4 */].create();
  /**
   * _TracksReady
   * @returns {*}
   * @private
   */

  this._TracksReady = function () {
    return positionCurve || rotationCurve || scaleCurve;
  };
  /**
   * _ApplyTracks
   * @param trackGroup
   * @param duration
   * @private
   */


  this._ApplyTracks = function (trackGroup, duration) {
    for (let i = 0; i < trackGroup.transformTracks.length; ++i) {
      let track = trackGroup.transformTracks[i];

      if (track.name === this.name) {
        this.duration = duration;
        positionCurve = track.position;
        rotationCurve = track.orientation;
        scaleCurve = track.scaleShear;
      }
    }

    this.UpdateValue(0);
  };
  /**
   * Updates a value at a specific time
   * @param {number} time
   * @prototype
   */


  this._UpdateValue = function (time) {
    if (positionCurve) {
      global["v" /* curve */].evaluate(positionCurve, time, this.translation, this.cycle, this.duration);
    }

    if (rotationCurve) {
      global["v" /* curve */].evaluate(rotationCurve, time, this.rotation, this.cycle, this.duration);
      global["C" /* quat */].normalize(this.rotation, this.rotation);
    }

    if (scaleCurve) {
      global["v" /* curve */].evaluate(scaleCurve, time, scaleShear, this.cycle, this.duration);
    }

    this.scale[0] = scaleShear[0];
    this.scale[1] = scaleShear[5];
    this.scale[2] = scaleShear[10];
  };
}
/**
 * @type {Tw2WbgTrack}
 * @prototype
 */

Tw2WbgTransformTrack.prototype = new Tw2WbgTrack();
// CONCATENATED MODULE: ./curve/tracks/Tw2TransformTrack.js
function Tw2TransformTrack_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2TransformTrack_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2TransformTrack_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2TransformTrack_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2TransformTrack_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2TransformTrack_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2TransformTrack
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} resPath
 * @property {Object} res
 * @property {string} group
 * @property {boolean} cycle
 * @property {number} duration
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @property positionCurve
 * @property orientationCurve
 * @property scaleCurve
 * @property {mat4} _scaleShear
 * @class
 */

let Tw2TransformTrack_Tw2TransformTrack =
/*#__PURE__*/
function () {
  function Tw2TransformTrack() {
    Tw2TransformTrack_classCallCheck(this, Tw2TransformTrack);

    Tw2TransformTrack_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2TransformTrack_defineProperty(this, "name", '');

    Tw2TransformTrack_defineProperty(this, "resPath", '');

    Tw2TransformTrack_defineProperty(this, "res", null);

    Tw2TransformTrack_defineProperty(this, "group", '');

    Tw2TransformTrack_defineProperty(this, "cycle", false);

    Tw2TransformTrack_defineProperty(this, "duration", 0);

    Tw2TransformTrack_defineProperty(this, "translation", global["H" /* vec3 */].create());

    Tw2TransformTrack_defineProperty(this, "rotation", global["C" /* quat */].create());

    Tw2TransformTrack_defineProperty(this, "scale", global["H" /* vec3 */].fromValues(0, 0, 0));

    Tw2TransformTrack_defineProperty(this, "scaleShear", global["z" /* mat4 */].create());

    Tw2TransformTrack_defineProperty(this, "positionCurve", null);

    Tw2TransformTrack_defineProperty(this, "orientationCurve", null);

    Tw2TransformTrack_defineProperty(this, "scaleCurve", null);
  }

  Tw2TransformTrack_createClass(Tw2TransformTrack, [{
    key: "Initialize",

    /**
     * Initializes the Curve
     */
    value: function Initialize() {
      if (this.resPath !== '') {
        this.res = global["D" /* resMan */].GetResource(this.resPath);
      }
    }
    /**
     * Gets curve length
     *
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.duration;
    }
    /**
     * Updates a value at a specific time
     *
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      if (!this.res || !this.res.IsGood()) return;
      if (!this.positionCurve) this.FindTracks();
      if (!this.positionCurve) return;
      if (this.cycle) time = time % this.duration;
      if (time > this.duration || time < 0) return;
      global["v" /* curve */].evaluate(this.positionCurve, time, this.translation, this.cycle, this.duration);
      global["v" /* curve */].evaluate(this.orientationCurve, time, this.rotation, this.cycle, this.duration);
      global["C" /* quat */].normalize(this.rotation, this.rotation);
      global["v" /* curve */].evaluate(this.scaleCurve, time, this.scaleShear, this.cycle, this.duration);
      global["z" /* mat4 */].getScaling(this.scale, this.scaleCurve);
    }
    /**
     * FindTracks
     */

  }, {
    key: "FindTracks",
    value: function FindTracks() {
      let group = null;

      for (let i = 0; i < this.res.animations.length; ++i) {
        for (let j = 0; j < this.res.animations[i].trackGroups.length; ++j) {
          if (this.res.animations[i].trackGroups[j].name === this.group) {
            this.duration = this.res.animations[i].duration;
            group = this.res.animations[i].trackGroups[j];
            break;
          }
        }
      }

      if (!group) return;

      for (let i = 0; i < group.transformTracks.length; ++i) {
        if (this.name === group.transformTracks[i].name) {
          this.positionCurve = group.transformTracks[i].position;
          this.orientationCurve = group.transformTracks[i].orientation;
          this.scaleCurve = group.transformTracks[i].scaleShear;
          break;
        }
      }
    }
  }]);

  return Tw2TransformTrack;
}();
// CONCATENATED MODULE: ./curve/tracks/index.js


// CONCATENATED MODULE: ./curve/maya/Tw2MayaEulerRotationCurve.js
function Tw2MayaEulerRotationCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MayaEulerRotationCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MayaEulerRotationCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MayaEulerRotationCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MayaEulerRotationCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2MayaEulerRotationCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2MayaEulerRotationCurve_assertThisInitialized(self); }

function Tw2MayaEulerRotationCurve_getPrototypeOf(o) { Tw2MayaEulerRotationCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2MayaEulerRotationCurve_getPrototypeOf(o); }

function Tw2MayaEulerRotationCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2MayaEulerRotationCurve_setPrototypeOf(subClass, superClass); }

function Tw2MayaEulerRotationCurve_setPrototypeOf(o, p) { Tw2MayaEulerRotationCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2MayaEulerRotationCurve_setPrototypeOf(o, p); }

function Tw2MayaEulerRotationCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2MayaEulerRotationCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MayaEulerRotationCurve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {?Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} eulerValue
 * @property {boolean} updateQuaternion
 * @property {quat} quatValue
 * @property {number} length
 * @class
 */

let Tw2MayaEulerRotationCurve_Tw2MayaEulerRotationCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2MayaEulerRotationCurve_inherits(Tw2MayaEulerRotationCurve, _Tw2Curve);

  function Tw2MayaEulerRotationCurve() {
    var _this;

    Tw2MayaEulerRotationCurve_classCallCheck(this, Tw2MayaEulerRotationCurve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2MayaEulerRotationCurve_possibleConstructorReturn(this, Tw2MayaEulerRotationCurve_getPrototypeOf(Tw2MayaEulerRotationCurve).call(this, ...args));

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "xIndex", -1);

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "yIndex", -1);

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "zIndex", -1);

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "animationEngine", null);

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "eulerValue", global["H" /* vec3 */].create());

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "updateQuaternion", false);

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "quatValue", global["C" /* quat */].create());

    Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_assertThisInitialized(Tw2MayaEulerRotationCurve_assertThisInitialized(_this)), "length", 0);

    return _this;
  }

  Tw2MayaEulerRotationCurve_createClass(Tw2MayaEulerRotationCurve, [{
    key: "Sort",

    /**
     * Sorts the curve
     */
    value: function Sort() {
      this.ComputeLength();
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      if (this.animationEngine) {
        if (this.xIndex) {
          this.eulerValue[0] = this.animationEngine.Evaluate(this.xIndex, time);
        }

        if (this.yIndex) {
          if (this.yIndex === this.xIndex) {
            this.eulerValue[1] = this.eulerValue[0];
          } else {
            this.eulerValue[1] = this.animationEngine.Evaluate(this.yIndex, time);
          }
        }

        if (this.zIndex) {
          if (this.zIndex === this.xIndex) {
            this.eulerValue[2] = this.eulerValue[0];
          } else {
            this.eulerValue[2] = this.animationEngine.Evaluate(this.zIndex, time);
          }
        }

        if (this.updateQuaternion) {
          const sinYaw = Math.sin(this.eulerValue[0] / 2),
                cosYaw = Math.cos(this.eulerValue[0] / 2),
                sinPitch = Math.sin(this.eulerValue[1] / 2),
                cosPitch = Math.cos(this.eulerValue[1] / 2),
                sinRoll = Math.sin(this.eulerValue[2] / 2),
                cosRoll = Math.cos(this.eulerValue[2] / 2);
          this.quatValue[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
          this.quatValue[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
          this.quatValue[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
          this.quatValue[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
        }
      }
    }
    /**
     * Computes curve Length
     */

  }, {
    key: "ComputeLength",
    value: function ComputeLength() {
      if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;
      this.length = 0;

      if (this.xIndex >= 0) {
        this.length = this.animationEngine.GetLength(this.xIndex);
      }

      if (this.yIndex >= 0) {
        this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
      }

      if (this.zIndex >= 0) {
        this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
      }
    }
    /**
     * The curve's dimension
     * @type {number}
     */

  }]);

  return Tw2MayaEulerRotationCurve;
}(Tw2Curve_Tw2Curve);

Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_Tw2MayaEulerRotationCurve, "outputDimension", 3);

Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_Tw2MayaEulerRotationCurve, "valueProperty", 'eulerValue');

Tw2MayaEulerRotationCurve_defineProperty(Tw2MayaEulerRotationCurve_Tw2MayaEulerRotationCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_MAYA);
// CONCATENATED MODULE: ./curve/maya/Tw2MayaScalarCurve.js
function Tw2MayaScalarCurve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MayaScalarCurve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MayaScalarCurve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MayaScalarCurve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MayaScalarCurve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2MayaScalarCurve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2MayaScalarCurve_assertThisInitialized(self); }

function Tw2MayaScalarCurve_getPrototypeOf(o) { Tw2MayaScalarCurve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2MayaScalarCurve_getPrototypeOf(o); }

function Tw2MayaScalarCurve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2MayaScalarCurve_setPrototypeOf(subClass, superClass); }

function Tw2MayaScalarCurve_setPrototypeOf(o, p) { Tw2MayaScalarCurve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2MayaScalarCurve_setPrototypeOf(o, p); }

function Tw2MayaScalarCurve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2MayaScalarCurve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2MayaScalarCurve
 *
 * @property {number} index
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {number} value
 * @property {number} length
 * @class
 */

let Tw2MayaScalarCurve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2MayaScalarCurve_inherits(Tw2MayaScalarCurve, _Tw2Curve);

  function Tw2MayaScalarCurve() {
    var _this;

    Tw2MayaScalarCurve_classCallCheck(this, Tw2MayaScalarCurve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2MayaScalarCurve_possibleConstructorReturn(this, Tw2MayaScalarCurve_getPrototypeOf(Tw2MayaScalarCurve).call(this, ...args));

    Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve_assertThisInitialized(Tw2MayaScalarCurve_assertThisInitialized(_this)), "index", -1);

    Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve_assertThisInitialized(Tw2MayaScalarCurve_assertThisInitialized(_this)), "animationEngine", null);

    Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve_assertThisInitialized(Tw2MayaScalarCurve_assertThisInitialized(_this)), "value", 0);

    Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve_assertThisInitialized(Tw2MayaScalarCurve_assertThisInitialized(_this)), "length", 0);

    return _this;
  }

  Tw2MayaScalarCurve_createClass(Tw2MayaScalarCurve, [{
    key: "Sort",

    /**
     * Sorts the curve
     */
    value: function Sort() {
      this.ComputeLength();
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      if (this.animationEngine) {
        this.value = this.animationEngine.Evaluate(this.index, time);
      }
    }
    /**
     * Computes curve Length
     */

  }, {
    key: "ComputeLength",
    value: function ComputeLength() {
      if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;
      if (this.index >= 0) this.length = this.animationEngine.GetLength(this.index);
    }
    /**
     * The curve's dimension
     * @type {number}
     */

  }]);

  return Tw2MayaScalarCurve;
}(Tw2Curve_Tw2Curve);

Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve, "outputDimension", 1);

Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve, "valueProperty", 'value');

Tw2MayaScalarCurve_defineProperty(Tw2MayaScalarCurve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_MAYA);
// CONCATENATED MODULE: ./curve/maya/Tw2MayaVector3Curve.js
function Tw2MayaVector3Curve_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MayaVector3Curve_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MayaVector3Curve_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MayaVector3Curve_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MayaVector3Curve_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2MayaVector3Curve_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2MayaVector3Curve_assertThisInitialized(self); }

function Tw2MayaVector3Curve_getPrototypeOf(o) { Tw2MayaVector3Curve_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2MayaVector3Curve_getPrototypeOf(o); }

function Tw2MayaVector3Curve_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2MayaVector3Curve_setPrototypeOf(subClass, superClass); }

function Tw2MayaVector3Curve_setPrototypeOf(o, p) { Tw2MayaVector3Curve_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2MayaVector3Curve_setPrototypeOf(o, p); }

function Tw2MayaVector3Curve_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2MayaVector3Curve_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MayaVector3Curve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} value
 * @property {number} length
 */

let Tw2MayaVector3Curve_Tw2MayaVector3Curve =
/*#__PURE__*/
function (_Tw2Curve) {
  Tw2MayaVector3Curve_inherits(Tw2MayaVector3Curve, _Tw2Curve);

  function Tw2MayaVector3Curve() {
    var _this;

    Tw2MayaVector3Curve_classCallCheck(this, Tw2MayaVector3Curve);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2MayaVector3Curve_possibleConstructorReturn(this, Tw2MayaVector3Curve_getPrototypeOf(Tw2MayaVector3Curve).call(this, ...args));

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "xIndex", -1);

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "yIndex", -1);

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "zIndex", -1);

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "animationEngine", null);

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "value", global["H" /* vec3 */].create());

    Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_assertThisInitialized(Tw2MayaVector3Curve_assertThisInitialized(_this)), "length", 0);

    return _this;
  }

  Tw2MayaVector3Curve_createClass(Tw2MayaVector3Curve, [{
    key: "Sort",

    /**
     * Sorts the curve's keys
     */
    value: function Sort() {
      this.ComputeLength();
    }
    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength() {
      return this.length;
    }
    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: "UpdateValue",
    value: function UpdateValue(time) {
      if (this.animationEngine) {
        if (this.xIndex) {
          this.value[0] = this.animationEngine.Evaluate(this.xIndex, time);
        }

        if (this.yIndex) {
          if (this.yIndex === this.xIndex) {
            this.value[1] = this.value[0];
          } else {
            this.value[1] = this.animationEngine.Evaluate(this.yIndex, time);
          }
        }

        if (this.zIndex) {
          if (this.zIndex === this.xIndex) {
            this.value[2] = this.value[0];
          } else {
            this.value[2] = this.animationEngine.Evaluate(this.zIndex, time);
          }
        }
      }
    }
    /**
     * Computes curve Length
     */

  }, {
    key: "ComputeLength",
    value: function ComputeLength() {
      if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;
      this.length = 0;

      if (this.xIndex >= 0) {
        this.length = this.animationEngine.GetLength(this.xIndex);
      }

      if (this.yIndex >= 0) {
        this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
      }

      if (this.zIndex >= 0) {
        this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
      }
    }
    /**
     * The curve's dimension
     * @type {number}
     */

  }]);

  return Tw2MayaVector3Curve;
}(Tw2Curve_Tw2Curve);

Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_Tw2MayaVector3Curve, "outputDimension", 3);

Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_Tw2MayaVector3Curve, "valueProperty", 'value');

Tw2MayaVector3Curve_defineProperty(Tw2MayaVector3Curve_Tw2MayaVector3Curve, "curveType", Tw2Curve_Tw2Curve.Type.CURVE_MAYA);
// EXTERNAL MODULE: ./core/index.js + 60 modules
var core = __webpack_require__(1);

// CONCATENATED MODULE: ./curve/maya/Tw2MayaAnimationEngine.js
function Tw2MayaAnimationEngine_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2MayaAnimationEngine_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2MayaAnimationEngine_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2MayaAnimationEngine_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2MayaAnimationEngine_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2MayaAnimationEngine_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2MayaAnimationEngine
 * TODO: Complete the prototype `_EvaluteBezier`
 *
 * @property {number|string} id
 * @property {Array} curves
 * @property {Array} hermiteSegments
 * @property {Array} bezierSegments
 * @property {number} _currentCurveIndex
 * @property _evalCache
 */

let Tw2MayaAnimationEngine_Tw2MayaAnimationEngine =
/*#__PURE__*/
function () {
  function Tw2MayaAnimationEngine() {
    Tw2MayaAnimationEngine_classCallCheck(this, Tw2MayaAnimationEngine);

    Tw2MayaAnimationEngine_defineProperty(this, "_id", global["F" /* util */].generateID());

    Tw2MayaAnimationEngine_defineProperty(this, "curves", []);

    Tw2MayaAnimationEngine_defineProperty(this, "hermiteSegments", []);

    Tw2MayaAnimationEngine_defineProperty(this, "bezierSegments", []);

    Tw2MayaAnimationEngine_defineProperty(this, "_currentCurveIndex", 0);

    Tw2MayaAnimationEngine_defineProperty(this, "_evalCache", null);
  }

  Tw2MayaAnimationEngine_createClass(Tw2MayaAnimationEngine, [{
    key: "Evaluate",

    /**
     * Evaluate
     * @param curveIndex
     * @param time
     * @returns {*}
     */
    value: function Evaluate(curveIndex, time) {
      if (this.curves.length <= curveIndex) return 0;
      this._currentCurveIndex = curveIndex;

      if (!this._evalCache) {
        this._evalCache = new Array(this.curves.length);

        for (let i = 0; i < this._evalCache.length; ++i) this._evalCache[i] = -1;
      }

      let animCurve = this.curves[curveIndex];
      let firstSegment = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET];
      let segments = null;

      if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
        segments = this.bezierSegments;
      } else {
        segments = this.hermiteSegments;
      }

      if (time < segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
        if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.PRE_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
          return segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
        }

        return this._EvaluateInfinities(animCurve, segments, firstSegment, time, true);
      }

      if (time > animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME]) {
        if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.POST_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
          return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
        }

        return this._EvaluateInfinities(animCurve, segments, firstSegment, time, false);
      }

      return this._EvaluateImpl(animCurve, segments, firstSegment, time);
    }
    /**
     * _EvaluateImpl
     * @param animCurve
     * @param segments
     * @param firstSegment
     * @param time
     * @returns {*}
     */

  }, {
    key: "_EvaluateImpl",
    value: function _EvaluateImpl(animCurve, segments, firstSegment, time) {
      let withinInterval = false,
          nextSegment = null,
          lastSegment = null,
          index;

      if (this._evalCache[this._currentCurveIndex] >= 0) {
        lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];

        if (this._evalCache[this._currentCurveIndex] < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS - 1] && time > segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
          nextSegment = firstSegment + this._evalCache[this._currentCurveIndex] + 1;

          if (time === segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
            this._evalCache[this._currentCurveIndex]++;
            return segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
          } else if (time < segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
            index = this._evalCache[this._currentCurveIndex] + 1;
            withinInterval = true;
          } else {
            nextSegment = null;
          }
        } else if (this._evalCache[this._currentCurveIndex] > 0 && time < segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
          let prevSegment = firstSegment + this._evalCache[this._currentCurveIndex] - 1;

          if (time > segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
            index = this._evalCache[this._currentCurveIndex];
            withinInterval = true;
          } else if (time === segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
            this._evalCache[this._currentCurveIndex]--;
            return segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
          }
        }
      }

      if (!withinInterval) {
        let result = this._Find(animCurve, time, segments, firstSegment);

        index = result[1];

        if (result[0] || index === 0) {
          if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
            index--;
            this._evalCache[this._currentCurveIndex] = index;
            return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
          } else {
            this._evalCache[this._currentCurveIndex] = index;
            return segments[firstSegment + index][Tw2MayaAnimationEngine.AnimSegment.VALUE];
          }
        } else if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1) {
          this._evalCache[this._currentCurveIndex] = 0;
          return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
        }
      }

      if (this._evalCache[this._currentCurveIndex] !== index - 1) {
        this._evalCache[this._currentCurveIndex] = index - 1;
        lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];
        if (nextSegment === null) nextSegment = firstSegment + index;
      }

      if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
        let bSegment = segments[lastSegment];

        if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP]) {
          return bSegment[Tw2MayaAnimationEngine.BezierSegment.VALUE];
        } else if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP_NEXT]) {
          if (nextSegment === null) {
            return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
          }

          return segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.VALUE];
        } else {
          let nextKeyTime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];

          if (this._evalCache[this._currentCurveIndex] + 1 < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
            nextKeyTime = segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.TIME];
          }

          return this._EvaluateBezier(bSegment, time, nextKeyTime);
        }
      } else {
        let hSegment = segments[lastSegment];

        if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP]) {
          return hSegment[Tw2MayaAnimationEngine.HermiteSegment.VALUE];
        } else if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP_NEXT]) {
          if (nextSegment === null) {
            return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
          }

          return segments[nextSegment][Tw2MayaAnimationEngine.HermiteSegment.VALUE];
        } else {
          return this._EvaluateHermite(hSegment, time);
        }
      }
    }
    /* eslint-disable no-unused-vars */

    /**
     * A static helper function to evaluate the infinity portion of an animation curve.
     * The infinity portion is the parts of the animation curve outside the range of keys.
     * @param curve - The animation curve to evaluate
     * @param segments
     * @param startSegment
     * @param {time} time
     * @param {boolean} bool - false: evaluate the post-infinity portion, true: evaluate the pre-infinity portion
     */

  }, {
    key: "_EvaluateInfinities",
    value: function _EvaluateInfinities(curve, segments, startSegment, time, bool) {
      throw new core["ErrFeatureNotImplemented"]({
        feature: 'Maya animation engine evaluate infinities'
      });
    }
    /* eslint-enable no-unused-vars */

    /**
     * _EvaluateHermite
     * @param segment
     * @param time
     * @returns {*}
     */

  }, {
    key: "_EvaluateHermite",
    value: function _EvaluateHermite(segment, time) {
      let t = time - segment[Tw2MayaAnimationEngine.HermiteSegment.TIME];
      let coeff = segment[Tw2MayaAnimationEngine.HermiteSegment.COEFF];
      return t * (t * (t * coeff[0] + coeff[1]) + coeff[2]) + coeff[3];
    }
    /**
     * _EvaluateBezier
     * @param segment
     * @param time
     * @param nextSegmentTime
     * @returns {*}
     */

  }, {
    key: "_EvaluateBezier",
    value: function _EvaluateBezier(segment, time, nextSegmentTime) {
      let t, s;
      s = (time - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]) / (nextSegmentTime - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]);

      if (segment[Tw2MayaAnimationEngine.BezierSegment.IS_LINEAR]) {
        t = s;
      } else {
        let poly = global["I" /* vec4 */].create();
        poly[3] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][3];
        poly[2] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][2];
        poly[1] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][1];
        poly[0] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][0] - s;
        let roots = [];
        if (global["v" /* curve */].polyZeroes(poly, 3, 0.0, 1, 1.0, 1, roots) === 1) t = roots[0];else t = 0.0;
      }

      let poly = segment[Tw2MayaAnimationEngine.BezierSegment.POLYY];
      return t * (t * (t * poly[3] + poly[2]) + poly[1]) + poly[0];
    }
    /**
     * _Find
     * @param animCurve
     * @param time
     * @param segments
     * @param firstSegment
     * @returns {*}
     */

  }, {
    key: "_Find",
    value: function _Find(animCurve, time, segments, firstSegment) {
      let len, mid, low, high;
      /* use a binary search to find the key */

      let index = 0;
      len = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1;
      let segment = null;
      let stime = 0.0;

      if (len > 0) {
        low = 0;
        high = len - 1;

        do {
          mid = low + high >> 1;

          if (mid < len - 1) {
            segment = firstSegment + mid;
            stime = segments[segment][Tw2MayaAnimationEngine.AnimSegment.TIME];
          } else {
            stime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];
          }

          if (time < stime) {
            high = mid - 1;
          } else if (time > stime) {
            low = mid + 1;
          } else {
            index = mid;
            return [true, index];
          }
        } while (low <= high);

        index = low;
      }

      return [false, index];
    }
    /**
     * Returns the total number of curves
     * @returns {number}
     */

  }, {
    key: "GetNumberOfCurves",
    value: function GetNumberOfCurves() {
      return this.curves.length;
    }
    /**
     * Gets specific curve's length
     * @property {number} index
     * @returns {number}
     */

  }, {
    key: "GetLength",
    value: function GetLength(index) {
      if (index < 0 || index >= this.curves.length) return 0;
      let curve = this.curves[index];
      let firstSegment;

      if (curve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
        firstSegment = this.bezierSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
      } else {
        firstSegment = this.hermiteSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
      }

      return curve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME] - firstSegment[Tw2MayaAnimationEngine.AnimSegment.TIME];
    }
  }]);

  return Tw2MayaAnimationEngine;
}();

Tw2MayaAnimationEngine_defineProperty(Tw2MayaAnimationEngine_Tw2MayaAnimationEngine, "AnimCurveFields", {
  NUM_SEGMENTS: 0,
  SEGMENT_OFFSET: 1,
  END_TIME: 2,
  END_VALUE: 3,
  IN_TANGENT: 4,
  OUT_TANGENT: 5,
  PRE_INFINITY: 6,
  POST_INFINITY: 7,
  IS_WEIGHTED: 8
});

Tw2MayaAnimationEngine_defineProperty(Tw2MayaAnimationEngine_Tw2MayaAnimationEngine, "AnimSegment", {
  TIME: 0,
  VALUE: 1
});

Tw2MayaAnimationEngine_defineProperty(Tw2MayaAnimationEngine_Tw2MayaAnimationEngine, "HermiteSegment", {
  TIME: 0,
  VALUE: 1,
  COEFF: 2,
  IS_STEP: 3,
  IS_STEP_NEXT: 4
});

Tw2MayaAnimationEngine_defineProperty(Tw2MayaAnimationEngine_Tw2MayaAnimationEngine, "BezierSegment", {
  TIME: 0,
  VALUE: 1,
  COEFF: 2,
  POLYY: 3,
  IS_STEP: 4,
  IS_STEP_NEXT: 5,
  IS_LINEAR: 6
});

Tw2MayaAnimationEngine_defineProperty(Tw2MayaAnimationEngine_Tw2MayaAnimationEngine, "INFINITY", 0);
// CONCATENATED MODULE: ./curve/maya/index.js




// CONCATENATED MODULE: ./curve/index.js
/* concated harmony reexport Tw2CurveKey */__webpack_require__.d(__webpack_exports__, "Tw2CurveKey", function() { return Tw2Curve_Tw2CurveKey; });
/* concated harmony reexport Tw2Curve */__webpack_require__.d(__webpack_exports__, "Tw2Curve", function() { return Tw2Curve_Tw2Curve; });
/* concated harmony reexport Tw2ColorKey */__webpack_require__.d(__webpack_exports__, "Tw2ColorKey", function() { return Tw2ColorCurve_Tw2ColorKey; });
/* concated harmony reexport Tw2ColorCurve */__webpack_require__.d(__webpack_exports__, "Tw2ColorCurve", function() { return Tw2ColorCurve_Tw2ColorCurve; });
/* concated harmony reexport Tw2ColorKey2 */__webpack_require__.d(__webpack_exports__, "Tw2ColorKey2", function() { return Tw2ColorCurve2_Tw2ColorKey2; });
/* concated harmony reexport Tw2ColorCurve2 */__webpack_require__.d(__webpack_exports__, "Tw2ColorCurve2", function() { return Tw2ColorCurve2_Tw2ColorCurve2; });
/* concated harmony reexport Tw2EventKey */__webpack_require__.d(__webpack_exports__, "Tw2EventKey", function() { return Tw2EventKey; });
/* concated harmony reexport Tw2EventCurve */__webpack_require__.d(__webpack_exports__, "Tw2EventCurve", function() { return Tw2EventCurve_Tw2EventCurve; });
/* concated harmony reexport Tw2PerlinCurve */__webpack_require__.d(__webpack_exports__, "Tw2PerlinCurve", function() { return Tw2PerlinCurve_Tw2PerlinCurve; });
/* concated harmony reexport Tw2QuaternionKey2 */__webpack_require__.d(__webpack_exports__, "Tw2QuaternionKey2", function() { return Tw2QuaternionCurve_Tw2QuaternionKey2; });
/* concated harmony reexport Tw2QuaternionCurve */__webpack_require__.d(__webpack_exports__, "Tw2QuaternionCurve", function() { return Tw2QuaternionCurve_Tw2QuaternionCurve; });
/* concated harmony reexport Tw2RandomConstantCurve */__webpack_require__.d(__webpack_exports__, "Tw2RandomConstantCurve", function() { return Tw2RandomConstantCurve; });
/* concated harmony reexport Tw2Torque */__webpack_require__.d(__webpack_exports__, "Tw2Torque", function() { return Tw2RigidOrientation_Tw2Torque; });
/* concated harmony reexport Tw2RigidOrientation */__webpack_require__.d(__webpack_exports__, "Tw2RigidOrientation", function() { return Tw2RigidOrientation_Tw2RigidOrientation; });
/* concated harmony reexport Tw2QuaternionKey */__webpack_require__.d(__webpack_exports__, "Tw2QuaternionKey", function() { return Tw2RotationCurve_Tw2QuaternionKey; });
/* concated harmony reexport Tw2RotationCurve */__webpack_require__.d(__webpack_exports__, "Tw2RotationCurve", function() { return Tw2RotationCurve_Tw2RotationCurve; });
/* concated harmony reexport Tw2ScalarKey */__webpack_require__.d(__webpack_exports__, "Tw2ScalarKey", function() { return Tw2ScalarKey; });
/* concated harmony reexport Tw2ScalarCurve */__webpack_require__.d(__webpack_exports__, "Tw2ScalarCurve", function() { return Tw2ScalarCurve_Tw2ScalarCurve; });
/* concated harmony reexport Tw2ScalarKey2 */__webpack_require__.d(__webpack_exports__, "Tw2ScalarKey2", function() { return Tw2ScalarKey2; });
/* concated harmony reexport Tw2ScalarCurve2 */__webpack_require__.d(__webpack_exports__, "Tw2ScalarCurve2", function() { return Tw2ScalarCurve2_Tw2ScalarCurve2; });
/* concated harmony reexport Tw2SineCurve */__webpack_require__.d(__webpack_exports__, "Tw2SineCurve", function() { return Tw2SineCurve; });
/* concated harmony reexport Tw2Vector2Key */__webpack_require__.d(__webpack_exports__, "Tw2Vector2Key", function() { return Tw2Vector2Curve_Tw2Vector2Key; });
/* concated harmony reexport Tw2Vector2Curve */__webpack_require__.d(__webpack_exports__, "Tw2Vector2Curve", function() { return Tw2Vector2Curve_Tw2Vector2Curve; });
/* concated harmony reexport Tw2Vector3Key */__webpack_require__.d(__webpack_exports__, "Tw2Vector3Key", function() { return Tw2Vector3Curve_Tw2Vector3Key; });
/* concated harmony reexport Tw2Vector3Curve */__webpack_require__.d(__webpack_exports__, "Tw2Vector3Curve", function() { return Tw2Vector3Curve_Tw2Vector3Curve; });
/* concated harmony reexport Tw2VectorKey */__webpack_require__.d(__webpack_exports__, "Tw2VectorKey", function() { return Tw2VectorCurve_Tw2VectorKey; });
/* concated harmony reexport Tw2VectorCurve */__webpack_require__.d(__webpack_exports__, "Tw2VectorCurve", function() { return Tw2VectorCurve_Tw2VectorCurve; });
/* concated harmony reexport Tw2ColorSequencer */__webpack_require__.d(__webpack_exports__, "Tw2ColorSequencer", function() { return Tw2ColorSequencer_Tw2ColorSequencer; });
/* concated harmony reexport Tw2EulerRotation */__webpack_require__.d(__webpack_exports__, "Tw2EulerRotation", function() { return Tw2EulerRotation_Tw2EulerRotation; });
/* concated harmony reexport Tw2QuaternionSequencer */__webpack_require__.d(__webpack_exports__, "Tw2QuaternionSequencer", function() { return Tw2QuaternionSequencer_Tw2QuaternionSequencer; });
/* concated harmony reexport Tw2RGBAScalarSequencer */__webpack_require__.d(__webpack_exports__, "Tw2RGBAScalarSequencer", function() { return Tw2RGBAScalarSequencer_Tw2RGBAScalarSequencer; });
/* concated harmony reexport Tw2ScalarSequencer */__webpack_require__.d(__webpack_exports__, "Tw2ScalarSequencer", function() { return Tw2ScalarSequencer_Tw2ScalarSequencer; });
/* concated harmony reexport Tw2VectorSequencer */__webpack_require__.d(__webpack_exports__, "Tw2VectorSequencer", function() { return Tw2VectorSequencer_Tw2VectorSequencer; });
/* concated harmony reexport Tw2XYZScalarSequencer */__webpack_require__.d(__webpack_exports__, "Tw2XYZScalarSequencer", function() { return Tw2XYZScalarSequencer_Tw2XYZScalarSequencer; });
/* concated harmony reexport Tw2YPRSequencer */__webpack_require__.d(__webpack_exports__, "Tw2YPRSequencer", function() { return Tw2YPRSequencer_Tw2YPRSequencer; });
/* concated harmony reexport Tw2WbgTrack */__webpack_require__.d(__webpack_exports__, "Tw2WbgTrack", function() { return Tw2WbgTrack; });
/* concated harmony reexport Tw2WbgTransformTrack */__webpack_require__.d(__webpack_exports__, "Tw2WbgTransformTrack", function() { return Tw2WbgTransformTrack; });
/* concated harmony reexport Tw2TransformTrack */__webpack_require__.d(__webpack_exports__, "Tw2TransformTrack", function() { return Tw2TransformTrack_Tw2TransformTrack; });
/* concated harmony reexport Tw2MayaEulerRotationCurve */__webpack_require__.d(__webpack_exports__, "Tw2MayaEulerRotationCurve", function() { return Tw2MayaEulerRotationCurve_Tw2MayaEulerRotationCurve; });
/* concated harmony reexport Tw2MayaScalarCurve */__webpack_require__.d(__webpack_exports__, "Tw2MayaScalarCurve", function() { return Tw2MayaScalarCurve; });
/* concated harmony reexport Tw2MayaVector3Curve */__webpack_require__.d(__webpack_exports__, "Tw2MayaVector3Curve", function() { return Tw2MayaVector3Curve_Tw2MayaVector3Curve; });
/* concated harmony reexport Tw2MayaAnimationEngine */__webpack_require__.d(__webpack_exports__, "Tw2MayaAnimationEngine", function() { return Tw2MayaAnimationEngine_Tw2MayaAnimationEngine; });





/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2Effect; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2Effect
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} effectFilePath
 * @property {Tw2EffectRes|null} effectRes
 * @property {Object.<string, Tw2Parameter>} parameters
 * @property {Object.<string, Array>} techniques
 * @property {Object.<string, string>} options
 * @property {Tw2Shader|null} shader
 * @property {Array} samplerOverrides
 * @property {boolean} autoParameter
 * @class
 */

let Tw2Effect =
/*#__PURE__*/
function () {
  function Tw2Effect() {
    _classCallCheck(this, Tw2Effect);

    _defineProperty(this, "_id", _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].generateID());

    _defineProperty(this, "name", '');

    _defineProperty(this, "effectFilePath", '');

    _defineProperty(this, "effectRes", null);

    _defineProperty(this, "parameters", {});

    _defineProperty(this, "techniques", []);

    _defineProperty(this, "samplerOverrides", []);

    _defineProperty(this, "autoParameter", false);

    _defineProperty(this, "options", {});

    _defineProperty(this, "shader", null);
  }

  _createClass(Tw2Effect, [{
    key: "Initialize",

    /**
     * Initializes the Tw2Effect
     */
    value: function Initialize() {
      if (this.effectFilePath !== '') {
        this.effectFilePath = this.effectFilePath.toLowerCase();
        const path = Tw2Effect.ToEffectResPath(this.effectFilePath);
        this.effectRes = _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].GetResource(path);
        this.effectRes.RegisterNotification(this);
      }
    }
    /**
     * Checks if the effect's resource is good
     * @returns {boolean}
     */

  }, {
    key: "IsGood",
    value: function IsGood() {
      this.KeepAlive();
      return this.shader !== null;
    }
    /**
     * Keeps the effect and it's parameters alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      const res = this.GetResources();

      for (let i = 0; i < res.length; i++) {
        res[i].KeepAlive();
      }
    }
    /**
     * Gets effect resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.effectRes && !out.includes(this.effectRes)) {
        out.push(this.effectRes);
      }

      for (let param in this.parameters) {
        if (this.parameters.hasOwnProperty(param)) {
          if ('GetResources' in this.parameters[param]) {
            this.parameters[param].GetResources(out);
          }
        }
      }

      return out;
    }
    /**
     * Rebuilds Cached Data
     * @param resource
     */

  }, {
    key: "RebuildCachedData",
    value: function RebuildCachedData(resource) {
      this.shader = resource.GetShader(this.options);
      this.BindParameters();
    }
    /**
     * Unbinds parameters
     * @returns {boolean}
     */

  }, {
    key: "UnBindParameters",
    value: function UnBindParameters() {
      for (let t in this.techniques) {
        if (this.techniques.hasOwnProperty(t)) {
          let technique = this.techniques[t];

          for (let i = 0; i < technique.length; ++i) {
            for (let j = 0; j < technique[i].stages.length; ++j) {
              for (let k = 0; k < technique[i].stages[j].reroutedParameters.length; ++k) {
                technique[i].stages[j].reroutedParameters[k].Unbind();
              }
            }
          }
        }
      }

      this.techniques = {};
    }
    /**
     * Binds parameters
     * @returns {boolean}
     */

  }, {
    key: "BindParameters",
    value: function BindParameters() {
      this.UnBindParameters();

      if (!this.IsGood()) {
        return false;
      }

      for (let techniqueName in this.shader.techniques) {
        if (this.shader.techniques.hasOwnProperty(techniqueName)) {
          let technique = this.shader.techniques[techniqueName];
          let passes = [];

          for (let i = 0; i < technique.passes.length; ++i) {
            const pass = [];
            pass.stages = [];

            for (let j = 0; j < technique.passes[i].stages.length; ++j) {
              const stageRes = technique.passes[i].stages[j],
                    stage = {};
              stage.constantBuffer = new Float32Array(stageRes.constantSize);
              stage.reroutedParameters = [];
              stage.parameters = [];
              stage.textures = [];
              stage.constantBuffer.set(stageRes.constantValues);

              for (let k = 0; k < stageRes.constants.length; ++k) {
                const constant = stageRes.constants[k],
                      name = constant.name,
                      Type = constant.Type;
                if (Tw2Effect.ConstantIgnore.includes(name)) continue;

                if (name in this.parameters) {
                  const param = this.parameters[name];

                  if (param.Bind(stage.constantBuffer, constant.offset, constant.size)) {
                    stage.reroutedParameters.push(param);
                  } else {
                    stage.parameters.push({
                      parameter: param,
                      constantBuffer: stage.constantBuffer,
                      offset: constant.offset,
                      size: constant.size
                    });
                  }
                } else if (_global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].HasVariable(name)) {
                  stage.parameters.push({
                    parameter: _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].GetVariable(name),
                    constantBuffer: stage.constantBuffer,
                    offset: constant.offset,
                    size: constant.size
                  });
                } else if (constant.isAutoregister && Type) {
                  const variable = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].RegisterVariable(name, undefined, Type);

                  if (variable) {
                    stage.parameters.push({
                      parameter: variable,
                      constantBuffer: stage.constantBuffer,
                      offset: constant.offset,
                      size: constant.size
                    });
                  }
                } else if (this.autoParameter && constant.elements === 1) {
                  let value = stage.constantBuffer.subarray(constant.offset, constant.offset + constant.size);

                  if (value.length === 0) {
                    value = undefined;
                  } else if (value.length === 1) {
                    value = value[0];
                  }

                  const param = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].CreateType(name, value, Type);

                  if (param) {
                    this.parameters[name] = param;

                    if (param.Bind(stage.constantBuffer, constant.offset, constant.size)) {
                      stage.reroutedParameters.push(param);
                    } else {
                      stage.parameter.push({
                        parameter: param,
                        constantBuffer: stage.constantBuffer,
                        offset: constant.offset,
                        size: constant.size
                      });
                    }
                  }
                }
              }

              for (let k = 0; k < stageRes.textures.length; ++k) {
                const name = stageRes.textures[k].name;
                let param = null;

                if (name in this.parameters) {
                  param = this.parameters[name];
                } else if (_global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].HasVariable(name)) {
                  param = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].GetVariable(name);
                } else if (stageRes.textures[k].isAutoregister) {
                  param = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].RegisterVariable(name, undefined, _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"]);
                } else if (this.autoParameter) {
                  param = this.parameters[name] = new _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"](name);
                } else {
                  continue;
                }

                const p = {
                  parameter: param,
                  slot: stageRes.textures[k].registerIndex,
                  sampler: null
                };

                for (let n = 0; n < stageRes.samplers.length; ++n) {
                  if (stageRes.samplers[n].registerIndex === p.slot) {
                    if (stageRes.samplers[n].name in this.samplerOverrides) {
                      p.sampler = this.samplerOverrides[stageRes.samplers[n].name].GetSampler(stageRes.samplers[n]);
                    } else {
                      p.sampler = stageRes.samplers[n];
                    }

                    break;
                  }
                }

                if (j === 0) p.slot += 12;
                stage.textures.push(p);
              }

              pass.stages.push(stage);
            }

            passes.push(pass);
          }

          this.techniques[techniqueName] = passes;
        }
      }

      if (_global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"]['effectObserver']) {
        _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"]['effectObserver']['OnEffectChanged'](this);
      }

      this.autoParameter = false;
      return true;
    }
    /**
     * ApplyPass
     * @param technique {string} - technique name
     * @param pass {number}
     */

  }, {
    key: "ApplyPass",
    value: function ApplyPass(technique, pass) {
      if (!this.IsGood() || !(technique in this.techniques) || pass >= this.techniques[technique].length) {
        return;
      }

      this.shader.ApplyPass(technique, pass);
      const p = this.techniques[technique][pass],
            rp = this.shader.techniques[technique].passes[pass],
            d = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"],
            gl = d.gl;
      const program = d.IsAlphaTestEnabled() && rp.shadowShaderProgram ? rp.shadowShaderProgram : rp.shaderProgram;

      for (let i = 0; i < 2; ++i) {
        const stages = p.stages[i];

        for (let j = 0; j < stages.parameters.length; ++j) {
          let pp = stages.parameters[j];
          pp.parameter.Apply(pp.constantBuffer, pp.offset, pp.size);
        }

        for (let j = 0; j < stages.textures.length; ++j) {
          let tex = stages.textures[j];
          tex.parameter.Apply(tex.slot, tex.sampler, program.volumeSlices[tex.sampler.registerIndex]);
        }
      }

      const cbh = program.constantBufferHandles;
      if (cbh[0]) gl.uniform4fv(cbh[0], p.stages[0].constantBuffer);
      if (cbh[7]) gl.uniform4fv(cbh[7], p.stages[1].constantBuffer);
      if (d.perFrameVSData && cbh[1]) gl.uniform4fv(cbh[1], d.perFrameVSData.data);
      if (d.perFramePSData && cbh[2]) gl.uniform4fv(cbh[2], d.perFramePSData.data);
      if (d.perObjectData) d.perObjectData.SetPerObjectDataToDevice(cbh);
    }
    /**
     * GetPassCount
     * @param technique {string} - technique name
     * @returns {number}
     */

  }, {
    key: "GetPassCount",
    value: function GetPassCount(technique) {
      if (this.shader === null || !(technique in this.techniques)) {
        return 0;
      }

      return this.techniques[technique].length;
    }
    /**
     * GetPassInput
     * @param technique {string} - technique name
     * @param {number} pass
     * @returns {*}
     */

  }, {
    key: "GetPassInput",
    value: function GetPassInput(technique, pass) {
      if (this.shader === null || !(technique in this.techniques) || pass >= this.techniques[technique].length) {
        return null;
      }

      if (_global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].IsAlphaTestEnabled() && this.shader.techniques[technique].passes[pass].shadowShaderProgram) {
        return this.shader.techniques[technique].passes[pass].shadowShaderProgram.input;
      } else {
        return this.shader.techniques[technique].passes[pass].shaderProgram.input;
      }
    }
    /**
     * Render
     * @param {function} cb - callback
     */

  }, {
    key: "Render",
    value: function Render(cb) {
      const count = this.GetPassCount('Main');

      for (let i = 0; i < count; ++i) {
        this.ApplyPass('Main', i);
        cb(this, i);
      }
    }
    /**
     * Gets an object containing the textures currently set in the Tw2Effect
     * @param {{}} [out={}]
     * @returns {Object.<string, string>} out
     */

  }, {
    key: "GetTextures",
    value: function GetTextures() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (let key in this.parameters) {
        if (this.parameters.hasOwnProperty(key) && this.parameters[key] instanceof _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"]) {
          let resourcePath = this.parameters[key].GetValue();

          if (resourcePath) {
            out[key] = resourcePath;
          }
        }
      }

      return out;
    }
    /**
     * Sets textures from an object
     * @param {{string:string}} options
     * @returns {boolean} true if updated
     */

  }, {
    key: "SetTextures",
    value: function SetTextures() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let updated = false;

      for (let key in options) {
        if (options.hasOwnProperty(key)) {
          const value = options[key],
                param = this.parameters[key];

          if (_parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"].isValue(value)) {
            if (param) {
              if (!param.EqualsValue(value)) {
                param.SetTexturePath(value);
                updated = true;
              }
            } else {
              this.parameters[key] = new _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"](key, value);
              updated = true;
            }
          }
        }
      }

      return updated;
    }
    /**
     * Gets an object containing all non texture parameters currently set in the Tw2Effect
     * - Matches sof parameter object
     * @param {{}} [out={}]
     * @returns {Object.<string, *>}
     */

  }, {
    key: "GetParameters",
    value: function GetParameters() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (let key in this.parameters) {
        if (this.parameters.hasOwnProperty(key) && !(this.parameters[key] instanceof _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"])) {
          out[key] = this.parameters[key].GetValue(true);
        }
      }

      return out;
    }
    /**
     * Sets parameters from an object
     * @param {{string:*}} [options={}]
     * @returns {boolean} true if updated
     */

  }, {
    key: "SetParameters",
    value: function SetParameters() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let updated = false;

      for (let key in options) {
        if (options.hasOwnProperty(key)) {
          const value = options[key],
                param = this.parameters[key];

          if (param) {
            if (param.constructor.isValue(value) && !param.EqualsValue(value)) {
              this.parameters[key].SetValue(value);
              updated = true;
            }
          } else {
            const parameter = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].CreateType(key, value);

            if (parameter) {
              this.parameters[key] = parameter;
              updated = true;
            }
          }
        }
      }

      return updated;
    }
    /**
     * Sets texture overrides
     * @param {*} [options={}]
     * @returns {boolean} true if updated
     */

  }, {
    key: "SetOverrides",
    value: function SetOverrides() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let updated = false;

      for (let key in options) {
        if (options.hasOwnProperty(key)) {
          const param = this.parameters[key];

          if (param && param instanceof _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"]) {
            let doUpdate = false;
            const overrides = options[key];

            for (let prop in overrides) {
              if (overrides.hasOwnProperty(prop) && _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"].overrideProperties.includes(prop)) {
                if (overrides[prop] !== param[prop]) {
                  doUpdate = true;
                  break;
                }
              }
            }

            if (doUpdate) {
              param.SetOverrides(options[key]);
              updated = true;
            }
          }
        }
      }

      return updated;
    }
    /**
     * Gets texture overrides
     * @param {{ string: {}}} [out={}]
     */

  }, {
    key: "GetOverrides",
    value: function GetOverrides() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (let key in this.parameters) {
        if (this.parameters.hasOwnProperty(key)) {
          const param = this.parameters[key];

          if (param && param instanceof _parameter_Tw2TextureParameter__WEBPACK_IMPORTED_MODULE_1__[/* Tw2TextureParameter */ "a"] && param.useAllOverrides) {
            out[key] = this.parameters[key].GetOverrides();
          }
        }
      }

      return out;
    }
    /**
     * Adds effect parameters automatically
     * @returns {boolean} true if updated
     */

  }, {
    key: "AutoParameter",
    value: function AutoParameter() {
      this.autoParameter = true;
      return this.BindParameters();
    }
    /**
     * Converts an effect file path into one suitable for an effect resource
     * @param {string} path
     * @returns {string}
     */

  }], [{
    key: "ToEffectResPath",
    value: function ToEffectResPath(path) {
      path = path ? path.substr(0, path.lastIndexOf('.')).replace('/effect/', _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].effectDir) + '.sm_' + _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].shaderModel : '';
      return path.toLowerCase();
    }
    /**
     * Converts an effect resource path back into a normal effect file path
     * @param {string} path
     * @param {string} [ext='fx']
     * @returns {string}
     */

  }, {
    key: "FromEffectResPath",
    value: function FromEffectResPath(path) {
      let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fx';
      path = path.substr(0, path.lastIndexOf('.')).replace(_global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].effectDir, '/effect/') + '.' + ext;
      return path.toLowerCase();
    }
    /**
     * Creates a Tw2Effect from an object
     * @param {{}} [opt]
     * @param {string} [opt.name='']
     * @param {string} [opt.effectFilePath='']
     * @param {boolean} [opt.autoParameter]
     * @param {{string: *}} [opt.parameters]
     * @param {{string: string}} [opt.textures]
     * @param {{string: {}}} [opt.overrides]
     * @returns {Tw2Effect}
     */

  }, {
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const effect = new this();
      _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].assignIfExists(effect, opt, ['name', 'effectFilePath', 'display', 'autoParameter']);
      if ('parameters' in opt) effect.SetParameters(opt.parameters);
      if ('textures' in opt) effect.SetTextures(opt.textures);
      if ('overrides' in opt) effect.SetOverrides(opt.overrides);

      if (effect.name === '' && opt.effectFilePath !== '') {
        let path = opt.effectFilePath;
        effect.name = path.substring(path.lastIndexOf('/') + 1, path.length);
      }

      if (!effect.name && effect.effectFilePath) {
        effect.name = effect.effectFilePath.substring(effect.effectFilePath.lastIndexOf('/') + 1, effect.effectFilePath.lastIndexOf('.'));
      }

      effect.Initialize();
      return effect;
    }
    /**
     * Constant parameters which are ignored when creating an effect
     * @type {string[]}
     */

  }]);

  return Tw2Effect;
}();

_defineProperty(Tw2Effect, "ConstantIgnore", ['PerFrameVS', 'PerObjectVS', 'PerFramePS', 'PerObjectPS', 'PerObjectPSInt']);

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./core/sampler/Tw2SamplerState.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2SamplerState
 *
 * @property {string} name
 * @property {number} registerIndex
 * @property {number} minFilter
 * @property {number} maxFilter
 * @property {number} magFilter
 * @property {number} minFilterNoMips
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} anisotropy
 * @property samplerType
 * @property {boolean} isVolume
 * @property {number} hash
 * @class
 */

let Tw2SamplerState_Tw2SamplerState =
/*#__PURE__*/
function () {
  function Tw2SamplerState() {
    _classCallCheck(this, Tw2SamplerState);

    _defineProperty(this, "name", '');

    _defineProperty(this, "registerIndex", 0);

    _defineProperty(this, "minFilter", global["q" /* GL_LINEAR */]);

    _defineProperty(this, "maxFilter", global["q" /* GL_LINEAR */]);

    _defineProperty(this, "magFilter", global["q" /* GL_LINEAR */]);

    _defineProperty(this, "minFilterNoMips", global["q" /* GL_LINEAR */]);

    _defineProperty(this, "addressU", global["r" /* GL_REPEAT */]);

    _defineProperty(this, "addressV", global["r" /* GL_REPEAT */]);

    _defineProperty(this, "addressW", global["r" /* GL_REPEAT */]);

    _defineProperty(this, "anisotropy", 1);

    _defineProperty(this, "samplerType", global["s" /* GL_TEXTURE_2D */]);

    _defineProperty(this, "isVolume", false);

    _defineProperty(this, "hash", 0);
  }

  _createClass(Tw2SamplerState, [{
    key: "ComputeHash",

    /**
     * Computes the sampler hash
     */
    value: function ComputeHash() {
      this.hash = 2166136261;
      this.hash *= 16777619;
      this.hash ^= this.minFilter;
      this.hash *= 16777619;
      this.hash ^= this.maxFilter;
      this.hash *= 16777619;
      this.hash ^= this.addressU;
      this.hash *= 16777619;
      this.hash ^= this.addressV;
      this.hash *= 16777619;
      this.hash ^= this.anisotropy;
    }
    /**
     * Apply
     * @param {boolean} hasMipMaps
     */

  }, {
    key: "Apply",
    value: function Apply(hasMipMaps) {
      const targetType = this.samplerType,
            d = global["w" /* device */],
            gl = d.gl;
      gl.texParameteri(targetType, gl.TEXTURE_WRAP_S, hasMipMaps ? this.addressU : gl.CLAMP_TO_EDGE);
      gl.texParameteri(targetType, gl.TEXTURE_WRAP_T, hasMipMaps ? this.addressV : gl.CLAMP_TO_EDGE);
      gl.texParameteri(targetType, gl.TEXTURE_MIN_FILTER, hasMipMaps ? this.minFilter : this.minFilterNoMips);
      gl.texParameteri(targetType, gl.TEXTURE_MAG_FILTER, this.magFilter);

      if (d.ext.AnisotropicFilter && d.enableAnisotropicFiltering) {
        gl.texParameterf(targetType, d.ext.AnisotropicFilter.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.anisotropy, d.ext.AnisotropicFilter.maxAnisotropy));
      }
    }
  }, {
    key: "filterMode",

    /**
     * Gets the current filter mode
     * @returns {number}
     */
    get: function get() {
      return this.minFilterNoMips in global["p" /* FilterMode */] ? global["p" /* FilterMode */][this.minFilterNoMips] : 2;
    }
    /**
     * Gets the current mip filter mode
     * @returns {number}
     */

  }, {
    key: "mipFilterMode",
    get: function get() {
      return this.minFilter in global["t" /* MipFilterMode */] ? global["t" /* MipFilterMode */][this.minFilter] : 2;
    }
  }]);

  return Tw2SamplerState;
}();
// CONCATENATED MODULE: ./core/sampler/Tw2SamplerOverride.js
function Tw2SamplerOverride_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2SamplerOverride_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2SamplerOverride_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2SamplerOverride_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2SamplerOverride_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2SamplerOverride_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2SamplerOverride
 *
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} filter
 * @property {number} mipFilter
 * @property {number} lodBias
 * @property {number} maxMipLevel
 * @property {number} maxAnisotropy
 * @property {Tw2SamplerState} _sampler
 * @class
 */

let Tw2SamplerOverride_Tw2SamplerOverride =
/*#__PURE__*/
function () {
  function Tw2SamplerOverride() {
    Tw2SamplerOverride_classCallCheck(this, Tw2SamplerOverride);

    Tw2SamplerOverride_defineProperty(this, "name", '');

    Tw2SamplerOverride_defineProperty(this, "addressU", 0);

    Tw2SamplerOverride_defineProperty(this, "addressV", 0);

    Tw2SamplerOverride_defineProperty(this, "addressW", 0);

    Tw2SamplerOverride_defineProperty(this, "filter", 0);

    Tw2SamplerOverride_defineProperty(this, "mipFilter", 0);

    Tw2SamplerOverride_defineProperty(this, "lodBias", 0);

    Tw2SamplerOverride_defineProperty(this, "maxMipLevel", 0);

    Tw2SamplerOverride_defineProperty(this, "maxAnisotropy", 0);

    Tw2SamplerOverride_defineProperty(this, "_sampler", null);
  }

  Tw2SamplerOverride_createClass(Tw2SamplerOverride, [{
    key: "GetSampler",

    /**
     * Gets the sampler
     * @param {Tw2SamplerState} originalSampler
     * @returns {Tw2SamplerState}
     */
    value: function GetSampler(originalSampler) {
      if (this._sampler) {
        return this._sampler;
      }

      this._sampler = new Tw2SamplerState_Tw2SamplerState();
      const sampler = this._sampler;
      sampler.registerIndex = originalSampler.registerIndex;
      sampler.name = originalSampler.name;
      const wrapModes = global["w" /* device */].wrapModes,
            gl = global["w" /* device */].gl;

      if (this.filter === 1) {
        switch (this.mipFilter) {
          case 0:
            sampler.minFilter = gl.NEAREST;
            break;

          case 1:
            sampler.minFilter = gl.NEAREST_MIPMAP_NEAREST;
            break;

          default:
            sampler.minFilter = gl.NEAREST_MIPMAP_LINEAR;
        }

        sampler.minFilterNoMips = gl.NEAREST;
        sampler.magFilter = gl.NEAREST;
      } else {
        switch (this.mipFilter) {
          case 0:
            sampler.minFilter = gl.LINEAR;
            break;

          case 1:
            sampler.minFilter = gl.LINEAR_MIPMAP_NEAREST;
            break;

          default:
            sampler.minFilter = gl.LINEAR_MIPMAP_LINEAR;
        }

        sampler.minFilterNoMips = gl.LINEAR;
        sampler.magFilter = gl.LINEAR;
      }

      if (this.filter === 3 || this.mipFilter === 3) {
        sampler.anisotropy = Math.max(this.maxAnisotropy, 1);
      }

      sampler.addressU = wrapModes[this.addressU];
      sampler.addressV = wrapModes[this.addressV];
      sampler.addressW = wrapModes[this.addressW];
      sampler.samplerType = originalSampler.samplerType;
      sampler.isVolume = originalSampler.isVolume;
      sampler.ComputeHash();
      return sampler;
    }
  }]);

  return Tw2SamplerOverride;
}();
// CONCATENATED MODULE: ./core/sampler/index.js
/* concated harmony reexport Tw2SamplerState */__webpack_require__.d(__webpack_exports__, "b", function() { return Tw2SamplerState_Tw2SamplerState; });
/* concated harmony reexport Tw2SamplerOverride */__webpack_require__.d(__webpack_exports__, "a", function() { return Tw2SamplerOverride_Tw2SamplerOverride; });



/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2LoadingObject; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _Tw2Resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _reader_Tw2ObjectReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2LoadingObject
 *
 * @property {?string} _redContents         - object's .red file xml contents
 * @property {Number} _inPrepare            - the amount of child objects to prepare
 * @property {Array.<Object>} _objects      - the child objects to prepare
 * @property {Tw2ObjectReader} _constructor - A function for constructing child objects
 * @inheritDoc {Tw2Resource}
 * @class
 */

let Tw2LoadingObject =
/*#__PURE__*/
function (_Tw2Resource) {
  _inherits(Tw2LoadingObject, _Tw2Resource);

  function Tw2LoadingObject() {
    var _this;

    _classCallCheck(this, Tw2LoadingObject);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2LoadingObject).call(this, ...args));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "path", '');

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_redContents", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_inPrepare", null);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_objects", []);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_constructor", null);

    return _this;
  }

  _createClass(Tw2LoadingObject, [{
    key: "AddObject",

    /**
     * Adds a child object
     * @param {Function} onResolved
     * @param {Function} onRejected
     * @returns {Object}
     */
    value: function AddObject(onResolved, onRejected) {
      if (this.HasErrors()) {
        if (onRejected) {
          onRejected(this.GetErrors()[0]);
        }
      } else {
        this._objects.push({
          onResolved,
          onRejected
        });
      }
    }
    /**
     * Prepare
     * @param text
     */

  }, {
    key: "Prepare",
    value: function Prepare(text) {
      if (this._inPrepare === null) {
        this._redContents = text;
        this._constructor = new _reader_Tw2ObjectReader__WEBPACK_IMPORTED_MODULE_2__[/* Tw2ObjectReader */ "a"](this._redContents);
        this._inPrepare = 0; // Test construction once for errors

        this._constructor.Construct();
      }

      while (this._inPrepare < this._objects.length) {
        const object = this._objects[this._inPrepare];

        try {
          object.onResolved(this._constructor.Construct());
        } catch (err) {
          if (object.onRejected) {
            object.onRejected(err);
            object.onRejected = null; // Only fire once
          }

          this.OnWarning({
            err,
            message: 'Error preparing child object'
          });
        }

        this._inPrepare++;
      }

      this.OnPrepared();
    }
    /**
     * Fires on errors
     * @param {Error} err
     * @returns {Error}
     */

  }, {
    key: "OnError",
    value: function OnError(err) {
      _get(_getPrototypeOf(Tw2LoadingObject.prototype), "OnError", this).call(this, err);

      for (let i = 0; i < this._objects.length; i++) {
        const object = this._objects[i];

        if (object.onRejected) {
          object.onRejected(err);
        }
      }

      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].motherLode.Remove(this.path);
      this._objects = [];
      return err;
    }
    /**
     * Fires when prepared
     * @param log
     */

  }, {
    key: "OnPrepared",
    value: function OnPrepared(log) {
      _global__WEBPACK_IMPORTED_MODULE_0__[/* resMan */ "D"].motherLode.Remove(this.path);
      this._objects = [];

      _get(_getPrototypeOf(Tw2LoadingObject.prototype), "OnPrepared", this).call(this, log);
    }
  }]);

  return Tw2LoadingObject;
}(_Tw2Resource__WEBPACK_IMPORTED_MODULE_1__[/* Tw2Resource */ "a"]);
/**
 * HTTP request response type
 * @type {string}
 */

Tw2LoadingObject.prototype.requestResponseType = 'arraybuffer';

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2ObjectReader; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _Tw2BinaryReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _Tw2Error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2ObjectReader
 *
 * @property {string} xmlNode
 * @property {?Array} _inputStack
 * @property {?Array} _initializeObjects
 * @property {?Object} _ids
 * @property {Tw2BinaryReader} _reader
 * @property {?Array} _stringTable
 * @property {?number} _start
 * @class
 */

let Tw2ObjectReader =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {string} xmlNode
   */
  function Tw2ObjectReader(xmlNode) {
    _classCallCheck(this, Tw2ObjectReader);

    _defineProperty(this, "xmlNode", null);

    _defineProperty(this, "_inputStack", null);

    _defineProperty(this, "_initializeObjects", null);

    _defineProperty(this, "_ids", {});

    _defineProperty(this, "_reader", null);

    _defineProperty(this, "_stringTable", null);

    _defineProperty(this, "_start", null);

    if (xmlNode) {
      this.xmlNode = xmlNode;
      if (xmlNode) this.Initialize();
    }
  }
  /**
   * Initializes the object reader
   */


  _createClass(Tw2ObjectReader, [{
    key: "Initialize",
    value: function Initialize() {
      if (!Tw2ObjectReader.IsValidXML(this.xmlNode)) {
        throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_2__[/* ErrXMLBinaryFormat */ "z"]({
          message: 'Invalid binary, expected binred'
        });
      }

      this._reader = new _Tw2BinaryReader__WEBPACK_IMPORTED_MODULE_1__[/* Tw2BinaryReader */ "a"](new Uint8Array(this.xmlNode));
      this._reader.cursor += 6;
      this._stringTable = [];

      const count = this._reader.ReadUInt32();

      for (let i = 0; i < count; ++i) {
        const len = this._reader.ReadUInt16();

        this._stringTable.push(String.fromCharCode.apply(null, this._reader.data.subarray(this._reader.cursor, this._reader.cursor + len)));

        this._reader.cursor += len;
      }

      this._start = this._reader.cursor;
    }
    /**
     * Constructs the loaded xml
     * @returns {*}
     */

  }, {
    key: "Construct",
    value: function Construct() {
      this._reader.cursor = this._start;
      return Tw2ObjectReader.ReadElement(this);
    }
    /**
     * Checks that the passed xml is valid
     * @param {*} xmlNode
     * @returns {boolean}
     */

  }], [{
    key: "IsValidXML",
    value: function IsValidXML(xmlNode) {
      return xmlNode && String.fromCharCode.apply(null, new Uint8Array(xmlNode).subarray(0, 6)) === 'binred';
    }
    /**
     * Constructs an object
     * @param {*} data
     * @returns {*}
     */

  }, {
    key: "ConstructObject",
    value: function ConstructObject(data) {
      if (data.type === 'json') {
        return data;
      }

      let Constructor = _global__WEBPACK_IMPORTED_MODULE_0__[/* store */ "E"].GetClass(data.type);

      if (!Constructor) {
        if (Tw2ObjectReader.DEBUG_ENABLED) {
          Constructor = Object;
        } else {
          throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_2__[/* ErrXMLObjectTypeUndefined */ "A"]({
            type: data.type
          });
        }
      }

      const object = new Constructor();

      for (let k in data) {
        if (data.hasOwnProperty(k) && k !== 'type') {
          if (data[k].constructor === Object) {
            if (this.DEBUG_ENABLED) {
              object[k] = object[k] || {};
            }

            if (object[k]) {
              for (let key in data[k]) {
                if (data[k].hasOwnProperty(key)) {
                  object[k][key] = data[k][key];
                }
              }
            }
          } else {
            object[k] = data[k];
          }
        }
      }

      if ('Initialize' in object) {
        object.Initialize();
      }

      return object;
    }
    /**
     * Reads a Uint
     * @param {Tw2ObjectReader} objReader
     * @param {number} type
     * @returns {*}
     */

  }, {
    key: "ReadUint",
    value: function ReadUint(objReader, type) {
      switch (type & 0x30) {
        case this.ElementSize.SMALL:
          return objReader._reader.ReadUInt8();

        case this.ElementSize.MEDIUM:
          return objReader._reader.ReadUInt16();

        default:
          return objReader._reader.ReadUInt32();
      }
    }
    /**
     * Reads element data
     * @param {Tw2ObjectReader} objReader
     * @param {number} type
     * @returns {*}
     */

  }, {
    key: "ReadElementData",
    value: function ReadElementData(objReader, type) {
      let offset, i, result, count, elementType;

      switch (type & 0xf) {
        case this.ElementRawType.NULL:
          return null;

        case this.ElementRawType.BOOL:
          switch (type & 0x30) {
            case this.ElementSize.SMALL:
              return objReader._reader.ReadUInt8() !== 0;

            case this.ElementSize.MEDIUM:
              return false;

            default:
              return true;
          }

        case this.ElementRawType.INT:
          switch (type & 0x30) {
            case this.ElementSize.SMALL:
              return objReader._reader.ReadInt8();

            case this.ElementSize.MEDIUM:
              return objReader._reader.ReadInt16();

            default:
              return objReader._reader.ReadInt32();
          }

        case this.ElementRawType.UINT:
          return this.ReadUint(objReader, type);

        case this.ElementRawType.FLOAT:
          switch (type & 0x30) {
            case this.ElementSize.SMALL:
              return objReader._reader.ReadFloat16();

            case this.ElementSize.MEDIUM:
              return objReader._reader.ReadFloat32();

            default:
              throw new _Tw2Error__WEBPACK_IMPORTED_MODULE_2__[/* ErrFeatureNotImplemented */ "c"]({
                feature: 'Element raw type Float64'
              });
          }

        case this.ElementRawType.STRING:
          offset = this.ReadUint(objReader, type);
          return objReader._stringTable[offset];

        case this.ElementRawType.ARRAY:
          count = this.ReadUint(objReader, type);
          result = [];

          for (i = 0; i < count; ++i) {
            result.push(this.ReadElement(objReader));
          }

          return result;

        case this.ElementRawType.MAPPING:
          count = this.ReadUint(objReader, type);
          result = {};

          for (i = 0; i < count; ++i) {
            result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElement(objReader);
          }

          return result;

        case this.ElementRawType.OBJECT:
          count = this.ReadUint(objReader, type);
          result = {};

          for (i = 0; i < count; ++i) {
            result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElement(objReader);
          }

          return this.ConstructObject(result);

        case this.ElementRawType.TYPED_ARRAY:
          count = this.ReadUint(objReader, type);
          elementType = objReader._reader.ReadUInt8();
          result = [];

          for (i = 0; i < count; ++i) {
            result.push(this.ReadElementData(objReader, elementType));
          }

          if (elementType in this.TypedArrays) {
            result = new this.TypedArrays[elementType](result);
          }

          return result;

        case this.ElementRawType.TYPED_MAPPING:
          count = this.ReadUint(objReader, type);
          elementType = objReader._reader.ReadUInt8();
          result = {};

          for (i = 0; i < count; ++i) {
            result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElementData(objReader, elementType);
          }

          return result;
      }
    }
    /**
     * Reads an element
     * @property {Tw2ObjectReader} objReader
     * @returns {*}
     */

  }, {
    key: "ReadElement",
    value: function ReadElement(objReader) {
      const type = objReader._reader.ReadUInt8();

      if (type === this.REFERENCE_BIT) {
        return objReader._ids[objReader._reader.ReadUInt16()];
      }

      let id;

      if ((type & this.ID_BIT) !== 0) {
        id = objReader._reader.ReadUInt16();
      }

      const result = this.ReadElementData(objReader, type & 0x3F);

      if ((type & this.ID_BIT) !== 0) {
        objReader._ids[id] = result;
      }

      return result;
    }
    /**
     * Enables debug mode
     * @type {boolean}
     */

  }]);

  return Tw2ObjectReader;
}();

_defineProperty(Tw2ObjectReader, "DEBUG_ENABLED", false);

_defineProperty(Tw2ObjectReader, "ID_BIT", 1 << 6);

_defineProperty(Tw2ObjectReader, "REFERENCE_BIT", 1 << 7);

_defineProperty(Tw2ObjectReader, "ElementRawType", {
  'NULL': 0,
  'BOOL': 1,
  'INT': 2,
  'UINT': 3,
  'FLOAT': 4,
  'STRING': 5,
  'ARRAY': 6,
  'MAPPING': 7,
  'OBJECT': 8,
  'TYPED_ARRAY': 9,
  'TYPED_MAPPING': 10
});

_defineProperty(Tw2ObjectReader, "ElementSize", {
  'SMALL': 0,
  'MEDIUM': 1 << 4,
  'LARGE': 2 << 4
});

_defineProperty(Tw2ObjectReader, "TypedArrays", {
  2: Int8Array,
  3: Uint8Array,
  18: Int16Array,
  19: Uint16Array,
  34: Int32Array,
  35: Uint32Array,
  4: Float32Array,
  20: Float32Array,
  36: Float64Array
});

const Raw = Tw2ObjectReader.ElementRawType,
      Size = Tw2ObjectReader.ElementSize;
/**
 * Element types
 * @type {{}}
 */

Tw2ObjectReader.ElementTypes = {
  'NULL': Raw.NULL | Size.SMALL,
  'BOOL': Raw.BOOL | Size.SMALL,
  'FALSE': Raw.BOOL | Size.MEDIUM,
  'TRUE': Raw.BOOL | Size.LARGE,
  'INT8': Raw.INT | Size.SMALL,
  'UINT8': Raw.UINT | Size.SMALL,
  'INT16': Raw.INT | Size.MEDIUM,
  'UINT16': Raw.UINT | Size.MEDIUM,
  'INT32': Raw.INT | Size.LARGE,
  'UINT32': Raw.UINT | Size.LARGE,
  'FLOAT16': Raw.FLOAT | Size.SMALL,
  'FLOAT32': Raw.FLOAT | Size.MEDIUM,
  'FLOAT64': Raw.FLOAT | Size.LARGE,
  'SHORT_STRING': Raw.STRING | Size.SMALL,
  'MEDIUM_STRING': Raw.STRING | Size.MEDIUM,
  'LARGE_STRING': Raw.STRING | Size.LARGE,
  'SHORT_ARRAY': Raw.ARRAY | Size.SMALL,
  'MEDIUM_ARRAY': Raw.ARRAY | Size.MEDIUM,
  'LARGE_ARRAY': Raw.ARRAY | Size.LARGE,
  'SHORT_MAPPING': Raw.MAPPING | Size.SMALL,
  'MEDIUM_MAPPING': Raw.MAPPING | Size.MEDIUM,
  'LARGE_MAPPING': Raw.MAPPING | Size.LARGE,
  'SHORT_OBJECT': Raw.OBJECT | Size.SMALL,
  'MEDIUM_OBJECT': Raw.OBJECT | Size.MEDIUM,
  'LARGE_OBJECT': Raw.OBJECT | Size.LARGE,
  'SHORT_TYPED_ARRAY': Raw.TYPED_ARRAY | Size.SMALL,
  'MEDIUM_TYPED_ARRAY': Raw.TYPED_ARRAY | Size.MEDIUM,
  'LARGE_TYPED_ARRAY': Raw.TYPED_ARRAY | Size.LARGE,
  'SHORT_TYPED_MAPPING': Raw.TYPED_MAPPING | Size.SMALL,
  'MEDIUM_TYPED_MAPPING': Raw.TYPED_MAPPING | Size.MEDIUM,
  'LARGE_TYPED_MAPPING': Raw.TYPED_MAPPING | Size.LARGE
};

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2BinaryReader; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2BinaryReader
 *
 * @property {*} data
 * @property {number} cursor
 */
let Tw2BinaryReader =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @param {*} data
   */
  function Tw2BinaryReader(data) {
    _classCallCheck(this, Tw2BinaryReader);

    _defineProperty(this, "data", null);

    _defineProperty(this, "cursor", 0);

    this.data = data;
  }
  /**
   * ReadUInt8
   * @returns {*}
   */


  _createClass(Tw2BinaryReader, [{
    key: "ReadUInt8",
    value: function ReadUInt8() {
      return this.data[this.cursor++];
    }
    /**
     * ReadInt8
     * @returns {*}
     */

  }, {
    key: "ReadInt8",
    value: function ReadInt8() {
      let val = this.data[this.cursor++];
      if (val > 0x7F) val = val - 0xff - 1;
      return val;
    }
    /**
     * ReadUInt16
     * @returns {*}
     */

  }, {
    key: "ReadUInt16",
    value: function ReadUInt16() {
      return this.data[this.cursor++] + (this.data[this.cursor++] << 8);
    }
    /**
     * ReadInt16
     * @returns {*}
     */

  }, {
    key: "ReadInt16",
    value: function ReadInt16() {
      let val = this.data[this.cursor++] + (this.data[this.cursor++] << 8);
      if (val > 0x7FFF) val = val - 0xffff - 1;
      return val;
    }
    /**
     * ReadUInt32
     * @returns {*}
     */

  }, {
    key: "ReadUInt32",
    value: function ReadUInt32() {
      return this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
    }
    /**
     * ReadInt32
     * @returns {*}
     */

  }, {
    key: "ReadInt32",
    value: function ReadInt32() {
      let val = this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
      if (val > 0x7FFFFFFF) val = val - 0xffffffff - 1;
      return val;
    }
    /**
     * ReadFloat16
     * @returns {number}
     */

  }, {
    key: "ReadFloat16",
    value: function ReadFloat16() {
      let b2 = this.data[this.cursor++],
          b1 = this.data[this.cursor++];
      const sign = 1 - 2 * (b1 >> 7); // sign = bit 0

      const exp = (b1 >> 2 & 0x1f) - 15; // exponent = bits 1..5

      const sig = (b1 & 3) << 8 | b2; // significand = bits 6..15

      if (sig === 0 && exp === -15) return 0.0;
      return sign * (1 + sig * Math.pow(2, -10)) * Math.pow(2, exp);
    }
    /**
     * ReadFloat32
     * @returns {number}
     */

  }, {
    key: "ReadFloat32",
    value: function ReadFloat32() {
      let b4 = this.data[this.cursor++],
          b3 = this.data[this.cursor++],
          b2 = this.data[this.cursor++],
          b1 = this.data[this.cursor++];
      const sign = 1 - 2 * (b1 >> 7); // sign = bit 0

      const exp = (b1 << 1 & 0xff | b2 >> 7) - 127; // exponent = bits 1..8

      const sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31

      if (sig === 0 && exp === -127) return 0.0;
      return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
    }
    /**
     * ReadString
     * @returns {string}
     */

  }, {
    key: "ReadString",
    value: function ReadString() {
      const length = this.data[this.cursor++];
      let str = '';

      for (let i = 0; i < length; ++i) {
        str += String.fromCharCode(this.data[this.cursor++]);
      }

      return str;
    }
  }]);

  return Tw2BinaryReader;
}();

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emitters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2StaticEmitter", function() { return _emitters__WEBPACK_IMPORTED_MODULE_0__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2DynamicEmitter", function() { return _emitters__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GpuUniqueEmitter", function() { return _emitters__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var _forces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleAttractorForce", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleDirectForce", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleDragForce", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleFluidDragForce", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleSpring", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleTurbulenceForce", function() { return _forces__WEBPACK_IMPORTED_MODULE_1__["f"]; });

/* harmony import */ var _generators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RandomIntegerAttributeGenerator", function() { return _generators__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RandomUniformAttributeGenerator", function() { return _generators__WEBPACK_IMPORTED_MODULE_2__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2SphereShapeAttributeGenerator", function() { return _generators__WEBPACK_IMPORTED_MODULE_2__["c"]; });

/* harmony import */ var _constraints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _constraints__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_constraints__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _constraints__WEBPACK_IMPORTED_MODULE_3__) if(["Tw2StaticEmitter","Tw2DynamicEmitter","Tw2GpuUniqueEmitter","Tw2ParticleAttractorForce","Tw2ParticleDirectForce","Tw2ParticleDragForce","Tw2ParticleFluidDragForce","Tw2ParticleSpring","Tw2ParticleTurbulenceForce","Tw2RandomIntegerAttributeGenerator","Tw2RandomUniformAttributeGenerator","Tw2SphereShapeAttributeGenerator","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _constraints__WEBPACK_IMPORTED_MODULE_3__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _Tw2ParticleSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleSystem", function() { return _Tw2ParticleSystem__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _Tw2ParticleElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleElement", function() { return _Tw2ParticleElement__WEBPACK_IMPORTED_MODULE_5__["a"]; });

/* harmony import */ var _Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ParticleElementDeclaration", function() { return _Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_6__["a"]; });









/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2ParticleElement; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Tw2ParticleElement
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {number} dimension
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @property buffer
 * @property {number} startOffset
 * @property {number} offset
 * @property {number} instanceStride
 * @property {number} vertexStride
 * @property {boolean} dirty
 * @class
 */
let Tw2ParticleElement =
/**
 * Constructor
 * @param {Tw2ParticleElementDeclaration} decl
 */
function Tw2ParticleElement(decl) {
  _classCallCheck(this, Tw2ParticleElement);

  _defineProperty(this, "elementType", null);

  _defineProperty(this, "customName", null);

  _defineProperty(this, "dimension", null);

  _defineProperty(this, "usageIndex", null);

  _defineProperty(this, "usedByGPU", null);

  _defineProperty(this, "buffer", null);

  _defineProperty(this, "startOffset", 0);

  _defineProperty(this, "offset", 0);

  _defineProperty(this, "instanceStride", 0);

  _defineProperty(this, "vertexStride", 0);

  _defineProperty(this, "dirty", false);

  if (decl) {
    this.elementType = decl.elementType;
    this.customName = decl.customName;
    this.dimension = decl.GetDimension();
    this.usageIndex = decl.usageIndex;
    this.usedByGPU = decl.usedByGPU;
  }
};

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./eve/child/EveChild.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * EveChild base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {boolean} useSRT
 * @property {number} lowestLodVisible
 * @property {boolean} staticTransform
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {vec3} scaling
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformLast
 * @property {?|Tw2BasicPerObjectData|Tw2PerObjectData} _perObjectData
 * @class
 */

let EveChild_EveChild =
/*#__PURE__*/
function () {
  function EveChild() {
    _classCallCheck(this, EveChild);

    _defineProperty(this, "_id", global["F" /* util */].generateID());

    _defineProperty(this, "name", '');

    _defineProperty(this, "display", true);

    _defineProperty(this, "useSRT", true);

    _defineProperty(this, "lowestLodVisible", 2);

    _defineProperty(this, "staticTransform", false);

    _defineProperty(this, "rotation", global["C" /* quat */].create());

    _defineProperty(this, "translation", global["H" /* vec3 */].create());

    _defineProperty(this, "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    _defineProperty(this, "localTransform", global["z" /* mat4 */].create());

    _defineProperty(this, "worldTransform", global["z" /* mat4 */].create());

    _defineProperty(this, "worldTransformLast", global["z" /* mat4 */].create());

    _defineProperty(this, "_perObjectData", null);

    _defineProperty(this, "isEffectChild", true);
  }

  _createClass(EveChild, [{
    key: "GetResources",

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt
     * @param {mat4} parentTransform
     */

  }, {
    key: "Update",
    value: function Update(dt, parentTransform) {
      if (this.useSRT) {
        global["C" /* quat */].normalize(this.rotation, this.rotation);
        global["z" /* mat4 */].fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
      }

      global["z" /* mat4 */].copy(this.worldTransformLast, this.worldTransform);
      global["z" /* mat4 */].multiply(this.worldTransform, parentTransform, this.localTransform);
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {}
    /**
     * Class globals and scratch variables
     * @type {Object}
     */

  }]);

  return EveChild;
}();

_defineProperty(EveChild_EveChild, "global", {
  mat4_0: global["z" /* mat4 */].create(),
  vec3_0: global["H" /* vec3 */].create()
});

_defineProperty(EveChild_EveChild, "perObjectData", {
  FFEData: [['world', 16], ['worldInverseTranspose', 16]]
});
// EXTERNAL MODULE: ./core/index.js + 60 modules
var core = __webpack_require__(1);

// CONCATENATED MODULE: ./eve/child/EveChildBillboard.js
function EveChildBillboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildBillboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveChildBillboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveChildBillboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveChildBillboard_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function EveChildBillboard_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { EveChildBillboard_get = Reflect.get; } else { EveChildBillboard_get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return EveChildBillboard_get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildBillboard_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Mesh attachment to space object and oriented towards the camera
 *
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */

let EveChildBillboard_EveChildBillboard =
/*#__PURE__*/
function (_EveChild) {
  _inherits(EveChildBillboard, _EveChild);

  function EveChildBillboard() {
    var _this;

    EveChildBillboard_classCallCheck(this, EveChildBillboard);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EveChildBillboard).call(this, ...args));

    EveChildBillboard_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "mesh", null);

    EveChildBillboard_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_perObjectData", new core["Tw2BasicPerObjectData"](EveChild_EveChild.perObjectData));

    return _this;
  }

  EveChildBillboard_createClass(EveChildBillboard, [{
    key: "GetResources",

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */
    value: function GetResources(out) {
      if (this.mesh) this.mesh.GetResources(out);
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt
     * @param {mat4} parentTransform
     */

  }, {
    key: "Update",
    value: function Update(dt, parentTransform) {
      EveChildBillboard_get(_getPrototypeOf(EveChildBillboard.prototype), "Update", this).call(this, dt, parentTransform);

      const viewInverse = EveChild_EveChild.global.mat4_0,
            finalScale = EveChild_EveChild.global.vec3_0;
      global["z" /* mat4 */].lookAt(viewInverse, global["w" /* device */].eyePosition, this.worldTransform.subarray(12), [0, 1, 0]);
      global["z" /* mat4 */].transpose(viewInverse, viewInverse);
      global["z" /* mat4 */].getScaling(finalScale, parentTransform);
      global["H" /* vec3 */].multiply(finalScale, finalScale, this.scaling);
      this.worldTransform[0] = viewInverse[0] * finalScale[0];
      this.worldTransform[1] = viewInverse[1] * finalScale[0];
      this.worldTransform[2] = viewInverse[2] * finalScale[0];
      this.worldTransform[4] = viewInverse[4] * finalScale[1];
      this.worldTransform[5] = viewInverse[5] * finalScale[1];
      this.worldTransform[6] = viewInverse[6] * finalScale[1];
      this.worldTransform[8] = viewInverse[8] * finalScale[2];
      this.worldTransform[9] = viewInverse[9] * finalScale[2];
      this.worldTransform[10] = viewInverse[10] * finalScale[2];
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display && this.mesh) {
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
        global["z" /* mat4 */].invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
        this.mesh.GetBatches(mode, accumulator, this._perObjectData);
      }
    }
  }]);

  return EveChildBillboard;
}(EveChild_EveChild);
// CONCATENATED MODULE: ./eve/child/EveChildCloud.js
function EveChildCloud_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildCloud_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveChildCloud_assertThisInitialized(self); }

function EveChildCloud_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildCloud_getPrototypeOf(o) { EveChildCloud_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveChildCloud_getPrototypeOf(o); }

function EveChildCloud_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveChildCloud_setPrototypeOf(subClass, superClass); }

function EveChildCloud_setPrototypeOf(o, p) { EveChildCloud_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveChildCloud_setPrototypeOf(o, p); }

function EveChildCloud_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * EveChildCloud - not implemented
 *
 * @class
 */

let EveChildCloud =
/*#__PURE__*/
function (_EveChild) {
  EveChildCloud_inherits(EveChildCloud, _EveChild);

  function EveChildCloud() {
    EveChildCloud_classCallCheck(this, EveChildCloud);

    return EveChildCloud_possibleConstructorReturn(this, EveChildCloud_getPrototypeOf(EveChildCloud).apply(this, arguments));
  }

  return EveChildCloud;
}(EveChild_EveChild);

EveChildCloud_defineProperty(EveChildCloud, "partialImplementation", true);
// CONCATENATED MODULE: ./eve/child/EveChildContainer.js
function EveChildContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildContainer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveChildContainer_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveChildContainer_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveChildContainer_defineProperties(Constructor, staticProps); return Constructor; }

function EveChildContainer_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveChildContainer_assertThisInitialized(self); }

function EveChildContainer_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { EveChildContainer_get = Reflect.get; } else { EveChildContainer_get = function _get(target, property, receiver) { var base = EveChildContainer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return EveChildContainer_get(target, property, receiver || target); }

function EveChildContainer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = EveChildContainer_getPrototypeOf(object); if (object === null) break; } return object; }

function EveChildContainer_getPrototypeOf(o) { EveChildContainer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveChildContainer_getPrototypeOf(o); }

function EveChildContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveChildContainer_setPrototypeOf(subClass, superClass); }

function EveChildContainer_setPrototypeOf(o, p) { EveChildContainer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveChildContainer_setPrototypeOf(o, p); }

function EveChildContainer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildContainer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Container for other child effects
 *
 * @parameter {Array.<{}>} objects
 * @parameter {Array.<Tw2CurveSet>} curveSets
 * @class
 */

let EveChildContainer =
/*#__PURE__*/
function (_EveChild) {
  EveChildContainer_inherits(EveChildContainer, _EveChild);

  function EveChildContainer() {
    var _this;

    EveChildContainer_classCallCheck(this, EveChildContainer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveChildContainer_possibleConstructorReturn(this, EveChildContainer_getPrototypeOf(EveChildContainer).call(this, ...args));

    EveChildContainer_defineProperty(EveChildContainer_assertThisInitialized(EveChildContainer_assertThisInitialized(_this)), "objects", []);

    EveChildContainer_defineProperty(EveChildContainer_assertThisInitialized(EveChildContainer_assertThisInitialized(_this)), "curveSets", []);

    return _this;
  }

  EveChildContainer_createClass(EveChildContainer, [{
    key: "GetResources",

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.objects.length; i++) {
        if ('GetResources' in this.objects[i]) {
          this.objects[i].GetResources(out);
        }
      }

      return out;
    }
    /**
     * Per frame update
     * @param {number} dt
     * @param {mat4} parentTransform
     */

  }, {
    key: "Update",
    value: function Update(dt, parentTransform) {
      EveChildContainer_get(EveChildContainer_getPrototypeOf(EveChildContainer.prototype), "Update", this).call(this, dt, parentTransform);

      for (let i = 0; i < this.curveSets.length; i++) {
        this.curveSets[i].Update(dt);
      }

      for (let i = 0; i < this.objects.length; i++) {
        this.objects[i].Update(dt, this.worldTransform);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (this.display) {
        for (let i = 0; i < this.objects.length; i++) {
          this.objects[i].GetBatches(mode, accumulator, perObjectData);
        }
      }
    }
  }]);

  return EveChildContainer;
}(EveChild_EveChild);
// CONCATENATED MODULE: ./eve/child/EveChildExplosion.js
function EveChildExplosion_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildExplosion_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveChildExplosion_assertThisInitialized(self); }

function EveChildExplosion_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildExplosion_getPrototypeOf(o) { EveChildExplosion_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveChildExplosion_getPrototypeOf(o); }

function EveChildExplosion_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveChildExplosion_setPrototypeOf(subClass, superClass); }

function EveChildExplosion_setPrototypeOf(o, p) { EveChildExplosion_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveChildExplosion_setPrototypeOf(o, p); }

function EveChildExplosion_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * 'Complex' explosion object. Not implemented.
 *
 * @class
 */

let EveChildExplosion =
/*#__PURE__*/
function (_EveChild) {
  EveChildExplosion_inherits(EveChildExplosion, _EveChild);

  function EveChildExplosion() {
    EveChildExplosion_classCallCheck(this, EveChildExplosion);

    return EveChildExplosion_possibleConstructorReturn(this, EveChildExplosion_getPrototypeOf(EveChildExplosion).apply(this, arguments));
  }

  return EveChildExplosion;
}(EveChild_EveChild);

EveChildExplosion_defineProperty(EveChildExplosion, "partialImplementation", true);
// CONCATENATED MODULE: ./eve/child/EveChildMesh.js
function EveChildMesh_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildMesh_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveChildMesh_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveChildMesh_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveChildMesh_defineProperties(Constructor, staticProps); return Constructor; }

function EveChildMesh_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveChildMesh_assertThisInitialized(self); }

function EveChildMesh_getPrototypeOf(o) { EveChildMesh_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveChildMesh_getPrototypeOf(o); }

function EveChildMesh_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveChildMesh_setPrototypeOf(subClass, superClass); }

function EveChildMesh_setPrototypeOf(o, p) { EveChildMesh_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveChildMesh_setPrototypeOf(o, p); }

function EveChildMesh_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildMesh_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Mesh attachment to space object
 *
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @property {boolean} useSpaceObjectData
 * @class
 */

let EveChildMesh_EveChildMesh =
/*#__PURE__*/
function (_EveChild) {
  EveChildMesh_inherits(EveChildMesh, _EveChild);

  function EveChildMesh() {
    var _this;

    EveChildMesh_classCallCheck(this, EveChildMesh);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveChildMesh_possibleConstructorReturn(this, EveChildMesh_getPrototypeOf(EveChildMesh).call(this, ...args));

    EveChildMesh_defineProperty(EveChildMesh_assertThisInitialized(EveChildMesh_assertThisInitialized(_this)), "mesh", null);

    EveChildMesh_defineProperty(EveChildMesh_assertThisInitialized(EveChildMesh_assertThisInitialized(_this)), "useSpaceObjectData", true);

    return _this;
  }

  EveChildMesh_createClass(EveChildMesh, [{
    key: "GetResources",

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */
    value: function GetResources(out) {
      if (this.mesh) this.mesh.GetResources(out);
      return out;
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.display || !this.mesh) return;

      if (this.useSpaceObjectData) {
        if (!this._perObjectData) {
          this._perObjectData = new core["Tw2PerObjectData"]();
          this._perObjectData.perObjectVSData = new core["Tw2RawData"]();
          this._perObjectData.perObjectVSData.data = new Float32Array(perObjectData.perObjectVSData.data.length);
          this._perObjectData.perObjectVSData.data[33] = 1;
          this._perObjectData.perObjectVSData.data[35] = 1;
          this._perObjectData.perObjectPSData = new core["Tw2RawData"]();
          this._perObjectData.perObjectPSData.data = new Float32Array(perObjectData.perObjectPSData.data.length);
          this._perObjectData.perObjectPSData.data[1] = 1;
          this._perObjectData.perObjectPSData.data[3] = 1;
        }

        this._perObjectData.perObjectVSData.data.set(perObjectData.perObjectVSData.data);

        this._perObjectData.perObjectPSData.data.set(perObjectData.perObjectPSData.data);

        global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.data, this.worldTransform);
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.data.subarray(16), this.worldTransformLast);
      } else {
        if (!this._perObjectData) {
          this._perObjectData = new core["Tw2BasicPerObjectData"](EveChild_EveChild.perObjectData);
        }

        global["z" /* mat4 */].transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
        global["z" /* mat4 */].invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
      }

      this.mesh.GetBatches(mode, accumulator, this._perObjectData);
    }
  }]);

  return EveChildMesh;
}(EveChild_EveChild);
// CONCATENATED MODULE: ./eve/child/EveChildParticleSystem.js
function EveChildParticleSystem_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveChildParticleSystem_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveChildParticleSystem_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveChildParticleSystem_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveChildParticleSystem_defineProperties(Constructor, staticProps); return Constructor; }

function EveChildParticleSystem_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveChildParticleSystem_assertThisInitialized(self); }

function EveChildParticleSystem_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { EveChildParticleSystem_get = Reflect.get; } else { EveChildParticleSystem_get = function _get(target, property, receiver) { var base = EveChildParticleSystem_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return EveChildParticleSystem_get(target, property, receiver || target); }

function EveChildParticleSystem_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = EveChildParticleSystem_getPrototypeOf(object); if (object === null) break; } return object; }

function EveChildParticleSystem_getPrototypeOf(o) { EveChildParticleSystem_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveChildParticleSystem_getPrototypeOf(o); }

function EveChildParticleSystem_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveChildParticleSystem_setPrototypeOf(subClass, superClass); }

function EveChildParticleSystem_setPrototypeOf(o, p) { EveChildParticleSystem_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveChildParticleSystem_setPrototypeOf(o, p); }

function EveChildParticleSystem_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveChildParticleSystem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Particle system attachment to space object
 *
 * @property {Tw2Mesh} mesh
 * @property {Array<Tw2ParticleEmitter>} particleEmitters
 * @property {Array<Tw2ParticleSystem>} particleSystems
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */

let EveChildParticleSystem_EveChildParticleSystem =
/*#__PURE__*/
function (_EveChild) {
  EveChildParticleSystem_inherits(EveChildParticleSystem, _EveChild);

  function EveChildParticleSystem() {
    var _this;

    EveChildParticleSystem_classCallCheck(this, EveChildParticleSystem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveChildParticleSystem_possibleConstructorReturn(this, EveChildParticleSystem_getPrototypeOf(EveChildParticleSystem).call(this, ...args));

    EveChildParticleSystem_defineProperty(EveChildParticleSystem_assertThisInitialized(EveChildParticleSystem_assertThisInitialized(_this)), "mesh", null);

    EveChildParticleSystem_defineProperty(EveChildParticleSystem_assertThisInitialized(EveChildParticleSystem_assertThisInitialized(_this)), "particleEmitters", []);

    EveChildParticleSystem_defineProperty(EveChildParticleSystem_assertThisInitialized(EveChildParticleSystem_assertThisInitialized(_this)), "particleSystems", []);

    EveChildParticleSystem_defineProperty(EveChildParticleSystem_assertThisInitialized(EveChildParticleSystem_assertThisInitialized(_this)), "_perObjectData", new core["Tw2BasicPerObjectData"](EveChild_EveChild.perObjectData));

    return _this;
  }

  EveChildParticleSystem_createClass(EveChildParticleSystem, [{
    key: "GetResources",

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */
    value: function GetResources(out) {
      if (this.mesh) this.mesh.GetResources(out);
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt
     * @param {mat4} parentTransform
     */

  }, {
    key: "Update",
    value: function Update(dt, parentTransform) {
      EveChildParticleSystem_get(EveChildParticleSystem_getPrototypeOf(EveChildParticleSystem.prototype), "Update", this).call(this, dt, parentTransform);

      for (let i = 0; i < this.particleEmitters.length; ++i) {
        this.particleEmitters[i].Update(dt);
      }

      for (let i = 0; i < this.particleSystems.length; ++i) {
        this.particleSystems[i].Update(dt);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display && this.mesh) {
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
        global["z" /* mat4 */].invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
        this.mesh.GetBatches(mode, accumulator, this._perObjectData);
      }
    }
  }]);

  return EveChildParticleSystem;
}(EveChild_EveChild);
// CONCATENATED MODULE: ./eve/child/index.js







// CONCATENATED MODULE: ./eve/effect/EveOccluder.js
function EveOccluder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveOccluder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveOccluder_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveOccluder_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveOccluder_defineProperties(Constructor, staticProps); return Constructor; }

function EveOccluder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * EveOccluder
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {number} value
 * @property {Array.<EveSpriteSet>} sprites
 * @class
 */

let EveOccluder_EveOccluder =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function EveOccluder() {
    EveOccluder_classCallCheck(this, EveOccluder);

    EveOccluder_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveOccluder_defineProperty(this, "name", '');

    EveOccluder_defineProperty(this, "value", 1);

    EveOccluder_defineProperty(this, "sprites", []);

    EveOccluder.init();
  }
  /**
   * UpdateValues
   * @param {mat4} parentTransform
   * @param {number} index
   */


  EveOccluder_createClass(EveOccluder, [{
    key: "UpdateValue",
    value: function UpdateValue(parentTransform, index) {
      if (!global["w" /* device */].alphaBlendBackBuffer) return;
      const d = global["w" /* device */],
            g = EveOccluder.global,
            worldViewProj = g.mat4_0,
            center = g.vec4_0;
      g.accumulator.Clear();

      for (let i = 0; i < this.sprites.length; ++i) {
        this.sprites[i].UpdateViewDependentData(parentTransform);
        this.sprites[i].GetBatches(d.RM_DECAL, g.accumulator);
      }

      global["E" /* store */].SetVariableValue('OccluderValue', [(1 << index * 2) / 255.0, (2 << index * 2) / 255.0, 0, 0]);
      g.accumulator.Render();
      global["z" /* mat4 */].multiply(worldViewProj, d.viewProjection, this.sprites[0].worldTransform);
      global["I" /* vec4 */].transformMat4(center, [0, 0, 0, 1], worldViewProj);
      const x0 = (center[0] / center[3] + 1) * 0.5,
            y0 = (center[1] / center[3] + 1) * 0.5;
      global["I" /* vec4 */].set(center, 0.5, 0.5, 0, 1);
      global["I" /* vec4 */].transformMat4(center, center, worldViewProj);
      const x1 = (center[0] / center[3] + 1) * 0.5,
            y1 = (center[1] / center[3] + 1) * 0.5;
      center[0] = x0;
      center[1] = y0;
      center[2] = x1 - x0;
      center[3] = y1 - y0;
      g.effect.parameters.OccluderPosition.SetValue(center);
    }
    /**
     * CollectSamples
     * @param {Tw2TextureRes} tex
     * @param {number} index
     * @param {number} total
     * @param {number} samples
     * @returns boolean
     */

  }], [{
    key: "CollectSamples",
    value: function CollectSamples(tex, index, total, samples) {
      const d = global["w" /* device */],
            g = this.global,
            effect = g.effect,
            vertexBuffer = g.vertexBuffer,
            decl = g.decl;
      if (!effect.effectRes || !effect.effectRes.IsGood()) return false;
      effect.parameters.BackBuffer.textureRes = tex;
      effect.parameters.OccluderIndex.SetValue([index, total, samples]);
      d.SetStandardStates(d.RM_ADDITIVE);
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, vertexBuffer);

      for (let pass = 0; pass < effect.GetPassCount('Main'); ++pass) {
        effect.ApplyPass('Main', pass);
        if (decl.SetDeclaration(effect.GetPassInput('Main', pass), 16)) return false;
        d.ApplyShadowState();
        d.gl.drawArrays(d.gl.TRIANGLES, 0, 255 * 6);
      }

      return true;
    }
    /**
     * Initializes class globals and scratch variables
     */

  }, {
    key: "init",
    value: function init() {
      if (EveOccluder.global) return;
      const d = global["w" /* device */],
            g = EveOccluder.global = {};
      g.mat4_0 = global["z" /* mat4 */].create();
      g.vec4_0 = global["I" /* vec4 */].create();
      g.accumulator = new core["Tw2BatchAccumulator"]();
      g.effect = core["Tw2Effect"].create({
        name: 'Occluder sampler',
        effectFilePath: 'res:/graphics/effect/managed/space/specialfx/lensflares/collectsamples.fx',
        parameters: {
          'OccluderPosition': [1, 1, 1, 1],
          'OccluderIndex': [1, 1, 1],
          'BackBuffer': ''
        }
      });
      g.vertexBuffer = null;
      g.decl = new core["Tw2VertexDeclaration"]();
      g.decl.elements.push(new core["Tw2VertexElement"](core["Tw2VertexDeclaration"].Type.POSITION, 0, d.gl.FLOAT, 2, 0));
      g.decl.elements.push(new core["Tw2VertexElement"](core["Tw2VertexDeclaration"].Type.TEXCOORD, 0, d.gl.FLOAT, 2, 8));
      g.decl.RebuildHash();
      const vb = new Float32Array(255 * 6 * 4);
      let index = 0;

      for (let i = 0; i < 16; ++i) {
        for (let j = 0; j < 16; ++j) {
          const x = (i + Math.random()) / 16 * 2 - 1,
                y = (j + Math.random()) / 16 * 2 - 1;
          vb[index++] = 1;
          vb[index++] = 1;
          vb[index++] = x;
          vb[index++] = y;
          vb[index++] = -1;
          vb[index++] = 1;
          vb[index++] = x;
          vb[index++] = y;
          vb[index++] = 1;
          vb[index++] = -1;
          vb[index++] = x;
          vb[index++] = y;
          vb[index++] = -1;
          vb[index++] = 1;
          vb[index++] = x;
          vb[index++] = y;
          vb[index++] = 1;
          vb[index++] = -1;
          vb[index++] = x;
          vb[index++] = y;
          vb[index++] = -1;
          vb[index++] = -1;
          vb[index++] = x;
          vb[index++] = y;
        }
      }

      g.vertexBuffer = d.gl.createBuffer();
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, g.vertexBuffer);
      d.gl.bufferData(d.gl.ARRAY_BUFFER, vb, d.gl.STATIC_DRAW);
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);
    }
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return EveOccluder;
}();

EveOccluder_defineProperty(EveOccluder_EveOccluder, "global", null);
// CONCATENATED MODULE: ./eve/effect/EveLensflare.js
function EveLensflare_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveLensflare_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveLensflare_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveLensflare_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveLensflare_defineProperties(Constructor, staticProps); return Constructor; }

function EveLensflare_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveLensFlare
 *
 * @property {number|string} _id
 * @property {String} name=
 * @property {boolean} display
 * @property {boolean} update
 * @property {boolean} doOcclusionQueries
 * @property {number} cameraFactor
 * @property {vec3} position
 * @property {Array} flares
 * @property {Array.<EveOccluder>} occluders
 * @property {Array.<EveOccluder>} backgroundOccluders
 * @property {number} occlusionIntensity
 * @property {number} backgroundOcclusionIntensity
 * @property {Array} distanceToEdgeCurves
 * @property {Array} distanceToCenterCurves
 * @property {Array} radialAngleCurves
 * @property {Array} xDistanceToCenter
 * @property {Array} yDistanceToCenter
 * @property {Array} bindings
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {?Tw2Mesh} mesh
 * @property {vec3} _direction
 * @property {mat4} _transform
 * @property {*} _backBuffer
 * @class
 */

let EveLensflare_EveLensflare =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function EveLensflare() {
    EveLensflare_classCallCheck(this, EveLensflare);

    EveLensflare_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveLensflare_defineProperty(this, "name", '');

    EveLensflare_defineProperty(this, "display", true);

    EveLensflare_defineProperty(this, "update", true);

    EveLensflare_defineProperty(this, "doOcclusionQueries", true);

    EveLensflare_defineProperty(this, "cameraFactor", 20);

    EveLensflare_defineProperty(this, "position", global["H" /* vec3 */].create());

    EveLensflare_defineProperty(this, "flares", []);

    EveLensflare_defineProperty(this, "occluders", []);

    EveLensflare_defineProperty(this, "backgroundOccluders", []);

    EveLensflare_defineProperty(this, "occlusionIntensity", 1);

    EveLensflare_defineProperty(this, "backgroundOcclusionIntensity", 1);

    EveLensflare_defineProperty(this, "distanceToEdgeCurves", []);

    EveLensflare_defineProperty(this, "distanceToCenterCurves", []);

    EveLensflare_defineProperty(this, "radialAngleCurves", []);

    EveLensflare_defineProperty(this, "xDistanceToCenter", []);

    EveLensflare_defineProperty(this, "yDistanceToCenter", []);

    EveLensflare_defineProperty(this, "bindings", []);

    EveLensflare_defineProperty(this, "curveSets", []);

    EveLensflare_defineProperty(this, "mesh", null);

    EveLensflare_defineProperty(this, "_direction", global["H" /* vec3 */].create());

    EveLensflare_defineProperty(this, "_transform", global["z" /* mat4 */].create());

    EveLensflare_defineProperty(this, "_backBuffer", null);

    EveLensflare.init();
  }
  /**
   * Gets lensflares's res objects
   * @param {Array} [out=[]] - Optional receiving array
   * @returns {Array.<Tw2Resource>} [out]
   */


  EveLensflare_createClass(EveLensflare, [{
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (this.mesh) this.mesh.GetResources(out);

      for (let i = 0; i < this.flares.length; i++) {
        this.flares[i].GetResources(out);
      }

      if (EveOccluder_EveOccluder.global && EveOccluder_EveOccluder.global.effect && !out.includes(EveOccluder_EveOccluder.global.effect)) {
        out.push(EveOccluder_EveOccluder.global.effect);
      }

      return out;
    }
    /**
     * Updates Occluders
     */

  }, {
    key: "UpdateOccluders",
    value: function UpdateOccluders() {
      if (!this.doOcclusionQueries) return;
      const d = global["w" /* device */],
            g = EveLensflare.global;

      if (!g.occluderLevels[0].texture || g.occluderLevels[0].width < this.occluders.length * 2) {
        for (let i = 0; i < g.occluderLevels.length; ++i) {
          g.occluderLevels[i].Create(this.occluders.length * 2, 1, false);
        }
      } // TODO: Is this deprecated?


      for (let j = 0; j < this.flares.length; ++j) {
        if ('_backBuffer' in this.flares[j]) {
          this.flares[j]._backBuffer.textureRes = g.occluderLevels.texture;
        }
      }

      this.occlusionIntensity = 1;
      this.backgroundOcclusionIntensity = 1;
      g.occluderLevels[g.occludedLevelIndex].Set();
      d.SetStandardStates(d.RM_OPAQUE);
      d.gl.clearColor(0.0, 0.0, 0.0, 1.0);
      d.gl.clear(d.gl.COLOR_BUFFER_BIT);
      g.occluderLevels[g.occludedLevelIndex].Unset();
      let samples = 1;

      if (d.antialiasing) {
        samples = d.msaaSamples;
        d.gl.sampleCoverage(1.0 / samples, false);
      }

      for (let i = 0; i < this.occluders.length; ++i) {
        d.SetRenderState(d.RS_COLORWRITEENABLE, 8);
        d.gl.colorMask(false, false, false, true);
        d.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        d.gl.clear(d.gl.COLOR_BUFFER_BIT); // Turn off antialiasing

        if (d.antialiasing) {
          d.gl.enable(d.gl.SAMPLE_COVERAGE);
          d.gl.sampleCoverage(0.25, false);
        }

        this.occluders[i].UpdateValue(this._transform, i);
        if (d.antialiasing) d.gl.disable(d.gl.SAMPLE_COVERAGE); // Copy back buffer into a texture

        if (!g.backBuffer.texture) g.backBuffer.Attach(d.gl.createTexture());
        d.gl.bindTexture(d.gl.TEXTURE_2D, g.backBuffer.texture);

        if (g.backBuffer.width !== d.viewportWidth || g.backBuffer.height !== d.viewportHeight) {
          d.gl.texImage2D(d.gl.TEXTURE_2D, 0, d.gl.RGBA, d.viewportWidth, d.viewportHeight, 0, d.gl.RGBA, d.gl.UNSIGNED_BYTE, null);
          d.gl.texParameteri(d.gl.TEXTURE_2D, d.gl.TEXTURE_MAG_FILTER, d.gl.LINEAR);
          d.gl.texParameteri(d.gl.TEXTURE_2D, d.gl.TEXTURE_MIN_FILTER, d.gl.LINEAR);
          g.backBuffer.width = d.viewportWidth;
          g.backBuffer.height = d.viewportHeight;
        }

        d.gl.copyTexImage2D(d.gl.TEXTURE_2D, 0, d.alphaBlendBackBuffer ? d.gl.RGBA : d.gl.RGB, 0, 0, g.backBuffer.width, g.backBuffer.height, 0);
        d.gl.bindTexture(d.gl.TEXTURE_2D, null); // Collect samples

        g.occluderLevels[g.occludedLevelIndex].Set();
        EveOccluder_EveOccluder.CollectSamples(g.backBuffer, i, g.occluderLevels[0].width / 2, samples);
        g.occluderLevels[g.occludedLevelIndex].Unset();
      }

      if (d.antialiasing) d.gl.sampleCoverage(1, false);
      g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Set();
      const pixels = new Uint8Array(g.occluderLevels[0].width * 4);
      d.gl.readPixels(0, 0, 2, 1, d.gl.RGBA, d.gl.UNSIGNED_BYTE, pixels);
      g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Unset();
      this.occlusionIntensity = 1;

      for (let i = 0; i < g.occluderLevels[0].width * 2; i += 4) {
        this.occlusionIntensity *= pixels[i + 1] ? pixels[i] / pixels[i + 1] : 1;
      }

      this.backgroundOcclusionIntensity = this.occlusionIntensity;
      global["E" /* store */].SetVariableValue('LensflareFxOccScale', [this.occlusionIntensity, this.occlusionIntensity, 0, 0]);
      g.occludedLevelIndex = (g.occludedLevelIndex + 1) % g.occluderLevels.length;
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (this.display) {
        const viewDir = global["I" /* vec4 */].set(EveLensflare.global.vec4_0, 0, 0, 1, 0);
        global["I" /* vec4 */].transformMat4(viewDir, viewDir, global["w" /* device */].viewInverse);
        if (global["H" /* vec3 */].dot(viewDir, this._direction) < 0) return;

        for (let i = 0; i < this.flares.length; ++i) {
          this.flares[i].GetBatches(mode, accumulator, perObjectData);
        }

        if (this.mesh) {
          this.mesh.GetBatches(mode, accumulator, perObjectData);
        }
      }
    }
    /**
     * Prepares the lensflare for rendering
     */

  }, {
    key: "PrepareRender",
    value: function PrepareRender() {
      if (!this.display) return;
      const g = EveLensflare.global,
            viewDir = g.vec4_0,
            cameraPos = g.vec3_0,
            scaleMat = global["z" /* mat4 */].identity(g.mat4_0),
            cameraSpacePos = g.vec3_2,
            negDirVec = g.vec3_3,
            negPos = g.vec3_1,
            dist = g.vec4_1;
      global["H" /* vec3 */].transformMat4(cameraPos, [0, 0, 0], global["w" /* device */].viewInverse);

      if (global["H" /* vec3 */].length(this.position) === 0) {
        global["H" /* vec3 */].negate(negPos, cameraPos); //let distScale = vec3.length(negPos);
        //distScale = distScale > 1.5 ? 1 / Math.log(distScale) : 2.5;
      } else {
        global["H" /* vec3 */].negate(negPos, this.position);
        global["H" /* vec3 */].normalize(this._direction, negPos);
      }

      global["I" /* vec4 */].transformMat4(viewDir, [0, 0, 1, 0], global["w" /* device */].viewInverse);
      global["H" /* vec3 */].scaleAndAdd(cameraSpacePos, cameraPos, viewDir, -this.cameraFactor);
      global["H" /* vec3 */].negate(negDirVec, this._direction);
      global["z" /* mat4 */].arcFromForward(this._transform, negDirVec);
      global["z" /* mat4 */].setTranslation(this._transform, cameraSpacePos);
      global["z" /* mat4 */].scale(scaleMat, scaleMat, [this.occlusionIntensity, this.occlusionIntensity, 1]); //mat4.multiply(scaleMat, scaleMat, this._transform);

      const dir = this._direction;
      global["E" /* store */].SetVariableValue('LensflareFxDirectionScale', [dir[0], dir[1], dir[2], 1]);
      global["I" /* vec4 */].set(dist, dir[0], dir[1], dir[2], 0);
      global["I" /* vec4 */].transformMat4(dist, dist, global["w" /* device */].view);
      global["I" /* vec4 */].transformMat4(dist, dist, global["w" /* device */].projection);
      dist[0] /= dist[3];
      dist[1] /= dist[3];
      const distToEdge = 1 - Math.min(1 - Math.abs(dist[0]), 1 - Math.abs(dist[1])),
            distToCenter = Math.sqrt(dist[0] * dist[0] + dist[1] * dist[1]),
            radialAngle = Math.atan2(dist[1], dist[0]) + Math.PI;

      for (let i = 0; i < this.distanceToEdgeCurves.length; ++i) {
        this.distanceToEdgeCurves[i].UpdateValue(distToEdge);
      }

      for (let i = 0; i < this.distanceToCenterCurves.length; ++i) {
        this.distanceToCenterCurves[i].UpdateValue(distToCenter);
      }

      for (let i = 0; i < this.radialAngleCurves.length; ++i) {
        this.radialAngleCurves[i].UpdateValue(radialAngle);
      }

      for (let i = 0; i < this.xDistanceToCenter.length; ++i) {
        this.xDistanceToCenter[i].UpdateValue(dist[0] + 10);
      }

      for (let i = 0; i < this.yDistanceToCenter.length; ++i) {
        this.yDistanceToCenter[i].UpdateValue(dist[1] + 10);
      }

      for (let i = 0; i < this.bindings.length; ++i) {
        this.bindings[i].CopyValue();
      }

      for (let i = 0; i < this.flares.length; ++i) {
        this.flares[i].UpdateViewDependentData(this._transform);
      }
    }
    /**
     * Initializes class global and scratch variables
     */

  }], [{
    key: "init",
    value: function init() {
      if (!EveLensflare.global) {
        const g = EveLensflare.global = {};
        g.vec3_0 = global["H" /* vec3 */].create();
        g.vec3_1 = global["H" /* vec3 */].create();
        g.vec3_2 = global["H" /* vec3 */].create();
        g.vec3_3 = global["H" /* vec3 */].create();
        g.vec4_0 = global["I" /* vec4 */].create();
        g.vec4_1 = global["I" /* vec4 */].create();
        g.mat4_0 = global["z" /* mat4 */].create();
        g.backBuffer = new core["Tw2TextureRes"]();
        g.backBuffer.width = 0;
        g.backBuffer.height = 0;
        g.backBuffer.hasMipMaps = false;
        g.occludedLevelIndex = 0;
        g.occluderLevels = [new core["Tw2RenderTarget"](), new core["Tw2RenderTarget"](), new core["Tw2RenderTarget"](), new core["Tw2RenderTarget"]()];
      }
    }
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return EveLensflare;
}();

EveLensflare_defineProperty(EveLensflare_EveLensflare, "global", null);
// CONCATENATED MODULE: ./eve/effect/EveMeshOverlayEffect.js
function EveMeshOverlayEffect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveMeshOverlayEffect_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveMeshOverlayEffect_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveMeshOverlayEffect_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveMeshOverlayEffect_defineProperties(Constructor, staticProps); return Constructor; }

function EveMeshOverlayEffect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Constructor for Overlay Effects
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display                     - Enables/ disables all batch accumulations
 * @property {{}} visible                          - Batch accumulation options for the overlay effect
 * @property {boolean} visible.opaqueEffects       - Enables/ disables opaque effect batch accumulation
 * @property {boolean} visible.decalEffects        - Enables/ disables decal effect batch accumulation
 * @property {boolean} visible.transparentEffects  - Enables/ disables transparent effect batch accumulation
 * @property {boolean} visible.additiveEffects     - Enables/ disables additive effect batch accumulation
 * @property {boolean} visible.distortionEffects   - Currently not supported
 * @property {boolean} update
 * @property {Tw2CurveSet} curveSet
 * @property {Array.<Tw2Effect>} opaqueEffects
 * @property {Array.<Tw2Effect>} decalEffects
 * @property {Array.<Tw2Effect>} transparentEffects
 * @property {Array.<Tw2Effect>} additiveEffects
 * @property {Array.<Tw2Effect>} distortionEffects - Currently not supported
 * @class
 */

let EveMeshOverlayEffect_EveMeshOverlayEffect =
/*#__PURE__*/
function () {
  function EveMeshOverlayEffect() {
    EveMeshOverlayEffect_classCallCheck(this, EveMeshOverlayEffect);

    EveMeshOverlayEffect_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveMeshOverlayEffect_defineProperty(this, "name", '');

    EveMeshOverlayEffect_defineProperty(this, "display", true);

    EveMeshOverlayEffect_defineProperty(this, "visible", {
      opaqueEffects: true,
      decalEffects: true,
      transparentEffects: true,
      additiveEffects: true,
      distortionEffects: true
    });

    EveMeshOverlayEffect_defineProperty(this, "update", true);

    EveMeshOverlayEffect_defineProperty(this, "curveSet", null);

    EveMeshOverlayEffect_defineProperty(this, "opaqueEffects", []);

    EveMeshOverlayEffect_defineProperty(this, "decalEffects", []);

    EveMeshOverlayEffect_defineProperty(this, "transparentEffects", []);

    EveMeshOverlayEffect_defineProperty(this, "additiveEffects", []);

    EveMeshOverlayEffect_defineProperty(this, "distortionEffects", []);
  }

  EveMeshOverlayEffect_createClass(EveMeshOverlayEffect, [{
    key: "GetResources",

    /**
     * Gets the mesh overlay's resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      global["F" /* util */].perArrayChild(this.opaqueEffects, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.decalEffects, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.transparentEffects, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.additiveEffects, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.distortionEffects, 'GetResources', out);
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (this.update && this.curveSet) this.curveSet.Update(dt);
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {Tw2Mesh} mesh
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData, mesh) {
      if (!this.display || !mesh || !mesh.IsGood()) return;
      const effects = this.GetEffects(mode);

      for (let i = 0; i < effects.length; i++) {
        const batch = new core["Tw2GeometryBatch"]();
        batch.renderMode = mode;
        batch.perObjectData = perObjectData;
        batch.geometryRes = mesh.geometryResource;
        batch.meshIx = mesh.meshIndex;
        batch.start = 0;
        batch.count = mesh.geometryResource.meshes[mesh.meshIndex].areas.length;
        batch.effect = effects[i];
        accumulator.Commit(batch);
      }
    }
    /**
     * Gets effects
     * @param {number} mode
     * @returns {Array.<Tw2Effect>}
     */

  }, {
    key: "GetEffects",
    value: function GetEffects(mode) {
      if (this.display) {
        switch (mode) {
          case global["w" /* device */].RM_OPAQUE:
            if (this.visible.opaqueEffects) return this.opaqueEffects;
            break;

          case global["w" /* device */].RM_TRANSPARENT:
            if (this.visible.transparentEffects) return this.transparentEffects;
            break;

          case global["w" /* device */].RM_ADDITIVE:
            if (this.visible.additiveEffects) return this.additiveEffects;
            break;

          case global["w" /* device */].RM_DECAL:
            if (this.visible.decalEffects) return this.decalEffects;
            break;

          case global["w" /* device */].RM_DISTORTION:
            if (this.visible.distortionEffects) return this.distortionEffects;
        }
      }

      return [];
    }
  }]);

  return EveMeshOverlayEffect;
}();
// CONCATENATED MODULE: ./eve/effect/EveStretch.js
function EveStretch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveStretch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveStretch_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveStretch_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveStretch_defineProperties(Constructor, staticProps); return Constructor; }

function EveStretch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * EveStretch
 *
 * @property {string|number} _id
 * @property {String} name
 * @property {boolean} display
 * @property {boolean} update
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {*} source
 * @property {*} dest
 * @property {*} sourceObject
 * @property {*} destObject
 * @property {*} stretchObject
 * @property {Tw2Float} length
 * @property {number} _time
 * @property {boolean} _useTransformsForStretch
 * @property {vec3} _sourcePosition
 * @property {vec3} _destinationPosition
 * @property {boolean} _displaySourceObject
 * @property {mat4} _sourceTransform
 * @property {boolean} _displayDestObject
 * @property {boolean} _useTransformsForStretch
 * @property {boolean} _isNegZForward
 * @class
 */

let EveStretch_EveStretch =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function EveStretch() {
    EveStretch_classCallCheck(this, EveStretch);

    EveStretch_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveStretch_defineProperty(this, "name", '');

    EveStretch_defineProperty(this, "display", true);

    EveStretch_defineProperty(this, "update", true);

    EveStretch_defineProperty(this, "curveSets", []);

    EveStretch_defineProperty(this, "source", null);

    EveStretch_defineProperty(this, "dest", null);

    EveStretch_defineProperty(this, "sourceObject", null);

    EveStretch_defineProperty(this, "destObject", null);

    EveStretch_defineProperty(this, "stretchObject", null);

    EveStretch_defineProperty(this, "length", new core["Tw2Float"]());

    EveStretch_defineProperty(this, "_time", 0);

    EveStretch_defineProperty(this, "_useTransformsForStretch", false);

    EveStretch_defineProperty(this, "_sourcePosition", global["H" /* vec3 */].create());

    EveStretch_defineProperty(this, "_destinationPosition", global["H" /* vec3 */].create());

    EveStretch_defineProperty(this, "_displaySourceObject", true);

    EveStretch_defineProperty(this, "_sourceTransform", null);

    EveStretch_defineProperty(this, "_displayDestObject", true);

    EveStretch_defineProperty(this, "_isNegZForward", false);

    EveStretch.init();
  }
  /**
   * Gets source position
   * @param {vec3} position
   */


  EveStretch_createClass(EveStretch, [{
    key: "SetSourcePosition",
    value: function SetSourcePosition(position) {
      this._useTransformsForStretch = false;
      this._sourcePosition = position;
    }
    /**
     * Sets the destination position
     * @param {vec3} position
     */

  }, {
    key: "SetDestinationPosition",
    value: function SetDestinationPosition(position) {
      this._destinationPosition = position;
    }
    /**
     * Sets the source transform
     * @param {mat4} transform
     */

  }, {
    key: "SetSourceTransform",
    value: function SetSourceTransform(transform) {
      this._useTransformsForStretch = true;
      this._sourceTransform = transform;
    }
    /**
     * SetIsNegZForward
     * @param {boolean} isNegZForward
     */

  }, {
    key: "SetIsNegZForward",
    value: function SetIsNegZForward(isNegZForward) {
      this._isNegZForward = isNegZForward;
    }
    /**
     * Gets the stretches resources
     * @param {Array} [out=[]]
     * @return {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (this.source && this.source.GetResources) this.source.GetResources(out);
      if (this.dest && this.dest.GetResources) this.dest.GetResources(out);
      if (this.sourceObject && this.sourceObject.GetResources) this.sourceObject.GetResources(out);
      if (this.destObject && this.destObject.GetResources) this.destObject.GetResources(out);
      if (this.stretchObject && this.stretchObject.GetResources) this.stretchObject.GetResources(out);
      return out;
    }
    /**
     * Updates view dependent data
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      if (!this.display) return;
      const g = EveStretch.global,
            directionVec = global["H" /* vec3 */].subtract(g.vec3_0, this._destinationPosition, this._sourcePosition),
            m = global["z" /* mat4 */].identity(g.mat4_0),
            x = global["H" /* vec3 */].set(g.vec3_1, 0, 0, 0),
            up = global["H" /* vec3 */].set(g.vec3_2, 0, 0, 0),
            s = global["z" /* mat4 */].identity(g.mat4_1);
      let scalingLength = global["H" /* vec3 */].length(directionVec);
      global["H" /* vec3 */].normalize(directionVec, directionVec);

      if (this._useTransformsForStretch) {
        global["z" /* mat4 */].rotateX(m, m, -Math.PI / 2);
        global["z" /* mat4 */].multiply(m, this._sourceTransform, m);
      } else {
        if (Math.abs(directionVec[1]) > 0.9) {
          up[2] = 1;
        } else {
          up[1] = 1;
        }

        global["H" /* vec3 */].cross(x, up, directionVec);
        global["H" /* vec3 */].normalize(x, x);
        global["H" /* vec3 */].cross(up, directionVec, x);
        m[0] = x[0];
        m[1] = x[1];
        m[2] = x[2];
        m[4] = -directionVec[0];
        m[5] = -directionVec[1];
        m[6] = -directionVec[2];
        m[8] = up[0];
        m[9] = up[1];
        m[10] = up[2];
      }

      if (this.destObject && this._displayDestObject) {
        global["z" /* mat4 */].setTranslation(m, this._destinationPosition);
        this.destObject.UpdateViewDependentData(m);
      }

      if (this.sourceObject && this._displaySourceObject) {
        if (this._useTransformsForStretch) {
          global["z" /* mat4 */].identity(m);
          global["z" /* mat4 */].rotateX(m, m, -Math.PI / 2);
          global["z" /* mat4 */].multiply(m, this._sourceTransform, m);
        } else {
          global["z" /* mat4 */].setTranslation(m, this._sourcePosition);
        }

        this.sourceObject.UpdateViewDependentData(m);
      }

      if (this.stretchObject) {
        if (this._useTransformsForStretch) {
          global["z" /* mat4 */].identity(m);
          global["z" /* mat4 */].scale(m, m, [1, 1, scalingLength]);
          global["z" /* mat4 */].multiply(m, this._sourceTransform, m);
        } else {
          m[0] = x[0];
          m[1] = x[1];
          m[2] = x[2];
          m[4] = up[0];
          m[5] = up[1];
          m[6] = up[2];
          m[8] = -directionVec[0];
          m[9] = -directionVec[1];
          m[10] = -directionVec[2];
          if (this._isNegZForward) scalingLength = -scalingLength;
          global["z" /* mat4 */].scale(s, s, [1, 1, scalingLength]);
          global["z" /* mat4 */].multiply(m, m, s);
        }

        this.stretchObject.UpdateViewDependentData(m);
      }
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Update(dt);
      }

      this._time += dt;

      if (this.source) {
        this.source.GetValueAt(this._time, this._sourcePosition);
      } else if (this._useTransformsForStretch) {
        this._sourcePosition[0] = this._sourceTransform[12];
        this._sourcePosition[1] = this._sourceTransform[13];
        this._sourcePosition[2] = this._sourceTransform[14];
      }

      if (this.dest) {
        this.source.GetValueAt(this._time, this._destinationPosition);
      }

      const directionVec = global["H" /* vec3 */].subtract(EveStretch.global.vec3_0, this._destinationPosition, this._sourcePosition);
      this.length.value = global["H" /* vec3 */].length(directionVec);
      global["H" /* vec3 */].normalize(directionVec, directionVec);

      if (this.sourceObject && this._displaySourceObject) {
        this.sourceObject.Update(dt);
      }

      if (this.stretchObject) {
        this.stretchObject.Update(dt);
      }

      if (this.destObject && this._displayDestObject) {
        this.destObject.Update(dt);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.display) return;

      if (this.sourceObject && this._displaySourceObject) {
        this.sourceObject.GetBatches(mode, accumulator, perObjectData);
      }

      if (this.destObject && this._displayDestObject) {
        this.destObject.GetBatches(mode, accumulator, perObjectData);
      }

      if (this.stretchObject) {
        this.stretchObject.GetBatches(mode, accumulator, perObjectData);
      }
    }
    /**
     * Initializes class global and scratch variables
     */

  }], [{
    key: "init",
    value: function init() {
      if (!EveStretch.global) {
        EveStretch.global = {
          vec3_0: global["H" /* vec3 */].create(),
          vec3_1: global["H" /* vec3 */].create(),
          vec3_2: global["H" /* vec3 */].create(),
          mat4_0: global["z" /* mat4 */].create(),
          mat4_1: global["z" /* mat4 */].create()
        };
      }
    }
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return EveStretch;
}();

EveStretch_defineProperty(EveStretch_EveStretch, "global", null);
// CONCATENATED MODULE: ./eve/effect/EveTurretFiringFX.js
function EveTurretFiringFX_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveTurretFiringFX_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveTurretFiringFX_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveTurretFiringFX_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveTurretFiringFX_defineProperties(Constructor, staticProps); return Constructor; }

function EveTurretFiringFX_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * EvePerMuzzleData
 *
 * @property {boolean} started
 * @property {boolean} readyToStart
 * @property muzzlePositionBone
 * @property {mat4} muzzleTransform
 * @property {vec3} muzzlePosition
 * @property {number} currentStartDelay
 * @property {number} constantDelay
 * @property {number} elapsedTime
 * @class
 */

let EveTurretFiringFX_EvePerMuzzleData =
/*#__PURE__*/
function () {
  function EvePerMuzzleData() {
    EveTurretFiringFX_classCallCheck(this, EvePerMuzzleData);

    EveTurretFiringFX_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveTurretFiringFX_defineProperty(this, "started", false);

    EveTurretFiringFX_defineProperty(this, "readyToStart", false);

    EveTurretFiringFX_defineProperty(this, "muzzlePositionBone", null);

    EveTurretFiringFX_defineProperty(this, "muzzleTransform", global["z" /* mat4 */].create());

    EveTurretFiringFX_defineProperty(this, "currentStartDelay", 0);

    EveTurretFiringFX_defineProperty(this, "constantDelay", 0);

    EveTurretFiringFX_defineProperty(this, "elapsedTime", 0);
  }

  EveTurretFiringFX_createClass(EvePerMuzzleData, [{
    key: "muzzlePosition",

    /**
     * Muzzle position
     * @returns {TypedArray}
     */
    get: function get() {
      return this.muzzleTransform.subarray(12, 15);
    }
  }]);

  return EvePerMuzzleData;
}();
/**
 * EveTurretFiringFX
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {boolean} display
 * @property {Array.<EveStretch>} stretch
 * @property {boolean} useMuzzleTransform
 * @property {boolean} isFiring
 * @property {boolean} isLoopFiring
 * @property {number} firingDelay1
 * @property {number} firingDelay2
 * @property {number} firingDelay3
 * @property {number} firingDelay4
 * @property {number} firingDelay5
 * @property {number} firingDelay6
 * @property {number} firingDelay7
 * @property {number} firingDelay8
 * @property {vec3} endPosition
 * @property {number} _firingDuration
 * @property {Array.<EvePerMuzzleData>} _perMuzzleData
 * @class
 */

let EveTurretFiringFX_EveTurretFiringFX =
/*#__PURE__*/
function () {
  function EveTurretFiringFX() {
    EveTurretFiringFX_classCallCheck(this, EveTurretFiringFX);

    EveTurretFiringFX_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveTurretFiringFX_defineProperty(this, "name", '');

    EveTurretFiringFX_defineProperty(this, "display", true);

    EveTurretFiringFX_defineProperty(this, "stretch", []);

    EveTurretFiringFX_defineProperty(this, "useMuzzleTransform", false);

    EveTurretFiringFX_defineProperty(this, "isFiring", false);

    EveTurretFiringFX_defineProperty(this, "isLoopFiring", false);

    EveTurretFiringFX_defineProperty(this, "firingDelay1", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay2", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay3", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay4", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay5", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay6", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay7", 0);

    EveTurretFiringFX_defineProperty(this, "firingDelay8", 0);

    EveTurretFiringFX_defineProperty(this, "endPosition", global["H" /* vec3 */].create());

    EveTurretFiringFX_defineProperty(this, "_firingDuration", 0);

    EveTurretFiringFX_defineProperty(this, "_perMuzzleData", []);
  }

  EveTurretFiringFX_createClass(EveTurretFiringFX, [{
    key: "Initialize",

    /**
     * Initializes the turret firing fx
     */
    value: function Initialize() {
      this._firingDuration = this.GetCurveDuration();

      for (let i = 0; i < this.stretch.length; ++i) {
        this._perMuzzleData[i] = new EveTurretFiringFX_EvePerMuzzleData();
      }

      const data = this._perMuzzleData;
      if (data.length > 0) data[0].constantDelay = this.firingDelay1;
      if (data.length > 1) data[1].constantDelay = this.firingDelay2;
      if (data.length > 2) data[2].constantDelay = this.firingDelay3;
      if (data.length > 3) data[3].constantDelay = this.firingDelay4;
      if (data.length > 4) data[4].constantDelay = this.firingDelay5;
      if (data.length > 5) data[5].constantDelay = this.firingDelay6;
      if (data.length > 6) data[6].constantDelay = this.firingDelay7;
      if (data.length > 7) data[7].constantDelay = this.firingDelay8;
    }
    /**
     * Gets the total curve duration
     * @returns {number}
     */

  }, {
    key: "GetCurveDuration",
    value: function GetCurveDuration() {
      let maxDuration = 0;

      for (let i = 0; i < this.stretch.length; ++i) {
        const stretch = this.stretch[i];

        for (let j = 0; j < stretch.curveSets.length; ++j) {
          maxDuration = Math.max(maxDuration, stretch.curveSets[j].GetMaxCurveDuration());
        }
      }

      return maxDuration;
    }
    /**
     * Gets a count of stretch effects
     * @returns {Number}
     */

  }, {
    key: "GetPerMuzzleEffectCount",
    value: function GetPerMuzzleEffectCount() {
      return this.stretch.length;
    }
    /**
     * Sets muzzle bone id
     * @param {number} index
     * @param bone
     */

  }, {
    key: "SetMuzzleBoneID",
    value: function SetMuzzleBoneID(index, bone) {
      this._perMuzzleData[index].muzzlePositionBone = bone;
    }
    /**
     * Gets a muzzle's transform
     * @param {number} index
     * @returns {mat4}
     */

  }, {
    key: "GetMuzzleTransform",
    value: function GetMuzzleTransform(index) {
      return this._perMuzzleData[index].muzzleTransform;
    }
    /**
     * Prepares the firing effect
     * @param {number} delay
     * @param {number} [muzzleID=-1]
     */

  }, {
    key: "PrepareFiring",
    value: function PrepareFiring(delay) {
      let muzzleID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      for (let i = 0; i < this.stretch.length; ++i) {
        if (muzzleID < 0 || muzzleID === i) {
          this._perMuzzleData[i].currentStartDelay = delay + this._perMuzzleData[i].constantDelay;
          this._perMuzzleData[i].started = false;
          this._perMuzzleData[i].readyToStart = false;
          this._perMuzzleData[i].elapsedTime = 0;
        } else {
          this._perMuzzleData[i].currentStartDelay = Number.MAX_VALUE;
          this._perMuzzleData[i].started = false;
          this._perMuzzleData[i].readyToStart = false;
          this._perMuzzleData[i].elapsedTime = 0;
        }
      }

      this.isFiring = true;
    }
    /**
     * Starts a muzzle effect
     * @param {number} muzzleID
     */

  }, {
    key: "StartMuzzleEffect",
    value: function StartMuzzleEffect(muzzleID) {
      const stretch = this.stretch[muzzleID];

      for (let i = 0; i < stretch.curveSets.length; ++i) {
        const curveSet = stretch.curveSets[i];

        switch (curveSet.name) {
          case 'play_start':
          case 'play_loop':
            curveSet.PlayFrom(-this._perMuzzleData[muzzleID].currentStartDelay);
            break;

          case 'play_stop':
            curveSet.Stop();
            break;
        }
      }

      this._perMuzzleData[muzzleID].started = true;
      this._perMuzzleData[muzzleID].readyToStart = false;
    }
    /**
     * Stops the firing effect
     */

  }, {
    key: "StopFiring",
    value: function StopFiring() {
      for (let j = 0; j < this.stretch.length; ++j) {
        const stretch = this.stretch[j];

        for (let i = 0; i < stretch.curveSets.length; ++i) {
          const curveSet = stretch.curveSets[i];

          switch (curveSet.name) {
            case 'play_start':
            case 'play_loop':
              curveSet.Stop();
              break;

            case 'play_stop':
              curveSet.Play();
              break;
          }
        }

        this._perMuzzleData[j].started = false;
        this._perMuzzleData[j].readyToStart = false;
        this._perMuzzleData[j].currentStartDelay = 0;
        this._perMuzzleData[j].elapsedTime = 0;
      }

      this.isFiring = false;
    }
    /**
     * Gets resources
     * @param {Array} [out=[]}
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.stretch.length; i++) {
        this.stretch[i].GetResources(out);
      }

      return out;
    }
    /**
     * Updates view dependant data
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      for (let i = 0; i < this.stretch.length; ++i) {
        this.stretch[i].UpdateViewDependentData();
      }
    }
    /**
     * Per frame update
     * @param {number} dt - Delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      for (let i = 0; i < this.stretch.length; ++i) {
        if (this._perMuzzleData[i].started) {
          this._perMuzzleData[i].elapsedTime += dt;
        }

        if (this._perMuzzleData[i].elapsedTime < this._firingDuration || this.isLoopFiring) {
          if (this.isFiring) {
            if (!this._perMuzzleData[i].started) {
              if (this._perMuzzleData[i].readyToStart) {
                this.StartMuzzleEffect(i);
                this._perMuzzleData[i].currentStartDelay = 0;
                this._perMuzzleData[i].elapsedTime = 0;
              } else {
                this._perMuzzleData[i].currentStartDelay -= dt;
              }

              if (this._perMuzzleData[i].currentStartDelay <= 0) {
                this._perMuzzleData[i].readyToStart = true;
              }
            } else {
              if (this.useMuzzleTransform) {
                this.stretch[i].SetSourceTransform(this._perMuzzleData[i].muzzleTransform);
              } else {
                this.stretch[i].SetSourcePosition(this._perMuzzleData[i].muzzlePosition);
              }

              this.stretch[i].SetDestinationPosition(this.endPosition);
              this.stretch[i].SetIsNegZForward(true);
            }
          }
        }

        this.stretch[i].Update(dt);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.display || !this.isFiring) return;

      for (let i = 0; i < this.stretch.length; ++i) {
        if (this._perMuzzleData[i].started && (this._firingDuration >= this._perMuzzleData[i].elapsedTime || this.isLoopFiring)) {
          this.stretch[i].GetBatches(mode, accumulator, perObjectData);
        }
      }
    }
  }]);

  return EveTurretFiringFX;
}();
// CONCATENATED MODULE: ./eve/effect/EveStarfield.js
function EveStarfield_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveStarfield_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * EveStarField - not implemented yet
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {boolean} display
 * @property {Tw2Effect} effect
 * @property {number} maxDist
 * @property {number} maxFlashRate
 * @property {number} minFlashIntensity
 * @property {number} minFlashRate
 * @property {number} seed
 */

let EveStarfield_EveStarfield = function EveStarfield() {
  EveStarfield_classCallCheck(this, EveStarfield);

  EveStarfield_defineProperty(this, "_id", global["F" /* util */].generateID());

  EveStarfield_defineProperty(this, "name", '');

  EveStarfield_defineProperty(this, "display", true);

  EveStarfield_defineProperty(this, "effect", null);

  EveStarfield_defineProperty(this, "maxDist", 0);

  EveStarfield_defineProperty(this, "maxFlashRate", 0);

  EveStarfield_defineProperty(this, "minFlashIntensity", 0);

  EveStarfield_defineProperty(this, "minFlashRate", 0);

  EveStarfield_defineProperty(this, "seed", 20);
};

EveStarfield_defineProperty(EveStarfield_EveStarfield, "partialImplementation", true);
// CONCATENATED MODULE: ./eve/effect/index.js






// CONCATENATED MODULE: ./eve/object/EveObject.js
function EveObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveObject_defineProperties(Constructor, staticProps); return Constructor; }

function EveObject_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * EveObject base class
 *
 * @property {number} _id
 * @property {string} name
 * @property {boolean} display
 * @class
 */

let EveObject_EveObject =
/*#__PURE__*/
function () {
  function EveObject() {
    EveObject_classCallCheck(this, EveObject);

    EveObject_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveObject_defineProperty(this, "name", '');

    EveObject_defineProperty(this, "display", true);
  }

  EveObject_createClass(EveObject, [{
    key: "Initialize",

    /**
     * Initializes the object
     */
    value: function Initialize() {}
    /**
     * Gets object resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {}
    /**
     * Accumulates batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {}
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return EveObject;
}();

EveObject_defineProperty(EveObject_EveObject, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  vec3_1: global["H" /* vec3 */].create(),
  vec3_2: global["H" /* vec3 */].create(),
  vec3_3: global["H" /* vec3 */].create(),
  vec3_4: global["H" /* vec3 */].create(),
  vec3_5: global["H" /* vec3 */].create(),
  vec3_6: global["H" /* vec3 */].create(),
  vec3_7: global["H" /* vec3 */].create(),
  mat4_0: global["z" /* mat4 */].create(),
  mat4_1: global["z" /* mat4 */].create(),
  mat4_2: global["z" /* mat4 */].create()
});
// CONCATENATED MODULE: ./eve/object/EveSpaceObject.js
function EveSpaceObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveSpaceObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveSpaceObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveSpaceObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveSpaceObject_defineProperties(Constructor, staticProps); return Constructor; }

function EveSpaceObject_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveSpaceObject_assertThisInitialized(self); }

function EveSpaceObject_getPrototypeOf(o) { EveSpaceObject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveSpaceObject_getPrototypeOf(o); }

function EveSpaceObject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveSpaceObject_setPrototypeOf(subClass, superClass); }

function EveSpaceObject_setPrototypeOf(o, p) { EveSpaceObject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveSpaceObject_setPrototypeOf(o, p); }

function EveSpaceObject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveSpaceObject_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveSpaceObject
 *
 * @property {String} name
 * @property {boolean} display                             - Enables/ disables visibility
 * @property {{}} visible                                  - Visibility options for the space object's elements
 * @property {boolean} visible.mesh                        - Enables/ disables mesh visibility
 * @property {boolean} visible.children                    - Enables/ disables child visibility
 * @property {boolean} visible.effectChildren              - Enables/ disables effect child visibility
 * @property {boolean} visible.spriteSets                  - Enables/ disables sprite visibility
 * @property {boolean} visible.decals                      - Enables/ disables decal visibility
 * @property {boolean} visible.spotlightSets               - Enables/ disables spotlight visibility
 * @property {boolean} visible.planeSets                   - Enables/ disables plane visibility
 * @property {boolean} visible.lineSets                    - Enables/ disables lines visibility
 * @property {boolean} visible.overlayEffects              - Enables/ disables overlay effect visibility
 * @property {boolean} visible.killmarks                   - Enables/ disables killmark visibility
 * @property {boolean} visible.customMasks                 - Enables/ disables custom mask visibility
 * @property {boolean} visible.turretSets      - Enables/ disables turret set batch accumulation
 * @property {boolean} visible.boosters        - Enables/ disables booster batch accumulation
 * @property {Number} lod
 * @property {Tw2Mesh} mesh
 * @property {Array.<EveLocator>} locators
 * @property {Array.<EveSpriteSet>} spriteSets
 * @property {Array.<EveTurretSet>} turretSets
 * @property {Array.<EveSpaceObjectDecal>} decals
 * @property {Array.<EveSpotlightSet>} spotlightSets
 * @property {Array.<EvePlaneSet>} planeSets
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {Array.<EveCurveLineSet>} lineSets
 * @property {Array.<EveMeshOverlayEffect>} overlayEffects
 * @property {Array.<{}>} children
 * @property {vec3} boundingSphereCenter
 * @property {Number} boundingSphereRadius
 * @property {vec3} shapeEllipsoidRadius
 * @property {vec3} shapeEllipsoidCenter
 * @property {mat4} transform
 * @property {Tw2AnimationController} animation
 * @property {number} killCount                            - number of kills to show on kill counter decals
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */

let EveSpaceObject_EveSpaceObject =
/*#__PURE__*/
function (_EveObject) {
  EveSpaceObject_inherits(EveSpaceObject, _EveObject);

  function EveSpaceObject() {
    var _this;

    EveSpaceObject_classCallCheck(this, EveSpaceObject);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveSpaceObject_possibleConstructorReturn(this, EveSpaceObject_getPrototypeOf(EveSpaceObject).call(this, ...args));

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "visible", {
      mesh: true,
      children: true,
      effectChildren: true,
      planeSets: true,
      spotlightSets: true,
      decals: true,
      spriteSets: true,
      overlayEffects: true,
      lineSets: true,
      killmarks: true,
      customMasks: true,
      turretSets: true,
      boosters: true
    });

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "mesh", null);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "animation", new core["Tw2AnimationController"]());

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "locators", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "spriteSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "turretSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "decals", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "spotlightSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "planeSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "curveSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "lineSets", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "overlayEffects", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "children", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "effectChildren", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "customMasks", []);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "lod", 3);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "killCount", 0);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "transform", global["z" /* mat4 */].create());

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "boundingSphereCenter", global["H" /* vec3 */].create());

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "boundingSphereRadius", 0);

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "shapeEllipsoidRadius", global["H" /* vec3 */].create());

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "shapeEllipsoidCenter", global["H" /* vec3 */].create());

    EveSpaceObject_defineProperty(EveSpaceObject_assertThisInitialized(EveSpaceObject_assertThisInitialized(_this)), "_perObjectData", new core["Tw2PerObjectData"](EveSpaceObject.perObjectData));

    return _this;
  }

  EveSpaceObject_createClass(EveSpaceObject, [{
    key: "Initialize",

    /**
     * Initializes the EveSpaceObject
     */
    value: function Initialize() {
      if (this.mesh) {
        this.animation.SetGeometryResource(this.mesh.geometryResource);

        for (let i = 0; i < this.decals.length; ++i) {
          this.decals[i].SetParentGeometry(this.mesh.geometryResource);
        }
      }
    }
    /**
     * Resets the lod
     */

  }, {
    key: "ResetLod",
    value: function ResetLod() {
      this.lod = 3;
    }
    /**
     * Updates the lod
     * @param {Tw2Frustum} frustum
     */

  }, {
    key: "UpdateLod",
    value: function UpdateLod(frustum) {
      const center = global["H" /* vec3 */].transformMat4(EveSpaceObject.global.vec3_0, this.boundingSphereCenter, this.transform);

      if (frustum.IsSphereVisible(center, this.boundingSphereRadius)) {
        if (frustum.GetPixelSizeAcross(center, this.boundingSphereRadius) < 100) {
          this.lod = 1;
        } else {
          this.lod = 2;
        }
      } else {
        this.lod = 0;
      }
    }
    /**
     * Adds a custom mask
     * @param {vec3} position
     * @param {vec3} scaling
     * @param {quat} rotation
     * @param {vec4} isMirrored
     * @param {vec4} sourceMaterial
     * @param {vec4} targetMaterials
     */

  }, {
    key: "AddCustomMask",
    value: function AddCustomMask(position, scaling, rotation, isMirrored, sourceMaterial, targetMaterials) {
      const transform = global["z" /* mat4 */].fromRotationTranslationScale(global["z" /* mat4 */].create(), rotation, position, scaling);
      global["z" /* mat4 */].invert(transform, transform);
      global["z" /* mat4 */].transpose(transform, transform);
      this.customMasks.push({
        transform: transform,
        maskData: global["I" /* vec4 */].fromValues(1, isMirrored ? 1 : 0, 0, 0),
        materialID: global["I" /* vec4 */].fromValues(sourceMaterial, 0, 0, 0),
        targets: targetMaterials
      });
    }
    /**
     * Gets locator count for a specific locator group
     * @param {String} prefix
     * @returns {number}
     */

  }, {
    key: "GetLocatorCount",
    value: function GetLocatorCount(prefix) {
      const locators = this.FindLocatorsByPrefix(prefix);
      return locators.length;
    }
    /**
     * Finds a locator's joint by name
     * @param {string} name
     * @returns {?mat4}
     */

  }, {
    key: "FindLocatorJointByName",
    value: function FindLocatorJointByName(name) {
      const locator = this.FindLocatorBoneByName(name);
      return locator ? locator.worldTransform : null;
    }
    /**
     *
     * @param name
     * @returns {null}
     */

  }, {
    key: "FindLocatorTransformByName",
    value: function FindLocatorTransformByName(name) {
      const locator = this.FindLocatorByName(name);
      return locator ? locator.transform : null;
    }
    /**
     * Checks if a locator prefix exists
     * @param {string} prefix
     * @returns {boolean}
     */

  }, {
    key: "HasLocatorPrefix",
    value: function HasLocatorPrefix(prefix) {
      for (let i = 0; i < this.locators.length; i++) {
        if (this.locators[i].name.substring(0, prefix.length) === prefix) {
          return true;
        }
      }

      return false;
    }
    /**
     * Finds a locator's bone by it's name
     * @param {String} name
     * @returns {?Tw2Bone} null if not found
     */

  }, {
    key: "FindLocatorBoneByName",
    value: function FindLocatorBoneByName(name) {
      const model = this.animation.FindModelForMesh(0);

      if (model) {
        for (let i = 0; i < model.bones.length; ++i) {
          if (model.bones[i].boneRes.name === name) {
            return model.bones[i];
          }
        }
      }

      return null;
    }
    /**
     * Finds a locator by name
     * @param {string} name
     * @returns {?EveLocator}
     */

  }, {
    key: "FindLocatorByName",
    value: function FindLocatorByName(name) {
      for (let i = 0; i < this.locators.length; i++) {
        if (this.locators[i].name === name) {
          return this.locators[i];
        }
      }

      return null;
    }
    /**
     * Finds locators with a given prefix
     * @param {string} prefix
     * @returns {Array<EveLocator>}
     */

  }, {
    key: "FindLocatorsByPrefix",
    value: function FindLocatorsByPrefix(prefix) {
      const locators = [];

      for (let i = 0; i < this.locators.length; i++) {
        if (this.locators[i].name.indexOf(prefix) === 0) {
          locators.push(this.locators[i]);
        }
      }

      return locators;
    }
    /**
     * Gets object's res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @param {Boolean} excludeChildren - True to exclude children's res objects
     * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let excludeChildren = arguments.length > 1 ? arguments[1] : undefined;
      if (this.mesh) this.mesh.GetResources(out);
      if (this.animation) this.animation.GetResources(out);
      global["F" /* util */].perArrayChild(this.spriteSets, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.turretSets, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.decals, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.spotlightSets, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.planeSets, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.lineSets, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.overlayEffects, 'GetResources', out);
      global["F" /* util */].perArrayChild(this.effectChildren, 'GetResources', out);

      if (!excludeChildren) {
        global["F" /* util */].perArrayChild(this.children, 'GetResources', out);
      }

      return out;
    }
    /**
     * A Per frame function that updates view dependent data
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      for (let i = 0; i < this.children.length; ++i) {
        this.children[i].UpdateViewDependentData(this.transform);
      }

      global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
      global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);

      const center = this._perObjectData.perObjectVSData.Get('EllipsoidCenter'),
            radii = this._perObjectData.perObjectVSData.Get('EllipsoidRadii');

      if (this.shapeEllipsoidRadius[0] > 0) {
        center[0] = this.shapeEllipsoidCenter[0];
        center[1] = this.shapeEllipsoidCenter[1];
        center[2] = this.shapeEllipsoidCenter[2];
        radii[0] = this.shapeEllipsoidRadius[0];
        radii[1] = this.shapeEllipsoidRadius[1];
        radii[2] = this.shapeEllipsoidRadius[2];
      } else if (this.mesh && this.mesh.IsGood()) {
        global["H" /* vec3 */].subtract(center, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
        global["H" /* vec3 */].scale(center, center, 0.5 * 1.732050807);
        global["H" /* vec3 */].add(radii, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
        global["H" /* vec3 */].scale(radii, radii, 0.5);
      }

      for (let i = 0; i < this.customMasks.length; ++i) {
        const targets = this.visible.customMasks ? this.customMasks[i].targets : [0, 0, 0, 0];

        this._perObjectData.perObjectVSData.Set(i ? 'CustomMaskMatrix1' : 'CustomMaskMatrix0', this.customMasks[i].transform);

        this._perObjectData.perObjectVSData.Set(i ? 'CustomMaskData1' : 'CustomMaskData0', this.customMasks[i].maskData);

        this._perObjectData.perObjectPSData.Set(i ? 'CustomMaskMaterialID1' : 'CustomMaskMaterialID0', this.customMasks[i].materialID);

        this._perObjectData.perObjectPSData.Set(i ? 'CustomMaskTarget1' : 'CustomMaskTarget0', targets);
      }

      if (this.animation.animations.length) {
        this._perObjectData.perObjectVSData.Set('JointMat', this.animation.GetBoneMatrices(0));
      }

      for (let i = 0; i < this.lineSets.length; ++i) {
        this.lineSets[i].UpdateViewDependentData(this.transform);
      }
    }
    /**
     * Per frame update
     * @param {Number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (this.lod > 0) {
        for (let i = 0; i < this.spriteSets.length; ++i) {
          this.spriteSets[i].Update(dt);
        }

        for (let i = 0; i < this.planeSets.length; i++) {
          this.planeSets[i].Update(dt);
        }

        for (let i = 0; i < this.spotlightSets.length; i++) {
          this.spotlightSets[i].Update(dt);
        }

        for (let i = 0; i < this.children.length; ++i) {
          this.children[i].Update(dt);
        }

        for (let i = 0; i < this.effectChildren.length; ++i) {
          this.effectChildren[i].Update(dt, this.transform);
        }

        for (let i = 0; i < this.curveSets.length; ++i) {
          this.curveSets[i].Update(dt);
        }

        for (let i = 0; i < this.overlayEffects.length; ++i) {
          this.overlayEffects[i].Update(dt);
        }

        for (let i = 0; i < this.lineSets.length; i++) {
          this.lineSets[i].Update(dt);
        }

        this.animation.Update(dt);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display) {
        const show = this.visible;

        if (show.mesh && this.mesh && this.lod > 0) {
          this.mesh.GetBatches(mode, accumulator, this._perObjectData);
        }

        if (this.lod > 1) {
          if (show.spriteSets) {
            for (let i = 0; i < this.spriteSets.length; i++) {
              this.spriteSets[i].GetBatches(mode, accumulator, this._perObjectData, this.transform);
            }
          }

          if (show.spotlightSets) {
            for (let i = 0; i < this.spotlightSets.length; i++) {
              this.spotlightSets[i].GetBatches(mode, accumulator, this._perObjectData);
            }
          }

          if (show.planeSets) {
            for (let i = 0; i < this.planeSets.length; i++) {
              this.planeSets[i].GetBatches(mode, accumulator, this._perObjectData);
            }
          }

          if (show.decals) {
            for (let i = 0; i < this.decals.length; i++) {
              this.decals[i].GetBatches(mode, accumulator, this._perObjectData, show.killmarks ? this.killCount : 0);
            }
          }

          if (show.lineSets) {
            for (let i = 0; i < this.lineSets.length; i++) {
              this.lineSets[i].GetBatches(mode, accumulator);
            }
          }
        }

        if (show.children) {
          for (let i = 0; i < this.children.length; i++) {
            this.children[i].GetBatches(mode, accumulator, this._perObjectData);
          }
        }

        if (show.effectChildren) {
          for (let i = 0; i < this.effectChildren.length; i++) {
            this.effectChildren[i].GetBatches(mode, accumulator, this._perObjectData);
          }
        }

        if (show.overlayEffects && this.mesh && this.mesh.IsGood()) {
          for (let i = 0; i < this.overlayEffects.length; i++) {
            this.overlayEffects[i].GetBatches(mode, accumulator, this._perObjectData, this.mesh);
          }
        }
      }
    }
    /**
     * RenderDebugInfo
     * @param debugHelper
     */

  }, {
    key: "RenderDebugInfo",
    value: function RenderDebugInfo(debugHelper) {
      this.animation.RenderDebugInfo(debugHelper);
    }
    /**
     * Per object data
     * @type {{VSData: *[], PSData: *[]}}
     */

  }]);

  return EveSpaceObject;
}(EveObject_EveObject);

EveSpaceObject_defineProperty(EveSpaceObject_EveSpaceObject, "perObjectData", {
  VSData: [['WorldMat', 16], ['WorldMatLast', 16], ['Shipdata', 4, [0, 1, 0, -10]], ['Clipdata1', 4], ['EllipsoidRadii', 4], ['EllipsoidCenter', 4], ['CustomMaskMatrix0', 16, global["z" /* mat4 */].identity([])], ['CustomMaskMatrix1', 16, global["z" /* mat4 */].identity([])], ['CustomMaskData0', 4], ['CustomMaskData1', 4], ['JointMat', 696]],
  PSData: [['Shipdata', 4, [0, 1, 0, 1]], ['Clipdata1', 4], ['Clipdata2', 4], ['ShLighting', 4 * 7], ['CustomMaskMaterialID0', 4], ['CustomMaskMaterialID1', 4], ['CustomMaskTarget0', 4], ['CustomMaskTarget1', 4]]
});


// CONCATENATED MODULE: ./eve/object/EveEffectRoot.js
function EveEffectRoot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveEffectRoot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveEffectRoot_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveEffectRoot_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveEffectRoot_defineProperties(Constructor, staticProps); return Constructor; }

function EveEffectRoot_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveEffectRoot_assertThisInitialized(self); }

function EveEffectRoot_getPrototypeOf(o) { EveEffectRoot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveEffectRoot_getPrototypeOf(o); }

function EveEffectRoot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveEffectRoot_setPrototypeOf(subClass, superClass); }

function EveEffectRoot_setPrototypeOf(o, p) { EveEffectRoot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveEffectRoot_setPrototypeOf(o, p); }

function EveEffectRoot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveEffectRoot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * EveEffectRoot root objects for FX, can be put into scene's objects array
 *
 * @property {string} name
 * @property {boolean} display
 * @property {[{}]} curveSets
 * @property {[{}]} effectChildren
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {mat4} localTransform
 * @property {mat4} rotationTransform
 * @property {vec3} boundingSphereCenter
 * @property {number} boundingSphereRadius
 * @property {number} duration
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */

let EveEffectRoot_EveEffectRoot =
/*#__PURE__*/
function (_EveObject) {
  EveEffectRoot_inherits(EveEffectRoot, _EveObject);

  function EveEffectRoot() {
    var _this;

    EveEffectRoot_classCallCheck(this, EveEffectRoot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveEffectRoot_possibleConstructorReturn(this, EveEffectRoot_getPrototypeOf(EveEffectRoot).call(this, ...args));

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "curveSets", []);

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "effectChildren", []);

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "duration", 0);

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "rotation", global["C" /* quat */].create());

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "translation", global["H" /* vec3 */].create());

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "localTransform", global["z" /* mat4 */].create());

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "rotationTransform", global["z" /* mat4 */].create());

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "boundingSphereCenter", global["H" /* vec3 */].create());

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "boundingSphereRadius", 0);

    EveEffectRoot_defineProperty(EveEffectRoot_assertThisInitialized(EveEffectRoot_assertThisInitialized(_this)), "_perObjectData", new core["Tw2PerObjectData"](EveSpaceObject_EveSpaceObject.perObjectData));

    return _this;
  }

  EveEffectRoot_createClass(EveEffectRoot, [{
    key: "Start",

    /**
     * Starts playing the effectRoot's curveSets if they exist
     */
    value: function Start() {
      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Play();
      }
    }
    /**
     * Stops the effectRoot's curveSets from playing
     */

  }, {
    key: "Stop",
    value: function Stop() {
      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Stop();
      }
    }
    /**
     * Gets effect root res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2EffectRes|Tw2TextureRes>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.effectChildren.length; ++i) {
        this.effectChildren[i].GetResources(out);
      }

      return out;
    }
    /**
     * Internal per frame update
     * @param {number} dt - Delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      global["C" /* quat */].normalize(this.rotation, this.rotation); // Don't really need to normalize...

      global["z" /* mat4 */].fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);

      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Update(dt);
      }

      for (let i = 0; i < this.effectChildren.length; ++i) {
        this.effectChildren[i].Update(dt, this.localTransform);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (!this.display) return;

      for (let i = 0; i < this.effectChildren.length; ++i) {
        this.effectChildren[i].GetBatches(mode, accumulator, this._perObjectData);
      }
    }
  }]);

  return EveEffectRoot;
}(EveObject_EveObject);
// CONCATENATED MODULE: ./eve/object/EveMissile.js
function EveMissile_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveMissile_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveMissile_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveMissile_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveMissile_defineProperties(Constructor, staticProps); return Constructor; }

function EveMissile_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveMissile_assertThisInitialized(self); }

function EveMissile_getPrototypeOf(o) { EveMissile_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveMissile_getPrototypeOf(o); }

function EveMissile_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveMissile_setPrototypeOf(subClass, superClass); }

function EveMissile_setPrototypeOf(o, p) { EveMissile_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveMissile_setPrototypeOf(o, p); }

function EveMissile_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveMissile_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveMissileWarhead
 *
 * @property {String} name
 * @property {Boolean} display
 * @property {Tw2Mesh} mesh
 * @property {EveSpriteSet} spriteSet
 * @property {Number} state
 * @property {Number} time
 * @property {Number} durationEjectPhase
 * @property {Number} startEjectVelocity
 * @property {Number} acceleration
 * @property {Number} maxExplosionDistance
 * @property {Number} impactSize
 * @property {Number} impactDuration
 * @property {vec3} pathOffset
 * @property {mat4} transform
 * @property {vec3} velocity
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */

let EveMissile_EveMissileWarhead =
/*#__PURE__*/
function (_EveObject) {
  EveMissile_inherits(EveMissileWarhead, _EveObject);

  function EveMissileWarhead() {
    var _this;

    EveMissile_classCallCheck(this, EveMissileWarhead);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveMissile_possibleConstructorReturn(this, EveMissile_getPrototypeOf(EveMissileWarhead).call(this, ...args));

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "mesh", null);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "spriteSet", null);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "state", EveMissileWarhead.State.READY);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "time", 0);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "durationEjectPhase", 0);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "startEjectVelocity", 0);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "acceleration", 1);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "maxExplosionDistance", 40);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "impactSize", 0);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "impactDuration", 0.6);

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "pathOffset", global["H" /* vec3 */].create());

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "transform", global["z" /* mat4 */].create());

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "velocity", global["H" /* vec3 */].create());

    EveMissile_defineProperty(EveMissile_assertThisInitialized(EveMissile_assertThisInitialized(_this)), "_perObjectData", new core["Tw2PerObjectData"](EveMissileWarhead.perObjectData));

    return _this;
  }

  EveMissile_createClass(EveMissileWarhead, [{
    key: "Initialize",

    /**
     * Initializes the warhead
     */
    value: function Initialize() {
      if (this.spriteSet) this.spriteSet.UseQuads(true);
    }
    /**
     * Sets up the warhead for rendering
     * @param {mat4} transform - Initial local to world transform
     */

  }, {
    key: "Launch",
    value: function Launch(transform) {
      global["z" /* mat4 */].copy(this.transform, transform);
      this.velocity[0] = transform[8] * this.startEjectVelocity;
      this.velocity[1] = transform[9] * this.startEjectVelocity;
      this.velocity[2] = transform[10] * this.startEjectVelocity;
      this.time = 0;
      this.state = EveMissileWarhead.State.IN_FLIGHT;
    }
    /**
     * Creates a clone of the warhead
     * @returns {EveMissileWarhead}
     */

  }, {
    key: "Clone",
    value: function Clone() {
      const warhead = new EveMissileWarhead();
      warhead.mesh = this.mesh;
      warhead.spriteSet = this.spriteSet;
      return warhead;
    }
    /**
     * Gets warhead resources
     * @param {Array} [out=[]] - Receiving array
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (this.mesh) this.mesh.GetResources(out);
      if (this.spriteSet) this.spriteSet.GetResources(out);
    }
    /**
     * Per frame view dependent data update
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      if (!this.display || this.state === EveMissileWarhead.State.DEAD) return;
      global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
      global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);
    }
    /**
     * Per frame update
     * @param {Number} dt - Time since previous frame
     * @param {vec3} missilePosition - Missile position
     * @param {vec3} missileTarget - Missile target position
     */

  }, {
    key: "Update",
    value: function Update(dt, missilePosition, missileTarget) {
      if (this.state === EveMissileWarhead.State.IN_FLIGHT) {
        const g = EveMissileWarhead.global,
              position = global["z" /* mat4 */].getTranslation(g.vec3_0, this.transform),
              tmp = g.vec3_1,
              x = g.vec3_2,
              y = g.vec3_3;
        this.time += dt;

        if (this.time > this.durationEjectPhase) {
          global["H" /* vec3 */].subtract(position, this.velocity, missilePosition);
          global["H" /* vec3 */].lerp(position, position, missilePosition, 1 - Math.exp(-dt * 0.9999));
          global["z" /* mat4 */].setTranslation(this.transform, position);
          global["H" /* vec3 */].subtract(tmp, missileTarget, position);

          if (global["H" /* vec3 */].length(tmp) < this.maxExplosionDistance) {
            console.log(position, tmp);
            this.state = EveMissileWarhead.State.DEAD;
          }
        } else {
          global["H" /* vec3 */].scale(tmp, this.velocity, dt);
          this.transform[12] += tmp[0];
          this.transform[13] += tmp[1];
          this.transform[14] += tmp[2];
        }

        const z = global["H" /* vec3 */].normalize(tmp, this.velocity);

        if (Math.abs(z[0]) < 0.99) {
          global["H" /* vec3 */].cross(x, z, [1, 0, 0]);
        } else {
          global["H" /* vec3 */].cross(x, z, [0, 1, 0]);
        }

        global["H" /* vec3 */].normalize(x, x);
        global["H" /* vec3 */].cross(y, x, z);
        this.transform[0] = x[0];
        this.transform[1] = x[1];
        this.transform[2] = x[2];
        this.transform[4] = y[0];
        this.transform[5] = y[1];
        this.transform[6] = y[2];
        this.transform[8] = z[0];
        this.transform[9] = z[1];
        this.transform[10] = z[2];
      }

      if (this.spriteSet) {
        this.spriteSet.Update(dt);
      }
    }
    /**
     * Accumulates render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display && this.mesh && this.state !== EveMissileWarhead.State.DEAD) {
        if (this.mesh) {
          this.mesh.GetBatches(mode, accumulator, this._perObjectData);
        }

        if (this.spriteSet) {
          this.spriteSet.GetBatches(mode, accumulator, this._perObjectData, this.transform);
        }
      }
    }
    /**
     * Per object data
     * @type {*}
     */

  }]);

  return EveMissileWarhead;
}(EveObject_EveObject);
/**
 * EveMissile
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {Boolean} display
 * @property {Array} warheads
 * @property {Array} curveSets
 * @property {vec3} boundingSphereCenter
 * @property {Number} boundingSphereRadius
 * @property {vec3} position
 * @property {vec3} target
 * @property {Number} speed
 * @property {?function(EveMissileWarhead): void} warheadExplosionCallback
 * @property {?function(EveMissile): void} missileFinishedCallback
 * @class
 */

EveMissile_defineProperty(EveMissile_EveMissileWarhead, "perObjectData", {
  VSData: [['WorldMat', 16], ['WorldMatLast', 16], ['Shipdata', 4, [0, 1, 0, -10]], ['Clipdata1', 4], ['JointMat', 696]],
  PSData: [['Shipdata', 4, [0, 1, 0, 1]], ['Clipdata1', 4], ['Clipdata2', 4]]
});

EveMissile_defineProperty(EveMissile_EveMissileWarhead, "State", {
  READY: 0,
  IN_FLIGHT: 1,
  DEAD: 2
});

let EveMissile_EveMissile =
/*#__PURE__*/
function () {
  function EveMissile() {
    EveMissile_classCallCheck(this, EveMissile);

    EveMissile_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveMissile_defineProperty(this, "name", '');

    EveMissile_defineProperty(this, "display", true);

    EveMissile_defineProperty(this, "warheads", []);

    EveMissile_defineProperty(this, "curveSets", []);

    EveMissile_defineProperty(this, "speed", 1);

    EveMissile_defineProperty(this, "position", global["H" /* vec3 */].create());

    EveMissile_defineProperty(this, "target", global["H" /* vec3 */].create());

    EveMissile_defineProperty(this, "boundingSphereCenter", global["H" /* vec3 */].create());

    EveMissile_defineProperty(this, "boundingSphereRadius", 0);

    EveMissile_defineProperty(this, "warheadExplosionCallback", null);

    EveMissile_defineProperty(this, "missileFinishedCallback", null);
  }

  EveMissile_createClass(EveMissile, [{
    key: "Launch",

    /**
     * Prepares missile for rendering
     * @param {vec3} position - Missile starting position
     * @param {Array} turretTransforms - Turret muzzle local to world transforms
     * @param {vec3} target - Target position
     */
    value: function Launch(position, turretTransforms, target) {
      global["H" /* vec3 */].copy(this.position, position);
      global["H" /* vec3 */].copy(this.target, target);

      if (this.warheads.length > turretTransforms.length) {
        this.warheads.splice(turretTransforms.length);
      } else {
        while (this.warheads.length < turretTransforms.length) {
          this.warheads.push(this.warheads[0].Clone());
        }
      }

      for (let i = 0; i < this.warheads.length; ++i) {
        this.warheads[0].Launch(turretTransforms[i]);
      }
    }
    /**
     * Gets missile res objects
     * @param {Array} [out=[]] - Receiving array
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      for (let i = 0; i < this.warheads.length; ++i) {
        this.warheads[i].GetResources(out);
      }
    }
    /**
     * Per frame view dependent data update
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      for (let i = 0; i < this.warheads.length; ++i) {
        this.warheads[i].UpdateViewDependentData();
      }
    }
    /**
     * Per frame update
     * @param {Number} dt - Time since previous frame
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      const tmp = global["H" /* vec3 */].subtract(EveMissile_EveMissileWarhead.global.vec3_0, this.target, this.position),
            distance = global["H" /* vec3 */].length(tmp);

      if (distance > 0.1) {
        global["H" /* vec3 */].normalize(tmp, tmp);
        global["H" /* vec3 */].scale(tmp, tmp, Math.min(dt * this.speed, distance));
        global["H" /* vec3 */].add(this.position, this.position, tmp);
      }

      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Update(dt);
      }

      let checkDead = false;

      for (let i = 0; i < this.warheads.length; ++i) {
        const state = this.warheads[i].state;
        this.warheads[i].Update(dt, this.position, this.target);

        if (state !== EveMissile_EveMissileWarhead.State.DEAD && this.warheads[i].state === EveMissile_EveMissileWarhead.State.DEAD) {
          if (this.warheadExplosionCallback) {
            this.warheadExplosionCallback(this.warheads[i]);
          }

          checkDead = true;
        }
      }

      if (checkDead && this.missileFinishedCallback) {
        for (let i = 0; i < this.warheads.length; ++i) {
          if (this.warheads[i].state !== EveMissile_EveMissileWarhead.State.DEAD) {
            return;
          }
        }

        this.missileFinishedCallback(this);
      }
    }
    /**
     * Accumulates render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (!this.display) return;

      for (let i = 0; i < this.warheads.length; ++i) {
        this.warheads[i].GetBatches(mode, accumulator);
      }
    }
  }]);

  return EveMissile;
}();
// CONCATENATED MODULE: ./eve/object/EveTransform.js
function EveTransform_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveTransform_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveTransform_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveTransform_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveTransform_defineProperties(Constructor, staticProps); return Constructor; }

function EveTransform_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveTransform_assertThisInitialized(self); }

function EveTransform_getPrototypeOf(o) { EveTransform_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveTransform_getPrototypeOf(o); }

function EveTransform_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveTransform_setPrototypeOf(subClass, superClass); }

function EveTransform_setPrototypeOf(o, p) { EveTransform_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveTransform_setPrototypeOf(o, p); }

function EveTransform_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveTransform_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveTransform
 *
 * @property {{}} visible                                           - Batch accumulation options for the transforms's elements
 * @property {Boolean} visible.mesh                                 - Enables/ disables mesh batch accumulation
 * @property {Boolean} visible.children                             - Enables/ disables child batch accumulation
 * @property {Tw2Mesh} mesh
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {Array} children
 * @property {Array.<Tw2ParticleSystem>} particleSystems
 * @property {Array.<Tw2StaticEmitter|Tw2DynamicEmitter>} particleEmitters
 * @property {Number} Modifier
 * @property {Number} sortValueMultiplier
 * @property {Number} distanceBasedScaleArg1
 * @property {Number} distanceBasedScaleArg2
 * @property {Boolean} useDistanceBasedScale
 * @property {vec3} scaling
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {Array.<mat4>} _mat4Cache
 * @property {Array.<vec3>} _vec3Cache
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */

let EveTransform_EveTransform =
/*#__PURE__*/
function (_EveObject) {
  EveTransform_inherits(EveTransform, _EveObject);

  function EveTransform() {
    var _this;

    EveTransform_classCallCheck(this, EveTransform);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveTransform_possibleConstructorReturn(this, EveTransform_getPrototypeOf(EveTransform).call(this, ...args));

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "visible", {
      mesh: true,
      children: true
    });

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "mesh", null);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "curveSets", []);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "children", []);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "particleSystems", []);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "particleEmitters", []);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "modifier", EveTransform.Modifier.NONE);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "sortValueMultiplier", 1.0);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "distanceBasedScaleArg1", 0.2);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "distanceBasedScaleArg2", 0.63);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "useDistanceBasedScale", false);

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "translation", global["H" /* vec3 */].create());

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "rotation", global["C" /* quat */].create());

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "localTransform", global["z" /* mat4 */].create());

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "worldTransform", global["z" /* mat4 */].create());

    EveTransform_defineProperty(EveTransform_assertThisInitialized(EveTransform_assertThisInitialized(_this)), "_perObjectData", new core["Tw2BasicPerObjectData"](EveTransform.perObjectData));

    return _this;
  }

  EveTransform_createClass(EveTransform, [{
    key: "Initialize",

    /**
     * Initializes the EveTransform
     */
    value: function Initialize() {
      global["z" /* mat4 */].fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
    }
    /**
     * Gets transform res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @param {Boolean} [excludeChildren] - True to exclude children's res objects
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let excludeChildren = arguments.length > 1 ? arguments[1] : undefined;
      if (this.mesh) this.mesh.GetResources(out);

      if (!excludeChildren) {
        for (let i = 0; i < this.children; i++) {
          this.children[i].GetResources(out);
        }
      }

      return out;
    }
    /**
     * Per frame update
     * @param {mat4} parentTransform
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData(parentTransform) {
      const d = global["w" /* device */],
            g = EveTransform.global,
            finalScale = g.vec3_0,
            parentScale = g.vec3_1,
            dir = g.vec3_2,
            viewInv = d.viewInverse;
      global["C" /* quat */].normalize(this.rotation, this.rotation);
      global["z" /* mat4 */].fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
      global["z" /* mat4 */].getScaling(parentScale, parentTransform);

      switch (this.modifier) {
        case EveTransform.Modifier.BILLBOARD:
        case EveTransform.Modifier.SIMPLE_HALO:
          const dirNorm = g.vec3_3;
          global["z" /* mat4 */].multiply(this.worldTransform, parentTransform, this.localTransform);
          global["H" /* vec3 */].multiply(finalScale, this.scaling, parentScale);

          if (this.modifier === EveTransform.Modifier.SIMPLE_HALO) {
            global["H" /* vec3 */].subtract(dir, d.GetEyePosition(dir), this.worldTransform.subarray(12));
            global["H" /* vec3 */].normalize(dirNorm, this.worldTransform.subarray(8));
            global["H" /* vec3 */].normalize(dir, dir);
            let scale = global["H" /* vec3 */].dot(dir, dirNorm);
            if (scale < 0) scale = 0;
            global["H" /* vec3 */].scale(finalScale, finalScale, scale * scale);
          }

          this.worldTransform[0] = viewInv[0] * finalScale[0];
          this.worldTransform[1] = viewInv[1] * finalScale[0];
          this.worldTransform[2] = viewInv[2] * finalScale[0];
          this.worldTransform[4] = viewInv[4] * finalScale[1];
          this.worldTransform[5] = viewInv[5] * finalScale[1];
          this.worldTransform[6] = viewInv[6] * finalScale[1];
          this.worldTransform[8] = viewInv[8] * finalScale[2];
          this.worldTransform[9] = viewInv[9] * finalScale[2];
          this.worldTransform[10] = viewInv[10] * finalScale[2];
          break;

        case EveTransform.Modifier.EVE_CAMERA_ROTATION:
          const translation = g.vec3_3;
          global["H" /* vec3 */].transformMat4(translation, this.translation, parentTransform);
          global["z" /* mat4 */].fromRotationTranslationScale(this.localTransform, this.rotation, translation, this.scaling);
          global["z" /* mat4 */].multiply(this.worldTransform, viewInv, this.localTransform);
          this.worldTransform[12] = this.localTransform[12];
          this.worldTransform[13] = this.localTransform[13];
          this.worldTransform[14] = this.localTransform[14];
          break;

        case EveTransform.Modifier.EVE_CAMERA_ROTATION_ALIGNED:
        case EveTransform.Modifier.EVE_SIMPLE_HALO:
          const camFwd = g.vec3_3,
                right = g.vec3_4,
                up = g.vec3_5,
                forward = g.vec3_6,
                dirToCamNorm = g.vec3_7,
                parentT = g.mat4_0,
                alignMat = g.mat4_1,
                rotationT = g.mat4_2; // 3 4 3 3 3 4 3 3

          global["z" /* mat4 */].translate(this.worldTransform, parentTransform, this.translation);
          global["z" /* mat4 */].transpose(parentT, parentTransform);
          d.GetEyePosition(dir);
          dir[0] -= this.worldTransform[12];
          dir[1] -= this.worldTransform[13];
          dir[2] -= this.worldTransform[14];
          global["H" /* vec3 */].copy(camFwd, dir);
          global["H" /* vec3 */].transformMat4(camFwd, camFwd, parentT);
          global["H" /* vec3 */].divide(camFwd, camFwd, parentScale);
          global["H" /* vec3 */].normalize(camFwd, camFwd);
          global["H" /* vec3 */].set(right, d.view[0], d.view[4], d.view[8]);
          global["H" /* vec3 */].transformMat4(right, right, parentT);
          global["H" /* vec3 */].normalize(right, right);
          global["H" /* vec3 */].cross(up, camFwd, right);
          global["H" /* vec3 */].normalize(up, up);
          global["H" /* vec3 */].cross(right, up, camFwd);
          alignMat[0] = right[0];
          alignMat[1] = right[1];
          alignMat[2] = right[2];
          alignMat[4] = up[0];
          alignMat[5] = up[1];
          alignMat[6] = up[2];
          alignMat[8] = camFwd[0];
          alignMat[9] = camFwd[1];
          alignMat[10] = camFwd[2];
          alignMat[15] = 1;
          global["z" /* mat4 */].fromQuat(rotationT, this.rotation);
          global["z" /* mat4 */].multiply(alignMat, alignMat, rotationT);

          if (this.modifier === EveTransform.Modifier.EVE_SIMPLE_HALO) {
            global["H" /* vec3 */].normalize(forward, this.worldTransform.subarray(8));
            global["H" /* vec3 */].normalize(dirToCamNorm, dir);
            let scale = -global["H" /* vec3 */].dot(dirToCamNorm, forward);
            if (scale < 0) scale = 0;
            global["z" /* mat4 */].multiply(this.worldTransform, this.worldTransform, alignMat);
            global["z" /* mat4 */].scale(this.worldTransform, this.worldTransform, [this.scaling[0] * scale, this.scaling[1] * scale, this.scaling[2] * scale]);
          } else {
            global["z" /* mat4 */].scale(this.worldTransform, this.worldTransform, this.scaling);
            global["z" /* mat4 */].multiply(this.worldTransform, this.worldTransform, alignMat);
          }

          break;

        case EveTransform.Modifier.LOOK_AT_CAMERA:
          const lookAt = g.mat4_0;
          global["z" /* mat4 */].multiply(this.worldTransform, parentTransform, this.localTransform);
          global["z" /* mat4 */].lookAt(lookAt, viewInv.subarray(12), this.worldTransform.subarray(12), [0, 1, 0]);
          global["z" /* mat4 */].transpose(lookAt, lookAt);
          global["H" /* vec3 */].multiply(finalScale, this.scaling, parentScale);
          this.worldTransform[0] = lookAt[0] * finalScale[0];
          this.worldTransform[1] = lookAt[1] * finalScale[0];
          this.worldTransform[2] = lookAt[2] * finalScale[0];
          this.worldTransform[4] = lookAt[4] * finalScale[1];
          this.worldTransform[5] = lookAt[5] * finalScale[1];
          this.worldTransform[6] = lookAt[6] * finalScale[1];
          this.worldTransform[8] = lookAt[8] * finalScale[2];
          this.worldTransform[9] = lookAt[9] * finalScale[2];
          this.worldTransform[10] = lookAt[10] * finalScale[2];
          break;

        default:
          global["z" /* mat4 */].multiply(this.worldTransform, parentTransform, this.localTransform);
      }

      for (let i = 0; i < this.children.length; ++i) {
        this.children[i].UpdateViewDependentData(this.worldTransform);
      }
    }
    /**
     * Per frame update
     * @param {Number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      for (let i = 0; i < this.children.length; ++i) {
        this.children[i].Update(dt);
      }

      for (let i = 0; i < this.particleEmitters.length; ++i) {
        this.particleEmitters[i].Update(dt);
      }

      for (let i = 0; i < this.particleSystems.length; ++i) {
        this.particleSystems[i].Update(dt);
      }

      for (let i = 0; i < this.curveSets.length; ++i) {
        this.curveSets[i].Update(dt);
      }
    }
    /**
     * Gets render batches for accumulation
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData|Tw2BasicPerObjectData} [perObjectData]
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.display) return;

      if (this.visible.mesh && this.mesh) {
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectFFEData.Get('World'), this.worldTransform);
        global["z" /* mat4 */].invert(this._perObjectData.perObjectFFEData.Get('WorldInverseTranspose'), this.worldTransform);

        if (perObjectData) {
          this._perObjectData.perObjectVSData = perObjectData.perObjectVSData;
          this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
        }

        this.mesh.GetBatches(mode, accumulator, this._perObjectData);
      }

      if (this.visible.children) {
        for (let i = 0; i < this.children.length; ++i) {
          this.children[i].GetBatches(mode, accumulator, perObjectData);
        }
      }
    }
    /**
     * multiply3x3
     */

  }], [{
    key: "Multiply3x3",
    value: function Multiply3x3(a, b, c) {
      c || (c = b);
      let d = b[0],
          e = b[1];
      b = b[2];
      c[0] = a[0] * d + a[4] * e + a[8] * b;
      c[1] = a[1] * d + a[5] * e + a[9] * b;
      c[2] = a[2] * d + a[6] * e + a[10] * b;
      return c;
    }
    /**
     * Per object data
     * @type {*}
     */

  }]);

  return EveTransform;
}(EveObject_EveObject);

EveTransform_defineProperty(EveTransform_EveTransform, "perObjectData", {
  FFEData: [['World', 16], ['WorldInverseTranspose', 16]]
});

EveTransform_defineProperty(EveTransform_EveTransform, "Modifier", {
  NONE: 0,
  BILLBOARD: 1,
  TRANSLATE_WITH_CAMERA: 2,
  LOOK_AT_CAMERA: 3,
  SIMPLE_HALO: 4,
  EVE_CAMERA_ROTATION_ALIGNED: 100,
  EVE_BOOSTER: 101,
  EVE_SIMPLE_HALO: 102,
  EVE_CAMERA_ROTATION: 103
});
// CONCATENATED MODULE: ./eve/object/EvePlanet.js
function EvePlanet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EvePlanet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EvePlanet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EvePlanet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EvePlanet_defineProperties(Constructor, staticProps); return Constructor; }

function EvePlanet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EvePlanet_assertThisInitialized(self); }

function EvePlanet_getPrototypeOf(o) { EvePlanet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EvePlanet_getPrototypeOf(o); }

function EvePlanet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EvePlanet_setPrototypeOf(subClass, superClass); }

function EvePlanet_setPrototypeOf(o, p) { EvePlanet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EvePlanet_setPrototypeOf(o, p); }

function EvePlanet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EvePlanet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * EvePlanet
 *
 * @property {string} name
 * @property {boolean} display
 * @property {EveTransform} highDetail
 * @property {Tw2Effect} effectHeight
 * @property {Tw2RenderTarget} heightMap
 * @property {*} zOnlyModel
 * @property {number} itemID
 * @property {string} heightMapResPath1
 * @property {string} heightMapResPath2
 * @property {boolean} heightDirty
 * @property {Array} lockedResources
 * @property {Array.<Tw2Resource>} watchedResources
 * @class
 */

let EvePlanet_EvePlanet =
/*#__PURE__*/
function (_EveObject) {
  EvePlanet_inherits(EvePlanet, _EveObject);

  function EvePlanet() {
    var _this;

    EvePlanet_classCallCheck(this, EvePlanet);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EvePlanet_possibleConstructorReturn(this, EvePlanet_getPrototypeOf(EvePlanet).call(this, ...args));

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "highDetail", new EveTransform_EveTransform());

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "effectHeight", new core["Tw2Effect"]());

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "heightMap", new core["Tw2RenderTarget"]());

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "zOnlyModel", null);

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "itemID", 0);

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "heightMapResPath1", '');

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "heightMapResPath2", '');

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "heightDirty", false);

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "lockedResources", []);

    EvePlanet_defineProperty(EvePlanet_assertThisInitialized(EvePlanet_assertThisInitialized(_this)), "watchedResources", []);

    return _this;
  }

  EvePlanet_createClass(EvePlanet, [{
    key: "Create",

    /**
     * Creates the planet from an options object
     * @param {{}} options={}                   - an object containing the planet's options
     * @param {number} options.itemID           - the item id is used for randomization
     * @param {string} options.planetPath       - .red file for a planet, or planet template
     * @param {string} [options.atmospherePath] - optional .red file for a planet's atmosphere
     * @param {string} options.heightMap1       - the planet's first height map
     * @param {string} options.heightMap2       - the planet's second height map
     * @param {function} [onLoaded]             - an optional callback which is fired when the planet has loaded
     */
    value: function Create() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let onLoaded = arguments.length > 1 ? arguments[1] : undefined;
      const _options$itemID = options.itemID,
            itemID = _options$itemID === void 0 ? 0 : _options$itemID,
            planetPath = options.planetPath,
            atmospherePath = options.atmospherePath,
            heightMap1 = options.heightMap1,
            heightMap2 = options.heightMap2;
      this.itemID = itemID;
      this.heightMapResPath1 = heightMap1;
      this.heightMapResPath2 = heightMap2;
      this.highDetail.children = [];
      this.heightDirty = true;
      let loadingParts = 1;
      if (planetPath) loadingParts++;
      if (atmospherePath) loadingParts++;
      /**
       * Handles the optional onLoaded callback which is fired when all parts have loaded
       */

      function onPartLoaded() {
        loadingParts--;

        if (loadingParts < 1 && onLoaded) {
          onLoaded();
        }
      }

      if (planetPath) {
        global["D" /* resMan */].GetObject(planetPath, obj => {
          EvePlanet.MeshLoaded(this, obj);
          onPartLoaded();
        });
      }

      if (atmospherePath) {
        global["D" /* resMan */].GetObject(atmospherePath, obj => {
          this.highDetail.children.push(obj);
          onPartLoaded();
        });
      }

      global["D" /* resMan */].GetObject('res:/dx9/model/worldobject/planet/planetzonly.red', obj => {
        this.zOnlyModel = obj;
        onPartLoaded();
      });
    }
    /**
     * GetPlanetResources
     * Todo: Replace this, using this.GetResources();
     * @param obj
     * @param visited
     * @param result
     */

  }, {
    key: "GetPlanetResources",
    value: function GetPlanetResources(obj, visited, result) {
      if (visited.includes(obj)) return;
      visited.push(obj);

      if (obj && !global["F" /* util */].isUndefined(obj['doNotPurge'])) {
        result.push(obj);
        return;
      }

      for (let prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (global["F" /* util */].isObjectLike(obj[prop])) {
            this.GetPlanetResources(obj[prop], visited, result);
          }
        }
      }
    }
    /**
     * Gets planet res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (this.highDetail) this.highDetail.GetResources(out);
      if (this.effectHeight) this.effectHeight.GetResources(out);
      return out;
    }
    /**
     * Updates view dependent data
     * @param {mat4} parentTransform
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData(parentTransform) {
      this.highDetail.UpdateViewDependentData(parentTransform);

      if (this.zOnlyModel) {
        this.zOnlyModel.translation = this.highDetail.translation;
        this.zOnlyModel.scaling = this.highDetail.scaling;
        this.zOnlyModel.UpdateViewDependentData(parentTransform);
      }
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      this.highDetail.Update(dt);
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display && this.heightDirty && this.watchedResources.length && this.heightMapResPath1 !== '') {
        for (let i = 0; i < this.watchedResources.length; ++i) {
          if (this.watchedResources[i] && !this.watchedResources[i].IsGood()) return;
        }

        this.watchedResources = [];
        this.heightMap.Set();
        global["w" /* device */].SetStandardStates(global["w" /* device */].RM_FULLSCREEN);
        global["w" /* device */].gl.clearColor(0.0, 0.0, 0.0, 0.0);
        global["w" /* device */].gl.clear(global["w" /* device */].gl.COLOR_BUFFER_BIT);
        global["w" /* device */].RenderFullScreenQuad(this.effectHeight);
        this.heightMap.Unset();
        this.heightDirty = false;

        for (let i = 0; i < this.lockedResources.length; ++i) {
          this.lockedResources[i].doNotPurge--;
        }

        const mainMesh = this.highDetail.children[0].mesh;
        let originalEffect = null;

        if (mainMesh.transparentAreas.length) {
          originalEffect = mainMesh.transparentAreas[0].effect;
        } else if (mainMesh.opaqueAreas.length) {
          originalEffect = mainMesh.opaqueAreas[0].effect;
        }

        if (originalEffect) {
          originalEffect.parameters['HeightMap'].textureRes = this.heightMap.texture;
        }
      }

      if (this.display) {
        this.highDetail.GetBatches(mode, accumulator);
      }
    }
    /**
     * Gets z buffer only batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetZOnlyBatches",
    value: function GetZOnlyBatches(mode, accumulator) {
      if (this.display && this.zOnlyModel) {
        this.zOnlyModel.GetBatches(mode, accumulator);
      }
    }
    /**
     * Internal helper function that fires when a planet's mesh has loaded
     * @property {EvePlanet} planet
     * @property {*} obj
     */

  }], [{
    key: "MeshLoaded",
    value: function MeshLoaded(planet, obj) {
      planet.highDetail.children.unshift(obj);
      planet.lockedResources = [];
      planet.GetPlanetResources(planet.highDetail, [], planet.lockedResources);
      let mainMesh = planet.highDetail.children[0].mesh,
          originalEffect = null,
          resPath;

      if (mainMesh.transparentAreas.length) {
        originalEffect = mainMesh.transparentAreas[0].effect;
        resPath = originalEffect.effectFilePath;
      } else if (mainMesh.opaqueAreas.length) {
        originalEffect = mainMesh.opaqueAreas[0].effect;
        resPath = originalEffect.effectFilePath;
      } else {
        resPath = 'res:/Graphics/Effect/Managed/Space/Planet/EarthlikePlanet.fx';
      }

      resPath = resPath.replace('.fx', 'BlitHeight.fx');
      planet.watchedResources = [];

      for (let param in originalEffect.parameters) {
        if (originalEffect.parameters.hasOwnProperty(param)) {
          planet.effectHeight.parameters[param] = originalEffect.parameters[param];

          if ('textureRes' in originalEffect.parameters[param]) {
            planet.watchedResources.push(originalEffect.parameters[param].textureRes);
          }
        }
      }

      for (let i = 0; i < planet.highDetail.children[0].children.length; ++i) {
        mainMesh = planet.highDetail.children[0].children[i].mesh;
        if (!mainMesh) continue;
        originalEffect = null;

        if (mainMesh.transparentAreas.length) {
          originalEffect = mainMesh.transparentAreas[0].effect;
        } else if (mainMesh.opaqueAreas.length) {
          originalEffect = mainMesh.opaqueAreas[0].effect;
        } else {
          continue;
        }

        for (let param in originalEffect.parameters) {
          if (originalEffect.parameters.hasOwnProperty(param)) {
            planet.effectHeight.parameters[param] = originalEffect.parameters[param];

            if ('textureRes' in originalEffect.parameters[param]) {
              planet.watchedResources.push(originalEffect.parameters[param].textureRes);
            }
          }
        }
      }

      const NormalHeight1 = new core["Tw2TextureParameter"]('NormalHeight1', planet.heightMapResPath1);
      NormalHeight1.Initialize();
      planet.watchedResources.push(NormalHeight1.textureRes);
      planet.lockedResources.push(NormalHeight1.textureRes);
      planet.effectHeight.parameters.NormalHeight1 = NormalHeight1;
      const NormalHeight2 = new core["Tw2TextureParameter"]('NormalHeight2', planet.heightMapResPath2);
      NormalHeight2.Initialize();
      planet.watchedResources.push(NormalHeight2.textureRes);
      planet.lockedResources.push(NormalHeight2.textureRes);
      planet.effectHeight.parameters.NormalHeight2 = NormalHeight2;
      planet.effectHeight.parameters.Random = new core["Tw2FloatParameter"]('Random', planet.itemID % 100);
      planet.effectHeight.parameters.TargetTextureHeight = new core["Tw2FloatParameter"]('TargetTextureHeight', 1024);
      planet.effectHeight.effectFilePath = resPath;
      planet.effectHeight.Initialize();
      planet.heightDirty = true;
      planet.heightMap.Create(2048, 1024, false);
      planet.watchedResources.push(planet.effectHeight.effectRes);

      for (let i = 0; i < planet.lockedResources.length; ++i) {
        planet.lockedResources[i].doNotPurge++;

        if (planet.lockedResources[i].IsPurged()) {
          planet.lockedResources[i].Reload();
        }
      }
    }
  }]);

  return EvePlanet;
}(EveObject_EveObject);
// CONCATENATED MODULE: ./eve/object/EveShip.js
function EveShip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveShip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveShip_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveShip_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveShip_defineProperties(Constructor, staticProps); return Constructor; }

function EveShip_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveShip_assertThisInitialized(self); }

function EveShip_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { EveShip_get = Reflect.get; } else { EveShip_get = function _get(target, property, receiver) { var base = EveShip_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return EveShip_get(target, property, receiver || target); }

function EveShip_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = EveShip_getPrototypeOf(object); if (object === null) break; } return object; }

function EveShip_getPrototypeOf(o) { EveShip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveShip_getPrototypeOf(o); }

function EveShip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveShip_setPrototypeOf(subClass, superClass); }

function EveShip_setPrototypeOf(o, p) { EveShip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveShip_setPrototypeOf(o, p); }

function EveShip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveShip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * EveShip
 *
 * @property {Array.<EveBoosterSet>} boosters
 * @property {Array.<EveTurretSet>} turretSets
 * @property {number} boosterGain
 * @class
 */

let EveShip =
/*#__PURE__*/
function (_EveSpaceObject) {
  EveShip_inherits(EveShip, _EveSpaceObject);

  function EveShip() {
    var _this;

    EveShip_classCallCheck(this, EveShip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveShip_possibleConstructorReturn(this, EveShip_getPrototypeOf(EveShip).call(this, ...args));

    EveShip_defineProperty(EveShip_assertThisInitialized(EveShip_assertThisInitialized(_this)), "boosters", null);

    EveShip_defineProperty(EveShip_assertThisInitialized(EveShip_assertThisInitialized(_this)), "turretSets", []);

    EveShip_defineProperty(EveShip_assertThisInitialized(EveShip_assertThisInitialized(_this)), "boosterGain", 1);

    return _this;
  }

  EveShip_createClass(EveShip, [{
    key: "Initialize",

    /**
     * Initializes the Eve Ship
     */
    value: function Initialize() {
      EveShip_get(EveShip_getPrototypeOf(EveShip.prototype), "Initialize", this).call(this);

      if (this.boosters) {
        this.RebuildBoosterSet();
      }
    }
    /**
     * Rebuilds the ship's booster set
     */

  }, {
    key: "RebuildBoosterSet",
    value: function RebuildBoosterSet() {
      if (this.boosters) {
        this.boosters.UpdateItemsFromLocators(this.FindLocatorsByPrefix('locator_booster'));
      }
    }
    /**
     * Rebuilds turret sets
     */

  }, {
    key: "RebuildTurretPositions",
    value: function RebuildTurretPositions() {
      for (let i = 0; i < this.turretSets.length; i++) {
        this.RebuildTurretSet(i);
      }
    }
    /**
     * Rebuilds a turret set
     * @param {number} index
     */

  }, {
    key: "RebuildTurretSet",
    value: function RebuildTurretSet(index) {
      if (this.turretSets[index] === undefined) return;
      const turretSet = this.turretSets[index],
            prefix = turretSet.locatorName,
            count = this.GetLocatorCount(prefix),
            locators = [];

      for (let j = 0; j < count; ++j) {
        const name = prefix + String.fromCharCode('a'.charCodeAt(0) + j),
              locator = this.FindLocatorByName(name);

        if (locator) {
          locator.FindBone(this.animation);
          locators.push(locator);
        }
      }

      turretSet.UpdateItemsFromLocators(locators);
    }
    /**
     * Gets ship's res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @param {Boolean} excludeChildren - True to exclude children's res objects
     * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let excludeChildren = arguments.length > 1 ? arguments[1] : undefined;

      EveShip_get(EveShip_getPrototypeOf(EveShip.prototype), "GetResources", this).call(this, out, excludeChildren);

      for (let i = 0; i < this.turretSets.length; i++) {
        this.turretSets[i].GetResources(out);
      }

      if (this.boosters) {
        this.boosters.GetResources(out);
      }

      return out;
    }
    /**
     * Updates view dependant data
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      EveShip_get(EveShip_getPrototypeOf(EveShip.prototype), "UpdateViewDependentData", this).call(this);

      for (let i = 0; i < this.turretSets.length; ++i) {
        this.turretSets[i].UpdateViewDependentData();
      }
    }
    /**
     * Per frame update
     * @param {number} dt - deltaTime
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      EveShip_get(EveShip_getPrototypeOf(EveShip.prototype), "Update", this).call(this, dt);

      if (this.boosters) {
        if (this.boosters._locatorRebuildPending) {
          this.RebuildBoosterSet();
        }

        this.boosters.Update(dt, this.transform);
      }

      for (let i = 0; i < this.turretSets.length; ++i) {
        if (this.turretSets[i]._locatorRebuildPending) {
          this.RebuildTurretSet(i);
        }

        this.turretSets[i].Update(dt, this.transform);
      }
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (this.display) {
        EveShip_get(EveShip_getPrototypeOf(EveShip.prototype), "GetBatches", this).call(this, mode, accumulator);

        this._perObjectData.perObjectVSData.Get('Shipdata')[0] = this.boosterGain;
        this._perObjectData.perObjectPSData.Get('Shipdata')[0] = this.boosterGain;

        if (this.boosters && this.visible.boosters) {
          this.boosters.GetBatches(mode, accumulator, this._perObjectData);
        }

        if (this.visible.turretSets) {
          if (this.lod > 1) {
            for (let i = 0; i < this.turretSets.length; ++i) {
              this.turretSets[i].GetBatches(mode, accumulator, this._perObjectData, this.visible.firingEffects);
            }
          } else if (this.visible.firingEffects) {
            for (let i = 0; i < this.turretSets.length; ++i) {
              if (this.turretSets[i].firingEffect) {
                this.turretSets[i].firingEffect.GetBatches(mode, accumulator, this._perObjectData);
              }
            }
          }
        }
      }
    }
  }]);

  return EveShip;
}(EveSpaceObject_EveSpaceObject);
// CONCATENATED MODULE: ./eve/object/index.js







// CONCATENATED MODULE: ./eve/item/EveObjectSet.js
function EveObjectSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveObjectSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveObjectSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveObjectSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveObjectSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveObjectSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * EveObjectSetItem base class
 *
 * @property {string|number} _id     - The set item's id
 * @property {string} name           - The set item's name
 * @property {boolean} display       - Toggles the set item's visibility
 * @property {?Function} _onModified - A callback which is fired on value changes
 */

let EveObjectSet_EveObjectSetItem =
/*#__PURE__*/
function () {
  function EveObjectSetItem() {
    EveObjectSet_classCallCheck(this, EveObjectSetItem);

    EveObjectSet_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveObjectSet_defineProperty(this, "name", '');

    EveObjectSet_defineProperty(this, "display", true);

    EveObjectSet_defineProperty(this, "_rebuildPending", true);

    EveObjectSet_defineProperty(this, "_onModified", null);
  }

  EveObjectSet_createClass(EveObjectSetItem, [{
    key: "OnValueChanged",

    /**
     * Fire on value changes
     */
    value: function OnValueChanged() {
      this._rebuildPending = true;
      if (this._onModified) this._onModified(this);
    }
  }]);

  return EveObjectSetItem;
}();
/**
 * EveObjectSet base class
 *
 * @property {number|String} _id                     - The set's id
 * @property {string} name                           - The set's name
 * @property {boolean} display                       - Toggles set visibility
 * @property {Array<EveObjectSetItem>} items         - The set's items
 * @property {Array<EveObjectSetItem>} _visibleItems - The set's items that will be rendered when the set is visible
 * @property {boolean} _rebuildPending               - Identifies if the set requires rebuilding
 * @class
 */

let EveObjectSet_EveObjectSet =
/*#__PURE__*/
function () {
  function EveObjectSet() {
    EveObjectSet_classCallCheck(this, EveObjectSet);

    EveObjectSet_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveObjectSet_defineProperty(this, "name", '');

    EveObjectSet_defineProperty(this, "display", true);

    EveObjectSet_defineProperty(this, "items", []);

    EveObjectSet_defineProperty(this, "_visibleItems", []);

    EveObjectSet_defineProperty(this, "_rebuildPending", false);

    EveObjectSet_defineProperty(this, "_onChildModified", item => this.OnValueChanged(item));
  }

  EveObjectSet_createClass(EveObjectSet, [{
    key: "Initialize",

    /**
     * Initializes the set
     */
    value: function Initialize() {
      this.Rebuild();
    }
    /**
     * Fires on value changes
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged() {
      this._rebuildPending = true;
    }
    /**
     * Creates an item from an options object and then adds it to the set
     * @param {*} [opt={}]
     * @returns {?EveObjectSetItem|*}
     */

  }, {
    key: "CreateItem",
    value: function CreateItem() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const Item = this.constructor.Item;

      if (Item && 'create' in Item) {
        const item = Item.create(opt);
        this.AddItem(item);
        return item;
      }

      return null;
    }
    /**
     * Adds a set item
     * @param {EveObjectSetItem|*} item
     */

  }, {
    key: "AddItem",
    value: function AddItem(item) {
      if (!this.items.includes(item)) {
        item._onModified = this._onChildModified;
        this.items.push(item);
        this.OnValueChanged();
      }
    }
    /**
     * Removes a set item
     * @param {EveObjectSetItem|*} item
     */

  }, {
    key: "RemoveItem",
    value: function RemoveItem(item) {
      const index = this.items.indexOf(item);

      if (index !== -1) {
        item._onModified = null;
        this.items.splice(index, 1);
        this.OnValueChanged();
      }
    }
    /**
     * Clears all set items
     */

  }, {
    key: "ClearItems",
    value: function ClearItems() {
      for (let i = 0; i < this.items.length; i++) {
        this.items[i]._onModified = null;
      }

      this.items = [];
      this.OnValueChanged();
    }
    /**
     * Finds an item by it's id
     * @param {?number} [id=null]
     * @returns {?EveObjectSetItem|*}
     */

  }, {
    key: "FindItemByID",
    value: function FindItemByID() {
      let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (id !== null) {
        for (let i = 0; i < this.items.length; i++) {
          if (this.items[i]._id === id) {
            return this.items[i];
          }
        }
      }

      return null;
    }
    /**
     * Gets the set's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>}
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return out;
    }
    /**
     * Per frame update
     * @param {number} dt
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      if (this._rebuildPending) {
        this.Rebuild();
      }
    }
    /**
     * Unloads the set's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {}
    /**
     * Rebuilds the set
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      this.constructor.RebuildItems(this);
      this._rebuildPending = false;
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData|Tw2BasicPerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {}
    /**
     * Renders the set
     */

  }, {
    key: "Render",
    value: function Render() {}
    /**
     * Rebuilds the set's items
     *
     * @param {EveObjectSet|*} eveSet
     */

  }], [{
    key: "RebuildItems",
    value: function RebuildItems(eveSet) {
      eveSet._visibleItems = [];

      for (let i = 0; i < eveSet.items.length; i++) {
        const item = eveSet.items[i];
        item._onModified = eveSet._onChildModified;
        item._rebuildPending = false;

        if (item.display) {
          eveSet._visibleItems.push(item);
        }
      }
    }
    /**
     * The object set's item
     * @type {?Function}
     */

  }]);

  return EveObjectSet;
}();

EveObjectSet_defineProperty(EveObjectSet_EveObjectSet, "Item", null);

EveObjectSet_defineProperty(EveObjectSet_EveObjectSet, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  vec3_1: global["H" /* vec3 */].create(),
  vec3_2: global["H" /* vec3 */].create(),
  vec4_0: global["I" /* vec4 */].create(),
  vec4_1: global["I" /* vec4 */].create(),
  mat4_0: global["z" /* mat4 */].create()
});
// CONCATENATED MODULE: ./eve/item/EveBoosterSet.js
function EveBoosterSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveBoosterSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveBoosterSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveBoosterSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveBoosterSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveBoosterSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveBoosterSet_assertThisInitialized(self); }

function EveBoosterSet_getPrototypeOf(o) { EveBoosterSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveBoosterSet_getPrototypeOf(o); }

function EveBoosterSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveBoosterSet_setPrototypeOf(subClass, superClass); }

function EveBoosterSet_setPrototypeOf(o, p) { EveBoosterSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveBoosterSet_setPrototypeOf(o, p); }

function EveBoosterSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveBoosterSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Booster render batch
 *
 * @property {EveBoosterSet} boosters
 * @class
 */

let EveBoosterBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  EveBoosterSet_inherits(EveBoosterBatch, _Tw2RenderBatch);

  function EveBoosterBatch() {
    var _this;

    EveBoosterSet_classCallCheck(this, EveBoosterBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveBoosterSet_possibleConstructorReturn(this, EveBoosterSet_getPrototypeOf(EveBoosterBatch).call(this, ...args));

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this)), "boosters", null);

    return _this;
  }

  EveBoosterSet_createClass(EveBoosterBatch, [{
    key: "Commit",

    /**
     * Commits the batch
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      this.boosters.Render(technique);
    }
  }]);

  return EveBoosterBatch;
}(core["Tw2RenderBatch"]);
/**
 * EveBoosterSetItem
 *
 * @param {boolean} enableCustomValues   - Enables custom values
 * @property {{}} visible                - Visibility options
 * @property {boolean} visible.halo      - Toggles halo visibility
 * @property {boolean} visible.symHalo   - Toggles symmetrical halo visibility
 * @property {boolean} visible.glow      - Toggles glow visibility
 * @property {boolean} visible.trail     - Toggles trail visibility (not implemented)
 * @property {?string} locatorName       - The item's locator name, if it was built from one
 * @property {boolean} updateFromLocator - Sets whether the item should be updated when it's locator is
 * @property {mat4} transform            - The item's local transform
 * @property {number} atlas0             - The item's atlas index 0
 * @property {number} atlas1             - The item's atlas index 1
 * @property {number} seed               - A random seed which affects any glows built from this item
 * @property {number} wavePhase          - A random seed which affects the booster wave pattern
 * @property {*} customValues            - An optional object containing custom values
 * @class
 */

let EveBoosterSet_EveBoosterSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EveBoosterSet_inherits(EveBoosterSetItem, _EveObjectSetItem);

  function EveBoosterSetItem() {
    var _this2;

    EveBoosterSet_classCallCheck(this, EveBoosterSetItem);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = EveBoosterSet_possibleConstructorReturn(this, EveBoosterSet_getPrototypeOf(EveBoosterSetItem).call(this, ...args));

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "visible", {
      glow: true,
      symHalo: true,
      halo: true,
      trail: true,
      customValues: true
    });

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "locatorName", null);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "updateFromLocator", false);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "seed", Math.random() * 7);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "wavePhase", Math.random());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "atlas0", 0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "atlas1", 0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "transform", global["z" /* mat4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this2)), "customValues", null);

    return _this2;
  }

  EveBoosterSet_createClass(EveBoosterSetItem, [{
    key: "GetPosition",

    /**
     * Gets the item's position
     * @param {vec3} out
     * @returns {vec3} out
     */
    value: function GetPosition(out) {
      return global["z" /* mat4 */].getTranslation(out, this.transform);
    }
    /**
     * Gets the item's direction
     * @param {vec3} out
     * @returns {vec3} out
     */

  }, {
    key: "GetDirection",
    value: function GetDirection(out) {
      global["H" /* vec3 */].set(out, this.transform[8], this.transform[9], this.transform[10]);
      global["H" /* vec3 */].normalize(out, out);
      const scale = this.GetScale();
      if (scale < 3) global["H" /* vec3 */].scale(out, out, scale / 3);
      return out;
    }
    /**
     * Gets the item's scale
     * @returns {number}
     */

  }, {
    key: "GetScale",
    value: function GetScale() {
      const tr = this.transform;
      return Math.max(global["H" /* vec3 */].length([tr[0], tr[1], tr[2]]), global["H" /* vec3 */].length([tr[4], tr[5], tr[6]]));
    }
    /**
     * Creates an item from an object
     * @param {*} [opt={}]
     * @returns {EveBoosterSetItem}
     */

  }], [{
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item.visible, opt.visible, ['glow', 'symHalo', 'halo', 'trail']);
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'seed', 'wavePhase', 'transform', 'locatorName', 'updateFromLocator', 'atlas0', 'atlas1']);
      return item;
    }
  }]);

  return EveBoosterSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EveBoosterSet
 *
 * @property {{}} visible                      - Visibility controls
 * @property {boolean} visible.glows           - Toggles glow visibility
 * @property {boolean} visible.symHalos        - Toggles symmetrical halo visibility
 * @property {boolean} visible.halos           - Toggles halo visibility
 * @property {boolean} visible.trails          - Toggles trails visibility (Not implemented)
 * @property {Tw2Effect} effect                - The booster's booster effect
 * @property {?Tw2Effect} glows                - The booster's glows (sprites)
 * @property {number} maxVel                   - (Not implemented)
 * @property {boolean} alwaysOn                - (Not implemented)
 * @property {number} glowDistance             - The distance between the booster's locators and glow sprites
 * @property {number} glowScale                - The base scale of the booster's glow sprites
 * @property {vec4} glowColor                  - The color of the booster set's glow sprites
 * @property {vec4} warpGlowColor              - The color of the booster set's glow sprites when warping (Not implemented)
 * @property {number} haloDistance             - The distance between the booster set's locators and halo sprites
 * @property {number} haloScaleX               - The base vertical scale of the booster set's halos
 * @property {number} haloScaleY               - The base horizontal scale of the booster set's halos
 * @property {vec4} haloColor                  - The color of the booster set's halo sprites
 * @property {vec4} warpHaloColor              - The color of the booster set's halo sprites when warping (Not implemented)
 * @property {vec4} trailSize                  - The booster set's trail size (Not implemented)
 * @property {vec4} trailColor                 - The booster set's trail color (Not implemented)
 * @property {number} symHaloDistance          - The distance between the booster set's locators and symmetrical halo sprites
 * @property {number} symHaloScale             - The base scale of the booster set's symmetrical halos
 * @property {mat4} _parentTransform           - The booster set's parent's transform
 * @property {WebGLBuffer} _positions          - The booster set's webgl buffer
 * @property {Tw2VertexDeclaration} _decl      - The booster set's vertex declarations
 * @property {Tw2PerObjectData} _perObjectData - The booster set's shader data
 * @property {boolean} _locatorRebuildPending  - Identifies that the booster set needs to be rebuilt from locators
 * @class
 */

let EveBoosterSet_EveBoosterSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EveBoosterSet_inherits(EveBoosterSet, _EveObjectSet);

  function EveBoosterSet() {
    var _this3;

    EveBoosterSet_classCallCheck(this, EveBoosterSet);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = EveBoosterSet_possibleConstructorReturn(this, EveBoosterSet_getPrototypeOf(EveBoosterSet).call(this, ...args));

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "visible", {
      glows: true,
      symHalos: true,
      halos: true,
      trails: true
    });

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "effect", null);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "glows", null);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "alwaysOn", true);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "maxVel", 250);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "glowDistance", 2.5);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "glowScale", 1.0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "glowColor", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "warpGlowColor", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "haloDistance", 3.01);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "haloScaleX", 1.0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "haloScaleY", 1.0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "haloColor", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "warpHaloColor", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "symHaloDistance", 3);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "symHaloScale", 1.0);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "trailColor", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "trailSize", global["I" /* vec4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "_parentTransform", global["z" /* mat4 */].create());

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "_positions", null);

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "_decl", new core["Tw2VertexDeclaration"](EveBoosterSet.vertexDeclarations));

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "_perObjectData", new core["Tw2PerObjectData"](EveBoosterSet.perObjectData));

    EveBoosterSet_defineProperty(EveBoosterSet_assertThisInitialized(EveBoosterSet_assertThisInitialized(_this3)), "_locatorRebuildPending", true);

    return _this3;
  }

  EveBoosterSet_createClass(EveBoosterSet, [{
    key: "FindItemByLocatorName",

    /**
     * Finds a booster item that belongs to a locator by it's name
     * @param {string} locatorName
     * @returns {?EveBoosterSetItem}
     */
    value: function FindItemByLocatorName(locatorName) {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].locatorName && this.items[i].locatorName === locatorName) {
          return this.items[i];
        }
      }

      return null;
    }
    /**
     * Updates booster items that were built from locators
     * @param {Array.<EveLocator>} locators
     */

  }, {
    key: "UpdateItemsFromLocators",
    value: function UpdateItemsFromLocators(locators) {
      const items = Array.from(this.items);

      for (let i = 0; i < locators.length; i++) {
        const _locators$i = locators[i],
              name = _locators$i.name,
              transform = _locators$i.transform,
              atlasIndex0 = _locators$i.atlasIndex0,
              atlasIndex1 = _locators$i.atlasIndex1;
        let item = this.FindItemByLocatorName(name);

        if (!item) {
          this.CreateItem({
            name: name,
            locatorName: name,
            updateFromLocator: true,
            atlas0: atlasIndex0,
            atlas1: atlasIndex1,
            transform: transform
          });
        } else {
          items.splice(items.indexOf(item), 1);

          if (item.updateFromLocator) {
            global["z" /* mat4 */].copy(item.transform, transform);
            item.atlas0 = atlasIndex0;
            item.atlas1 = atlasIndex1;
            item.OnValueChanged();
          }
        }
      }

      for (let i = 0; i < items.length; i++) {
        if (items[i].locatorName !== null) {
          this.RemoveItem(items[i]);
          i--;
        }
      }

      this._locatorRebuildPending = false;

      if (this._rebuildPending) {
        this.Rebuild();
      }
    }
    /**
     * Rebuilds the booster set from it's parent's locators
     */

  }, {
    key: "RebuildItemsFromLocators",
    value: function RebuildItemsFromLocators() {
      this._locatorRebuildPending = true;
    }
    /**
     * Gets booster set resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.effect) {
        this.effect.GetResources(out);
      }

      if (this.glows) {
        this.glows.effect.GetResources(out);
      }

      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - DeltaTime
     * @param {mat4} parentMatrix
     */

  }, {
    key: "Update",
    value: function Update(dt, parentMatrix) {
      global["z" /* mat4 */].copy(this._parentTransform, parentMatrix);
      if (this._rebuildPending) this.Rebuild();
      if (this.glows) this.glows.Update(dt);
    }
    /**
     * Unloads the booster's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this._positions) {
        global["w" /* device */].gl.deleteBuffer(this._positions);
        this._positions = null;
      }

      if (this.glows) {
        this.glows.Unload();
      }
    }
    /**
     * Rebuilds the boosters
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      this.constructor.RebuildItems(this);
      const itemCount = this._visibleItems.length;
      this._rebuildPending = false;
      if (!itemCount) return;
      const d = global["w" /* device */],
            box = EveBoosterSet._box,
            data = new Float32Array(itemCount * box.length * 6 * 28),
            order = [0, 3, 1, 3, 2, 1];
      let index = 0;

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i];

        for (let b = 0; b < box.length; ++b) {
          for (let j = 0; j < order.length; ++j) {
            data[index++] = box[b][order[j]][0];
            data[index++] = box[b][order[j]][1];
            data[index++] = box[b][order[j]][2];
            data[index++] = 0;
            data[index++] = 0;
            data.set(item.transform, index);
            index += 16;
            data[index++] = 0;
            data[index++] = 1;
            data[index++] = 1;
            data[index++] = 1;
            data[index++] = item.wavePhase;
            data[index++] = item.atlas0;
            data[index++] = item.atlas1;
          }
        }
      }

      this._positions = d.gl.createBuffer();
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._positions);
      d.gl.bufferData(d.gl.ARRAY_BUFFER, data, d.gl.STATIC_DRAW);
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);
      this._positions.count = itemCount * 12 * 3;
      if (this.glows) this.glows.Rebuild();
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (!this.display || mode !== global["w" /* device */].RM_ADDITIVE || !this._positions || !this._visibleItems.length) return;

      if (this.effect) {
        const batch = new EveBoosterBatch();
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this._parentTransform);

        this._perObjectData.perObjectVSData.Set('Shipdata', perObjectData.perObjectVSData.Get('Shipdata'));

        this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
        batch.perObjectData = this._perObjectData;
        batch.boosters = this;
        batch.renderMode = global["w" /* device */].RM_ADDITIVE;
        accumulator.Commit(batch);
      }

      if (this.glows) {
        this.glows.GetBoosterGlowBatches(mode, accumulator, perObjectData, this._parentTransform, perObjectData.perObjectVSData.Get('Shipdata')[0], 0);
      }
    }
    /**
     * Renders the accumulated batches
     * @param {string} technique - technique name
     * @returns {boolean}
     */

  }, {
    key: "Render",
    value: function Render(technique) {
      if (!this.effect || !this.effect.IsGood()) return false;
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, this._positions);

      for (let pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
        this.effect.ApplyPass(technique, pass);
        if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 112)) return false;
        global["w" /* device */].ApplyShadowState();
        global["w" /* device */].gl.drawArrays(global["w" /* device */].gl.TRIANGLES, 0, this._positions.count);
      }

      return true;
    }
    /**
     * Rebuilds a booster set's items
     * @param {EveBoosterSet} boosters
     */

  }], [{
    key: "RebuildItems",
    value: function RebuildItems(boosters) {
      const glows = boosters.glows,
            g = EveBoosterSet.global,
            spritePos = g.vec3_0;
      if (glows) glows.ClearItems();
      boosters._visibleItems = [];

      for (let i = 0; i < boosters.items.length; i++) {
        const item = boosters.items[i];
        item._onModified = boosters._onChildModified;

        if (item.display) {
          boosters._visibleItems.push(item);

          if (glows) {
            const src = item.customValues && item.customValues.display ? item.customValues : boosters,
                  pos = item.GetPosition(g.vec3_1),
                  dir = item.GetDirection(g.vec3_2),
                  scale = item.GetScale();

            if (boosters.visible.glows && item.visible.glow) {
              glows.CreateItem({
                name: item.name + '_glow',
                position: global["H" /* vec3 */].subtract(spritePos, pos, global["H" /* vec3 */].scale(spritePos, dir, src.glowDistance)),
                blinkRate: item.seed,
                blinkPhase: item.seed,
                minScale: src.glowScale * scale,
                maxScale: src.glowScale * scale,
                color: src.glowColor,
                warpColor: src.warpGlowColor
              });
            }

            if (boosters.visible.symHalos && item.visible.symHalo) {
              glows.CreateItem({
                name: item.name + '_symHalo',
                position: global["H" /* vec3 */].subtract(spritePos, pos, global["H" /* vec3 */].scale(spritePos, dir, src.symHaloDistance)),
                blinkRate: item.seed,
                blinkPhase: item.seed + 1,
                minScale: src.symHaloScale * scale,
                maxScale: src.symHaloScale * scale,
                color: src.haloColor,
                warpColor: src.warpHaloColor
              });
            }

            if (boosters.visible.halos && item.visible.halo) {
              glows.CreateItem({
                name: item.name + '_halo',
                position: global["H" /* vec3 */].subtract(spritePos, pos, global["H" /* vec3 */].scale(spritePos, dir, src.haloDistance)),
                blinkRate: item.seed,
                blinkPhase: item.seed + 1,
                minScale: src.haloScaleX * scale,
                maxScale: src.haloScaleY * scale,
                color: src.haloColor,
                warpColor: src.warpHaloColor
              });
            }
          }

          item._rebuildPending = false;
        }
      }
    }
    /**
     * The booster set's item constructor
     * @type {EveBoosterSetItem}
     */

  }]);

  return EveBoosterSet;
}(EveObjectSet_EveObjectSet);

EveBoosterSet_defineProperty(EveBoosterSet_EveBoosterSet, "Item", EveBoosterSet_EveBoosterSetItem);

EveBoosterSet_defineProperty(EveBoosterSet_EveBoosterSet, "perObjectData", {
  VSData: [['WorldMat', 16], ['Shipdata', 4]]
});

EveBoosterSet_defineProperty(EveBoosterSet_EveBoosterSet, "vertexDeclarations", [['POSITION', 0, 3], ['TEXCOORD', 0, 2], ['TEXCOORD', 1, 4], ['TEXCOORD', 2, 4], ['TEXCOORD', 3, 4], ['TEXCOORD', 4, 4], ['TEXCOORD', 5, 4], ['TEXCOORD', 6, 1], ['TEXCOORD', 7, 2]]);

EveBoosterSet_defineProperty(EveBoosterSet_EveBoosterSet, "_box", [[[-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0]], [[-1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [1.0, 1.0, -1.0], [1.0, -1.0, -1.0]], [[-1.0, -1.0, 0.0], [-1.0, 1.0, 0.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, -1.0]], [[1.0, -1.0, 0.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [1.0, 1.0, 0.0]], [[-1.0, -1.0, 0.0], [-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, -1.0, 0.0]], [[-1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0]]]);
// CONCATENATED MODULE: ./eve/item/EveCurveLineSet.js
function EveCurveLineSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveCurveLineSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveCurveLineSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveCurveLineSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveCurveLineSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveCurveLineSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveCurveLineSet_assertThisInitialized(self); }

function EveCurveLineSet_getPrototypeOf(o) { EveCurveLineSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveCurveLineSet_getPrototypeOf(o); }

function EveCurveLineSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveCurveLineSet_setPrototypeOf(subClass, superClass); }

function EveCurveLineSet_setPrototypeOf(o, p) { EveCurveLineSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveCurveLineSet_setPrototypeOf(o, p); }

function EveCurveLineSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveCurveLineSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveCurveLineSetItem
 *
 * @property {number} type
 * @property {vec3} position1
 * @property {vec4} color1
 * @property {vec3} position2
 * @property {vec4} color2
 * @property {vec3} intermediatePosition
 * @property {number} width
 * @property {vec4} multiColor
 * @property {number} multiColorBorder
 * @property {vec4} overlayColor
 * @property {number} animationSpeed
 * @property {number} animationScale
 * @property {number} numOfSegments
 * @class
 */

let EveCurveLineSet_EveCurveLineSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EveCurveLineSet_inherits(EveCurveLineSetItem, _EveObjectSetItem);

  function EveCurveLineSetItem() {
    var _this;

    EveCurveLineSet_classCallCheck(this, EveCurveLineSetItem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveCurveLineSet_possibleConstructorReturn(this, EveCurveLineSet_getPrototypeOf(EveCurveLineSetItem).call(this, ...args));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "type", EveCurveLineSetItem.Type.INVALID);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "position1", global["H" /* vec3 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "color1", global["I" /* vec4 */].fromValues(1, 1, 1, 1));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "position2", global["H" /* vec3 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "color2", global["I" /* vec4 */].fromValues(1, 1, 1, 1));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "intermediatePosition", global["H" /* vec3 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "width", 1);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "multiColor", global["I" /* vec4 */].fromValues(0, 0, 0, 1));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "multiColorBorder", -1);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "overlayColor", global["I" /* vec4 */].fromValues(0, 0, 0, 1));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "animationSpeed", 0);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "animationScale", 1);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this)), "numOfSegments", 1);

    return _this;
  }

  EveCurveLineSet_createClass(EveCurveLineSetItem, [{
    key: "ChangeColor",

    /**
     * Changes the line's colors
     * @param {vec3} startColor
     * @param {vec3} endColor
     */
    value: function ChangeColor(startColor, endColor) {
      global["H" /* vec3 */].copy(this.color1, startColor);
      global["H" /* vec3 */].copy(this.color2, endColor);
      this.OnValueChanged();
    }
    /**
     * Changes the line's width
     * @param {number} width
     */

  }, {
    key: "ChangeWidth",
    value: function ChangeWidth(width) {
      this.width = width;
      this.OnValueChanged();
    }
    /**
     * Changes positions from cartesian coordinates
     * @param {vec3} startPosition
     * @param {vec3} endPosition
     * @param {vec3} middle
     */

  }, {
    key: "ChangeCartesian",
    value: function ChangeCartesian(startPosition, endPosition, middle) {
      global["H" /* vec3 */].copy(this.position1, startPosition);
      global["H" /* vec3 */].copy(this.position2, endPosition);
      global["H" /* vec3 */].copy(this.intermediatePosition, middle);
      this.OnValueChanged();
    }
    /**
     * Changes cartesian position
     * @param {vec3} startPosition
     * @param {vec3} endPosition
     */

  }, {
    key: "ChangePositionCartesian",
    value: function ChangePositionCartesian(startPosition, endPosition) {
      global["H" /* vec3 */].copy(this.position1, startPosition);
      global["H" /* vec3 */].copy(this.position2, endPosition);
      this.OnValueChanged();
    }
    /**
     * Changes cartesian intermediate position
     * @param {vec3} intermediatePosition
     */

  }, {
    key: "ChangeIntermediateCartesian",
    value: function ChangeIntermediateCartesian(intermediatePosition) {
      global["H" /* vec3 */].copy(this.intermediatePosition, intermediatePosition);
      this.OnValueChanged();
    }
    /**
     * Changes positions from spherical
     * @param {vec3} startPosition
     * @param {vec3} endPosition
     * @param {vec3} middle
     * @param {vec3} center
     */

  }, {
    key: "ChangeSpherical",
    value: function ChangeSpherical(startPosition, endPosition, middle, center) {
      global["H" /* vec3 */].fromSpherical(this.position1, startPosition, center);
      global["H" /* vec3 */].fromSpherical(this.position2, endPosition, center);
      global["H" /* vec3 */].fromSpherical(this.intermediatePosition, middle, center);
      this.OnValueChanged();
    }
    /**
     * Changes position from spherical coordinates
     * @param {vec3} startPosition
     * @param {vec3} endPosition
     * @param {vec3} center
     */

  }, {
    key: "ChangePositionSpherical",
    value: function ChangePositionSpherical(startPosition, endPosition, center) {
      global["H" /* vec3 */].fromSpherical(this.position1, startPosition, center);
      global["H" /* vec3 */].fromSpherical(this.position2, endPosition, center);
      this.OnValueChanged();
    }
    /**
     * Changes spherical intermediate position
     * @param {vec3} intermediatePosition
     * @param {vec3} center
     */

  }, {
    key: "ChangeIntermediateSpherical",
    value: function ChangeIntermediateSpherical(intermediatePosition, center) {
      global["H" /* vec3 */].fromSpherical(this.intermediatePosition, intermediatePosition, center);
      this.OnValueChanged();
    }
    /**
     * Changes multi line color
     * @param {vec4} color
     * @param {number} border
     */

  }, {
    key: "ChangeMultiColor",
    value: function ChangeMultiColor(color, border) {
      global["I" /* vec4 */].copy(this.multiColor, color);
      this.multiColorBorder = border;
      this.OnValueChanged();
    }
    /**
     * Changes animated color settings
     * @param {vec4} color
     * @param {number} speed
     * @param {number} scale
     */

  }, {
    key: "ChangeAnimation",
    value: function ChangeAnimation(color, speed, scale) {
      global["I" /* vec4 */].copy(this.overlayColor, color);
      this.animationSpeed = speed;
      this.animationScale = scale;
      this.OnValueChanged();
    }
    /**
     * Changes line segmentation
     * @param {number} numOfSegments
     */

  }, {
    key: "ChangeSegmentation",
    value: function ChangeSegmentation(numOfSegments) {
      if (this.type !== EveCurveLineSetItem.Type.STRAIGHT) {
        this.numOfSegments = numOfSegments;
        this.OnValueChanged();
      }
    }
    /**
     * Creates a line from an object
     * @param {*} [opt={}]
     * @returns {EveCurveLineSetItem}
     */

  }], [{
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'type', 'position1', 'color1', 'position2', 'color2', 'intermediatePosition', 'width', 'multiColor', 'multiColorBorder', 'overlayColor', 'animationSpeed', 'animationScale', 'numOfSegments']);
      return item;
    }
    /**
     * Curve line types
     * @type {{INVALID: number, STRAIGHT: number, SPHERED: number, CURVED: number}}
     */

  }]);

  return EveCurveLineSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EveCurveLineSet
 *
 * @property {Tw2Effect} lineEffect
 * @property {?Tw2Effect} pickEffect
 * @property {number} lineWidthFactor
 * @property {boolean} additive
 * @property {number} depthOffset
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} transform
 * @property {mat4} parentTransform
 * @property {number} _vertexSize
 * @property {number} _vbSize
 * @property {?WebGLBuffer} _vb
 * @property {Tw2PerObjectData} _perObjectData
 * @property {Tw2VertexDeclaration} _decl
 * @class
 */

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSetItem, "Type", {
  INVALID: 0,
  STRAIGHT: 1,
  SPHERED: 2,
  CURVED: 3
});

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSetItem, "DEFAULT_CURVED_SEGMENTS", 20);

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSetItem, "DEFAULT_SPHERED_SEGMENTS", 20);

let EveCurveLineSet_EveCurveLineSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EveCurveLineSet_inherits(EveCurveLineSet, _EveObjectSet);

  /**
   * Constructor
   */
  function EveCurveLineSet() {
    var _this2;

    EveCurveLineSet_classCallCheck(this, EveCurveLineSet);

    _this2 = EveCurveLineSet_possibleConstructorReturn(this, EveCurveLineSet_getPrototypeOf(EveCurveLineSet).call(this));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "lineEffect", core["Tw2Effect"].create({
      effectFilePath: 'res:/Graphics/Effect/Managed/Space/SpecialFX/Lines3D.fx',
      textures: {
        'TexMap': 'res:/texture/global/white.dds.0.png',
        'OverlayTexMap': 'res:/texture/global/white.dds.0.png'
      }
    }));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "pickEffect", null);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "lineWidthFactor", 1);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "additive", false);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "pickable", true);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "depthOffset", 0);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "translation", global["H" /* vec3 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "rotation", global["C" /* quat */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "transform", global["z" /* mat4 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "parentTransform", global["z" /* mat4 */].create());

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "_vertexSize", 26);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "_vbSize", 0);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "_vb", null);

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "_perObjectData", new core["Tw2PerObjectData"](EveCurveLineSet.perObjectData));

    EveCurveLineSet_defineProperty(EveCurveLineSet_assertThisInitialized(EveCurveLineSet_assertThisInitialized(_this2)), "_decl", new core["Tw2VertexDeclaration"](EveCurveLineSet.vertexDeclarations, 4 * _this2._vertexSize));

    EveCurveLineSet.init();
    return _this2;
  }
  /**
   * Alias for this.items
   * @returns {Array}
   */


  EveCurveLineSet_createClass(EveCurveLineSet, [{
    key: "Initialize",

    /**
     * Initializes the curve line set
     */
    value: function Initialize() {
      this.OnValueChanged();
      this.Rebuild();
    }
    /**
     * Creates a straight line
     * @param {vec3} start
     * @param {vec3} end
     * @param {number} [width]
     * @param {vec4} [startColor]
     * @param {vec4} [endColor]
     * @returns {EveCurveLineSetItem}
     */

  }, {
    key: "AddStraightLine",
    value: function AddStraightLine(start, end, width, startColor, endColor) {
      return this.CreateItem({
        type: EveCurveLineSet_EveCurveLineSetItem.Type.STRAIGHT,
        position1: start,
        position2: end,
        color1: startColor,
        color2: endColor,
        width: width
      });
    }
    /**
     * Creates and adds a curved line from cartesian coordinates
     * @param {vec3} start
     * @param {vec3} end
     * @param {vec3} center
     * @param {number} [width]
     * @param {vec4} [startColor]
     * @param {vec4} [endColor]
     * @returns {EveCurveLineSetItem}
     */

  }, {
    key: "AddCurvedLineCrt",
    value: function AddCurvedLineCrt(start, end, center, width, startColor, endColor) {
      return this.CreateItem({
        type: EveCurveLineSet_EveCurveLineSetItem.Type.CURVED,
        position1: start,
        position2: end,
        intermediatePosition: center,
        color1: startColor,
        color2: endColor,
        width: width,
        numOfSegments: EveCurveLineSet_EveCurveLineSetItem.DEFAULT_CURVED_SEGMENTS
      });
    }
    /**
     * Creates and adds a curved line from spherical coordinates
     * @param {vec3} start
     * @param {vec3} end
     * @param {vec3} center
     * @param {vec3} middle
     * @param {number} [width]
     * @param {vec4} [startColor]
     * @param {vec4} [endColor]
     * @returns {EveCurveLineSetItem}
     */

  }, {
    key: "AddCurvedLineSph",
    value: function AddCurvedLineSph(start, end, center, middle, width, startColor, endColor) {
      const g = EveCurveLineSet.global;
      return this.CreateItem({
        type: EveCurveLineSet_EveCurveLineSetItem.Type.CURVED,
        position1: global["H" /* vec3 */].fromSpherical(g.vec3_0, start, center),
        position2: global["H" /* vec3 */].fromSpherical(g.vec3_1, end, center),
        intermediatePosition: global["H" /* vec3 */].fromSpherical(g.vec3_2, middle, center),
        color1: startColor,
        color2: endColor,
        width: width,
        numOfSegments: EveCurveLineSet_EveCurveLineSetItem.DEFAULT_CURVED_SEGMENTS
      });
    }
    /**
     * Creates and adds a sphered line from cartesian coordinates
     * @param {vec3} start
     * @param {vec3} end
     * @param {vec3} center
     * @param {number} [width]
     * @param {vec4} [startColor]
     * @param {vec4} [endColor]
     * @returns {EveCurveLineSetItem}
     */

  }, {
    key: "AddSpheredLineCrt",
    value: function AddSpheredLineCrt(start, end, center, width, startColor, endColor) {
      return this.CreateItem({
        type: EveCurveLineSet_EveCurveLineSetItem.Type.SPHERED,
        position1: start,
        position2: end,
        intermediatePosition: center,
        color1: startColor,
        color2: endColor,
        width: width,
        numOfSegments: EveCurveLineSet_EveCurveLineSetItem.DEFAULT_SPHERED_SEGMENTS
      });
    }
    /**
     * Creates and adds a sphered line from spherical coordinates
     * @param {vec3} start
     * @param {vec3} end
     * @param {vec3} center
     * @param {vec3} middle
     * @param {number} [width]
     * @param {vec4} [startColor]
     * @param {vec4} [endColor]
     * @returns {EveCurveLineSetItem}
     */

  }, {
    key: "AddSpheredLineSph",
    value: function AddSpheredLineSph(start, end, center, middle, width, startColor, endColor) {
      const g = EveCurveLineSet.global;
      return this.CreateItem({
        type: EveCurveLineSet_EveCurveLineSetItem.Type.SPHERED,
        position1: global["H" /* vec3 */].fromSpherical(g.vec3_0, start, center),
        position2: global["H" /* vec3 */].fromSpherical(g.vec3_1, end, center),
        intermediatePosition: global["H" /* vec3 */].fromSpherical(g.vec3_2, middle, center),
        color1: startColor,
        color2: endColor,
        width: width,
        numOfSegments: EveCurveLineSet_EveCurveLineSetItem.DEFAULT_SPHERED_SEGMENTS
      });
    }
    /**
     * Fire on value changes
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged() {
      global["z" /* mat4 */].fromRotationTranslationScale(this.transform, this.rotation, this.translation, this.scaling);
      this._rebuildPending = true;
    }
    /**
     * Per frame update
     * @param {mat4} parentTransform
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData(parentTransform) {
      global["z" /* mat4 */].copy(this.parentTransform, parentTransform);
    }
    /**
     * Per frame update
     */

  }, {
    key: "Update",
    value: function Update() {
      if (this._rebuildPending) {
        this.Rebuild();
      }
    }
    /**
     * Unloads the line set's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this._vb) {
        global["w" /* device */].gl.deleteBuffer(this._vb);
        this._vb = null;
      }
    }
    /**
     * Rebuilds the line set
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      EveCurveLineSet.RebuildItems(this);
      this._vb = null;
      this._vbSize = this.lineCount;
      this._rebuildPending = false;
      const visibleItems = this._visibleItems.length;
      if (!visibleItems) return;
      const g = EveCurveLineSet.global,
            data = new Float32Array(this._vbSize * 6 * this._vertexSize),
            startDir = g.vec3_0,
            endDir = g.vec3_1,
            startDirNrm = g.vec3_2,
            endDirNrm = g.vec3_3,
            rotationAxis = g.vec3_4,
            tangent1 = g.vec3_5,
            tangent2 = g.vec3_6,
            rotationMatrix = g.mat4_0;
      let dir1 = g.vec3_7,
          dir2 = g.vec3_8,
          pos1 = g.vec3_9,
          pos2 = g.vec3_10,
          col1 = g.vec4_0,
          col2 = g.vec4_1,
          offset = 0,
          tmp;

      for (let i = 0; i < visibleItems; ++i) {
        const item = this._visibleItems[i];

        switch (item.type) {
          case EveCurveLineSet_EveCurveLineSetItem.Type.INVALID:
            break;

          case EveCurveLineSet_EveCurveLineSetItem.Type.STRAIGHT:
            EveCurveLineSet.WriteLineVerticesToBuffer(this, item.position1, item.color1, 0, item.position2, item.color2, 1, i, data, offset);
            offset += 6 * this._vertexSize;
            break;

          case EveCurveLineSet_EveCurveLineSetItem.Type.SPHERED:
            global["H" /* vec3 */].subtract(startDir, item.position1, item.intermediatePosition);
            global["H" /* vec3 */].subtract(endDir, item.position2, item.intermediatePosition);
            global["H" /* vec3 */].normalize(startDirNrm, startDir);
            global["H" /* vec3 */].normalize(endDirNrm, endDir);
            global["H" /* vec3 */].cross(rotationAxis, startDir, endDir);
            const fullAngle = Math.acos(global["H" /* vec3 */].dot(startDirNrm, endDirNrm)),
                  segmentAngle = fullAngle / item.numOfSegments;
            global["z" /* mat4 */].identity(rotationMatrix);
            global["z" /* mat4 */].rotate(rotationMatrix, rotationMatrix, segmentAngle, rotationAxis);
            global["H" /* vec3 */].copy(dir1, startDir);
            global["I" /* vec4 */].copy(col1, item.color1);

            for (let j = 0; j < this.lines[i].numOfSegments; ++j) {
              const segmentFactor = (j + 1) / item.numOfSegments;
              global["H" /* vec3 */].transformMat4(dir2, dir1, rotationMatrix);
              col2[0] = item.color1[0] * (1 - segmentFactor) + item.color2[0] * segmentFactor;
              col2[1] = item.color1[1] * (1 - segmentFactor) + item.color2[1] * segmentFactor;
              col2[2] = item.color1[2] * (1 - segmentFactor) + item.color2[2] * segmentFactor;
              col2[3] = item.color1[3] * (1 - segmentFactor) + item.color2[3] * segmentFactor;
              global["H" /* vec3 */].add(pos1, dir1, item.intermediatePosition);
              global["H" /* vec3 */].add(pos2, dir2, item.intermediatePosition);
              EveCurveLineSet.WriteLineVerticesToBuffer(this, pos1, col1, j / item.numOfSegments, pos2, col2, segmentFactor, i, data, offset);
              offset += 6 * this._vertexSize;
              tmp = dir1;
              dir1 = dir2;
              dir2 = tmp;
              tmp = col1;
              col1 = col2;
              col2 = tmp;
            }

            break;

          case EveCurveLineSet_EveCurveLineSetItem.Type.CURVED:
            global["H" /* vec3 */].subtract(tangent1, item.intermediatePosition, item.position1);
            global["H" /* vec3 */].subtract(tangent2, item.position2, item.intermediatePosition);
            global["H" /* vec3 */].copy(pos1, item.position1);
            global["H" /* vec3 */].copy(col1, item.color1);

            for (let j = 0; j < item.numOfSegments; ++j) {
              const segmentFactor = (j + 1) / item.numOfSegments;
              global["H" /* vec3 */].hermite(pos2, item.position1, tangent1, item.position2, tangent2, segmentFactor);
              col2[0] = item.color1[0] * (1 - segmentFactor) + item.color2[0] * segmentFactor;
              col2[1] = item.color1[1] * (1 - segmentFactor) + item.color2[1] * segmentFactor;
              col2[2] = item.color1[2] * (1 - segmentFactor) + item.color2[2] * segmentFactor;
              col2[3] = item.color1[3] * (1 - segmentFactor) + item.color2[3] * segmentFactor;
              EveCurveLineSet.WriteLineVerticesToBuffer(this, pos1, col1, j / item.numOfSegments, pos2, col2, segmentFactor, i, data, offset);
              offset += 6 * this._vertexSize;
              tmp = pos1;
              pos1 = pos2;
              pos2 = tmp;
              tmp = col1;
              col1 = col2;
              col2 = tmp;
            }

        }
      } //if (this._vb) device.gl.deleteBuffer(this._vb);


      this._vb = global["w" /* device */].gl.createBuffer();
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, this._vb);
      global["w" /* device */].gl.bufferData(global["w" /* device */].gl.ARRAY_BUFFER, data, global["w" /* device */].gl.STATIC_DRAW);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, null);
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator) {
      if (!this.display || !this._vb) return;
      let effect;

      switch (mode) {
        case global["w" /* device */].RM_TRANSPARENT:
          if (this.additive || !this.lineEffect) return;
          effect = this.lineEffect;
          break;

        case global["w" /* device */].RM_ADDITIVE:
          if (!this.additive || !this.lineEffect) return;
          effect = this.lineEffect;
          break;

        case global["w" /* device */].RM_PICKABLE:
          if (!this.pickable || !this.pickEffect) return;
          effect = this.pickEffect;
      }

      const batch = new core["Tw2ForwardingRenderBatch"](),
            worldTransform = EveCurveLineSet.global.mat4_0;
      global["z" /* mat4 */].multiply(worldTransform, this.transform, this.parentTransform);
      global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), worldTransform);
      global["z" /* mat4 */].transpose(this._perObjectData.perObjectPSData.Get('WorldMat'), worldTransform);
      batch.perObjectData = this._perObjectData;
      batch.geometryProvider = this;
      batch.renderMode = mode;
      batch.effect = effect;
      accumulator.Commit(batch);
    }
    /**
     * Per frame update
     * @param {Tw2ForwardingRenderBatch} batch
     * @param {string} technique - technique name
     * @returns {boolean}
     */

  }, {
    key: "Render",
    value: function Render(batch, technique) {
      if (!batch.effect || !batch.effect.IsGood()) return false;
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, this._vb);
      let passCount = batch.effect.GetPassCount(technique);

      for (let pass = 0; pass < passCount; ++pass) {
        batch.effect.ApplyPass(technique, pass);
        let passInput = batch.effect.GetPassInput(technique, pass);
        if (!this._decl.SetDeclaration(passInput, this._decl.stride)) return false;
        global["w" /* device */].ApplyShadowState();
        global["w" /* device */].gl.drawArrays(global["w" /* device */].gl.TRIANGLES, 0, this._vbSize * 6);
      }

      return true;
    }
    /**
     * Fills color vertices
     * @param {EveCurveLineSetItem} item
     * @param buffer
     * @param {number} offset
     * @returns {number}
     */

  }, {
    key: "lines",
    get: function get() {
      return this.items;
    }
    /**
     * Alias for this.items
     * @param {Array} arr
     */
    ,
    set: function set(arr) {
      this.items = arr;
    }
    /**
     * Gets the current line count
     * @returns {number}
     */

  }, {
    key: "lineCount",
    get: function get() {
      let count = 0;

      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].type !== EveCurveLineSet_EveCurveLineSetItem.Type.INVALID) {
          count += this.items[i].numOfSegments;
        }
      }

      return count;
    }
  }], [{
    key: "FillColorVertices",
    value: function FillColorVertices(item, buffer, offset) {
      buffer[offset++] = item.multiColor[0];
      buffer[offset++] = item.multiColor[1];
      buffer[offset++] = item.multiColor[2];
      buffer[offset++] = item.multiColor[3];
      buffer[offset++] = item.overlayColor[0];
      buffer[offset++] = item.overlayColor[1];
      buffer[offset++] = item.overlayColor[2];
      buffer[offset++] = item.overlayColor[3];
      return offset;
    }
    /**
     * Writes line vertices to the vertex buffer
     * @param {EveCurveLineSet} lineSet
     * @param {vec3} start
     * @param {quat} startColor
     * @param length1
     * @param {vec3} end
     * @param {quat} endColor
     * @param length2
     * @param {Number} lineID
     * @param buffer
     * @param {Number} offset
     */

  }, {
    key: "WriteLineVerticesToBuffer",
    value: function WriteLineVerticesToBuffer(lineSet, start, startColor, length1, end, endColor, length2, lineID, buffer, offset) {
      const item = lineSet.items[lineID];
      buffer[offset++] = start[0];
      buffer[offset++] = start[1];
      buffer[offset++] = start[2];
      buffer[offset++] = end[0] - start[0];
      buffer[offset++] = end[1] - start[1];
      buffer[offset++] = end[2] - start[2];
      buffer[offset++] = -lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 0;
      buffer[offset++] = length1;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = startColor[0];
      buffer[offset++] = startColor[1];
      buffer[offset++] = startColor[2];
      buffer[offset++] = startColor[3];
      offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);
      buffer[offset++] = start[0];
      buffer[offset++] = start[1];
      buffer[offset++] = start[2];
      buffer[offset++] = end[0] - start[0];
      buffer[offset++] = end[1] - start[1];
      buffer[offset++] = end[2] - start[2];
      buffer[offset++] = lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 0;
      buffer[offset++] = length1;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = startColor[0];
      buffer[offset++] = startColor[1];
      buffer[offset++] = startColor[2];
      buffer[offset++] = startColor[3];
      offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);
      buffer[offset++] = end[0];
      buffer[offset++] = end[1];
      buffer[offset++] = end[2];
      buffer[offset++] = start[0] - end[0];
      buffer[offset++] = start[1] - end[1];
      buffer[offset++] = start[2] - end[2];
      buffer[offset++] = -lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 1;
      buffer[offset++] = length2;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = endColor[0];
      buffer[offset++] = endColor[1];
      buffer[offset++] = endColor[2];
      buffer[offset++] = endColor[3];
      offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);
      buffer[offset++] = start[0];
      buffer[offset++] = start[1];
      buffer[offset++] = start[2];
      buffer[offset++] = end[0] - start[0];
      buffer[offset++] = end[1] - start[1];
      buffer[offset++] = end[2] - start[2];
      buffer[offset++] = lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 0;
      buffer[offset++] = length1;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = startColor[0];
      buffer[offset++] = startColor[1];
      buffer[offset++] = startColor[2];
      buffer[offset++] = startColor[3];
      offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);
      buffer[offset++] = end[0];
      buffer[offset++] = end[1];
      buffer[offset++] = end[2];
      buffer[offset++] = start[0] - end[0];
      buffer[offset++] = start[1] - end[1];
      buffer[offset++] = start[2] - end[2];
      buffer[offset++] = lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 1;
      buffer[offset++] = length2;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = endColor[0];
      buffer[offset++] = endColor[1];
      buffer[offset++] = endColor[2];
      buffer[offset++] = endColor[3];
      offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);
      buffer[offset++] = end[0];
      buffer[offset++] = end[1];
      buffer[offset++] = end[2];
      buffer[offset++] = start[0] - end[0];
      buffer[offset++] = start[1] - end[1];
      buffer[offset++] = start[2] - end[2];
      buffer[offset++] = -lineSet.lineWidthFactor * item.width;
      buffer[offset++] = 1;
      buffer[offset++] = length2;
      buffer[offset++] = item.multiColorBorder;
      buffer[offset++] = length2 - length1;
      buffer[offset++] = item.animationSpeed;
      buffer[offset++] = item.animationScale;
      buffer[offset++] = lineID;
      buffer[offset++] = endColor[0];
      buffer[offset++] = endColor[1];
      buffer[offset++] = endColor[2];
      buffer[offset++] = endColor[3];
      EveCurveLineSet.FillColorVertices(item, buffer, offset);
    }
    /**
     * Initializes class global variables and scratch
     */

  }, {
    key: "init",
    value: function init() {
      if (!EveCurveLineSet.global) {
        EveCurveLineSet.global = {
          vec3_0: global["H" /* vec3 */].create(),
          // start direction
          vec3_1: global["H" /* vec3 */].create(),
          // end direction
          vec3_2: global["H" /* vec3 */].create(),
          // start direction normalized
          vec3_3: global["H" /* vec3 */].create(),
          // end direction normalized
          vec3_4: global["H" /* vec3 */].create(),
          // rotationAxis
          vec3_5: global["H" /* vec3 */].create(),
          // direction1
          vec3_6: global["H" /* vec3 */].create(),
          // direction2
          vec3_7: global["H" /* vec3 */].create(),
          // position 1
          vec3_8: global["H" /* vec3 */].create(),
          // position 2
          vec3_9: global["H" /* vec3 */].create(),
          // tangent1
          vec3_10: global["H" /* vec3 */].create(),
          // tangent2
          vec4_0: global["I" /* vec4 */].create(),
          // color 1
          vec4_1: global["I" /* vec4 */].create(),
          // color 2
          mat4_0: global["z" /* mat4 */].create() // rotationMatrix

        };
      }
    }
    /**
     * Line set item constructor
     * @type {EveCurveLineSetItem}
     */

  }]);

  return EveCurveLineSet;
}(EveObjectSet_EveObjectSet);

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSet, "Item", EveCurveLineSet_EveCurveLineSetItem);

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSet, "global", null);

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSet, "perObjectData", {
  VSData: [['WorldMat', 16]],
  PSData: [['WorldMat', 16]]
});

EveCurveLineSet_defineProperty(EveCurveLineSet_EveCurveLineSet, "vertexDeclarations", [['POSITION', 0, 3], ['TEXCOORD', 0, 4], ['TEXCOORD', 1, 4], ['TEXCOORD', 2, 3], ['COLOR', 0, 4], ['COLOR', 1, 4], ['COLOR', 2, 4]]);
// CONCATENATED MODULE: ./eve/item/EveLocator.js
function EveLocator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveLocator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveLocator_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveLocator_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveLocator_defineProperties(Constructor, staticProps); return Constructor; }

function EveLocator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Contains transform information for T3 Attachments, Boosters, Turrets and XLTurrets
 *
 * @property {string} name                  - The locator's name
 * @property {mat4} transform               - The locator's transform
 * @property {?number} atlasIndex0          - A booster locator's atlasIndex0
 * @property {?number} atlasIndex1          - A booster locator's atlasIndex1
 * @property {?Tw2Bone} bone                - A turret locator's bone
 */

let EveLocator_EveLocator =
/*#__PURE__*/
function () {
  function EveLocator() {
    EveLocator_classCallCheck(this, EveLocator);

    EveLocator_defineProperty(this, "name", '');

    EveLocator_defineProperty(this, "transform", global["z" /* mat4 */].create());

    EveLocator_defineProperty(this, "atlasIndex0", null);

    EveLocator_defineProperty(this, "atlasIndex1", null);

    EveLocator_defineProperty(this, "bone", null);
  }

  EveLocator_createClass(EveLocator, [{
    key: "FindBone",

    /**
     * Gets the locator's bone from an animation controller
     * @param {Tw2AnimationController} animationController
     * @returns {?Tw2Bone}
     */
    value: function FindBone(animationController) {
      this.bone = null;
      const model = animationController.FindModelForMesh(0);

      if (model) {
        for (let i = 0; i < model.bones.length; ++i) {
          if (model.bones[i].boneRes.name === this.name) {
            this.bone = model.bones[i];
            break;
          }
        }
      }

      return this.bone;
    }
    /**
     * Locator name prefixes
     * @type {{AUDIO: string, ATTACH: string, BOOSTER: string, TURRET: string, XL_TURRET: string}}
     */

  }]);

  return EveLocator;
}();

EveLocator_defineProperty(EveLocator_EveLocator, "Prefix", {
  AUDIO: 'locator_audio',
  ATTACH: 'locator_attach',
  BOOSTER: 'locator_booster',
  TURRET: 'locator_turret',
  XL_TURRET: 'locator_xl'
});
// CONCATENATED MODULE: ./eve/item/EvePlaneSet.js
function EvePlaneSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EvePlaneSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EvePlaneSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EvePlaneSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EvePlaneSet_defineProperties(Constructor, staticProps); return Constructor; }

function EvePlaneSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EvePlaneSet_assertThisInitialized(self); }

function EvePlaneSet_getPrototypeOf(o) { EvePlaneSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EvePlaneSet_getPrototypeOf(o); }

function EvePlaneSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EvePlaneSet_setPrototypeOf(subClass, superClass); }

function EvePlaneSet_setPrototypeOf(o, p) { EvePlaneSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EvePlaneSet_setPrototypeOf(o, p); }

function EvePlaneSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EvePlaneSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Plane set render batch
 *
 * @property {EvePlaneSet} planeSet
 * @class
 */

let EvePlaneSetBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  EvePlaneSet_inherits(EvePlaneSetBatch, _Tw2RenderBatch);

  function EvePlaneSetBatch() {
    var _this;

    EvePlaneSet_classCallCheck(this, EvePlaneSetBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EvePlaneSet_possibleConstructorReturn(this, EvePlaneSet_getPrototypeOf(EvePlaneSetBatch).call(this, ...args));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this)), "planeSet", null);

    return _this;
  }

  EvePlaneSet_createClass(EvePlaneSetBatch, [{
    key: "Commit",

    /**
     * Commits the plan set
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      this.planeSet.Render(technique);
    }
  }]);

  return EvePlaneSetBatch;
}(core["Tw2RenderBatch"]);
/**
 * EvePlaneSetItem
 *
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @property {number} maskAtlasID
 * @property {vec3} position
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec4} color
 * @property {vec4} layer1Transform
 * @property {vec4} layer2Transform
 * @property {vec4} layer1Scroll
 * @property {vec4} layer2Scroll
 * @class
 */

let EvePlaneSet_EvePlaneSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EvePlaneSet_inherits(EvePlaneSetItem, _EveObjectSetItem);

  function EvePlaneSetItem() {
    var _this2;

    EvePlaneSet_classCallCheck(this, EvePlaneSetItem);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = EvePlaneSet_possibleConstructorReturn(this, EvePlaneSet_getPrototypeOf(EvePlaneSetItem).call(this, ...args));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "boneIndex", 0);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "groupIndex", -1);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "maskAtlasID", 0);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "position", global["H" /* vec3 */].create());

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "scaling", global["H" /* vec3 */].fromValues(1, 1, 1));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "rotation", global["C" /* quat */].create());

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "transform", global["z" /* mat4 */].create());

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "color", global["I" /* vec4 */].fromValues(1, 1, 1, 1));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "layer1Transform", global["I" /* vec4 */].fromValues(1, 1, 0, 0));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "layer2Transform", global["I" /* vec4 */].fromValues(1, 1, 0, 0));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "layer1Scroll", global["I" /* vec4 */].create());

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this2)), "layer2Scroll", global["I" /* vec4 */].create());

    return _this2;
  }

  EvePlaneSet_createClass(EvePlaneSetItem, null, [{
    key: "create",

    /**
     * Creates a plane set item from an object
     * @param {*} opt
     * @returns {EvePlaneSetItem}
     */
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'boneIndex', 'groupIndex', 'maskAtlasID', 'position', 'scaling', 'rotation', 'transform', 'color', 'layer1Transform', 'layer2Transform', 'layer1Scroll', 'layer2Scroll']);
      return item;
    }
  }]);

  return EvePlaneSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EvePlaneSet
 *
 * @property {String} name
 * @property {Array.<EvePlaneSetItem>} planes
 * @property {Tw2Effect} effect
 * @property {boolean} display
 * @property {boolean} hideOnLowQuality
 * @property {number} _time
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 * @class
 */

let EvePlaneSet_EvePlaneSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EvePlaneSet_inherits(EvePlaneSet, _EveObjectSet);

  function EvePlaneSet() {
    var _this3;

    EvePlaneSet_classCallCheck(this, EvePlaneSet);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = EvePlaneSet_possibleConstructorReturn(this, EvePlaneSet_getPrototypeOf(EvePlaneSet).call(this, ...args));

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "effect", null);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "hideOnLowQuality", false);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "_time", 0);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "_vertexBuffer", null);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "_indexBuffer", null);

    EvePlaneSet_defineProperty(EvePlaneSet_assertThisInitialized(EvePlaneSet_assertThisInitialized(_this3)), "_decl", new core["Tw2VertexDeclaration"](EvePlaneSet.vertexDeclarations));

    return _this3;
  }

  EvePlaneSet_createClass(EvePlaneSet, [{
    key: "GetResources",

    /**
     * Gets plane set res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array} {Array.<Tw2Resource>} [out]
     */
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.effect) {
        this.effect.GetResources(out);
      }

      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - Delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      this._time += dt;

      if (this._rebuildPending) {
        this.Rebuild();
      }
    }
    /**
     * Unloads the set's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this._vertexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._vertexBuffer);
        this._vertexBuffer = null;
      }

      if (this._indexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._indexBuffer);
        this._indexBuffer = null;
      }
    }
    /**
     * Rebuilds the plane set's buffers
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      this.Unload();
      EvePlaneSet.RebuildItems(this);
      this._rebuildPending = false;
      const itemCount = this._visibleItems.length;
      if (!itemCount) return;
      const vertexSize = 35,
            mat4_0 = EvePlaneSet.global.mat4_0;
      const array = new Float32Array(itemCount * 4 * vertexSize);

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i],
              offset = i * 4 * vertexSize;
        array[offset + vertexSize - 3] = 0;
        array[offset + vertexSize + vertexSize - 3] = 1;
        array[offset + 2 * vertexSize + vertexSize - 3] = 2;
        array[offset + 3 * vertexSize + vertexSize - 3] = 3;
        const itemTransform = global["z" /* mat4 */].fromRotationTranslationScale(mat4_0, item.rotation, item.position, item.scaling);

        for (let j = 0; j < 4; ++j) {
          const vtxOffset = offset + j * vertexSize;
          array[vtxOffset] = itemTransform[0];
          array[vtxOffset + 1] = itemTransform[4];
          array[vtxOffset + 2] = itemTransform[8];
          array[vtxOffset + 3] = itemTransform[12];
          array[vtxOffset + 4] = itemTransform[1];
          array[vtxOffset + 5] = itemTransform[5];
          array[vtxOffset + 6] = itemTransform[9];
          array[vtxOffset + 7] = itemTransform[13];
          array[vtxOffset + 8] = itemTransform[2];
          array[vtxOffset + 9] = itemTransform[6];
          array[vtxOffset + 10] = itemTransform[10];
          array[vtxOffset + 11] = itemTransform[14];
          array[vtxOffset + 12] = item.color[0];
          array[vtxOffset + 13] = item.color[1];
          array[vtxOffset + 14] = item.color[2];
          array[vtxOffset + 15] = item.color[3];
          array[vtxOffset + 16] = item.layer1Transform[0];
          array[vtxOffset + 17] = item.layer1Transform[1];
          array[vtxOffset + 18] = item.layer1Transform[2];
          array[vtxOffset + 19] = item.layer1Transform[3];
          array[vtxOffset + 20] = item.layer2Transform[0];
          array[vtxOffset + 21] = item.layer2Transform[1];
          array[vtxOffset + 22] = item.layer2Transform[2];
          array[vtxOffset + 23] = item.layer2Transform[3];
          array[vtxOffset + 24] = item.layer1Scroll[0];
          array[vtxOffset + 25] = item.layer1Scroll[1];
          array[vtxOffset + 26] = item.layer1Scroll[2];
          array[vtxOffset + 27] = item.layer1Scroll[3];
          array[vtxOffset + 28] = item.layer2Scroll[0];
          array[vtxOffset + 29] = item.layer2Scroll[1];
          array[vtxOffset + 30] = item.layer2Scroll[2];
          array[vtxOffset + 31] = item.layer2Scroll[3];
          array[vtxOffset + 33] = item.boneIndex;
          array[vtxOffset + 34] = item.maskAtlasID;
        }
      }

      this._vertexBuffer = global["w" /* device */].gl.createBuffer();
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, this._vertexBuffer);
      global["w" /* device */].gl.bufferData(global["w" /* device */].gl.ARRAY_BUFFER, array, global["w" /* device */].gl.STATIC_DRAW);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, null);
      const indexes = new Uint16Array(itemCount * 6);

      for (let i = 0; i < itemCount; ++i) {
        const offset = i * 6,
              vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 2;
        indexes[offset + 2] = vtxOffset + 1;
        indexes[offset + 3] = vtxOffset;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset + 2;
      }

      this._indexBuffer = global["w" /* device */].gl.createBuffer();
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      global["w" /* device */].gl.bufferData(global["w" /* device */].gl.ELEMENT_ARRAY_BUFFER, indexes, global["w" /* device */].gl.STATIC_DRAW);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ELEMENT_ARRAY_BUFFER, null);
      this._indexBuffer.count = itemCount * 6;
    }
    /**
     * Gets the plane set's render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (this.display && mode === global["w" /* device */].RM_ADDITIVE && this._indexBuffer && this._visibleItems.length) {
        const batch = new EvePlaneSetBatch();
        batch.renderMode = global["w" /* device */].RM_ADDITIVE;
        batch.planeSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
      }
    }
    /**
     * Renders the plane set
     * @param {string} technique - technique name
     */

  }, {
    key: "Render",
    value: function Render(technique) {
      if (!this.effect || !this.effect.IsGood()) return false;
      global["w" /* device */].SetStandardStates(global["w" /* device */].RM_ADDITIVE);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, this._vertexBuffer);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

      for (let pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
        this.effect.ApplyPass(technique, pass);
        if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 140)) return false;
        global["w" /* device */].ApplyShadowState();
        global["w" /* device */].gl.drawElements(global["w" /* device */].gl.TRIANGLES, this._indexBuffer.count, global["w" /* device */].gl.UNSIGNED_SHORT, 0);
      }

      return true;
    }
    /**
     * The plane set's item constructor
     * @type {EvePlaneSetItem}
     */

  }, {
    key: "planes",

    /**
     * Alias for this.items
     * @returns {Array}
     */
    get: function get() {
      return this.items;
    }
    /**
     * Alias for this.items
     * @param {Array} arr
     */
    ,
    set: function set(arr) {
      this.items = arr;
    }
  }]);

  return EvePlaneSet;
}(EveObjectSet_EveObjectSet);

EvePlaneSet_defineProperty(EvePlaneSet_EvePlaneSet, "Item", EvePlaneSet_EvePlaneSetItem);

EvePlaneSet_defineProperty(EvePlaneSet_EvePlaneSet, "vertexDeclarations", [['TEXCOORD', 0, 4], ['TEXCOORD', 1, 4], ['TEXCOORD', 2, 4], ['COLOR', 0, 4], ['TEXCOORD', 3, 4], ['TEXCOORD', 4, 4], ['TEXCOORD', 5, 4], ['TEXCOORD', 6, 4], ['TEXCOORD', 7, 3]]);
// CONCATENATED MODULE: ./eve/item/EveSpaceObjectDecal.js
function EveSpaceObjectDecal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveSpaceObjectDecal_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveSpaceObjectDecal_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveSpaceObjectDecal_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveSpaceObjectDecal_defineProperties(Constructor, staticProps); return Constructor; }

function EveSpaceObjectDecal_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * EveSpaceObjectDecal
 *
 * @property {String|number} _id
 * @property {String} name
 * @property {boolean} display
 * @property {Tw2Effect} decalEffect
 * @property {Tw2Effect} pickEffect
 * @property {Tw2GeometryRes} parentGeometry
 * @property {number} parentBoneIndex
 * @property {number} groupIndex
 * @property {boolean} pickable
 * @property {vec3} position
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} decalMatrix
 * @property {mat4} invDecalMatrix
 * @property {Array} indexBuffer
 * @property {*} _indexBuffer
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */

let EveSpaceObjectDecal_EveSpaceObjectDecal =
/*#__PURE__*/
function () {
  function EveSpaceObjectDecal() {
    EveSpaceObjectDecal_classCallCheck(this, EveSpaceObjectDecal);

    EveSpaceObjectDecal_defineProperty(this, "_id", global["F" /* util */].generateID());

    EveSpaceObjectDecal_defineProperty(this, "name", '');

    EveSpaceObjectDecal_defineProperty(this, "display", true);

    EveSpaceObjectDecal_defineProperty(this, "decalEffect", null);

    EveSpaceObjectDecal_defineProperty(this, "pickEffect", null);

    EveSpaceObjectDecal_defineProperty(this, "parentGeometry", null);

    EveSpaceObjectDecal_defineProperty(this, "parentBoneIndex", -1);

    EveSpaceObjectDecal_defineProperty(this, "groupIndex", -1);

    EveSpaceObjectDecal_defineProperty(this, "pickable", true);

    EveSpaceObjectDecal_defineProperty(this, "position", global["H" /* vec3 */].create());

    EveSpaceObjectDecal_defineProperty(this, "rotation", global["C" /* quat */].create());

    EveSpaceObjectDecal_defineProperty(this, "scaling", global["H" /* vec3 */].create());

    EveSpaceObjectDecal_defineProperty(this, "decalMatrix", global["z" /* mat4 */].create());

    EveSpaceObjectDecal_defineProperty(this, "invDecalMatrix", global["z" /* mat4 */].create());

    EveSpaceObjectDecal_defineProperty(this, "indexBuffer", []);

    EveSpaceObjectDecal_defineProperty(this, "_indexBuffer", null);

    EveSpaceObjectDecal_defineProperty(this, "_perObjectData", new core["Tw2PerObjectData"](EveSpaceObjectDecal.perObjectData));
  }

  EveSpaceObjectDecal_createClass(EveSpaceObjectDecal, [{
    key: "Initialize",

    /**
     * Initializes the decal
     */
    value: function Initialize() {
      this.SetIndexBuffer(this.indexBuffer);
    }
    /**
     * Fire on value changes
     */

  }, {
    key: "OnValueChanged",
    value: function OnValueChanged() {
      if (!this._indexBuffer && this.indexBuffer) {
        const gl = global["w" /* device */].gl,
              indexes = new Uint16Array(this.indexBuffer);
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexes, gl.STATIC_DRAW);
      }

      global["z" /* mat4 */].fromRotationTranslationScale(this.decalMatrix, this.rotation, this.position, this.scaling);
      global["z" /* mat4 */].invert(this.invDecalMatrix, this.decalMatrix);
    }
    /**
     * Sets the parent geometry
     * @param {Tw2GeometryRes} geometryRes
     */

  }, {
    key: "SetParentGeometry",
    value: function SetParentGeometry(geometryRes) {
      this.parentGeometry = geometryRes;
    }
    /**
     * Sets the decal's index buffer
     * @param {number[]} indices
     */

  }, {
    key: "SetIndexBuffer",
    value: function SetIndexBuffer(indices) {
      this.indexBuffer = indices;
      this.Unload();
      this.OnValueChanged();
    }
    /**
     * Gets decal resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.parentGeometry && !out.includes(this.parentGeometry)) {
        out.push(this.parentGeometry);
      }

      if (this.decalEffect) this.decalEffect.GetResources(out);
      if (this.pickEffect) this.pickEffect.GetResources(out);
      return out;
    }
    /**
     * Unloads the decal's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this._indexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._indexBuffer);
        this._indexBuffer = null;
      }
    }
    /**
     * Gets batches for rendering
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {number} [counter=0]
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData, counter) {
      let effect;

      switch (mode) {
        case global["w" /* device */].RM_DECAL:
          effect = this.decalEffect;
          break;

        case global["w" /* device */].RM_PICKABLE:
          effect = this.pickable ? this.pickEffect : null;
          break;
      }

      if (this.display && effect && effect.IsGood() && this.indexBuffer.length && this.parentGeometry && this.parentGeometry.IsGood()) {
        const batch = new core["Tw2ForwardingRenderBatch"]();

        this._perObjectData.perObjectVSData.Set('worldMatrix', perObjectData.perObjectVSData.Get('WorldMat'));

        if (this.parentBoneIndex >= 0) {
          const bones = perObjectData.perObjectVSData.Get('JointMat'),
                offset = this.parentBoneIndex * 12;

          if (bones[offset] || bones[offset + 4] || bones[offset + 8]) {
            const bone = this._perObjectData.perObjectVSData.Get('parentBoneMatrix');

            bone[0] = bones[offset];
            bone[1] = bones[offset + 4];
            bone[2] = bones[offset + 8];
            bone[3] = 0;
            bone[4] = bones[offset + 1];
            bone[5] = bones[offset + 5];
            bone[6] = bones[offset + 9];
            bone[7] = 0;
            bone[8] = bones[offset + 2];
            bone[9] = bones[offset + 6];
            bone[10] = bones[offset + 10];
            bone[11] = 0;
            bone[12] = bones[offset + 3];
            bone[13] = bones[offset + 7];
            bone[14] = bones[offset + 11];
            bone[15] = 1;
            global["z" /* mat4 */].transpose(bone, bone);
          }
        }

        global["z" /* mat4 */].invert(this._perObjectData.perObjectVSData.Get('invWorldMatrix'), this._perObjectData.perObjectVSData.Get('worldMatrix'));
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('decalMatrix'), this.decalMatrix);
        global["z" /* mat4 */].transpose(this._perObjectData.perObjectVSData.Get('invDecalMatrix'), this.invDecalMatrix);
        this._perObjectData.perObjectPSData.Get('displayData')[0] = counter || 0;

        this._perObjectData.perObjectPSData.Set('shipData', perObjectData.perObjectPSData.data);

        batch.perObjectData = this._perObjectData;
        batch.geometryProvider = this;
        batch.renderMode = mode;
        batch.effect = effect;
        accumulator.Commit(batch);
      }
    }
    /**
     * Renders the decal
     * @param {Tw2ForwardingRenderBatch} batch
     * @param {string} technique - technique name
     */

  }, {
    key: "Render",
    value: function Render(batch, technique) {
      const bkIB = this.parentGeometry.meshes[0].indexes,
            bkStart = this.parentGeometry.meshes[0].areas[0].start,
            bkCount = this.parentGeometry.meshes[0].areas[0].count,
            bkIndexType = this.parentGeometry.meshes[0].indexType;
      global["E" /* store */].SetVariableValue('u_DecalMatrix', this.decalMatrix);
      global["E" /* store */].SetVariableValue('u_InvDecalMatrix', this.invDecalMatrix);
      this.parentGeometry.meshes[0].indexes = this._indexBuffer;
      this.parentGeometry.meshes[0].areas[0].start = 0;
      this.parentGeometry.meshes[0].areas[0].count = this.indexBuffer.length;
      this.parentGeometry.meshes[0].indexType = global["w" /* device */].gl.UNSIGNED_SHORT;
      this.parentGeometry.RenderAreas(0, 0, 1, batch.effect, technique);
      this.parentGeometry.meshes[0].indexes = bkIB;
      this.parentGeometry.meshes[0].areas[0].start = bkStart;
      this.parentGeometry.meshes[0].areas[0].count = bkCount;
      this.parentGeometry.meshes[0].indexType = bkIndexType;
    }
    /**
     * Per object data
     * @type {{VSData: *[], PSData: *[]}}
     */

  }]);

  return EveSpaceObjectDecal;
}();

EveSpaceObjectDecal_defineProperty(EveSpaceObjectDecal_EveSpaceObjectDecal, "perObjectData", {
  VSData: [['worldMatrix', 16], ['invWorldMatrix', 16], ['decalMatrix', 16], ['invDecalMatrix', 16], ['parentBoneMatrix', 16, global["z" /* mat4 */].identity([])]],
  PSData: [['displayData', 4], ['shipData', 4 * 3]]
});
// CONCATENATED MODULE: ./eve/item/EveSpotlightSet.js
function EveSpotlightSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveSpotlightSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveSpotlightSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveSpotlightSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveSpotlightSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveSpotlightSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveSpotlightSet_assertThisInitialized(self); }

function EveSpotlightSet_getPrototypeOf(o) { EveSpotlightSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveSpotlightSet_getPrototypeOf(o); }

function EveSpotlightSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveSpotlightSet_setPrototypeOf(subClass, superClass); }

function EveSpotlightSet_setPrototypeOf(o, p) { EveSpotlightSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveSpotlightSet_setPrototypeOf(o, p); }

function EveSpotlightSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveSpotlightSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveSpotlightSetBatch
 *
 * @property {EveSpotlightSet} spotlightSet
 * @class
 */

let EveSpotlightSetBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  EveSpotlightSet_inherits(EveSpotlightSetBatch, _Tw2RenderBatch);

  function EveSpotlightSetBatch() {
    var _this;

    EveSpotlightSet_classCallCheck(this, EveSpotlightSetBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveSpotlightSet_possibleConstructorReturn(this, EveSpotlightSet_getPrototypeOf(EveSpotlightSetBatch).call(this, ...args));

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this)), "spotlightSet", null);

    return _this;
  }

  EveSpotlightSet_createClass(EveSpotlightSetBatch, [{
    key: "Commit",

    /**
     * Commits the spotlight set for rendering
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      this.spotlightSet.RenderCones(technique);
      this.spotlightSet.RenderGlow(technique);
    }
  }]);

  return EveSpotlightSetBatch;
}(core["Tw2RenderBatch"]);
/**
 * Spotlight Item
 *
 * @property {mat4} transform               - The spotlight's transform
 * @property {vec4} coneColor               - Colour of the spotlight's cone
 * @property {vec4} spriteColor             - Colour of the spotlight's sprite texture
 * @property {vec4} flareColor              - Colour of the spotlight's flare
 * @property {vec4} spriteScale             - The size of the spotlight
 * @property {number} boosterGainInfluence  - If true, the spotlight can change size on booster gain
 * @property {number} boneIndex             - The spotlight's bone index
 * @property {number} groupIndex            - The sof faction group that the spotlight belongs to
 * @property {number} coneIntensity         - Scales the spotlight's cone colour, set by an object's sof Faction
 * @property {number} spriteIntensity       - Scales the spotlight's sprite colour, set by an object's sof Faction
 * @property {number} flareIntensity        - Scales the spotlight's flare colour, set by an object's sof Faction
 * @class
 */

let EveSpotlightSet_EveSpotlightSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EveSpotlightSet_inherits(EveSpotlightSetItem, _EveObjectSetItem);

  function EveSpotlightSetItem() {
    var _this2;

    EveSpotlightSet_classCallCheck(this, EveSpotlightSetItem);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = EveSpotlightSet_possibleConstructorReturn(this, EveSpotlightSet_getPrototypeOf(EveSpotlightSetItem).call(this, ...args));

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "transform", global["z" /* mat4 */].create());

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "coneColor", global["I" /* vec4 */].create());

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "spriteColor", global["I" /* vec4 */].create());

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "flareColor", global["I" /* vec4 */].create());

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "spriteScale", global["H" /* vec3 */].fromValues(1, 1, 1));

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "boosterGainInfluence", 0);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "boneIndex", 0);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "groupIndex", -1);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "coneIntensity", 0);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "spriteIntensity", 0);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this2)), "flareIntensity", 0);

    return _this2;
  }

  EveSpotlightSet_createClass(EveSpotlightSetItem, null, [{
    key: "create",

    /**
     * Creates a spotlight set item from an object
     * @param {*} [opt={}
     * @returns {EveSpotlightSetItem}
     */
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'boosterGainInfluence', 'boneIndex', 'groupIndex', 'coneIntensity', 'spriteIntensity', 'flareIntensity', 'transform', 'coneColor', 'spriteColor', 'flareColor', 'spriteScale']);
      return item;
    }
  }]);

  return EveSpotlightSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EveSpotlightSet
 *
 * @property {string} name                               - The spotlight set's name
 * @property {boolean} display                           - controls the visibility of the spotlight set, and all it's children
 * @property {Tw2Effect} coneEffect                      - The spotlight set's cone effect
 * @property {Tw2Effect} glowEffect                      - The spotlight set's glow effect
 * @property {Array.<EveSpotlightSetItem) spotlightItems - The spotlight set's children
 * @property {WebGLBuffer} _coneVertexBuffer             - Webgl buffer for the spotlight set's cone vertices
 * @property {WebGLBuffer} _spriteVertexBuffer           - Webgl buffer for the spotlight set's sprite/glow vertices
 * @property {WebGLBuffer} _indexBuffer                  - Webgl buffer for the spotlight set
 * @property {Tw2VertexDeclaration} _decl                - The spotlight set's vertex declarations
 * @class
 */

let EveSpotlightSet_EveSpotlightSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EveSpotlightSet_inherits(EveSpotlightSet, _EveObjectSet);

  function EveSpotlightSet() {
    var _this3;

    EveSpotlightSet_classCallCheck(this, EveSpotlightSet);

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = EveSpotlightSet_possibleConstructorReturn(this, EveSpotlightSet_getPrototypeOf(EveSpotlightSet).call(this, ...args));

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "coneEffect", null);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "glowEffect", null);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "_coneVertexBuffer", null);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "_spriteVertexBuffer", null);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "_indexBuffer", null);

    EveSpotlightSet_defineProperty(EveSpotlightSet_assertThisInitialized(EveSpotlightSet_assertThisInitialized(_this3)), "_decl", new core["Tw2VertexDeclaration"](EveSpotlightSet.vertexDeclarations));

    return _this3;
  }

  EveSpotlightSet_createClass(EveSpotlightSet, [{
    key: "GetResources",

    /**
     * Gets the spotlight set's resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.coneEffect) {
        this.coneEffect.GetResources(out);
      }

      if (this.glowEffect) {
        this.glowEffect.GetResources(out);
      }

      return out;
    }
    /**
     * Unloads the spotlight set's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      if (this._coneVertexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._coneVertexBuffer);
        this._coneVertexBuffer = null;
      }

      if (this._spriteVertexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._spriteVertexBuffer);
        this._spriteVertexBuffer = null;
      }

      if (this._indexBuffer) {
        global["w" /* device */].gl.deleteBuffer(this._indexBuffer);
        this._indexBuffer = null;
      }
    }
    /**
     * Rebuilds the spotlight set's buffers
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      this.Unload();
      EveSpotlightSet.RebuildItems(this);
      this._rebuildPending = false;
      const itemCount = this._visibleItems.length;
      if (!itemCount) return;
      const d = global["w" /* device */],
            vertCount = 4,
            coneQuadCount = 4,
            coneVertexCount = itemCount * coneQuadCount * vertCount,
            vertexSize = 22,
            coneIndices = [1, 0, 2, 3],
            coneArray = new Float32Array(coneVertexCount * vertexSize);

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i];

        for (let q = 0; q < coneQuadCount; ++q) {
          for (let v = 0; v < vertCount; ++v) {
            const offset = (i * coneQuadCount * vertCount + vertCount * q + v) * vertexSize;
            coneArray[offset] = item.coneColor[0] * item.coneIntensity;
            coneArray[offset + 1] = item.coneColor[1] * item.coneIntensity;
            coneArray[offset + 2] = item.coneColor[2] * item.coneIntensity;
            coneArray[offset + 3] = item.coneColor[3];
            coneArray[offset + 4] = item.transform[0];
            coneArray[offset + 5] = item.transform[4];
            coneArray[offset + 6] = item.transform[8];
            coneArray[offset + 7] = item.transform[12];
            coneArray[offset + 8] = item.transform[1];
            coneArray[offset + 9] = item.transform[5];
            coneArray[offset + 10] = item.transform[9];
            coneArray[offset + 11] = item.transform[13];
            coneArray[offset + 12] = item.transform[2];
            coneArray[offset + 13] = item.transform[6];
            coneArray[offset + 14] = item.transform[10];
            coneArray[offset + 15] = item.transform[14];
            coneArray[offset + 16] = 1;
            coneArray[offset + 17] = 1;
            coneArray[offset + 18] = 1;
            coneArray[offset + 19] = q * vertCount + coneIndices[v];
            coneArray[offset + 20] = item.boneIndex;
            coneArray[offset + 21] = item.boosterGainInfluence ? 255 : 0;
          }
        }
      }

      this._coneVertexBuffer = d.gl.createBuffer();
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._coneVertexBuffer);
      d.gl.bufferData(d.gl.ARRAY_BUFFER, coneArray, d.gl.STATIC_DRAW);
      this._coneVertexBuffer.count = itemCount * coneQuadCount * 6;
      const spriteQuadCount = 2,
            spriteVertexCount = itemCount * spriteQuadCount * vertCount,
            spriteArray = new Float32Array(spriteVertexCount * vertexSize),
            spriteIndexes = [1, 0, 2, 3];

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i];

        for (let q = 0; q < spriteQuadCount; ++q) {
          for (let v = 0; v < vertCount; ++v) {
            const offset = (i * spriteQuadCount * vertCount + vertCount * q + v) * vertexSize;

            if (q % 2 === 0) {
              spriteArray[offset] = item.spriteColor[0] * item.spriteIntensity;
              spriteArray[offset + 1] = item.spriteColor[1] * item.spriteIntensity;
              spriteArray[offset + 2] = item.spriteColor[2] * item.spriteIntensity;
              spriteArray[offset + 3] = item.spriteColor[3];
              spriteArray[offset + 16] = item.spriteScale[0];
              spriteArray[offset + 17] = 1;
              spriteArray[offset + 18] = 1;
            } else {
              spriteArray[offset] = item.flareColor[0] * item.flareIntensity;
              spriteArray[offset + 1] = item.flareColor[1] * item.flareIntensity;
              spriteArray[offset + 2] = item.flareColor[2] * item.flareIntensity;
              spriteArray[offset + 3] = item.flareColor[3];
              spriteArray[offset + 16] = 1;
              spriteArray[offset + 17] = item.spriteScale[1];
              spriteArray[offset + 18] = item.spriteScale[2];
            }

            spriteArray[offset + 4] = item.transform[0];
            spriteArray[offset + 5] = item.transform[4];
            spriteArray[offset + 6] = item.transform[8];
            spriteArray[offset + 7] = item.transform[12];
            spriteArray[offset + 8] = item.transform[1];
            spriteArray[offset + 9] = item.transform[5];
            spriteArray[offset + 10] = item.transform[9];
            spriteArray[offset + 11] = item.transform[13];
            spriteArray[offset + 12] = item.transform[2];
            spriteArray[offset + 13] = item.transform[6];
            spriteArray[offset + 14] = item.transform[10];
            spriteArray[offset + 15] = item.transform[14];
            spriteArray[offset + 19] = q * vertCount + spriteIndexes[v];
            spriteArray[offset + 20] = item.boneIndex;
            spriteArray[offset + 21] = item.boosterGainInfluence ? 255 : 0;
          }
        }
      }

      this._spriteVertexBuffer = d.gl.createBuffer();
      d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._spriteVertexBuffer);
      d.gl.bufferData(d.gl.ARRAY_BUFFER, spriteArray, d.gl.STATIC_DRAW);
      this._spriteVertexBuffer.count = itemCount * spriteQuadCount * 6;
      const indexes = new Uint16Array(itemCount * coneQuadCount * 6);

      for (let i = 0; i < itemCount * coneQuadCount; ++i) {
        const offset = i * 6,
              vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 1;
        indexes[offset + 2] = vtxOffset + 2;
        indexes[offset + 3] = vtxOffset + 2;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset;
      }

      this._indexBuffer = d.gl.createBuffer();
      d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      d.gl.bufferData(d.gl.ELEMENT_ARRAY_BUFFER, indexes, d.gl.STATIC_DRAW);
      d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, null);
      this._indexBuffer.count = itemCount;
    }
    /**
     * Gets the spotlight set's render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData) {
      if (this.display && mode === global["w" /* device */].RM_ADDITIVE && this._indexBuffer && this._indexBuffer.count) {
        const batch = new EveSpotlightSetBatch();
        batch.renderMode = global["w" /* device */].RM_ADDITIVE;
        batch.spotlightSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
      }
    }
    /**
     * Renders the spotlight set's cone effect
     * @param {string} technique - technique name
     * @returns {boolean}
     */

  }, {
    key: "RenderCones",
    value: function RenderCones(technique) {
      return EveSpotlightSet.Render(this, this.coneEffect, technique, this._coneVertexBuffer);
    }
    /**
     * Renders the spotlight set's glow effect
     * @param {string} technique - technique name
     * @returns {boolean}
     */

  }, {
    key: "RenderGlow",
    value: function RenderGlow(technique) {
      return EveSpotlightSet.Render(this, this.glowEffect, technique, this._spriteVertexBuffer);
    }
    /**
     * Internal render function
     * @param {EveSpotlightSet} spotlightSet
     * @param {Tw2Effect} effect   - The Tw2Effect to render
     * @param {string} technique - technique name
     * @param {WebGLBuffer} buffer - A webgl buffer (ie. cone or glow buffer)
     * @returns {boolean}
     * @private
     */

  }, {
    key: "spotlightItems",

    /**
     * Alias for this.items
     * @returns {Array}
     */
    get: function get() {
      return this.items;
    }
    /**
     * Alias for this.items
     * @param {Array} arr
     */
    ,
    set: function set(arr) {
      this.items = arr;
    }
  }], [{
    key: "Render",
    value: function Render(spotlightSet, effect, technique, buffer) {
      if (!effect || !effect.IsGood() || !buffer) return false;
      const stride = 22 * 4;
      global["w" /* device */].SetStandardStates(global["w" /* device */].RM_ADDITIVE);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ARRAY_BUFFER, buffer);
      global["w" /* device */].gl.bindBuffer(global["w" /* device */].gl.ELEMENT_ARRAY_BUFFER, spotlightSet._indexBuffer);

      for (let pass = 0; pass < effect.GetPassCount(technique); ++pass) {
        effect.ApplyPass(technique, pass);
        if (!spotlightSet._decl.SetDeclaration(effect.GetPassInput(technique, pass), stride)) return false;
        global["w" /* device */].ApplyShadowState();
        global["w" /* device */].gl.drawElements(global["w" /* device */].gl.TRIANGLES, buffer['count'], global["w" /* device */].gl.UNSIGNED_SHORT, 0);
      }

      return true;
    }
    /**
     * Spotlight set item constructor
     * @type {EveSpotlightSetItem}
     */

  }]);

  return EveSpotlightSet;
}(EveObjectSet_EveObjectSet);

EveSpotlightSet_defineProperty(EveSpotlightSet_EveSpotlightSet, "Item", EveSpotlightSet_EveSpotlightSetItem);

EveSpotlightSet_defineProperty(EveSpotlightSet_EveSpotlightSet, "vertexDeclarations", [['COLOR', 0, 4], ['TEXCOORD', 0, 4], ['TEXCOORD', 1, 4], ['TEXCOORD', 2, 4], ['TEXCOORD', 3, 3], ['TEXCOORD', 4, 3]]);
// CONCATENATED MODULE: ./eve/item/EveSpriteSet.js
function EveSpriteSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveSpriteSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveSpriteSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveSpriteSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveSpriteSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveSpriteSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveSpriteSet_assertThisInitialized(self); }

function EveSpriteSet_getPrototypeOf(o) { EveSpriteSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveSpriteSet_getPrototypeOf(o); }

function EveSpriteSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveSpriteSet_setPrototypeOf(subClass, superClass); }

function EveSpriteSet_setPrototypeOf(o, p) { EveSpriteSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveSpriteSet_setPrototypeOf(o, p); }

function EveSpriteSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveSpriteSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Sprite set render batch
 *
 * @property {boolean} boosterGlow
 * @property {EveSpriteSet} spriteSet
 * @property {mat4} world
 * @property {number}
 * @property {number}
 * @class
 */

let EveSpriteSetBatch =
/*#__PURE__*/
function (_Tw2RenderBatch) {
  EveSpriteSet_inherits(EveSpriteSetBatch, _Tw2RenderBatch);

  function EveSpriteSetBatch() {
    var _this;

    EveSpriteSet_classCallCheck(this, EveSpriteSetBatch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveSpriteSet_possibleConstructorReturn(this, EveSpriteSet_getPrototypeOf(EveSpriteSetBatch).call(this, ...args));

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this)), "boosterGlow", false);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this)), "spriteSet", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this)), "world", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this)), "boosterGain", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this)), "warpIntensity", 0);

    return _this;
  }

  EveSpriteSet_createClass(EveSpriteSetBatch, [{
    key: "Commit",

    /**
     * Commits the sprite set
     * @param {string} technique - technique name
     */
    value: function Commit(technique) {
      if (this.boosterGlow) {
        this.spriteSet.RenderBoosterGlow(technique, this.world, this.boosterGain, this.warpIntensity);
      } else {
        this.spriteSet.Render(technique, this.world, this.perObjectData);
      }
    }
  }]);

  return EveSpriteSetBatch;
}(core["Tw2RenderBatch"]);
/**
 * EveSpriteSetItem
 *
 * @property {vec3} position
 * @property {number} blinkRate
 * @property {number} blinkPhase
 * @property {number} minScale
 * @property {number} maxScale
 * @property {number} falloff
 * @property {vec4} color
 * @property {vec4} warpColor
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @class
 */

let EveSpriteSet_EveSpriteSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EveSpriteSet_inherits(EveSpriteSetItem, _EveObjectSetItem);

  function EveSpriteSetItem() {
    var _this2;

    EveSpriteSet_classCallCheck(this, EveSpriteSetItem);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = EveSpriteSet_possibleConstructorReturn(this, EveSpriteSet_getPrototypeOf(EveSpriteSetItem).call(this, ...args));

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "position", global["H" /* vec3 */].create());

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "blinkRate", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "blinkPhase", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "minScale", 1);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "maxScale", 1);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "falloff", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "color", global["I" /* vec4 */].create());

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "warpColor", global["I" /* vec4 */].create());

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "boneIndex", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this2)), "groupIndex", -1);

    return _this2;
  }

  EveSpriteSet_createClass(EveSpriteSetItem, null, [{
    key: "create",

    /**
     * Creates a sprite set item from an object
     * @param {*} [opt={}]
     * @returns {EveSpriteSetItem}
     */
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'blinkRate', 'blinkPhase', 'minScale', 'maxScale', 'falloff', 'boneIndex', 'groupIndex', 'position', 'color', 'warpColor']);
      return item;
    }
  }]);

  return EveSpriteSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EveSpriteSet
 *
 * @property {Tw2Effect} effect
 * @property {?boolean} useQuads - Use quad rendering (CPU transform)
 * @property {?boolean} isSkinned - Use bone transforms (when useQuads is true)
 * @property {number} _time
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 */

let EveSpriteSet_EveSpriteSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EveSpriteSet_inherits(EveSpriteSet, _EveObjectSet);

  /**
   * Constructor
   * @param {boolean} [useQuads] - Use quad rendering (CPU transform)
   * @param {boolean} [isSkinned] - Use bone transforms (when useQuads is true)
   */
  function EveSpriteSet() {
    var _this3;

    let useQuads = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let isSkinned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    EveSpriteSet_classCallCheck(this, EveSpriteSet);

    _this3 = EveSpriteSet_possibleConstructorReturn(this, EveSpriteSet_getPrototypeOf(EveSpriteSet).call(this));

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "effect", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "useQuads", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "isSkinned", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_time", 0);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_vertexBuffer", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_indexBuffer", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_instanceBuffer", null);

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_decl", new core["Tw2VertexDeclaration"]());

    EveSpriteSet_defineProperty(EveSpriteSet_assertThisInitialized(EveSpriteSet_assertThisInitialized(_this3)), "_vdecl", new core["Tw2VertexDeclaration"]([['TEXCOORD', 5, 1]]));

    _this3.UseQuads(useQuads, isSkinned);

    return _this3;
  }
  /**
   * Alias for this.items
   * @returns {Array}
   */


  EveSpriteSet_createClass(EveSpriteSet, [{
    key: "UseQuads",

    /**
     * Use instanced rendering or 'quad' rendering
     * @param {boolean} useQuads      - Use quad rendering (CPU transform)
     * @param {boolean} isSkinned     - Use bone transforms (when useQuads is true)
     */
    value: function UseQuads(useQuads, isSkinned) {
      if (this.useQuads === useQuads) return;
      this.useQuads = useQuads;
      this.isSkinned = isSkinned;

      this._decl.DeclareFromObject(!useQuads ? EveSpriteSet.vertexDeclarations : EveSpriteSet.quadVertexDeclarations);

      this._rebuildPending = true;
    }
    /**
     * Gets Sprite Set Resource Objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.effect) {
        this.effect.GetResources(out);
      }

      return out;
    }
    /**
     * Per frame update
     * @param {number} dt - Delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      this._time += dt;

      if (this._rebuildPending) {
        this.Rebuild();
      }
    }
    /**
     * Unloads the sprite set's buffers
     */

  }, {
    key: "Unload",
    value: function Unload() {
      const gl = global["w" /* device */].gl;

      if (this._vertexBuffer) {
        gl.deleteBuffer(this._vertexBuffer);
        this._vertexBuffer = null;
      } // Standard


      if (this._indexBuffer) {
        gl.deleteBuffer(this._indexBuffer);
        this._indexBuffer = null;
      } // Quad


      if (this._instanceBuffer) {
        gl.deleteBuffer(this._instanceBuffer);
        this._instanceBuffer = null;
      }
    }
    /**
     * Rebuilds the sprite set's buffers
     */

  }, {
    key: "Rebuild",
    value: function Rebuild() {
      this.constructor.RebuildItems(this);
      this._rebuildPending = false;
      const itemCount = this._visibleItems.length;
      if (!itemCount) return;
      const gl = global["w" /* device */].gl;

      if (this.useQuads) {
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 2, 2, 3, 0]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._instanceBuffer = gl.createBuffer();
        return;
      }

      const vertexSize = 13,
            array = new Float32Array(itemCount * 4 * vertexSize);

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i],
              offset = i * 4 * vertexSize;
        array[offset] = 0;
        array[offset + vertexSize] = 1;
        array[offset + 2 * vertexSize] = 2;
        array[offset + 3 * vertexSize] = 3;

        for (let j = 0; j < 4; ++j) {
          const vtxOffset = offset + j * vertexSize;
          array[vtxOffset + 1] = item.boneIndex;
          array[vtxOffset + 2] = item.position[0];
          array[vtxOffset + 3] = item.position[1];
          array[vtxOffset + 4] = item.position[2];
          array[vtxOffset + 5] = item.color[0];
          array[vtxOffset + 6] = item.color[1];
          array[vtxOffset + 7] = item.color[2];
          array[vtxOffset + 8] = item.blinkPhase;
          array[vtxOffset + 9] = item.blinkRate;
          array[vtxOffset + 10] = item.minScale;
          array[vtxOffset + 11] = item.maxScale;
          array[vtxOffset + 12] = item.falloff;
        }
      }

      this._vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      const indexes = new Uint16Array(itemCount * 6);

      for (let i = 0; i < itemCount; ++i) {
        const offset = i * 6,
              vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 2;
        indexes[offset + 2] = vtxOffset + 1;
        indexes[offset + 3] = vtxOffset;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset + 2;
      }

      this._indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexes, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      this._indexBuffer.count = itemCount * 6;
    }
    /**
     * Gets render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {mat4} world
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData, world) {
      if (this.display && mode === global["w" /* device */].RM_ADDITIVE && this._vertexBuffer && this._visibleItems.length) {
        const batch = new EveSpriteSetBatch();
        batch.world = world;
        batch.renderMode = global["w" /* device */].RM_ADDITIVE;
        batch.spriteSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
      }
    }
    /**
     * Gets render batches for booster glows
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {mat4} world
     * @param {Number} boosterGain
     * @param {Number} warpIntensity
     */

  }, {
    key: "GetBoosterGlowBatches",
    value: function GetBoosterGlowBatches(mode, accumulator, perObjectData, world, boosterGain, warpIntensity) {
      if (this.display && mode === global["w" /* device */].RM_ADDITIVE && this._vertexBuffer && this._visibleItems.length) {
        const batch = new EveSpriteSetBatch();
        batch.boosterGlow = true;
        batch.world = world;
        batch.boosterGain = boosterGain;
        batch.warpIntensity = warpIntensity;
        batch.renderMode = global["w" /* device */].RM_ADDITIVE;
        batch.spriteSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
      }
    }
    /**
     * Renders the sprite set
     * @param {string} technique - technique name
     * @param {mat4} world
     * @param {Tw2PerObjectData} perObjectData
     * @returns {boolean}
     */

  }, {
    key: "Render",
    value: function Render(technique, world, perObjectData) {
      if (this.useQuads) {
        return this.RenderQuads(technique, world, perObjectData);
      }

      if (!this.effect || !this.effect.IsGood() || !this._indexBuffer) return false;
      const d = global["w" /* device */],
            gl = d.gl;
      d.SetStandardStates(d.RM_ADDITIVE);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

      for (let pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
        this.effect.ApplyPass(technique, pass);
        if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 52)) return false;
        d.ApplyShadowState();
        gl.drawElements(gl.TRIANGLES, this._indexBuffer.count, gl.UNSIGNED_SHORT, 0);
      }

      return true;
    }
    /**
     * Renders the sprite set as booster glow
     * @param {string} technique - technique name
     * @param {mat4} world
     * @param {Number} boosterGain
     * @param {Number} warpIntensity
     * @returns {boolean}
     */

  }, {
    key: "RenderBoosterGlow",
    value: function RenderBoosterGlow(technique, world, boosterGain, warpIntensity) {
      if (!this.effect || !this.effect.IsGood() || !this._instanceBuffer) return false;
      const d = global["w" /* device */],
            gl = d.gl,
            pos = EveObjectSet_EveObjectSet.global.vec3_0,
            itemCount = this._visibleItems.length,
            array = new Float32Array(17 * itemCount);
      d.SetStandardStates(d.RM_ADDITIVE);
      let index = 0;

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i];
        global["H" /* vec3 */].transformMat4(pos, item.position, world);
        array[index++] = pos[0];
        array[index++] = pos[1];
        array[index++] = pos[2];
        array[index++] = world[8];
        array[index++] = item.blinkPhase;
        array[index++] = world[9];
        array[index++] = item.minScale;
        array[index++] = item.maxScale;
        array[index++] = world[10];
        array[index++] = item.color[0];
        array[index++] = item.color[1];
        array[index++] = item.color[2];
        array[index++] = boosterGain;
        array[index++] = item.warpColor[0];
        array[index++] = item.warpColor[1];
        array[index++] = item.warpColor[2];
        array[index++] = warpIntensity;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this._instanceBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);

      for (let pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
        this.effect.ApplyPass(technique, pass);
        const passInput = this.effect.GetPassInput(technique, pass);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

        this._vdecl.SetPartialDeclaration(passInput, 4);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._instanceBuffer);

        const resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);

        d.ApplyShadowState();
        d.ext.drawArraysInstanced(gl.TRIANGLES, 0, 6, itemCount);

        this._decl.ResetInstanceDivisors(resetData);
      }

      return true;
    }
    /**
     * Renders the sprite set with pre-transformed quads
     * @param {string} technique - technique name
     * @param {mat4} world
     * @param {Tw2PerObjectData} perObjectData
     * @returns {boolean}
     */

  }, {
    key: "RenderQuads",
    value: function RenderQuads(technique, world, perObjectData) {
      if (!this.effect || !this.effect.IsGood() || !this._instanceBuffer) return false;
      const d = global["w" /* device */],
            gl = d.gl,
            itemCount = this._visibleItems.length,
            array = new Float32Array(17 * itemCount),
            pos = EveObjectSet_EveObjectSet.global.vec3_0,
            bones = perObjectData.perObjectVSData.Get('JointMat');
      d.SetStandardStates(d.RM_ADDITIVE);
      let index = 0;

      for (let i = 0; i < itemCount; ++i) {
        const item = this._visibleItems[i];

        if (this.isSkinned) {
          const offset = item.boneIndex * 12;
          pos[0] = bones[offset] * item.position[0] + bones[offset + 1] * item.position[1] + bones[offset + 2] * item.position[2] + bones[offset + 3];
          pos[1] = bones[offset + 4] * item.position[0] + bones[offset + 5] * item.position[1] + bones[offset + 6] * item.position[2] + bones[offset + 7];
          pos[2] = bones[offset + 8] * item.position[0] + bones[offset + 9] * item.position[1] + bones[offset + 10] * item.position[2] + bones[offset + 11];
          global["H" /* vec3 */].transformMat4(pos, pos, world);
        } else {
          global["H" /* vec3 */].transformMat4(pos, item.position, world);
        }

        array[index++] = pos[0];
        array[index++] = pos[1];
        array[index++] = pos[2];
        array[index++] = 1;
        array[index++] = item.blinkPhase;
        array[index++] = item.blinkRate;
        array[index++] = item.minScale;
        array[index++] = item.maxScale;
        array[index++] = item.falloff;
        array[index++] = item.color[0];
        array[index++] = item.color[1];
        array[index++] = item.color[2];
        array[index++] = 1;
        array[index++] = item.warpColor[0];
        array[index++] = item.warpColor[1];
        array[index++] = item.warpColor[2];
        array[index++] = 1;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this._instanceBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);

      for (let pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
        this.effect.ApplyPass(technique, pass);
        const passInput = this.effect.GetPassInput(technique, pass);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

        this._vdecl.SetPartialDeclaration(passInput, 4);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._instanceBuffer);

        const resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);

        d.ApplyShadowState();
        d.ext.drawArraysInstanced(gl.TRIANGLES, 0, 6, itemCount);

        this._decl.ResetInstanceDivisors(resetData);
      }

      return true;
    }
    /**
     * The sprite set's item constructor
     * @type {EveSpriteSetItem}
     */

  }, {
    key: "sprites",
    get: function get() {
      return this.items;
    }
    /**
     * Alias for this.items
     * @param {Array} arr
     */
    ,
    set: function set(arr) {
      this.items = arr;
    }
  }]);

  return EveSpriteSet;
}(EveObjectSet_EveObjectSet);

EveSpriteSet_defineProperty(EveSpriteSet_EveSpriteSet, "Item", EveSpriteSet_EveSpriteSetItem);

EveSpriteSet_defineProperty(EveSpriteSet_EveSpriteSet, "vertexDeclarations", [['TEXCOORD', 5, 2], ['POSITION', 0, 3], ['COLOR', 0, 3], ['TEXCOORD', 0, 1], ['TEXCOORD', 1, 1], ['TEXCOORD', 2, 1], ['TEXCOORD', 3, 1], ['TEXCOORD', 4, 1]]);

EveSpriteSet_defineProperty(EveSpriteSet_EveSpriteSet, "quadVertexDeclarations", [['POSITION', 0, 3], ['TEXCOORD', 0, 4], ['TEXCOORD', 1, 2], ['COLOR', 0, 4], ['COLOR', 1, 4]]);
// CONCATENATED MODULE: ./eve/item/EveTurretSet.js
function EveTurretSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveTurretSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveTurretSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveTurretSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveTurretSet_defineProperties(Constructor, staticProps); return Constructor; }

function EveTurretSet_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return EveTurretSet_assertThisInitialized(self); }

function EveTurretSet_getPrototypeOf(o) { EveTurretSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return EveTurretSet_getPrototypeOf(o); }

function EveTurretSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) EveTurretSet_setPrototypeOf(subClass, superClass); }

function EveTurretSet_setPrototypeOf(o, p) { EveTurretSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return EveTurretSet_setPrototypeOf(o, p); }

function EveTurretSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function EveTurretSet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * EveTurretSetItem
 *
 * @property {?Tw2Bone} bone                - The bone the turret is on
 * @property {boolean} isJoint              - Identifies if the turret is on a joint
 * @property {?string} locatorName          - The item's locator name
 * @property {boolean} updateFromLocator    - Allows the turret to be updated from a locator's transforms
 * @property {boolean} canFireWhenHidden    - Enables firing effects when hidden
 * @property {vec3} position                - The turret's position
 * @property {quat} rotation                - The turret's rotation
 * @property {mat4} _localTransform         - The turret's local transform
 * @property {quat} _localRotation          - the turret's local rotation
 */

let EveTurretSet_EveTurretSetItem =
/*#__PURE__*/
function (_EveObjectSetItem) {
  EveTurretSet_inherits(EveTurretSetItem, _EveObjectSetItem);

  function EveTurretSetItem() {
    var _this;

    EveTurretSet_classCallCheck(this, EveTurretSetItem);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = EveTurretSet_possibleConstructorReturn(this, EveTurretSet_getPrototypeOf(EveTurretSetItem).call(this, ...args));

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "bone", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "locatorName", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "updateFromLocator", false);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "canFireWhenHidden", false);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "position", global["H" /* vec3 */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "rotation", global["C" /* quat */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "_localTransform", global["z" /* mat4 */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this)), "_localRotation", global["C" /* quat */].create());

    return _this;
  }

  EveTurretSet_createClass(EveTurretSetItem, [{
    key: "UpdateTransforms",

    /**
     * Updates the turret's transforms
     */
    value: function UpdateTransforms() {
      global["z" /* mat4 */].fromRotationTranslation(this._localTransform, this.rotation, this.position);

      if (this.bone) {
        global["z" /* mat4 */].multiply(this._localTransform, this.bone.offsetTransform, this._localTransform);
        global["z" /* mat4 */].getRotation(this._localRotation, this._localTransform);
      } else {
        global["C" /* quat */].copy(this._localRotation, this.rotation);
      }
    }
    /**
     * Creates a turret item from an object
     * @param {*} [opt={}]
     * @returns {EveTurretSetItem}
     */

  }], [{
    key: "create",
    value: function create() {
      let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const item = new this();
      global["F" /* util */].assignIfExists(item, opt, ['name', 'display', 'locatorName', 'updateFromLocator', 'position', 'rotation', 'bone', 'canFireWhenHidden']);
      item.UpdateTransforms();
      return item;
    }
  }]);

  return EveTurretSetItem;
}(EveObjectSet_EveObjectSetItem);
/**
 * EveTurretSet
 *
 * @property {Array.<EveTurretSetItem>} turrets
 * @property {Tw2AnimationController} activeAnimation
 * @property {Tw2AnimationController} inactiveAnimation
 * @property {string} geometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @property {number} bottomClipHeight
 * @property {string} locatorName
 * @property {Tw2Effect} turretEffect
 * @property {vec3} targetPosition
 * @property {number} sysBoneHeight
 * @property {string} firingEffectResPath
 * @property {EveTurretFiringFX} firingEffect
 * @property {number} state
 * @property {boolean} hasCyclingFiringPos
 * @property {mat4} parentMatrix
 * @property {quat} boundingSphere
 * @property {number} _activeTurret
 * @property {number} _recheckTimeLeft
 * @property {number} _currentCyclingFiresPos
 * @property {Tw2PerObjectData} _perObjectDataActive
 * @property {Tw2PerObjectData} _perObjectDataInactive
 * @property {boolean} _locatorRebuildPending
 * @class
 */

let EveTurretSet_EveTurretSet =
/*#__PURE__*/
function (_EveObjectSet) {
  EveTurretSet_inherits(EveTurretSet, _EveObjectSet);

  function EveTurretSet() {
    var _this2;

    EveTurretSet_classCallCheck(this, EveTurretSet);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = EveTurretSet_possibleConstructorReturn(this, EveTurretSet_getPrototypeOf(EveTurretSet).call(this, ...args));

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "visible", {
      turrets: true,
      firingEffects: true
    });

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "activeAnimation", new core["Tw2AnimationController"]());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "inactiveAnimation", new core["Tw2AnimationController"]());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "geometryResPath", '');

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "geometryResource", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "turretEffect", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "firingEffectResPath", '');

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "firingEffect", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "fireCallback", null);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "fireCallbackPending", false);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "state", EveTurretSet.State.IDLE);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "bottomClipHeight", 0);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "locatorName", '');

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "sysBoneHeight", 0);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "hasCyclingFiringPos", false);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "targetPosition", global["H" /* vec3 */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "parentMatrix", global["z" /* mat4 */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "boundingSphere", global["C" /* quat */].create());

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_activeTurret", -1);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_recheckTimeLeft", 0);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_currentCyclingFiresPos", 0);

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_perObjectDataActive", new core["Tw2PerObjectData"](EveTurretSet.perObjectData));

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_perObjectDataInactive", new core["Tw2PerObjectData"](EveTurretSet.perObjectData));

    EveTurretSet_defineProperty(EveTurretSet_assertThisInitialized(EveTurretSet_assertThisInitialized(_this2)), "_locatorRebuildPending", true);

    return _this2;
  }

  EveTurretSet_createClass(EveTurretSet, [{
    key: "Initialize",

    /**
     * Initializes the Turret Set
     */
    value: function Initialize() {
      if (this.turretEffect && this.geometryResPath !== '') {
        this.geometryResource = global["D" /* resMan */].GetResource(this.geometryResPath);
        this.activeAnimation.SetGeometryResource(this.geometryResource);
        this.inactiveAnimation.SetGeometryResource(this.geometryResource);
        if (this.geometryResource) this.geometryResource.RegisterNotification(this);
      }

      if (this.firingEffectResPath !== '') {
        global["D" /* resMan */].GetObject(this.firingEffectResPath, object => this.firingEffect = object);
      }

      this.Rebuild();
    }
    /**
     * Initializes turret set's firing effect
     */

  }, {
    key: "InitializeFiringEffect",
    value: function InitializeFiringEffect() {
      if (!this.firingEffect) return;

      if (this.geometryResource && this.geometryResource.models.length) {
        const model = this.geometryResource.models[0];

        for (let i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
          this.firingEffect.SetMuzzleBoneID(i, model.FindBoneByName(EveTurretSet.positionBoneSkeletonNames[i]));
        }
      }
    }
    /**
     * Helper function for finding out what turret should be firing
     * @returns {number}
     */

  }, {
    key: "GetClosestTurret",
    value: function GetClosestTurret() {
      let closestTurret = -1,
          closestAngle = -2;
      const g = EveTurretSet.global,
            nrmToTarget = g.vec3_0,
            nrmUp = g.vec4_0,
            turretPosition = g.vec4_1;

      for (let i = 0; i < this.items.length; ++i) {
        const item = this.items[i];
        if (!item.display && !item.canFireWhenHidden) continue;
        turretPosition[0] = item._localTransform[12];
        turretPosition[1] = item._localTransform[13];
        turretPosition[2] = item._localTransform[14];
        turretPosition[3] = 1;
        global["I" /* vec4 */].transformMat4(turretPosition, turretPosition, this.parentMatrix);
        global["H" /* vec3 */].subtract(nrmToTarget, this.targetPosition, turretPosition);
        global["H" /* vec3 */].normalize(nrmToTarget, nrmToTarget);
        global["I" /* vec4 */].set(nrmUp, 0, 1, 0, 0);
        global["I" /* vec4 */].transformMat4(nrmUp, nrmUp, item._localTransform);
        global["I" /* vec4 */].transformMat4(nrmUp, nrmUp, this.parentMatrix);
        const angle = global["H" /* vec3 */].dot(nrmUp, nrmToTarget);

        if (angle > closestAngle) {
          closestTurret = this.items.indexOf(item);
          closestAngle = angle;
        }
      }

      return closestTurret;
    }
    /**
     * Animation helper function for deactivating a turret set
     */

  }, {
    key: "EnterStateDeactive",
    value: function EnterStateDeactive() {
      if (this.state === EveTurretSet.State.INACTIVE || this.state === EveTurretSet.State.PACKING) return;

      if (this.turretEffect) {
        this.activeAnimation.StopAllAnimations();
        this.inactiveAnimation.StopAllAnimations();
        this.activeAnimation.PlayAnimation('Pack', false, () => {
          this.state = EveTurretSet.State.INACTIVE;
          this.activeAnimation.PlayAnimation('Inactive', true);
        });
        this.inactiveAnimation.PlayAnimation('Pack', false, () => {
          this.state = EveTurretSet.State.INACTIVE;
          this.inactiveAnimation.PlayAnimation('Inactive', true);
        });
        this.state = EveTurretSet.State.PACKING;
      } else {
        this.state = EveTurretSet.State.INACTIVE;
      }

      this._activeTurret = -1;

      if (this.firingEffect) {
        this.firingEffect.StopFiring();
      }
    }
    /**
     * Animation helper function for putting a turret set into idle state
     */

  }, {
    key: "EnterStateIdle",
    value: function EnterStateIdle() {
      if (this.state === EveTurretSet.State.IDLE || this.state === EveTurretSet.State.UNPACKING) return;

      if (this.turretEffect) {
        this.activeAnimation.StopAllAnimations();
        this.inactiveAnimation.StopAllAnimations();

        if (this.state === EveTurretSet.State.FIRING) {
          this.activeAnimation.PlayAnimation('Active', true);
          this.inactiveAnimation.PlayAnimation('Active', true);
        } else {
          this.activeAnimation.PlayAnimation('Deploy', false, () => {
            this.state = EveTurretSet.State.IDLE;
            this.activeAnimation.PlayAnimation('Active', true);
          });
          this.inactiveAnimation.PlayAnimation('Deploy', false, () => {
            this.state = EveTurretSet.State.IDLE;
            this.inactiveAnimation.PlayAnimation('Active', true);
          });
        }

        this.state = EveTurretSet.State.UNPACKING;
      } else {
        this.state = EveTurretSet.State.IDLE;
      }

      this._activeTurret = -1;

      if (this.firingEffect) {
        this.firingEffect.StopFiring();
      }
    }
    /**
     * Animation helper function for putting a turret set into a firing state
     */

  }, {
    key: "EnterStateFiring",
    value: function EnterStateFiring() {
      if (!this.turretEffect || this.state === EveTurretSet.State.FIRING) {
        EveTurretSet.DoStartFiring(this);

        if (this.turretEffect) {
          this.activeAnimation.PlayAnimation('Fire', false, () => {
            this.activeAnimation.PlayAnimation('Active', true);
          });
        }

        return;
      }

      this.activeAnimation.StopAllAnimations();
      this.inactiveAnimation.StopAllAnimations();

      if (this.state === EveTurretSet.State.INACTIVE) {
        this.activeAnimation.PlayAnimation('Deploy', false, () => {
          EveTurretSet.DoStartFiring(this);
          this.activeAnimation.PlayAnimation('Fire', false, () => {
            this.activeAnimation.PlayAnimation('Active', true);
          });
        });
        this.inactiveAnimation.PlayAnimation('Deploy', false, () => {
          this.inactiveAnimation.PlayAnimation('Active', true);
        });
        this.state = EveTurretSet.State.UNPACKING;
      } else {
        EveTurretSet.DoStartFiring(this);
        this.activeAnimation.PlayAnimation('Fire', false, () => {
          this.activeAnimation.PlayAnimation('Active', true);
        });
        this.inactiveAnimation.PlayAnimation('Active', true);
      }
    }
    /**
     * Rebuilds the turret sets cached data
     */

  }, {
    key: "RebuildCachedData",
    value: function RebuildCachedData() {
      const instancedElement = new core["Tw2VertexElement"](core["Tw2VertexDeclaration"].Type.TEXCOORD, 1, global["w" /* device */].gl.FLOAT, 2),
            meshes = this.geometryResource.meshes,
            active = this.activeAnimation,
            inactive = this.inactiveAnimation;

      for (let i = 0; i < meshes.length; ++i) {
        meshes[i].declaration.elements.push(instancedElement);
        meshes[i].declaration.RebuildHash();
      }

      switch (this.state) {
        case EveTurretSet.State.INACTIVE:
          active.PlayAnimation('Inactive', true);
          inactive.PlayAnimation('Inactive', true);
          break;

        case EveTurretSet.State.IDLE:
          active.PlayAnimation('Active', true);
          inactive.PlayAnimation('Active', true);
          break;

        case EveTurretSet.State.FIRING:
          active.PlayAnimation('Fire', false, () => active.PlayAnimation('Active', true));
          inactive.PlayAnimation('Active', true);
          break;

        case EveTurretSet.State.PACKING:
          this.EnterStateIdle();
          break;

        case EveTurretSet.State.UNPACKING:
          this.EnterStateDeactive();
          break;
      }
    }
    /**
     * Finds a turret item by name
     * @param {string} name
     * @returns {?EveTurretSetItem}
     */

  }, {
    key: "FindItemByLocatorName",
    value: function FindItemByLocatorName(name) {
      for (let i = 0; i < this.items.length; i++) {
        if (this.items[i].locatorName === name) {
          return this.items[i];
        }
      }

      return null;
    }
    /**
     * Updates the turret set's items that were created from locators
     * - Turrets without locator names are ignored
     * @param {Array<EveLocator>} locators
     */

  }, {
    key: "UpdateItemsFromLocators",
    value: function UpdateItemsFromLocators(locators) {
      const g = EveTurretSet.global,
            toRemove = Array.from(this.items),
            norm = g.mat4_0;

      for (let i = 0; i < locators.length; i++) {
        const _locators$i = locators[i],
              name = _locators$i.name,
              transform = _locators$i.transform,
              _locators$i$bone = _locators$i.bone,
              bone = _locators$i$bone === void 0 ? null : _locators$i$bone;
        let item = this.FindItemByLocatorName(name);

        if (!item) {
          item = this.CreateItem({
            name: name,
            locatorName: name,
            updateFromLocator: true
          });
        } else {
          toRemove.splice(toRemove.indexOf(item), 1);
        }

        if (item.updateFromLocator) {
          item.bone = bone;
          global["z" /* mat4 */].copy(norm, transform);
          global["H" /* vec3 */].normalize(norm.subarray(0, 3), norm.subarray(0, 3));
          global["H" /* vec3 */].normalize(norm.subarray(4, 7), norm.subarray(4, 7));
          global["H" /* vec3 */].normalize(norm.subarray(8, 11), norm.subarray(8, 11));
          global["z" /* mat4 */].getRotation(item.rotation, norm);
          global["z" /* mat4 */].getTranslation(item.position, norm);
          item.OnValueChanged();
        }
      }

      for (let i = 0; i < toRemove.length; i++) {
        if (toRemove[i].locatorName) {
          this.RemoveItem(toRemove[i]);
          i--;
        }
      }

      this._locatorRebuildPending = false;
      if (this._rebuildPending) this.Rebuild();
    }
    /**
     * Rebuilds the turret set's items from it's parent's locators
     */

  }, {
    key: "RebuildItemsFromLocators",
    value: function RebuildItemsFromLocators() {
      this._locatorRebuildPending = true;
    }
    /**
     * Gets turret set res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (this.geometryResource && !out.includes(this.geometryResource)) {
        out.push(this.geometryResource);
      }

      if (this.turretEffect) {
        this.turretEffect.GetResources(out);
      }

      if (this.firingEffect) {
        this.firingEffect.GetResources(out);
      }

      return out;
    }
    /**
     * Updates view dependent data
     */

  }, {
    key: "UpdateViewDependentData",
    value: function UpdateViewDependentData() {
      if (this.firingEffect) {
        this.firingEffect.UpdateViewDependentData();
      }
    }
    /**
     * Per frame update
     * @param {number} dt - Delta Time
     * @param {mat4} parentMatrix
     */

  }, {
    key: "Update",
    value: function Update(dt, parentMatrix) {
      if (this._rebuildPending) {
        this.Rebuild();
      }

      if (this.turretEffect) {
        this.activeAnimation.Update(dt);
        this.inactiveAnimation.Update(dt);
      }

      global["z" /* mat4 */].copy(this.parentMatrix, parentMatrix);

      if (this.firingEffect && this._visibleItems.length) {
        if (this._activeTurret !== -1) {
          if (this.firingEffect.isLoopFiring) {
            if (this.state === EveTurretSet.State.FIRING) {
              this._recheckTimeLeft -= dt;

              if (this._recheckTimeLeft <= 0) {
                EveTurretSet.DoStartFiring(this);
              }
            }
          }

          const activeItem = this.items[this._activeTurret];

          if (this.activeAnimation.models.length) {
            const bones = this.activeAnimation.models[0].bonesByName;

            for (let i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
              const transform = bones[EveTurretSet.positionBoneSkeletonNames[i]].worldTransform,
                    out = this.firingEffect.GetMuzzleTransform(i);
              global["z" /* mat4 */].multiply(out, activeItem._localTransform, transform);
              global["z" /* mat4 */].multiply(out, out, parentMatrix);
            }
          } else {
            for (let i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
              global["z" /* mat4 */].multiply(this.firingEffect.GetMuzzleTransform(i), parentMatrix, activeItem._localTransform);
            }
          }

          if (this.fireCallbackPending) {
            if (this.fireCallback) {
              const cbTransforms = [];

              for (let i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                cbTransforms.push(this.firingEffect.GetMuzzleTransform(i));
              }

              this.fireCallback(this, cbTransforms);
            }

            this.fireCallbackPending = false;
          }
        }

        global["H" /* vec3 */].copy(this.firingEffect.endPosition, this.targetPosition);
        this.firingEffect.Update(dt);
      }
    }
    /**
     * Gets turret set render batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {boolean} [hideFiringEffect]
     */

  }, {
    key: "GetBatches",
    value: function GetBatches(mode, accumulator, perObjectData, hideFiringEffect) {
      if (!this.turretEffect || !this.geometryResource || !this.display || !this._visibleItems.length) return;

      if (mode === global["w" /* device */].RM_OPAQUE && this.visible.turrets) {
        const transforms = this.inactiveAnimation.GetBoneMatrices(0);

        if (transforms.length !== 0) {
          EveTurretSet.UpdatePerObjectData(this, this._perObjectDataInactive.perObjectVSData, transforms);
          this._perObjectDataInactive.perObjectPSData = perObjectData.perObjectPSData;
          const batch = new core["Tw2ForwardingRenderBatch"]();
          batch.renderMode = mode;
          batch.renderActive = false;
          batch.perObjectData = this._perObjectDataInactive;
          batch.geometryProvider = this;
          accumulator.Commit(batch);

          if (this.state === EveTurretSet.State.FIRING) {
            const transforms = this.activeAnimation.GetBoneMatrices(0);

            if (transforms.length !== 0) {
              EveTurretSet.UpdatePerObjectData(this, this._perObjectDataActive.perObjectVSData, transforms, true);
              this._perObjectDataActive.perObjectPSData = perObjectData.perObjectPSData;
              const batch = new core["Tw2ForwardingRenderBatch"]();
              batch.renderActive = true;
              batch.perObjectData = this._perObjectDataActive;
              batch.geometryProvider = this;
              accumulator.Commit(batch);
            }
          }
        }
      }

      this.GetFiringEffectBatches(mode, accumulator, perObjectData, hideFiringEffect);
    }
    /**
     * Gets turret firing effect batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     * @param {Tw2PerObjectData} perObjectData
     * @param {boolean} [hideFiringEffect]
     */

  }, {
    key: "GetFiringEffectBatches",
    value: function GetFiringEffectBatches(mode, accumulator, perObjectData, hideFiringEffect) {
      if (this.firingEffect && this.display && this._visibleItems.length && this.visible.firingEffects && !hideFiringEffect) {
        this.firingEffect.GetBatches(mode, accumulator, perObjectData);
      }
    }
    /**
     * Renders the turret set
     * @param batch
     * @param {string} technique - technique name
     * @returns {boolean}
     */

  }, {
    key: "Render",
    value: function Render(batch, technique) {
      if (!this.turretEffect || !this.turretEffect.IsGood() || !this._visibleItems.length) return false;
      let index = 0;

      const customSetter = function customSetter(el) {
        global["w" /* device */].gl.disableVertexAttribArray(el.location);
        global["w" /* device */].gl.vertexAttrib2f(el.location, index, index);
      };

      for (let i = 0; i < this.geometryResource.meshes.length; ++i) {
        const decl = this.geometryResource.meshes[i].declaration;
        decl.FindUsage(core["Tw2VertexDeclaration"].Type.TEXCOORD, 1).customSetter = customSetter;
      }

      let rendered = 0;

      for (; index < this.items.length; ++index) {
        if (this.items[index].display) {
          const isActive = this.state === EveTurretSet.State.FIRING && index === this._activeTurret;

          if (batch.renderActive === isActive) {
            this.geometryResource.RenderAreas(0, 0, 1, this.turretEffect, technique);
            rendered++;
          }
        }
      }

      return !!rendered;
    }
    /**
     * Rebuilds the set's items
     *
     * @param {EveTurretSet} turretSet
     */

  }, {
    key: "turrets",

    /**
     * Alias for this.items
     * @returns {Array}
     */
    get: function get() {
      return this.items;
    }
    /**
     * Alias for this.items
     * @param {Array} arr
     */
    ,
    set: function set(arr) {
      this.items = arr;
    }
  }], [{
    key: "RebuildItems",
    value: function RebuildItems(turretSet) {
      turretSet._visibleItems = [];

      for (let i = 0; i < turretSet.items.length; i++) {
        const item = turretSet.items[i];
        item._onModified = turretSet._onChildModified;

        if (item.display) {
          turretSet._visibleItems.push(item);

          if (item._rebuildPending) {
            item.UpdateTransforms();
            item._rebuildPending = false;
          }
        }
      }
    }
    /**
     * Updates per object data
     * @param {EveTurretSet} turretSet
     * @param {Tw2RawData} perObjectData
     * @param transforms
     * @param {boolean} [skipBoneCalculations]
     */

  }, {
    key: "UpdatePerObjectData",
    value: function UpdatePerObjectData(turretSet, perObjectData, transforms, skipBoneCalculations) {
      global["z" /* mat4 */].transpose(perObjectData.Get('shipMatrix'), turretSet.parentMatrix);
      const transformCount = transforms.length / 12;
      perObjectData.Get('turretSetData')[0] = transformCount;
      perObjectData.Get('baseCutoffData')[0] = turretSet.bottomClipHeight;
      const translation = perObjectData.Get('turretTranslation'),
            rotation = perObjectData.Get('turretRotation'),
            pose = perObjectData.Get('turretPoseTransAndRot');

      for (let i = 0; i < turretSet._visibleItems.length; ++i) {
        const item = turretSet._visibleItems[i];

        for (let j = 0; j < transformCount; ++j) {
          pose[(i * transformCount + j) * 2 * 4] = transforms[j * 12 + 3];
          pose[(i * transformCount + j) * 2 * 4 + 1] = transforms[j * 12 + 7];
          pose[(i * transformCount + j) * 2 * 4 + 2] = transforms[j * 12 + 11];
          pose[(i * transformCount + j) * 2 * 4 + 3] = 1;
          EveTurretSet.mat3x4toquat(transforms, j, pose, (i * transformCount + j) * 2 + 1);
        }

        if (item.bone && !skipBoneCalculations) {
          item.UpdateTransforms();
        }

        translation[i * 4] = item._localTransform[12];
        translation[i * 4 + 1] = item._localTransform[13];
        translation[i * 4 + 2] = item._localTransform[14];
        translation[i * 4 + 3] = 1;
        rotation[i * 4] = item.rotation[0];
        rotation[i * 4 + 1] = item.rotation[1];
        rotation[i * 4 + 2] = item.rotation[2];
        rotation[i * 4 + 3] = item.rotation[3];
      }
    }
    /**
     * Animation helper function for turret firing
     * @param {EveTurretSet} turretSet
     * @returns {EveTurretSetItem} the closest turret
     */

  }, {
    key: "DoStartFiring",
    value: function DoStartFiring(turretSet) {
      if (turretSet.hasCyclingFiringPos) {
        turretSet._currentCyclingFiresPos = 1 - turretSet._currentCyclingFiresPos;
      }

      if (turretSet.firingEffect) {
        turretSet.firingEffect.PrepareFiring(0, turretSet.hasCyclingFiringPos ? turretSet._currentCyclingFiresPos : -1);
      }

      turretSet._activeTurret = turretSet.GetClosestTurret();
      turretSet.state = EveTurretSet.State.FIRING;
      turretSet._recheckTimeLeft = 2;

      if (turretSet.fireCallback) {
        turretSet.fireCallbackPending = true;
      }
    }
    /**
     * The eve turret set's item constructor
     * @type {EveTurretSetItem}
     */

  }]);

  return EveTurretSet;
}(EveObjectSet_EveObjectSet);

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "Item", EveTurretSet_EveTurretSetItem);

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "State", {
  INACTIVE: 0,
  IDLE: 1,
  FIRING: 2,
  PACKING: 2,
  UNPACKING: 4
});

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "worldNames", ['turretWorld0', 'turretWorld1', 'turretWorld2']);

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "positionBoneSkeletonNames", ['Pos_Fire01', 'Pos_Fire02', 'Pos_Fire03', 'Pos_Fire04', 'Pos_Fire05', 'Pos_Fire06', 'Pos_Fire07', 'Pos_Fire08']);

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "perObjectData", {
  VSData: [['baseCutoffData', 4], ['turretSetData', 4], ['shipMatrix', 16], ['turretTranslation', 4 * 24], ['turretRotation', 4 * 24], ['turretPoseTransAndRot', 2 * 4 * 72]]
});

EveTurretSet_defineProperty(EveTurretSet_EveTurretSet, "mat3x4toquat", function () {
  let m, q;
  return function (mm, index, out, outIndex) {
    if (!m) {
      m = global["z" /* mat4 */].create();
      q = global["C" /* quat */].create();
    }

    index *= 12;
    outIndex *= 4;
    m[0] = mm[index];
    m[1] = mm[index + 4];
    m[2] = mm[index + 8];
    m[3] = 0;
    m[4] = mm[index + 1];
    m[5] = mm[index + 5];
    m[6] = mm[index + 9];
    m[7] = 0;
    m[8] = mm[index + 2];
    m[9] = mm[index + 6];
    m[10] = mm[index + 10];
    m[11] = 0;
    m[12] = mm[index + 3];
    m[13] = mm[index + 7];
    m[14] = mm[index + 11];
    m[15] = 1;
    global["z" /* mat4 */].getRotation(q, m);
    out[outIndex] = q[0];
    out[outIndex + 1] = q[1];
    out[outIndex + 2] = q[2];
    out[outIndex + 3] = q[3];
  };
}());
// CONCATENATED MODULE: ./eve/item/index.js









// CONCATENATED MODULE: ./eve/EveSpaceScene.js
function EveSpaceScene_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EveSpaceScene_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function EveSpaceScene_createClass(Constructor, protoProps, staticProps) { if (protoProps) EveSpaceScene_defineProperties(Constructor.prototype, protoProps); if (staticProps) EveSpaceScene_defineProperties(Constructor, staticProps); return Constructor; }

function EveSpaceScene_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * EveSpaceScene
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {{}} visible
 * @property {boolean} visible.lensflare
 * @property {boolean} visible.objects
 * @property {boolean} visible.planets
 * @property {boolean} visible.fog
 * @property {boolean} visible.clearColor
 * @property {boolean} visible.nebula
 * @property {Array.<EveLensflare>} lensflares - Scene lensflares
 * @property {Array.<*>} objects - Scene objects
 * @property {Array.<EvePlanet>} planets - Scene planets
 * @property {number} nebulaIntensity - controls nebula intensity on scene objects
 * @property {vec4} ambientColor - unused
 * @property {null|Tw2Effect} backgroundEffect
 * @property {number} backgroundRenderingEnabled - Toggles background effect visibility
 * @property {vec3} endMapScaling - controls the scale of the environment maps
 * @property {quat} envMapRotation - controls the rotation of the environment maps
 * @property {boolean} logEnabled - toggles LOD
 * @property {number} fogStart - fog start distance
 * @property {number} fogEnd - fog end distance
 * @property {number} fogMax - fog maximum opacity
 * @property {number} fogType - fog blend type
 * @property {number} fogBlur - fog blur mode
 * @property {vec4} fogColor - fog color
 * @property {vec3} sunDirection - the direction of the scene sun
 * @property {vec4} sunDiffuseColor - the colour of the light from the sun
 * @property {String} envMapResPath - nebula reflection map path
 * @property {String} envMap1ResPath - nebula diffuse map path
 * @property {String} envMap2ResPath - nebular blur map path
 * @property {String} envMap3ResPath - unused
 * @property {null|Tw2TextureRes} envMapRes
 * @property {null|Tw2TextureRes} envMap1Res
 * @property {null|Tw2TextureRes} envMap2Res
 * @property {null} envMap3Res - unused
 * @property {Tw2BatchAccumulator} _batches - Scene batch accumulator
 * @property {Tw2RawData} _perFrameVS
 * @property {Tw2RawData} _perFramePS
 * @property {boolean} renderDebugInfo
 * @property {*} _debugHelper
 * @class
 */

let EveSpaceScene_EveSpaceScene =
/*#__PURE__*/
function () {
  function EveSpaceScene() {
    EveSpaceScene_classCallCheck(this, EveSpaceScene);

    this._id = global["F" /* util */].generateID();
    this.name = '';
    this.display = true;
    this.visible = {};
    this.visible.lensflares = true;
    this.visible.objects = true;
    this.visible.planets = true;
    this.visible.fog = true;
    this.visible.clearColor = true;
    this.visible.environmentReflection = true;
    this.visible.environmentDiffuse = true;
    this.visible.environmentBlur = true;
    Object.defineProperty(this.visible, 'environment', {
      get: () => {
        return this.backgroundRenderingEnabled;
      },
      set: bool => {
        this.backgroundRenderingEnabled = bool ? 1 : 0;
      }
    });
    this.lensflares = [];
    this.objects = [];
    this.planets = [];
    this.nebulaIntensity = 1;
    this.ambientColor = global["C" /* quat */].fromValues(0.25, 0.25, 0.25, 1);
    this.backgroundEffect = null;
    this.backgroundRenderingEnabled = 1;
    this.clearColor = global["I" /* vec4 */].fromValues(0, 0, 0, 0);
    this.lodEnabled = false;
    this.fogStart = 0;
    this.fogEnd = 0;
    this.fogMax = 0;
    this.fogType = 0;
    this.fogBlur = 0;
    this.fogColor = global["I" /* vec4 */].fromValues(0.25, 0.25, 0.25, 1);
    this.sunDirection = global["H" /* vec3 */].fromValues(1, -1, 1);
    this.sunDiffuseColor = global["I" /* vec4 */].fromValues(1, 1, 1, 1);
    this.envMapScaling = global["H" /* vec3 */].fromValues(1, 1, 1);
    this.envMapRotation = global["C" /* quat */].create();
    this.envMapResPath = '';
    this.envMap1ResPath = '';
    this.envMap2ResPath = '';
    this.envMap3ResPath = '';
    this.envMapRes = null;
    this.envMap1Res = null;
    this.envMap2Res = null;
    this.envMap3Res = null;
    this.renderDebugInfo = false;
    this._debugHelper = null;
    this._batches = new core["Tw2BatchAccumulator"]();
    this._perFrameVS = new core["Tw2RawData"](EveSpaceScene.perFrameData.VSData);
    this._perFramePS = new core["Tw2RawData"](EveSpaceScene.perFrameData.PSData);
    EveSpaceScene.init();
  }
  /**
   * Initializes the space scene
   */


  EveSpaceScene_createClass(EveSpaceScene, [{
    key: "Initialize",
    value: function Initialize() {
      this.SetEnvMapPath(0, this.envMapResPath);
      this.SetEnvMapPath(1, this.envMap1ResPath);
      this.SetEnvMapPath(2, this.envMap2ResPath);
      this.SetEnvMapPath(3, this.envMap3ResPath);
    }
    /**
     * Sets the environment's reflection map
     * @param {String} path
     */

  }, {
    key: "SetEnvMapReflection",
    value: function SetEnvMapReflection(path) {
      this.SetEnvMapPath(0, path);
    }
    /**
     * Sets the environment's diffuse map
     * @param {string} path
     */

  }, {
    key: "SetEnvMapDiffuse",
    value: function SetEnvMapDiffuse(path) {
      this.SetEnvMapPath(1, path);
    }
    /**
     * Sets the environment's blur map (used for fog)
     * @param {string} path
     */

  }, {
    key: "SetEnvMapBlur",
    value: function SetEnvMapBlur(path) {
      this.SetEnvMapPath(2, path);
    }
    /**
     * Sets an environment map
     * @param {number} index
     * @param {String} path
     */

  }, {
    key: "SetEnvMapPath",
    value: function SetEnvMapPath(index, path) {
      const _setEnvPath = (path, pathTarget, resTarget) => {
        path = path.toLowerCase();
        this[pathTarget] = path;
        this[resTarget] = path === '' ? null : global["D" /* resMan */].GetResource(path);
        return true;
      };

      switch (index) {
        case 0:
          // Reflection
          return _setEnvPath(path, 'envMapResPath', 'envMapRes');

        case 1:
          // Diffuse
          return _setEnvPath(path, 'envMap1ResPath', 'envMap1Res');

        case 2:
          // Blur
          return _setEnvPath(path, 'envMap2ResPath', 'envMap2Res');

        case 3:
          // Unused
          return _setEnvPath(path, 'envMap3ResPath', 'envMap3Res');
      }

      return false;
    }
    /**
     * Enables LOD
     * @param {boolean} enable
     */

  }, {
    key: "EnableLod",
    value: function EnableLod(enable) {
      this.lodEnabled = enable;

      if (!enable) {
        for (let i = 0; i < this.objects.length; ++i) {
          if (this.objects[i].ResetLod) {
            this.objects[i].ResetLod();
          }
        }
      }
    }
    /**
     * Keeps the scene and it's object's resources alive
     */

  }, {
    key: "KeepAlive",
    value: function KeepAlive() {
      const res = this.GetResources();

      for (let i = 0; i < res.length; i++) {
        res[i].KeepAlive();
      }
    }
    /**
     * Gets scene's resources
     * @param {Array} [out=[]] - Optional receiving array
     * @param {boolean} [excludeChildren]
     * @returns {Array.<Tw2Resource>} [out]
     */

  }, {
    key: "GetResources",
    value: function GetResources() {
      let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let excludeChildren = arguments.length > 1 ? arguments[1] : undefined;

      for (let i = 0; i < this.lensflares.length; i++) {
        this.lensflares[i].GetResources(out);
      }

      if (this.backgroundEffect) {
        this.backgroundEffect.GetResources(out);
      }

      if (this.envMapRes && !out.includes(this.envMapRes)) out.push(this.envMapRes);
      if (this.envMap1Res && !out.includes(this.envMap1Res)) out.push(this.envMapRes);
      if (this.envMap2Res && !out.includes(this.envMap2Res)) out.push(this.envMapRes);
      if (this.envMap3Res && !out.includes(this.envMap3Res)) out.push(this.envMapRes);

      if (!excludeChildren) {
        for (let i = 0; i < this.planets.length; i++) {
          this.planets[i].GetResources(out);
        }

        for (let i = 0; i < this.objects.length; i++) {
          if ('GetResources' in this.objects[i]) {
            this.objects[i].GetResources(out);
          }
        }
      }

      return out;
    }
    /**
     * Per frame update that is called per frame
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      for (let i = 0; i < this.planets.length; ++i) {
        if ('Update' in this.planets[i]) {
          this.planets[i].Update(dt);
        }
      }

      for (let i = 0; i < this.objects.length; ++i) {
        if ('Update' in this.objects[i]) {
          this.objects[i].Update(dt);
        }
      }
    }
    /**
     * Gets batches for rendering
     * @param {number} mode
     * @param {Array.<EveObject>} objectArray
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: "RenderBatches",
    value: function RenderBatches(mode, objectArray) {
      let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._batches;

      for (let i = 0; i < objectArray.length; ++i) {
        if ('GetBatches' in objectArray[i]) {
          objectArray[i].GetBatches(mode, accumulator);
        }
      }
    }
    /**
     * Updates children's view dependent data and renders them
     */

  }, {
    key: "Render",
    value: function Render() {
      this.ApplyPerFrameData();
      const d = global["w" /* device */],
            g = EveSpaceScene.global,
            id = global["z" /* mat4 */].identity(g.mat4_ID),
            show = this.visible;

      if (show['environment'] && this.backgroundEffect) {
        d.SetStandardStates(d.RM_FULLSCREEN);
        d.RenderCameraSpaceQuad(this.backgroundEffect);
      }

      if (show.planets && this.planets.length) {
        const tempProj = global["z" /* mat4 */].copy(g.mat4_0, d.projection),
              newProj = global["z" /* mat4 */].copy(g.mat4_1, d.projection),
              zn = 10000,
              zf = 1e11;
        newProj[10] = zf / (zn - zf);
        newProj[14] = zf * zn / (zn - zf);
        d.SetProjection(newProj, true);
        this.ApplyPerFrameData();

        for (let i = 0; i < this.planets.length; ++i) {
          if (this.planets[i].UpdateViewDependentData) {
            this.planets[i].UpdateViewDependentData(id);
          }
        }

        this._batches.Clear();

        d.gl.depthRange(0.9, 1);
        this.RenderBatches(d.RM_OPAQUE, this.planets);
        this.RenderBatches(d.RM_DECAL, this.planets);
        this.RenderBatches(d.RM_TRANSPARENT, this.planets);
        this.RenderBatches(d.RM_ADDITIVE, this.planets);

        this._batches.Render();

        d.SetProjection(tempProj, true);
        this.ApplyPerFrameData();
        d.gl.depthRange(0, 0.9);
      }

      if (this.lodEnabled) {
        g.frustum.Initialize(d.view, d.projection, d.viewportWidth, d.viewInverse, d.viewProjection);

        for (let i = 0; i < this.objects.length; ++i) {
          if (this.objects[i].UpdateLod) {
            this.objects[i].UpdateLod(g.frustum);
          }
        }
      }

      if (show.objects) {
        for (let i = 0; i < this.objects.length; ++i) {
          if (this.objects[i].UpdateViewDependentData) {
            this.objects[i].UpdateViewDependentData(id);
          }
        }
      }

      if (show.lensflares) {
        for (let i = 0; i < this.lensflares.length; ++i) {
          this.lensflares[i].PrepareRender();
        }
      }

      this._batches.Clear();

      if (show.planets) {
        for (let i = 0; i < this.planets.length; ++i) {
          this.planets[i].GetZOnlyBatches(d.RM_OPAQUE, this._batches);
        }
      }

      if (show.objects) {
        this.RenderBatches(d.RM_OPAQUE, this.objects);
        this.RenderBatches(d.RM_DECAL, this.objects);
        this.RenderBatches(d.RM_TRANSPARENT, this.objects);
        this.RenderBatches(d.RM_ADDITIVE, this.objects);
      }

      if (show.lensflares) {
        for (let i = 0; i < this.lensflares.length; ++i) {
          this.lensflares[i].GetBatches(d.RM_ADDITIVE, this._batches);
        }
      }

      this._batches.Render();

      if (show.lensflares) {
        for (let i = 0; i < this.lensflares.length; ++i) {
          this.lensflares[i].UpdateOccluders();
        }
      }

      if (this.renderDebugInfo) {
        if (EveSpaceScene.DebugRenderer) {
          if (!this._debugHelper) {
            this._debugHelper = new EveSpaceScene.DebugRenderer();
          }

          for (let i = 0; i < this.objects.length; ++i) {
            if (this.objects[i].RenderDebugInfo) {
              this.objects[i].RenderDebugInfo(this._debugHelper);
            }
          }

          this._debugHelper.Render();
        }
      }
    }
    /**
     * Applies per frame data
     */

  }, {
    key: "ApplyPerFrameData",
    value: function ApplyPerFrameData() {
      const d = global["w" /* device */],
            g = EveSpaceScene.global,
            envMapTransform = g.mat4_2,
            sunDir = g.vec3_0,
            show = this.visible;
      global["z" /* mat4 */].fromQuat(envMapTransform, this.envMapRotation);
      global["z" /* mat4 */].scale(envMapTransform, envMapTransform, this.envMapScaling);
      global["z" /* mat4 */].transpose(envMapTransform, envMapTransform);
      global["H" /* vec3 */].negate(sunDir, this.sunDirection);
      global["H" /* vec3 */].normalize(sunDir, sunDir);
      let distance = this.fogEnd - this.fogStart;
      if (Math.abs(distance) < 1e-5) distance = 1e-5;
      const f = 1.0 / distance;
      const VSData = this._perFrameVS;
      VSData.Set('FogFactors', [this.fogEnd * f, f, this.visible.fog ? this.fogMax : 0, 1]);
      VSData.Set('ViewportAdjustment', [1, 1, 1, 1]);
      VSData.Set('MiscSettings', [d.currentTime, 0, d.viewportWidth, d.viewportHeight]);
      VSData.Set('SunData.DirWorld', sunDir);
      VSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
      VSData.Set('TargetResolution', d.targetResolution);
      VSData.Set('ViewInverseTransposeMat', d.viewInverse);
      VSData.Set('ViewProjectionMat', d.viewProjectionTranspose);
      VSData.Set('ViewMat', d.viewTranspose);
      VSData.Set('ProjectionMat', d.projectionTranspose);
      VSData.Set('EnvMapRotationMat', envMapTransform);
      d.perFrameVSData = VSData;
      const PSData = this._perFramePS;
      PSData.Set('ViewInverseTransposeMat', d.viewInverse);
      PSData.Set('ViewMat', d.viewTranspose);
      PSData.Set('EnvMapRotationMat', envMapTransform);
      PSData.Set('SunData.DirWorld', sunDir);
      PSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
      PSData.Set('SceneData.AmbientColor', this.ambientColor);
      PSData.Set('MiscSettings', [d.currentTime, this.fogType, this.fogBlur, 1]);
      PSData.Set('SceneData.FogColor', this.fogColor);
      PSData.Set('FovXY', [d.targetResolution[3], d.targetResolution[2]]);
      PSData.Set('ShadowMapSettings', [1, 1, 0, 0]);
      PSData.Set('TargetResolution', d.targetResolution);
      PSData.Get('SceneData.NebulaIntensity')[0] = this.nebulaIntensity;
      PSData.Get('ViewportSize')[0] = d.viewportWidth;
      PSData.Get('ViewportSize')[1] = d.viewportHeight;
      PSData.Get('ShadowCameraRange')[0] = 1;
      PSData.Get('ProjectionToView')[0] = -d.projection[14];
      PSData.Get('ProjectionToView')[1] = -d.projection[10] - 1;
      d.perFramePSData = PSData;
      const envMap = this.envMapRes && show.environmentReflection ? this.envMapRes : g.emptyTexture,
            envMap1 = this.envMap1Res && show.environmentDiffuse ? this.envMap1Res : g.emptyTexture,
            envMap2 = this.envMap2Res && show.environmentBlur ? this.envMap2Res : g.emptyTexture,
            envMap3 = this.envMap3Res ? this.envMap3Res : g.emptyTexture;
      global["E" /* store */].GetVariable('EveSpaceSceneEnvMap').SetTextureRes(envMap);
      global["E" /* store */].GetVariable('EnvMap1').SetTextureRes(envMap1);
      global["E" /* store */].GetVariable('EnvMap2').SetTextureRes(envMap2);
      global["E" /* store */].GetVariable('EnvMap3').SetTextureRes(envMap3);
    }
    /**
     * Initializes class global and scratch variables
     */

  }], [{
    key: "init",
    value: function init() {
      if (!EveSpaceScene.global) {
        EveSpaceScene.global = {
          vec3_0: global["H" /* vec3 */].create(),
          vec4_0: global["I" /* vec4 */].create(),
          mat4_0: global["z" /* mat4 */].create(),
          mat4_1: global["z" /* mat4 */].create(),
          mat4_2: global["z" /* mat4 */].create(),
          mat4_ID: global["z" /* mat4 */].create(),
          frustum: new core["Tw2Frustum"](),
          emptyTexture: global["D" /* resMan */].GetResource('res:/texture/global/black.dds.0.png')
        };
      }
    }
    /**
     * Per frame data
     * @type {*}
     */

  }]);

  return EveSpaceScene;
}();

EveSpaceScene_defineProperty(EveSpaceScene_EveSpaceScene, "perFrameData", {
  PSData: [['ViewInverseTransposeMat', 16], ['ViewMat', 16], ['EnvMapRotationMat', 16], ['SunData.DirWorld', 4], ['SunData.DiffuseColor', 4], ['SceneData.AmbientColor', 3], ['SceneData.NebulaIntensity', 1], ['SceneData.FogColor', 4], ['ViewportOffset', 2], ['ViewportSize', 2], ['TargetResolution', 4], ['ShadowMapSettings', 4], ['ShadowCameraRange', 4], ['ProjectionToView', 2], ['FovXY', 2], ['MiscSettings', 4]],
  VSData: [['ViewInverseTransposeMat', 16], ['ViewProjectionMat', 16], ['ViewMat', 16], ['ProjectionMat', 16], ['ShadowViewMat', 16], ['ShadowViewProjectionMat', 16], ['EnvMapRotationMat', 16], ['SunData.DirWorld', 4], ['SunData.DiffuseColor', 4], ['FogFactors', 4], ['TargetResolution', 4], ['ViewportAdjustment', 4], ['MiscSettings', 4]]
});

EveSpaceScene_defineProperty(EveSpaceScene_EveSpaceScene, "global", null);

EveSpaceScene_defineProperty(EveSpaceScene_EveSpaceScene, "DebugRenderer", window['Tw2DebugRenderer'] || null);
// EXTERNAL MODULE: ./curve/index.js + 34 modules
var curve_0 = __webpack_require__(12);

// CONCATENATED MODULE: ./eve/EveSOF.js



















function EveSOF() {
  var data = null;
  var spriteEffect = null;

  function _get(obj, property, defaultValue) {
    if (property in obj) {
      return obj[property];
    }

    return defaultValue;
  }
  /**
   * @return {string}
   */


  function GetShaderPrefix(isAnimated) {
    return isAnimated ? _get(data['generic'], 'shaderPrefixAnimated', '') : _get(data['generic'], 'shaderPrefix', '');
  }

  function ModifyTextureResPath(path, name, area, faction, commands) {
    var pathInsert = null;

    if (_get(faction, 'resPathInsert', '').length) {
      pathInsert = faction.resPathInsert;
    }

    if ('respathinsert' in commands && commands.respathinsert.length === 1) {
      if (commands.respathinsert[0] === 'none') {
        return path;
      } else {
        pathInsert = commands.respathinsert[0];
      }
    }

    if (name === 'MaterialMap' || name === 'PaintMaskMap' || name === 'PmdgMap') {
      var index = path.lastIndexOf('/');
      var pathCopy = path;

      if (index >= 0) {
        pathCopy = path.substr(0, index + 1) + pathInsert + '/' + path.substr(index + 1);
      }

      index = pathCopy.lastIndexOf('_');

      if (index >= 0) {
        pathCopy = pathCopy.substr(0, index) + '_' + pathInsert + pathCopy.substr(index);

        var textureOverrides = _get(area, 'textureOverrides', {});

        if (name in textureOverrides && faction.name in textureOverrides[name]) {
          return pathCopy;
        }
      }
    }

    return path;
  }
  /**
   * @return {string}
   */


  function ModifyShaderPath(shader, isSkinned) {
    var prefix = GetShaderPrefix(isSkinned);
    shader = '/' + shader;
    var index = shader.lastIndexOf('/');
    return shader.substr(0, index + 1) + prefix + shader.substr(index + 1);
  }

  function FindPrefix(prefixes, name) {
    for (var m = 0; m < prefixes.length; ++m) {
      if (name.substr(0, prefixes[m].length) === prefixes[m]) {
        return m;
      }
    }

    return null;
  }

  function GetOverridenParameter(name, area, commands, race) {
    var prefixes, materialIndex, materialData, shortName;

    if ('mesh' in commands) {
      prefixes = data.generic.materialPrefixes;
      materialIndex = FindPrefix(prefixes, name);

      if (materialIndex !== null && materialIndex < commands.mesh.length && (_get(area, 'blockedMaterials', 0) & 1 << materialIndex) === 0) {
        materialData = _get(data.material, commands.mesh[materialIndex], null);

        if (materialData) {
          shortName = name.substr(prefixes[materialIndex].length);
          return _get(materialData.parameters, shortName, undefined);
        }
      }
    }

    prefixes = data.generic.patternMaterialPrefixes;
    materialIndex = FindPrefix(prefixes, name);

    if ('pattern' in commands) {
      if (materialIndex !== null && 1 + materialIndex < commands.pattern.length) {
        materialData = _get(data.material, commands.pattern[1 + materialIndex], null);

        if (materialData) {
          shortName = name.substr(prefixes[materialIndex].length);
          return _get(materialData.parameters, shortName, undefined);
        }
      }
    }

    if (materialIndex !== null) {
      materialData = _get(data.material, race.defaultPatternLayer1MaterialName, null);

      if (materialData) {
        shortName = name.substr(prefixes[materialIndex].length);
        return _get(materialData.parameters, shortName, undefined);
      }
    }
  }

  function GetAddressMode(projectionType) {
    switch (projectionType) {
      case 2:
        return 4;

      case 1:
        return 3;

      default:
        return 1;
    }
  }

  function FillMeshAreas(areas, areasName, hull, faction, race, pattern, commands, shaderOverride) {
    var hullAreas = _get(hull, areasName, []);

    for (var i = 0; i < hullAreas.length; ++i) {
      var area = hullAreas[i];
      var effect = new core["Tw2Effect"]();
      effect.effectFilePath = data['generic']['areaShaderLocation'] + ModifyShaderPath(shaderOverride ? shaderOverride : area.shader, hull['isSkinned']);

      var names = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'parameters', []);

      for (var j = 0; j < names.length; ++j) {
        var name = names[j];
        var param = GetOverridenParameter(name, area, commands, race);
        param = param || _get(_get(_get(data.generic.hullAreas, area.name, {}), 'parameters', {}), name);
        param = param || _get(_get(_get(race.hullAreas, area.name, {}), 'parameters', {}), name);
        param = param || _get(_get(_get(faction.areas, area.name, {}), 'parameters', {}), name);
        param = param || _get(_get(area, 'parameters', {}), name);

        if (param) {
          effect.parameters[name] = new core["Tw2Vector4Parameter"](name, param);
        }
      }

      var hullTextures = _get(area, 'textures', []);

      for (j in hullTextures) {
        if (hullTextures.hasOwnProperty(j)) {
          var path = hullTextures[j];
          path = ModifyTextureResPath(path, j, area, faction, commands);
          effect.parameters[j] = new core["Tw2TextureParameter"](j, path);
        }
      }

      for (j = 0; j < pattern.layers.length; ++j) {
        if (pattern.layers[j] && !(pattern.layers[j].textureName in effect.parameters)) {
          var patternTex = new core["Tw2TextureParameter"](pattern.layers[j].textureName);
          patternTex.resourcePath = pattern.layers[j].textureResFilePath;
          patternTex.useAllOverrides = true;
          patternTex.addressUMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeU', 0));
          patternTex.addressVMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeV', 0));
          patternTex.Initialize();
          effect.parameters[pattern.layers[j].textureName] = patternTex;
        }
      }

      var defaultTextures = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'defaultTextures', {});

      for (var texName in defaultTextures) {
        if (defaultTextures.hasOwnProperty(texName)) {
          if (!(texName in effect.parameters)) {
            effect.parameters[texName] = new core["Tw2TextureParameter"](texName, defaultTextures[texName]);
          }
        }
      }

      effect.Initialize();
      var newArea = new core["Tw2MeshArea"]();
      newArea.name = area.name;
      newArea.effect = effect;
      newArea.index = _get(area, 'index', 0);
      newArea.count = _get(area, 'count', 1);
      areas.push(newArea);
    }
  }

  function SetupMesh(ship, hull, faction, race, commands, pattern) {
    var mesh = new core["Tw2Mesh"]();
    mesh.geometryResPath = hull['geometryResFilePath'];
    ship.boundingSphereCenter[0] = hull.boundingSphere[0];
    ship.boundingSphereCenter[1] = hull.boundingSphere[1];
    ship.boundingSphereCenter[2] = hull.boundingSphere[2];
    ship.boundingSphereRadius = hull.boundingSphere[3];
    FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands);
    FillMeshAreas(_get(mesh, 'transparentAreas', []), 'transparentAreas', hull, faction, race, pattern, commands);
    FillMeshAreas(_get(mesh, 'additiveAreas', []), 'additiveAreas', hull, faction, race, pattern, commands);
    FillMeshAreas(_get(mesh, 'decalAreas', []), 'decalAreas', hull, faction, race, pattern, commands);
    FillMeshAreas(_get(mesh, 'depthAreas', []), 'depthAreas', hull, faction, race, pattern, commands);
    mesh.Initialize();
    ship.mesh = mesh;

    if ('shapeEllipsoidCenter' in hull) {
      ship.shapeEllipsoidCenter = hull.shapeEllipsoidCenter;
    }

    if ('shapeEllipsoidRadius' in hull) {
      ship.shapeEllipsoidRadius = hull.shapeEllipsoidRadius;
    }
  }

  function SetupPattern(hull, race, commands) {
    var pattern = {
      patterns: [],
      layers: []
    };

    if ('pattern' in commands) {
      var p = {};

      for (var k = 0; k < data.pattern.length; ++k) {
        if (data.pattern[k].name === commands.pattern[0]) {
          p = data.pattern[k];
          break;
        }
      }

      var layer = _get(p, 'layer1', null);

      if (layer) {
        pattern.layers.push(layer);
      }

      layer = _get(p, 'layer2', null);

      if (layer) {
        pattern.layers.push(layer);
      }

      var projections = _get(p, 'projections', []);

      for (var i = 0; i < projections.length; ++i) {
        if (projections[i].name === hull.name) {
          p = projections[i];
          layer = _get(p, 'transformLayer1', null);

          if (layer) {
            pattern.patterns.push(layer);
          }

          layer = _get(p, 'transformLayer2', null);

          if (layer) {
            pattern.patterns.push(layer);
          }
        }
      }
    } else if (_get(hull, 'defaultPattern')) {
      p = _get(hull, 'defaultPattern', {});
      layer = _get(p, 'transformLayer1', null);

      if (layer) {
        pattern.patterns.push(layer);
      }

      layer = _get(p, 'transformLayer2', null);

      if (layer) {
        pattern.patterns.push(layer);
      }

      p = _get(race, 'defaultPattern', {});
      layer = _get(p, 'layer1', null);

      if (layer) {
        pattern.layers.push(layer);
      }

      layer = _get(p, 'layer2', null);

      if (layer) {
        pattern.layers.push(layer);
      }
    }

    return pattern;
  }

  function SetupCustomMasks(ship, pattern) {
    for (var i = 0; i < pattern.patterns.length; ++i) {
      if (pattern.patterns[i] && pattern.layers[i]) {
        var p = pattern.patterns[i];
        var l = pattern.layers[i];
        ship.AddCustomMask(_get(p, 'position', global["H" /* vec3 */].create()), _get(p, 'scaling', global["H" /* vec3 */].fromValues(1, 1, 1)), _get(p, 'rotation', global["C" /* quat */].create()), _get(p, 'isMirrored', false), _get(l, 'materialSource', 0), global["I" /* vec4 */].fromValues(_get(l, 'isTargetMtl1', true) ? 1 : 0, _get(l, 'isTargetMtl2', true) ? 1 : 0, _get(l, 'isTargetMtl3', true) ? 1 : 0, _get(l, 'isTargetMtl4', true) ? 1 : 0));
      }
    }
  }

  function SetupDecals(ship, hull, faction) {
    var hullDecals = _get(hull, 'hullDecals', []);

    for (var i = 0; i < hullDecals.length; ++i) {
      var hullDecal = hullDecals[i];
      var factionDecal = null;

      var factionIndex = 'group' + _get(hullDecal, 'groupIndex', -1);

      if (faction.decals && factionIndex in faction.decals) {
        factionDecal = faction.decals[factionIndex];
      }

      if (factionDecal && !factionDecal['isVisible']) {
        continue;
      }

      var effect = new core["Tw2Effect"]();

      if (factionDecal && factionDecal.shader && factionDecal.shader.length) {
        effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + factionDecal.shader;
      } else if (hullDecal.shader && hullDecal.shader.length) {
        effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + hullDecal.shader;
      } else {
        continue;
      }

      var hullParameters = _get(hullDecal, 'parameters', {});

      for (var j in hullParameters) {
        if (hullParameters.hasOwnProperty(j)) {
          effect.parameters[j] = new core["Tw2Vector4Parameter"](j, hullParameters[j]);
        }
      }

      var hullTextures = _get(hullDecal, 'textures', {});

      for (j in hullTextures) {
        if (hullTextures.hasOwnProperty(j)) {
          effect.parameters[j] = new core["Tw2TextureParameter"](j, hullTextures[j]);
        }
      }

      if (factionDecal) {
        var factionParameters = _get(factionDecal, 'parameters', {});

        for (j in factionParameters) {
          if (factionParameters.hasOwnProperty(j)) {
            effect.parameters[j] = new core["Tw2Vector4Parameter"](j, factionParameters[j]);
          }
        }

        var factionTextures = _get(factionDecal, 'textures', {});

        for (j in factionTextures) {
          if (factionTextures.hasOwnProperty(j) && !(j in effect.parameters)) {
            effect.parameters[j] = new core["Tw2TextureParameter"](j, factionTextures[j]);
          }
        }
      }

      var defaultTextures = _get(_get(data['generic']['decalShaders'], hullDecal.shader, {}), 'defaultTextures', {});

      for (var texName in defaultTextures) {
        if (defaultTextures.hasOwnProperty(texName)) {
          if (!(texName in effect.parameters)) {
            effect.parameters[texName] = new core["Tw2TextureParameter"](texName, defaultTextures[texName]);
          }
        }
      }

      effect.Initialize();
      var decal = new EveSpaceObjectDecal_EveSpaceObjectDecal();
      global["H" /* vec3 */].copy(decal.position, _get(hullDecal, 'position', [0, 0, 0]));
      global["C" /* quat */].copy(decal.rotation, _get(hullDecal, 'rotation', [0, 0, 0, 1]));
      global["H" /* vec3 */].copy(decal.scaling, _get(hullDecal, 'scaling', [1, 1, 1]));
      decal.parentBoneIndex = _get(hullDecal, 'boneIndex', -1);
      decal.indexBuffer = new Uint16Array(hullDecal.indexBuffer);
      decal.decalEffect = effect;
      decal.name = _get(hullDecals[i], 'name', '');

      if ('groupIndex' in hullDecals[i]) {
        decal.groupIndex = hullDecals[i].groupIndex;
      }

      decal.Initialize();
      ship.decals.push(decal);
    }
  }

  function SetupInstancedMeshes(ship, hull, faction, race, commands, pattern) {
    var instancedMeshes = _get(hull, 'instancedMeshes', []);

    for (var i = 0; i < instancedMeshes.length; ++i) {
      var him = instancedMeshes[i];
      var mesh = new core["Tw2InstancedMesh"]();
      mesh.instanceGeometryResPath = him.instanceGeometryResPath;
      mesh.geometryResPath = him.geometryResPath;
      mesh.Initialize();
      FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands, him.shader);
      var child = new EveChildMesh_EveChildMesh();
      child.mesh = mesh;
      ship.effectChildren.push(child);
    }
  }

  function SetupSpriteSets(ship, hull, faction) {
    var hullSets = _get(hull, 'spriteSets', []);

    var factionSets = _get(faction, 'spriteSets', {});

    for (var i = 0; i < hullSets.length; ++i) {
      var spriteSet = new EveSpriteSet_EveSpriteSet(true, !!(hull['isSkinned'] && hullSets[i]['skinned']));
      spriteSet.name = _get(hullSets[i], 'name', '');
      spriteSet.effect = spriteEffect;

      var hullData = _get(hullSets[i], 'items', []);

      for (var j = 0; j < hullData.length; ++j) {
        if (!('group' + _get(hullData[j], 'groupIndex', -1) in factionSets)) continue;
        var item = new EveSpriteSet_EveSpriteSetItem();
        item.blinkPhase = _get(hullData[j], 'blinkPhase', 0);
        item.blinkRate = _get(hullData[j], 'blinkRate', 0.1);
        item.boneIndex = _get(hullData[j], 'boneIndex', 0);
        item.falloff = _get(hullData[j], 'falloff', 0);
        item.maxScale = _get(hullData[j], 'maxScale', 10);
        item.minScale = _get(hullData[j], 'minScale', 1);
        item.name = _get(hullData[j], 'name', '');
        item.groupIndex = _get(hullData[j], 'groupIndex', -1);
        global["H" /* vec3 */].copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));
        var factionSet = factionSets['group' + item.groupIndex];

        if (factionSet) {
          item.groupName = factionSet.name;
          if ('color' in factionSet) global["I" /* vec4 */].copy(item.color, factionSet.color);
        }

        spriteSet.sprites.push(item);
      }

      spriteSet.Initialize();
      ship.spriteSets.push(spriteSet);
    }
  }

  function SetupSpotlightSets(ship, hull, faction) {
    var hullSets = _get(hull, 'spotlightSets', []);

    var factionSets = _get(faction, 'spotlightSets', {});

    for (var i = 0; i < hullSets.length; ++i) {
      var spotlightSet = new EveSpotlightSet_EveSpotlightSet();
      spotlightSet.name = _get(hullSets[i], 'name', '');
      spotlightSet.coneEffect = new core["Tw2Effect"]();
      spotlightSet.glowEffect = new core["Tw2Effect"]();

      if (hullSets[i]['skinned']) {
        spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightcone.fx';
        spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightglow.fx';
      } else {
        spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightcone.fx';
        spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightglow.fx';
      }

      spotlightSet.coneEffect.parameters['TextureMap'] = new core["Tw2TextureParameter"]('TextureMap', hullSets[i]['coneTextureResPath']);
      spotlightSet.glowEffect.parameters['TextureMap'] = new core["Tw2TextureParameter"]('TextureMap', hullSets[i]['glowTextureResPath']);
      spotlightSet.coneEffect.parameters['zOffset'] = new core["Tw2FloatParameter"]('zOffset', _get(hullSets[i], 'zOffset', 0));
      spotlightSet.coneEffect.Initialize();
      spotlightSet.glowEffect.Initialize();

      var hullData = _get(hullSets[i], 'items', []);

      for (var j = 0; j < hullData.length; ++j) {
        var item = new EveSpotlightSet_EveSpotlightSetItem();
        item.name = _get(hullData[j], 'name', '');
        item.groupIndex = _get(hullData[j], 'groupIndex', -1);
        item.boneIndex = _get(hullData[j], 'boneIndex', 0);
        item.boosterGainInfluence = _get(hullData[j], 'boosterGainInfluence', 0);
        item.coneIntensity = _get(hullData[j], 'coneIntensity', 0);
        item.spriteIntensity = _get(hullData[j], 'spriteIntensity', 0);
        item.flareIntensity = _get(hullData[j], 'flareIntensity', 0);
        var factionSet = factionSets['group' + item.groupIndex];

        if (factionSet) {
          global["I" /* vec4 */].copy(item.coneColor, _get(factionSet, 'coneColor', [0, 0, 0, 0]));
          global["I" /* vec4 */].copy(item.spriteColor, _get(factionSet, 'spriteColor', [0, 0, 0, 0]));
          global["I" /* vec4 */].copy(item.flareColor, _get(factionSet, 'flareColor', [0, 0, 0, 0]));
        }

        global["H" /* vec3 */].copy(item.spriteScale, _get(hullData[j], 'spriteScale', [1, 1, 1]));

        if ('transform' in hullData[j]) {
          global["z" /* mat4 */].copy(item.transform, hullData[j].transform);
        } else {
          global["z" /* mat4 */].identity(item.transform);
        }

        spotlightSet.spotlightItems.push(item);
      }

      spotlightSet.Initialize();
      ship.spotlightSets.push(spotlightSet);
    }
  }

  function _assignIfExists(dest, src, attr) {
    if (attr in src) {
      dest[attr] = src[attr];
    }
  }

  function SetupPlaneSets(ship, hull, faction) {
    var hullSets = _get(hull, 'planeSets', []);

    var factionSets = _get(faction, 'planeSets', {});

    for (var i = 0; i < hullSets.length; ++i) {
      var planeSet = new EvePlaneSet_EvePlaneSet();
      planeSet.name = _get(hullSets[i], 'name', '');
      planeSet.effect = new core["Tw2Effect"]();

      if (hullSets[i]['skinned']) {
        planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_planeglow.fx';
      } else {
        planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/planeglow.fx';
      }

      planeSet.effect.parameters['Layer1Map'] = new core["Tw2TextureParameter"]('Layer1Map', hullSets[i]['layer1MapResPath']);
      planeSet.effect.parameters['Layer2Map'] = new core["Tw2TextureParameter"]('Layer2Map', hullSets[i]['layer2MapResPath']);
      planeSet.effect.parameters['MaskMap'] = new core["Tw2TextureParameter"]('MaskMap', hullSets[i]['maskMapResPath']);
      planeSet.effect.parameters['PlaneData'] = new core["Tw2Vector4Parameter"]('PlaneData', _get(hullSets[i], 'planeData', [1, 0, 0, 0]));
      planeSet.effect.Initialize();

      var hullData = _get(hullSets[i], 'items', []);

      for (var j = 0; j < hullData.length; ++j) {
        var item = new EvePlaneSet_EvePlaneSetItem();

        _assignIfExists(item, hullData[j], 'groupIndex');

        _assignIfExists(item, hullData[j], 'name');

        item.boneIndex = _get(hullData[j], 'boneIndex', -1);
        item.maskAtlasID = _get(hullData[j], 'maskMapAtlasIndex', 0); // Do not copy reference!

        global["H" /* vec3 */].copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));
        global["C" /* quat */].copy(item.rotation, _get(hullData[j], 'rotation', [0, 0, 0, 1]));
        global["H" /* vec3 */].copy(item.scaling, _get(hullData[j], 'scaling', [1, 1, 1]));
        global["I" /* vec4 */].copy(item.color, _get(hullData[j], 'color', [0, 0, 0, 0]));
        global["I" /* vec4 */].copy(item.layer1Transform, _get(hullData[j], 'layer1Transform', [0, 0, 0, 0]));
        global["I" /* vec4 */].copy(item.layer1Scroll, _get(hullData[j], 'layer1Scroll', [0, 0, 0, 0]));
        global["I" /* vec4 */].copy(item.layer2Transform, _get(hullData[j], 'layer2Transform', [0, 0, 0, 0]));
        global["I" /* vec4 */].copy(item.layer2Scroll, _get(hullData[j], 'layer2Scroll', [0, 0, 0, 0]));

        var factionSet = factionSets['group' + _get(hullData[j], 'groupIndex', -1)];

        if (factionSet) global["I" /* vec4 */].copy(item.color, _get(factionSet, 'color', [0, 0, 0, 0]));
        planeSet.planes.push(item);
      }

      planeSet.Initialize();
      ship.planeSets.push(planeSet);
    }
  }

  function SetupBoosters(ship, hull, race) {
    if (!('booster' in hull)) {
      return;
    }

    var booster = new EveBoosterSet_EveBoosterSet();
    var hullBooster = hull['booster'];

    var raceBooster = _get(race, 'booster', {});

    _assignIfExists(booster, raceBooster, 'glowScale');

    _assignIfExists(booster, raceBooster, 'symHaloScale');

    _assignIfExists(booster, raceBooster, 'haloScaleX');

    _assignIfExists(booster, raceBooster, 'haloScaleY');

    _assignIfExists(booster, raceBooster, 'haloColor');

    global["I" /* vec4 */].copy(booster.glowColor, _get(raceBooster, 'glowColor', [0, 0, 0, 0]));
    global["I" /* vec4 */].copy(booster.warpGlowColor, _get(raceBooster, 'warpGlowColor', [0, 0, 0, 0]));
    global["I" /* vec4 */].copy(booster.warpHaloColor, _get(raceBooster, 'warpHalpColor', [0, 0, 0, 0]));
    global["I" /* vec4 */].copy(booster.trailColor, _get(raceBooster, 'trailColor', [0, 0, 0, 0]));
    global["I" /* vec4 */].copy(booster.trailSize, _get(raceBooster, 'trailSize', [0, 0, 0, 0]));
    booster.effect = new core["Tw2Effect"]();
    booster.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterVolumetric.fx';
    booster.effect.parameters['NoiseFunction0'] = new core["Tw2FloatParameter"]('NoiseFunction0', _get(raceBooster.shape0, 'noiseFunction', 0));
    booster.effect.parameters['NoiseSpeed0'] = new core["Tw2FloatParameter"]('NoiseSpeed0', _get(raceBooster.shape0, 'noiseSpeed', 0));
    booster.effect.parameters['NoiseAmplitudeStart0'] = new core["Tw2Vector4Parameter"]('NoiseAmplitudeStart0', _get(raceBooster.shape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
    booster.effect.parameters['NoiseAmplitudeEnd0'] = new core["Tw2Vector4Parameter"]('NoiseAmplitudeEnd0', _get(raceBooster.shape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
    booster.effect.parameters['NoiseFrequency0'] = new core["Tw2Vector4Parameter"]('NoiseFrequency0', _get(raceBooster.shape0, 'noiseFrequency', [0, 0, 0, 0]));
    booster.effect.parameters['Color0'] = new core["Tw2Vector4Parameter"]('Color0', _get(raceBooster.shape0, 'color', [0, 0, 0, 0]));
    booster.effect.parameters['NoiseFunction1'] = new core["Tw2FloatParameter"]('NoiseFunction1', _get(raceBooster.shape1, 'noiseFunction', 0));
    booster.effect.parameters['NoiseSpeed1'] = new core["Tw2FloatParameter"]('NoiseSpeed1', _get(raceBooster.shape1, 'noiseSpeed', 0));
    booster.effect.parameters['NoiseAmplitudeStart1'] = new core["Tw2Vector4Parameter"]('NoiseAmplitudeStart1', _get(raceBooster.shape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
    booster.effect.parameters['NoiseAmplitudeEnd1'] = new core["Tw2Vector4Parameter"]('NoiseAmplitudeEnd1', _get(raceBooster.shape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
    booster.effect.parameters['NoiseFrequency1'] = new core["Tw2Vector4Parameter"]('NoiseFrequency1', _get(raceBooster.shape1, 'noiseFrequency', [0, 0, 0, 0]));
    booster.effect.parameters['Color1'] = new core["Tw2Vector4Parameter"]('Color1', _get(raceBooster.shape1, 'color', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseFunction0'] = new core["Tw2FloatParameter"]('WarpNoiseFunction0', _get(raceBooster.warpShape0, 'noiseFunction', 0));
    booster.effect.parameters['WarpNoiseSpeed0'] = new core["Tw2FloatParameter"]('WarpNoiseSpeed0', _get(raceBooster.warpShape0, 'noiseSpeed', 0));
    booster.effect.parameters['WarpNoiseAmplitudeStart0'] = new core["Tw2Vector4Parameter"]('WarpNoiseAmplitudeStart0', _get(raceBooster.warpShape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseAmplitudeEnd0'] = new core["Tw2Vector4Parameter"]('WarpNoiseAmplitudeEnd0', _get(raceBooster.warpShape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseFrequency0'] = new core["Tw2Vector4Parameter"]('WarpNoiseFrequency0', _get(raceBooster.warpShape0, 'noiseFrequency', [0, 0, 0, 0]));
    booster.effect.parameters['WarpColor0'] = new core["Tw2Vector4Parameter"]('WarpColor0', _get(raceBooster.warpShape0, 'color', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseFunction1'] = new core["Tw2FloatParameter"]('WarpNoiseFunction1', _get(raceBooster.warpShape1, 'noiseFunction', 0));
    booster.effect.parameters['WarpNoiseSpeed1'] = new core["Tw2FloatParameter"]('WarpNoiseSpeed1', _get(raceBooster.warpShape1, 'noiseSpeed', 0));
    booster.effect.parameters['WarpNoiseAmplitudeStart1'] = new core["Tw2Vector4Parameter"]('WarpNoiseAmplitudeStart1', _get(raceBooster.warpShape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseAmplitudeEnd1'] = new core["Tw2Vector4Parameter"]('WarpNoiseAmplitudeEnd1', _get(raceBooster.warpShape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
    booster.effect.parameters['WarpNoiseFrequency1'] = new core["Tw2Vector4Parameter"]('WarpNoiseFrequency1', _get(raceBooster.warpShape1, 'noiseFrequency', [0, 0, 0, 0]));
    booster.effect.parameters['WarpColor1'] = new core["Tw2Vector4Parameter"]('WarpColor1', _get(raceBooster.warpShape1, 'color', [0, 0, 0, 0]));
    booster.effect.parameters['ShapeAtlasSize'] = new core["Tw2Vector4Parameter"]('ShapeAtlasSize', [_get(raceBooster, 'shapeAtlasHeight', 0), _get(raceBooster, 'shapeAtlasCount', 0), 0, 0]);
    booster.effect.parameters['BoosterScale'] = new core["Tw2Vector4Parameter"]('BoosterScale', _get(raceBooster, 'scale', [1, 1, 1, 1]));
    booster.effect.parameters['ShapeMap'] = new core["Tw2TextureParameter"]('ShapeMap', raceBooster.shapeAtlasResPath);
    booster.effect.parameters['GradientMap0'] = new core["Tw2TextureParameter"]('GradientMap0', raceBooster.gradient0ResPath);
    booster.effect.parameters['GradientMap1'] = new core["Tw2TextureParameter"]('GradientMap1', raceBooster.gradient1ResPath);
    booster.effect.parameters['NoiseMap'] = new core["Tw2TextureParameter"]('ShapeMap', 'res:/Texture/Global/noise32cube_volume.dds.0.png');
    booster.effect.Initialize();
    booster.glows = new EveSpriteSet_EveSpriteSet(true);
    booster.glows.effect = new core["Tw2Effect"]();
    booster.glows.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterGlowAnimated.fx';
    booster.glows.effect.parameters['DiffuseMap'] = new core["Tw2TextureParameter"]('DiffuseMap', 'res:/Texture/Particle/whitesharp.dds.0.png');
    booster.glows.effect.parameters['NoiseMap'] = new core["Tw2TextureParameter"]('NoiseMap', 'res:/Texture/global/noise.dds.0.png');
    booster.glows.effect.Initialize();

    var items = _get(hullBooster, 'items', []);

    for (var i = 0; i < items.length; ++i) {
      var locator = new EveLocator_EveLocator();
      locator.name = 'locator_booster_' + (i + 1);

      if ('transform' in items[i]) {
        global["z" /* mat4 */].copy(locator.transform, items[i].transform);
      } else {
        global["z" /* mat4 */].identity(locator.transform);
      }

      locator.atlasIndex0 = _get(items[i], 'atlasIndex0', 0);
      locator.atlasIndex1 = _get(items[i], 'atlasIndex1', 0);
      ship.locators.push(locator);
    }

    booster.Initialize();
    ship.boosters = booster;
  }

  function SetupLocators(ship, hull) {
    var hullLocators = _get(hull, 'locatorTurrets', []);

    for (var i = 0; i < hullLocators.length; ++i) {
      var locator = new EveLocator_EveLocator();
      locator.name = hullLocators[i].name;

      if ('transform' in hullLocators[i]) {
        global["z" /* mat4 */].copy(locator.transform, hullLocators[i].transform);
      } else {
        global["z" /* mat4 */].identity(locator.transform);
      }

      ship.locators.push(locator);
    }
  }

  function BindParticleEmitters(obj, curveSet, curve) {
    if (Array.isArray(obj.particleEmitters)) {
      for (var i = 0; i < obj.particleEmitters.length; ++i) {
        if ('rate' in obj.particleEmitters[i]) {
          var binding = new core["Tw2ValueBinding"]();
          binding.sourceObject = curve;
          binding.sourceAttribute = 'currentValue';
          binding.destinationObject = obj.particleEmitters[i];
          binding.destinationAttribute = 'rate';
          binding.Initialize();
          curveSet.bindings.push(binding);
        }
      }

      for (i = 0; i < obj.children.length; ++i) {
        BindParticleEmitters(obj.children[i], curveSet, curve);
      }
    } else {
      global["D" /* resMan */].log({
        type: 'warning',
        name: 'Space object factory',
        message: `Unable to bind particle emitters: ${obj.constructor.name}`
      });
    }
  }

  function SetupChildren(ship, hull, curveSet, curves) {
    function onChildLoaded(child) {
      return function (obj) {
        if (obj.isEffectChild) {
          ship.effectChildren.push(obj);
        } else {
          ship.children.push(obj);
        }

        global["H" /* vec3 */].copy(obj.translation, _get(child, 'translation', [0, 0, 0]));
        global["C" /* quat */].copy(obj.rotation, _get(child, 'rotation', [0, 0, 0, 1]));
        global["H" /* vec3 */].copy(obj.scaling, _get(child, 'scaling', [1, 1, 1]));

        var id = _get(child, 'id', -1);

        if (id !== -1 && curves[id]) {
          BindParticleEmitters(obj, curveSet, curves[id]);
        }
      };
    }

    const children = _get(hull, 'children', []);

    for (let i = 0; i < children.length; ++i) {
      const resPath = children[i]['redFilePath'];

      if (resPath) {
        global["D" /* resMan */].GetObject(resPath, onChildLoaded(children[i]));
      } else {
        global["D" /* resMan */].log({
          type: 'warning',
          name: 'Space object factory',
          message: `No resource path found for "${hull.name}" child at index ${i}`
        });
      }
    }
  }

  function SetupAnimations(ship, hull) {
    var id_curves = [];
    var curveSet = null;

    var animations = _get(hull, 'animations', []);

    for (var i = 0; i < animations.length; ++i) {
      if (_get(animations[i], 'id', -1) !== -1 && _get(animations[i], 'startRate', -1) !== -1) {
        if (!curveSet) {
          curveSet = new core["Tw2CurveSet"]();
        }

        var curve = new curve_0["Tw2ScalarCurve2"]();
        curve.keys.push(new curve_0["Tw2ScalarKey2"]());
        curve.keys.push(new curve_0["Tw2ScalarKey2"]());
        curve.keys[0].value = _get(animations[i], 'startRate', -1);
        curve.keys[1].time = 1;
        curve.keys[1].value = _get(animations[i], 'endRate', -1);
        curve.Initialize();
        curveSet.curves.push(curve);
        ship.curveSets.push(curveSet);
        id_curves[_get(animations[i], 'id', -1)] = curve;
      }
    }

    if (curveSet) {
      curveSet.Initialize();
    }

    return [curveSet, id_curves];
  }

  var dataLoading = false;
  var pendingLoads = [];

  function Build(dna) {
    var parts = dna.split(':');
    var commands = {};

    for (var i = 3; i < parts.length; ++i) {
      var subparts = parts[i].split('?');
      commands[subparts[0]] = subparts[1].split(';');
    }

    var hull = data['hull'][parts[0]];
    var faction = data['faction'][parts[1]];
    var race = data['race'][parts[2]];
    var ship = new (_get(hull, 'buildClass', 0) === 2 ? EveSpaceObject_EveSpaceObject : EveShip)();
    var pattern = SetupPattern(hull, race, commands);
    SetupMesh(ship, hull, faction, race, commands, pattern);
    SetupCustomMasks(ship, pattern);
    SetupDecals(ship, hull, faction);
    SetupSpriteSets(ship, hull, faction);
    SetupSpotlightSets(ship, hull, faction);
    SetupPlaneSets(ship, hull, faction);
    SetupBoosters(ship, hull, race);
    SetupLocators(ship, hull);
    var curves = SetupAnimations(ship, hull);
    SetupChildren(ship, hull, curves[0], curves[1]);
    SetupInstancedMeshes(ship, hull, faction, race, commands, pattern);
    ship.Initialize();
    return ship;
  }

  this.LoadData = function (callback) {
    if (data === null) {
      if (callback) {
        pendingLoads.push(callback);
      }

      if (!dataLoading) {
        spriteEffect = new core["Tw2Effect"]();
        spriteEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/blinkinglightspool.fx';
        spriteEffect.parameters['MainIntensity'] = new core["Tw2FloatParameter"]('MainIntensity', 1);
        spriteEffect.parameters['GradientMap'] = new core["Tw2TextureParameter"]('GradientMap', 'res:/texture/particle/whitesharp_gradient.dds.0.png');
        spriteEffect.Initialize();
        global["D" /* resMan */].GetObject('res:/dx9/model/spaceobjectfactory/data.red', function (obj) {
          data = obj;

          for (var i = 0; i < pendingLoads.length; ++i) {
            pendingLoads[i]();
          }

          pendingLoads = [];
        });
        dataLoading = true;
      }
    } else {
      if (callback) {
        callback();
      }
    }
  };

  this.BuildFromDNA = function (dna, callback) {
    if (data === null) {
      this.LoadData(function () {
        var result = Build(dna);

        if (callback) {
          callback(result);
        }
      });
    } else {
      var result = Build(dna);

      if (callback) {
        callback(result);
      }
    }
  };

  function GetTurretMaterialParameter(name, parentFaction, areaData) {
    var materialIdx = -1;

    for (var i = 0; i < data['generic']['materialPrefixes'].length; ++i) {
      if (name.substr(0, data['generic']['materialPrefixes'][i].length) === data['generic']['materialPrefixes'][i]) {
        materialIdx = i;
        name = name.substr(data['generic']['materialPrefixes'][i].length);
      }
    }

    if (materialIdx !== -1) {
      var turretMaterialIndex = _get(parentFaction, 'materialUsageMtl' + (materialIdx + 1), materialIdx);

      if (turretMaterialIndex >= 0 && turretMaterialIndex < data['generic']['materialPrefixes'].length) {
        name = data['generic']['materialPrefixes'][turretMaterialIndex] + name;

        if (name in areaData.parameters) {
          return areaData.parameters[name];
        }
      }
    }
  }

  var zeroColor = [0, 0, 0, 0];

  function CombineTurretMaterial(name, parentValue, turretValue, overrideMethod) {
    switch (overrideMethod) {
      case 'overridable':
        return parentValue ? parentValue : turretValue ? turretValue : zeroColor;

      case 'half_overridable':
        if (name.indexOf('GlowColor') >= 0) {
          return turretValue ? turretValue : zeroColor;
        }

        return parentValue ? parentValue : turretValue ? turretValue : zeroColor;

      case 'not_overridable':
      case 'half_overridable_2':
        return turretValue ? turretValue : zeroColor;
    }

    return zeroColor;
  }

  function SetupTurretMaterial(turretSet, parentFactionName, turretFactionName) {
    var parentFaction = data['faction'][parentFactionName];
    var turretFaction = data['faction'][turretFactionName];
    var parentArea = null;

    if (parentFaction && parentFaction.areas && 'hull' in parentFaction.areas) {
      parentArea = parentFaction.areas.hull;
    }

    var turretArea = null;

    if (turretFaction && turretFaction.areas && 'hull' in turretFaction.areas) {
      turretArea = turretFaction.areas.hull;
    }

    if (!parentArea && !turretArea) {
      return;
    }

    if (turretSet.turretEffect) {
      var params = turretSet.turretEffect.parameters;

      for (var i in params) {
        if (params.hasOwnProperty(i)) {
          if (params[i].constructor.prototype !== core["Tw2Vector4Parameter"].prototype) {
            continue;
          }

          var parentValue = null;
          var turretValue = null;

          if (parentArea) {
            parentValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
          }

          if (turretArea) {
            turretValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
          }

          global["I" /* vec4 */].copy(params[i].value, CombineTurretMaterial(i, parentValue, turretValue, turretSet.turretEffect.name));
        }
      }

      turretSet.turretEffect.BindParameters();
    }
  }

  this.SetupTurretMaterial = function (turretSet, parentFactionName, turretFactionName, callback) {
    if (data === null) {
      this.LoadData(function () {
        SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);

        if (callback) {
          callback();
        }
      });
    } else {
      SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);

      if (callback) {
        callback();
      }
    }
  };

  function getDataKeys(name) {
    if (name !== 'all') {
      var names = {};

      for (var i in data[name]) {
        if (data[name].hasOwnProperty(i)) {
          names[i] = data[name][i].description || '';
        }
      }

      return names;
    } else {
      return data;
    }
  }

  this.GetHullNames = function (callback) {
    this.LoadData(function () {
      callback(getDataKeys('hull'));
    });
  };

  this.GetFactionNames = function (callback) {
    this.LoadData(function () {
      callback(getDataKeys('faction'));
    });
  };

  this.GetRaceNames = function (callback) {
    this.LoadData(function () {
      callback(getDataKeys('race'));
    });
  };

  this.GetSofData = function (callback) {
    this.LoadData(function () {
      callback(getDataKeys('all'));
    });
  };
}
// CONCATENATED MODULE: ./eve/index.js
/* concated harmony reexport EveChild */__webpack_require__.d(__webpack_exports__, "EveChild", function() { return EveChild_EveChild; });
/* concated harmony reexport EveChildBillboard */__webpack_require__.d(__webpack_exports__, "EveChildBillboard", function() { return EveChildBillboard_EveChildBillboard; });
/* concated harmony reexport EveChildCloud */__webpack_require__.d(__webpack_exports__, "EveChildCloud", function() { return EveChildCloud; });
/* concated harmony reexport EveChildContainer */__webpack_require__.d(__webpack_exports__, "EveChildContainer", function() { return EveChildContainer; });
/* concated harmony reexport EveChildExplosion */__webpack_require__.d(__webpack_exports__, "EveChildExplosion", function() { return EveChildExplosion; });
/* concated harmony reexport EveChildMesh */__webpack_require__.d(__webpack_exports__, "EveChildMesh", function() { return EveChildMesh_EveChildMesh; });
/* concated harmony reexport EveChildParticleSystem */__webpack_require__.d(__webpack_exports__, "EveChildParticleSystem", function() { return EveChildParticleSystem_EveChildParticleSystem; });
/* concated harmony reexport EveLensflare */__webpack_require__.d(__webpack_exports__, "EveLensflare", function() { return EveLensflare_EveLensflare; });
/* concated harmony reexport EveMeshOverlayEffect */__webpack_require__.d(__webpack_exports__, "EveMeshOverlayEffect", function() { return EveMeshOverlayEffect_EveMeshOverlayEffect; });
/* concated harmony reexport EveOccluder */__webpack_require__.d(__webpack_exports__, "EveOccluder", function() { return EveOccluder_EveOccluder; });
/* concated harmony reexport EveStretch */__webpack_require__.d(__webpack_exports__, "EveStretch", function() { return EveStretch_EveStretch; });
/* concated harmony reexport EvePerMuzzleData */__webpack_require__.d(__webpack_exports__, "EvePerMuzzleData", function() { return EveTurretFiringFX_EvePerMuzzleData; });
/* concated harmony reexport EveTurretFiringFX */__webpack_require__.d(__webpack_exports__, "EveTurretFiringFX", function() { return EveTurretFiringFX_EveTurretFiringFX; });
/* concated harmony reexport EveStarfield */__webpack_require__.d(__webpack_exports__, "EveStarfield", function() { return EveStarfield_EveStarfield; });
/* concated harmony reexport EveObject */__webpack_require__.d(__webpack_exports__, "EveObject", function() { return EveObject_EveObject; });
/* concated harmony reexport EveEffectRoot */__webpack_require__.d(__webpack_exports__, "EveEffectRoot", function() { return EveEffectRoot_EveEffectRoot; });
/* concated harmony reexport EveMissileWarhead */__webpack_require__.d(__webpack_exports__, "EveMissileWarhead", function() { return EveMissile_EveMissileWarhead; });
/* concated harmony reexport EveMissile */__webpack_require__.d(__webpack_exports__, "EveMissile", function() { return EveMissile_EveMissile; });
/* concated harmony reexport EvePlanet */__webpack_require__.d(__webpack_exports__, "EvePlanet", function() { return EvePlanet_EvePlanet; });
/* concated harmony reexport EveShip */__webpack_require__.d(__webpack_exports__, "EveShip", function() { return EveShip; });
/* concated harmony reexport EveSpaceObject */__webpack_require__.d(__webpack_exports__, "EveSpaceObject", function() { return EveSpaceObject_EveSpaceObject; });
/* concated harmony reexport EveStation */__webpack_require__.d(__webpack_exports__, "EveStation", function() { return EveSpaceObject_EveSpaceObject; });
/* concated harmony reexport EveTransform */__webpack_require__.d(__webpack_exports__, "EveTransform", function() { return EveTransform_EveTransform; });
/* concated harmony reexport EveObjectSetItem */__webpack_require__.d(__webpack_exports__, "EveObjectSetItem", function() { return EveObjectSet_EveObjectSetItem; });
/* concated harmony reexport EveObjectSet */__webpack_require__.d(__webpack_exports__, "EveObjectSet", function() { return EveObjectSet_EveObjectSet; });
/* concated harmony reexport EveBoosterBatch */__webpack_require__.d(__webpack_exports__, "EveBoosterBatch", function() { return EveBoosterBatch; });
/* concated harmony reexport EveBoosterSetItem */__webpack_require__.d(__webpack_exports__, "EveBoosterSetItem", function() { return EveBoosterSet_EveBoosterSetItem; });
/* concated harmony reexport EveBoosterSet */__webpack_require__.d(__webpack_exports__, "EveBoosterSet", function() { return EveBoosterSet_EveBoosterSet; });
/* concated harmony reexport EveCurveLineSetItem */__webpack_require__.d(__webpack_exports__, "EveCurveLineSetItem", function() { return EveCurveLineSet_EveCurveLineSetItem; });
/* concated harmony reexport EveCurveLineSet */__webpack_require__.d(__webpack_exports__, "EveCurveLineSet", function() { return EveCurveLineSet_EveCurveLineSet; });
/* concated harmony reexport EveLocator */__webpack_require__.d(__webpack_exports__, "EveLocator", function() { return EveLocator_EveLocator; });
/* concated harmony reexport EvePlaneSetBatch */__webpack_require__.d(__webpack_exports__, "EvePlaneSetBatch", function() { return EvePlaneSetBatch; });
/* concated harmony reexport EvePlaneSetItem */__webpack_require__.d(__webpack_exports__, "EvePlaneSetItem", function() { return EvePlaneSet_EvePlaneSetItem; });
/* concated harmony reexport EvePlaneSet */__webpack_require__.d(__webpack_exports__, "EvePlaneSet", function() { return EvePlaneSet_EvePlaneSet; });
/* concated harmony reexport EveSpaceObjectDecal */__webpack_require__.d(__webpack_exports__, "EveSpaceObjectDecal", function() { return EveSpaceObjectDecal_EveSpaceObjectDecal; });
/* concated harmony reexport EveSpotlightSetBatch */__webpack_require__.d(__webpack_exports__, "EveSpotlightSetBatch", function() { return EveSpotlightSetBatch; });
/* concated harmony reexport EveSpotlightSetItem */__webpack_require__.d(__webpack_exports__, "EveSpotlightSetItem", function() { return EveSpotlightSet_EveSpotlightSetItem; });
/* concated harmony reexport EveSpotlightSet */__webpack_require__.d(__webpack_exports__, "EveSpotlightSet", function() { return EveSpotlightSet_EveSpotlightSet; });
/* concated harmony reexport EveSpriteSetBatch */__webpack_require__.d(__webpack_exports__, "EveSpriteSetBatch", function() { return EveSpriteSetBatch; });
/* concated harmony reexport EveSpriteSetItem */__webpack_require__.d(__webpack_exports__, "EveSpriteSetItem", function() { return EveSpriteSet_EveSpriteSetItem; });
/* concated harmony reexport EveSpriteSet */__webpack_require__.d(__webpack_exports__, "EveSpriteSet", function() { return EveSpriteSet_EveSpriteSet; });
/* concated harmony reexport EveTurretSetItem */__webpack_require__.d(__webpack_exports__, "EveTurretSetItem", function() { return EveTurretSet_EveTurretSetItem; });
/* concated harmony reexport EveTurretSet */__webpack_require__.d(__webpack_exports__, "EveTurretSet", function() { return EveTurretSet_EveTurretSet; });
/* concated harmony reexport EveSpaceScene */__webpack_require__.d(__webpack_exports__, "EveSpaceScene", function() { return EveSpaceScene_EveSpaceScene; });
/* concated harmony reexport EveSOF */__webpack_require__.d(__webpack_exports__, "EveSOF", function() { return EveSOF; });







/***/ }),
/* 21 */
/***/ (function(module, exports) {



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tw2ParticleSystem; });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _Tw2ParticleElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19);
/* harmony import */ var _Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





/**
 * Tw2ParticleSystem
 *
 * @property {number|string} id
 * @property {string} name
 * @property {number} aliveCount
 * @property {number} maxParticleCount
 * @property {*} emitParticleOnDeathEmitter
 * @property {*} emitParticleDuringLifeEmitter
 * @property {Array.<Tw2ParticleElement>} elements
 * @property {boolean} isValid
 * @property {boolean} requiresSorting
 * @property {boolean} updateSimulation
 * @property {boolean} applyForce
 * @property {boolean} applyAging
 * @property {boolean} isGlobal
 * @property {Array<Tw2ParticleForce>} forces
 * @property {Array<Tw2ParticleConstraint>} constraints
 * @property {boolean} updateBoundingBox
 * @property {vec3} aabbMin
 * @property {vec3} aabbMax
 * @property {number} peakAliveCount
 * @property {boolean} bufferDirty
 * @property {WebGLBuffer} _vb
 * @property {Tw2VertexDeclaration} _declaration
 * @property {Array<Tw2ParticleElement>} _stdElements
 * @property {Array<Tw2ParticleElement>} _elements
 * @property {Array} instanceStride
 * @property {Array} vertexStride
 * @property {Array} buffers
 * @class
 */

let Tw2ParticleSystem =
/*#__PURE__*/
function () {
  /**
   * Constructor
   */
  function Tw2ParticleSystem() {
    _classCallCheck(this, Tw2ParticleSystem);

    _defineProperty(this, "_id", _global__WEBPACK_IMPORTED_MODULE_0__[/* util */ "F"].generateID());

    _defineProperty(this, "name", '');

    _defineProperty(this, "aliveCount", 0);

    _defineProperty(this, "maxParticleCount", 0);

    _defineProperty(this, "emitParticleOnDeathEmitter", null);

    _defineProperty(this, "emitParticleDuringLifeEmitter", null);

    _defineProperty(this, "elements", []);

    _defineProperty(this, "isValid", false);

    _defineProperty(this, "requiresSorting", false);

    _defineProperty(this, "updateSimulation", true);

    _defineProperty(this, "applyForce", true);

    _defineProperty(this, "applyAging", true);

    _defineProperty(this, "isGlobal", false);

    _defineProperty(this, "forces", []);

    _defineProperty(this, "constraints", []);

    _defineProperty(this, "updateBoundingBox", false);

    _defineProperty(this, "aabbMin", _global__WEBPACK_IMPORTED_MODULE_0__[/* vec3 */ "H"].create());

    _defineProperty(this, "aabbMax", _global__WEBPACK_IMPORTED_MODULE_0__[/* vec3 */ "H"].create());

    _defineProperty(this, "peakAliveCount", 0);

    _defineProperty(this, "bufferDirty", false);

    _defineProperty(this, "_vb", null);

    _defineProperty(this, "_declaration", null);

    _defineProperty(this, "_stdElements", [null, null, null, null]);

    _defineProperty(this, "_elements", []);

    _defineProperty(this, "instanceStride", [null, null]);

    _defineProperty(this, "vertexStride", [null, null]);

    _defineProperty(this, "buffers", [null, null]);

    Tw2ParticleSystem.init();
  }
  /**
   * Initializes the Particle System
   */


  _createClass(Tw2ParticleSystem, [{
    key: "Initialize",
    value: function Initialize() {
      this.UpdateElementDeclaration();
    }
    /**
     * Updates Element Declarations
     */

  }, {
    key: "UpdateElementDeclaration",
    value: function UpdateElementDeclaration() {
      this.isValid = false;
      const gl = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].gl;

      if (this._vb) {
        gl.deleteBuffer(this._vb);
        this._vb = null;
      }

      this._declaration = null;
      this.aliveCount = 0;
      if (this.elements.length === 0) return;
      this._stdElements = [null, null, null, null];
      this._elements = [];
      this.instanceStride = [0, 0];
      this.vertexStride = [0, 0];
      this._declaration = new _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VertexDeclaration"]();
      this.buffers = [null, null];

      for (let i = 0; i < this.elements.length; ++i) {
        const bufferIndex = this.elements[i].usedByGPU ? 0 : 1,
              el = new _Tw2ParticleElement__WEBPACK_IMPORTED_MODULE_2__[/* Tw2ParticleElement */ "a"](this.elements[i]); //el.buffer = this.buffers[bufferIndex];

        el.startOffset = this.vertexStride[bufferIndex];
        el.offset = el.startOffset;

        if (this.elements[i].elementType !== _Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.CUSTOM) {
          this._stdElements[this.elements[i].elementType] = el;
        }

        this.vertexStride[bufferIndex] += el.dimension;

        this._elements.push(el);

        if (bufferIndex === 0) {
          const d = this.elements[i].GetDeclaration();
          d.offset = el.startOffset * 4;

          this._declaration.elements.push(d);
        }
      }

      this._declaration.RebuildHash();

      for (let i = 0; i < this._elements.length; ++i) {
        const bufferIndex = this._elements[i].usedByGPU ? 0 : 1;
        this._elements[i].vertexStride = this.vertexStride[bufferIndex];
      }

      this.instanceStride[0] = this.vertexStride[0] * 4;
      this.instanceStride[1] = this.vertexStride[1] * 4;

      for (let i = 0; i < this._elements.length; ++i) {
        const bufferIndex = this._elements[i].usedByGPU ? 0 : 1;
        this._elements[i].instanceStride = this.instanceStride[bufferIndex];
      }

      this.buffers = [null, null];

      if (this.instanceStride[0] && this.maxParticleCount) {
        this.buffers[0] = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
        this._vb = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vb);
        gl.bufferData(gl.ARRAY_BUFFER, this.buffers[0].length, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      if (this.instanceStride[1]) {
        this.buffers[1] = new Float32Array(this.instanceStride[1] * this.maxParticleCount);
      }

      for (let i = 0; i < this._elements.length; ++i) {
        const bufferIndex = this._elements[i].usedByGPU ? 0 : 1;
        this._elements[i].buffer = this.buffers[bufferIndex];
      }

      if (this.requiresSorting) {
        this._sortedIndexes = new Array(this.maxParticleCount);
        this._sortedBuffer = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
        this._distancesBuffer = new Float32Array(this.maxParticleCount);
      }

      this.isValid = true;
      this.bufferDirty = true;
    }
    /**
     * Checks if an element type exists
     * @param {number} type
     * @returns {boolean}
     */

  }, {
    key: "HasElement",
    value: function HasElement(type) {
      return this._stdElements[type] !== null;
    }
    /**
     * Gets an element by it's type
     * @param {number} type
     * @returns {Tw2ParticleElement}
     */

  }, {
    key: "GetElement",
    value: function GetElement(type) {
      if (this._stdElements[type]) {
        this._stdElements[type].offset = this._stdElements[type].startOffset;
      }

      return this._stdElements[type];
    }
    /**
     * Begins particle spawning
     * @returns {?number}
     */

  }, {
    key: "BeginSpawnParticle",
    value: function BeginSpawnParticle() {
      if (!this.isValid || this.aliveCount >= this.maxParticleCount) return null;
      return this.aliveCount++;
    }
    /**
     * Ends particle spawning
     */

  }, {
    key: "EndSpawnParticle",
    value: function EndSpawnParticle() {
      this.bufferDirty = true;
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      dt = Math.min(dt, 0.1);

      if (this.applyAging && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.LIFETIME)) {
        const lifetime = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.LIFETIME),
              position = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION) : null,
              velocity = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.VELOCITY) : null;

        for (let i = 0; i < this.aliveCount; ++i) {
          lifetime.buffer[lifetime.offset] += dt / lifetime.buffer[lifetime.offset + 1];

          if (lifetime.buffer[lifetime.offset] > 1) {
            if (this.emitParticleOnDeathEmitter) {
              this.emitParticleOnDeathEmitter.SpawnParticles(position, velocity, 1);
            }

            this.aliveCount--;

            if (i < this.aliveCount) {
              for (let j = 0; j < 2; ++j) {
                if (this.buffers[j]) {
                  this.buffers[j].set(this.buffers[j].subarray(this.instanceStride[j] * this.aliveCount, this.instanceStride[j] * this.aliveCount + this.instanceStride[j]), i * this.instanceStride[j]);
                }
              }

              --i;
              this.bufferDirty = true;
            }
          } else {
            lifetime.offset += lifetime.instanceStride;
            if (position) position.offset += position.instanceStride;
            if (velocity) velocity.offset += velocity.instanceStride;
          }
        }

        lifetime.dirty = true;
      }

      const vec3_0 = Tw2ParticleSystem.global.vec3_0;

      if (this.updateSimulation && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION) && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.VELOCITY)) {
        const hasForces = this.applyForce && this.forces.length;

        for (let i = 0; i < this.forces.length; ++i) {
          this.forces[i].Update(dt);
        }

        const position = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION),
              velocity = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.VELOCITY),
              mass = hasForces ? this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.MASS) : null;

        for (let i = 0; i < this.aliveCount; ++i) {
          if (hasForces) {
            const amass = mass ? mass.buffer[mass.offset] : 1,
                  force = _global__WEBPACK_IMPORTED_MODULE_0__[/* vec3 */ "H"].set(vec3_0, 0, 0, 0);

            for (let j = 0; j < this.forces.length; ++j) {
              this.forces[j].ApplyForce(position, velocity, force, dt, amass);
            }

            if (mass) _global__WEBPACK_IMPORTED_MODULE_0__[/* vec3 */ "H"].scale(force, force, 1 / mass.buffer[mass.offset]);
            velocity.buffer[velocity.offset] += force[0] * dt;
            velocity.buffer[velocity.offset + 1] += force[1] * dt;
            velocity.buffer[velocity.offset + 2] += force[2] * dt;
          }

          position.buffer[position.offset] += velocity.buffer[velocity.offset] * dt;
          position.buffer[position.offset + 1] += velocity.buffer[velocity.offset + 1] * dt;
          position.buffer[position.offset + 2] += velocity.buffer[velocity.offset + 2] * dt;

          if (this.emitParticleDuringLifeEmitter) {
            this.emitParticleDuringLifeEmitter.SpawnParticles(position, velocity, dt);
          }

          position.offset += position.instanceStride;
          velocity.offset += velocity.instanceStride;
          if (mass) mass.offset += mass.instanceStride;
        }

        position.dirty = true;
        velocity.dirty = true;
      }

      if (this.updateSimulation && this.constraints.length) {
        for (let i = 0; i < this.constraints.length; ++i) {
          this.constraints[i].ApplyConstraint(this.buffers, this.instanceStride, this.aliveCount, dt);
        }
      }

      if (this.updateBoundingBox) {
        this.GetBoundingBox(this.aabbMin, this.aabbMax);
      }

      if (this.emitParticleDuringLifeEmitter && !(this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION) && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.VELOCITY)) && this.updateSimulation) {
        const position = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION),
              velocity = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.VELOCITY);

        for (let i = 0; i < this.aliveCount; ++i) {
          this.emitParticleDuringLifeEmitter.SpawnParticles(position, velocity, 1);
          if (position) position.offset += position.instanceStride;
          if (velocity) velocity.offset += velocity.instanceStride;
        }
      }

      for (let i = 0; i < this._elements.length; ++i) {
        const el = this._elements[i];
        el.offset = el.startOffset;

        if (el.dirty) {
          this.bufferDirty = true;
          el.dirty = false;
        }
      }
    }
    /**
     * Gets bounding box
     * @param {vec3} aabbMin
     * @param {vec3} aabbMax
     * @returns {boolean}
     */

  }, {
    key: "GetBoundingBox",
    value: function GetBoundingBox(aabbMin, aabbMax) {
      if (this.aliveCount && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION)) {
        const position = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION);
        aabbMin[0] = position.buffer[position.offset];
        aabbMin[1] = position.buffer[position.offset + 1];
        aabbMin[2] = position.buffer[position.offset + 2];
        aabbMax[0] = position.buffer[position.offset];
        aabbMax[1] = position.buffer[position.offset + 1];
        aabbMax[2] = position.buffer[position.offset + 2];

        for (let i = 0; i < this.aliveCount; ++i) {
          aabbMin[0] = Math.min(aabbMin[0], position.buffer[position.offset]);
          aabbMin[1] = Math.min(aabbMin[1], position.buffer[position.offset + 1]);
          aabbMin[2] = Math.min(aabbMin[2], position.buffer[position.offset + 2]);
          aabbMax[0] = Math.max(aabbMax[0], position.buffer[position.offset]);
          aabbMax[1] = Math.max(aabbMax[1], position.buffer[position.offset + 1]);
          aabbMax[2] = Math.max(aabbMax[2], position.buffer[position.offset + 2]);
          position.offset += position.instanceStride;
        }

        return true;
      }

      return false;
    }
    /**
     * _Sort
     * @private
     */

  }, {
    key: "_Sort",
    value: function _Sort() {
      const eye = _global__WEBPACK_IMPORTED_MODULE_0__[/* mat4 */ "z"].multiply(Tw2ParticleSystem.global.mat4_0, _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].projection, _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].view),
            //device.viewInverse;
      position = this.GetElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION),
            count = this.aliveCount,
            distances = this._distancesBuffer;

      for (let i = 0; i < count; ++i) {
        const o0 = position.offset + position.instanceStride * i;
        let dd = position.buffer[o0] - eye[12],
            l0 = dd * dd;
        dd = position.buffer[o0 + 1] - eye[13];
        l0 += dd * dd;
        dd = position.buffer[o0 + 2] - eye[14];
        l0 += dd * dd;
        distances[i] = l0;
      }
      /**
       * sortItems
       * @param a
       * @param b
       * @returns {number}
       * @private
       */


      function sortItems(a, b) {
        if (a >= count && b >= count) {
          if (a < b) return -1;
          if (a > b) return 1;
          return 0;
        }

        if (a >= count) return 1;
        if (b >= count) return -1;
        const l0 = distances[a],
              l1 = distances[b];
        if (l0 < l1) return 1;
        if (l0 > l1) return -1;
        return 0;
      }

      for (let i = 0; i < this.maxParticleCount; ++i) {
        this._sortedIndexes[i] = i;
      }

      this._sortedIndexes.sort(sortItems);
    }
    /**
     * Updates and gets the particle system's InstanceBuffer
     * @returns {?WebGLBuffer}
     */

  }, {
    key: "GetInstanceBuffer",
    value: function GetInstanceBuffer() {
      if (this.aliveCount === 0) return undefined;
      const gl = _global__WEBPACK_IMPORTED_MODULE_0__[/* device */ "w"].gl;

      if (this.requiresSorting && this.HasElement(_Tw2ParticleElementDeclaration__WEBPACK_IMPORTED_MODULE_3__[/* Tw2ParticleElementDeclaration */ "a"].Type.POSITION) && this.buffers) {
        this._Sort();

        const stride = this.instanceStride[0],
              gpuBuffer = this.buffers[0];

        for (let i = 0; i < this.aliveCount; ++i) {
          const toOffset = i * stride,
                fromOffset = this._sortedIndexes[i] * stride;

          for (let j = 0; j < stride; ++j) {
            this._sortedBuffer[toOffset + j] = gpuBuffer[j + fromOffset];
          }
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vb);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._sortedBuffer.subarray(0, this.vertexStride[0] * this.aliveCount));
        this.bufferDirty = false;
      } else if (this.bufferDirty) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vb);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.buffers[0].subarray(0, this.vertexStride[0] * this.aliveCount));
        this.bufferDirty = false;
      }

      return this._vb;
    }
    /**
     * Gets the particle system's InstanceDeclaration
     * @returns {Tw2VertexDeclaration}
     */

  }, {
    key: "GetInstanceDeclaration",
    value: function GetInstanceDeclaration() {
      return this._declaration;
    }
    /**
     * Gets the particle system's InstanceStride
     * @returns {number}
     */

  }, {
    key: "GetInstanceStride",
    value: function GetInstanceStride() {
      return this.instanceStride[0];
    }
    /**
     * Gets the particle system's InstanceCount
     * @returns {number}
     */

  }, {
    key: "GetInstanceCount",
    value: function GetInstanceCount() {
      return this.aliveCount;
    }
    /**
     * Initializes class globals
     */

  }], [{
    key: "init",
    value: function init() {
      if (!Tw2ParticleSystem.global) {
        Tw2ParticleSystem.global = {
          vec3_0: _global__WEBPACK_IMPORTED_MODULE_0__[/* vec3 */ "H"].create(),
          mat4_0: _global__WEBPACK_IMPORTED_MODULE_0__[/* mat4 */ "z"].create()
        };
      }
    }
    /**
     * Global and scratch variables
     */

  }]);

  return Tw2ParticleSystem;
}();

_defineProperty(Tw2ParticleSystem, "global", null);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// CONCATENATED MODULE: ./particle/forces/Tw2ParticleForce.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * Tw2ParticleForce base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */

let Tw2ParticleForce_Tw2ParticleForce =
/*#__PURE__*/
function () {
  function Tw2ParticleForce() {
    _classCallCheck(this, Tw2ParticleForce);

    _defineProperty(this, "_id", global["F" /* util */].generateID());

    _defineProperty(this, "name", '');
  }

  _createClass(Tw2ParticleForce, [{
    key: "ApplyForce",

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     * @param {number} [dt]
     * @param {number} [mass]
     */
    value: function ApplyForce(position, velocity, force, dt, mass) {}
    /**
     * Per frame update (Called before ApplyForce)
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {}
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return Tw2ParticleForce;
}();

_defineProperty(Tw2ParticleForce_Tw2ParticleForce, "global", {
  vec3_0: global["H" /* vec3 */].create(),
  vec3_1: global["H" /* vec3 */].create(),
  vec4_0: global["I" /* vec4 */].create()
});
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleAttractorForce.js
function Tw2ParticleAttractorForce_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleAttractorForce_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleAttractorForce_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleAttractorForce_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleAttractorForce_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleAttractorForce_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleAttractorForce
 *
 * @property {number} magnitude
 * @property {vec3} position
 * @property {vec3} _tempVec
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleAttractorForce_Tw2ParticleAttractorForce =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  _inherits(Tw2ParticleAttractorForce, _Tw2ParticleForce);

  function Tw2ParticleAttractorForce() {
    var _this;

    Tw2ParticleAttractorForce_classCallCheck(this, Tw2ParticleAttractorForce);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2ParticleAttractorForce).call(this, ...args));

    Tw2ParticleAttractorForce_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "magnitude", 0);

    Tw2ParticleAttractorForce_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "position", global["H" /* vec3 */].create());

    return _this;
  }

  Tw2ParticleAttractorForce_createClass(Tw2ParticleAttractorForce, [{
    key: "ApplyForce",

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */
    value: function ApplyForce(position, velocity, force) {
      const vec3_0 = Tw2ParticleForce_Tw2ParticleForce.global.vec3_0;
      vec3_0[0] = this.position[0] - position.buffer[position.offset];
      vec3_0[1] = this.position[1] - position.buffer[position.offset + 1];
      vec3_0[2] = this.position[2] - position.buffer[position.offset + 2];
      global["H" /* vec3 */].normalize(vec3_0, vec3_0);
      global["H" /* vec3 */].scale(vec3_0, vec3_0, this.magnitude);
      global["H" /* vec3 */].add(force, force, vec3_0);
    }
  }]);

  return Tw2ParticleAttractorForce;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleDirectForce.js
function Tw2ParticleDirectForce_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleDirectForce_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleDirectForce_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleDirectForce_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleDirectForce_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ParticleDirectForce_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ParticleDirectForce_assertThisInitialized(self); }

function Tw2ParticleDirectForce_getPrototypeOf(o) { Tw2ParticleDirectForce_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ParticleDirectForce_getPrototypeOf(o); }

function Tw2ParticleDirectForce_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ParticleDirectForce_setPrototypeOf(subClass, superClass); }

function Tw2ParticleDirectForce_setPrototypeOf(o, p) { Tw2ParticleDirectForce_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ParticleDirectForce_setPrototypeOf(o, p); }

function Tw2ParticleDirectForce_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleDirectForce_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleDirectForce
 *
 * @property {vec3} force
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleDirectForce_Tw2ParticleDirectForce =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  Tw2ParticleDirectForce_inherits(Tw2ParticleDirectForce, _Tw2ParticleForce);

  function Tw2ParticleDirectForce() {
    var _this;

    Tw2ParticleDirectForce_classCallCheck(this, Tw2ParticleDirectForce);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ParticleDirectForce_possibleConstructorReturn(this, Tw2ParticleDirectForce_getPrototypeOf(Tw2ParticleDirectForce).call(this, ...args));

    Tw2ParticleDirectForce_defineProperty(Tw2ParticleDirectForce_assertThisInitialized(Tw2ParticleDirectForce_assertThisInitialized(_this)), "force", global["H" /* vec3 */].create());

    return _this;
  }

  Tw2ParticleDirectForce_createClass(Tw2ParticleDirectForce, [{
    key: "ApplyForce",

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */
    value: function ApplyForce(position, velocity, force) {
      global["H" /* vec3 */].add(force, force, this.force);
    }
  }]);

  return Tw2ParticleDirectForce;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleDragForce.js
function Tw2ParticleDragForce_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleDragForce_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleDragForce_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleDragForce_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleDragForce_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ParticleDragForce_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ParticleDragForce_assertThisInitialized(self); }

function Tw2ParticleDragForce_getPrototypeOf(o) { Tw2ParticleDragForce_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ParticleDragForce_getPrototypeOf(o); }

function Tw2ParticleDragForce_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ParticleDragForce_setPrototypeOf(subClass, superClass); }

function Tw2ParticleDragForce_setPrototypeOf(o, p) { Tw2ParticleDragForce_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ParticleDragForce_setPrototypeOf(o, p); }

function Tw2ParticleDragForce_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleDragForce_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2ParticleDragForce
 *
 * @property {number} drag
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleDragForce =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  Tw2ParticleDragForce_inherits(Tw2ParticleDragForce, _Tw2ParticleForce);

  function Tw2ParticleDragForce() {
    var _this;

    Tw2ParticleDragForce_classCallCheck(this, Tw2ParticleDragForce);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ParticleDragForce_possibleConstructorReturn(this, Tw2ParticleDragForce_getPrototypeOf(Tw2ParticleDragForce).call(this, ...args));

    Tw2ParticleDragForce_defineProperty(Tw2ParticleDragForce_assertThisInitialized(Tw2ParticleDragForce_assertThisInitialized(_this)), "drag", 0.1);

    return _this;
  }

  Tw2ParticleDragForce_createClass(Tw2ParticleDragForce, [{
    key: "ApplyForce",

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */
    value: function ApplyForce(position, velocity, force) {
      force[0] += velocity.buffer[velocity.offset] * -this.drag;
      force[1] += velocity.buffer[velocity.offset + 1] * -this.drag;
      force[2] += velocity.buffer[velocity.offset + 2] * -this.drag;
    }
  }]);

  return Tw2ParticleDragForce;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleFluidDragForce.js
function Tw2ParticleFluidDragForce_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleFluidDragForce_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleFluidDragForce_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleFluidDragForce_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleFluidDragForce_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ParticleFluidDragForce_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ParticleFluidDragForce_assertThisInitialized(self); }

function Tw2ParticleFluidDragForce_getPrototypeOf(o) { Tw2ParticleFluidDragForce_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ParticleFluidDragForce_getPrototypeOf(o); }

function Tw2ParticleFluidDragForce_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ParticleFluidDragForce_setPrototypeOf(subClass, superClass); }

function Tw2ParticleFluidDragForce_setPrototypeOf(o, p) { Tw2ParticleFluidDragForce_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ParticleFluidDragForce_setPrototypeOf(o, p); }

function Tw2ParticleFluidDragForce_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleFluidDragForce_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleFluidDragForce
 *
 * @property {number} drag
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleFluidDragForce_Tw2ParticleFluidDragForce =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  Tw2ParticleFluidDragForce_inherits(Tw2ParticleFluidDragForce, _Tw2ParticleForce);

  function Tw2ParticleFluidDragForce() {
    var _this;

    Tw2ParticleFluidDragForce_classCallCheck(this, Tw2ParticleFluidDragForce);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ParticleFluidDragForce_possibleConstructorReturn(this, Tw2ParticleFluidDragForce_getPrototypeOf(Tw2ParticleFluidDragForce).call(this, ...args));

    Tw2ParticleFluidDragForce_defineProperty(Tw2ParticleFluidDragForce_assertThisInitialized(Tw2ParticleFluidDragForce_assertThisInitialized(_this)), "drag", 0.1);

    return _this;
  }

  Tw2ParticleFluidDragForce_createClass(Tw2ParticleFluidDragForce, [{
    key: "ApplyForce",

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     * @param {number} dt - delta time
     * @param { number} mass
     */
    value: function ApplyForce(position, velocity, force, dt, mass) {
      const vec3_0 = Tw2ParticleForce_Tw2ParticleForce.global.vec3_0,
            vec3_1 = Tw2ParticleForce_Tw2ParticleForce.global.vec3_1,
            speed = Math.sqrt(velocity.buffer[velocity.offset] * velocity.buffer[velocity.offset] + velocity.buffer[velocity.offset + 1] * velocity.buffer[velocity.offset + 1] + velocity.buffer[velocity.offset + 2] * velocity.buffer[velocity.offset + 2]);
      vec3_0[0] = velocity.buffer[velocity.offset] * -speed * this.drag;
      vec3_0[1] = velocity.buffer[velocity.offset + 1] * -speed * this.drag;
      vec3_0[2] = velocity.buffer[velocity.offset + 2] * -speed * this.drag;
      global["H" /* vec3 */].scale(vec3_1, vec3_0, dt * mass);
      vec3_1[0] += velocity.buffer[velocity.offset];
      vec3_1[1] += velocity.buffer[velocity.offset + 1];
      vec3_1[2] += velocity.buffer[velocity.offset + 2];
      const dot = velocity.buffer[velocity.offset] * vec3_1[0] + velocity.buffer[velocity.offset + 1] * vec3_1[1] + velocity.buffer[velocity.offset + 2] * vec3_1[2];

      if (dot < 0) {
        force[0] = -velocity.buffer[velocity.offset] / dt / mass;
        force[1] = -velocity.buffer[velocity.offset + 1] / dt / mass;
        force[2] = -velocity.buffer[velocity.offset + 2] / dt / mass;
      } else {
        global["H" /* vec3 */].copy(force, vec3_0);
      }
    }
  }]);

  return Tw2ParticleFluidDragForce;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleSpring.js
function Tw2ParticleSpring_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleSpring_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleSpring_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleSpring_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleSpring_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ParticleSpring_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ParticleSpring_assertThisInitialized(self); }

function Tw2ParticleSpring_getPrototypeOf(o) { Tw2ParticleSpring_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ParticleSpring_getPrototypeOf(o); }

function Tw2ParticleSpring_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ParticleSpring_setPrototypeOf(subClass, superClass); }

function Tw2ParticleSpring_setPrototypeOf(o, p) { Tw2ParticleSpring_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ParticleSpring_setPrototypeOf(o, p); }

function Tw2ParticleSpring_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleSpring_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleSpring
 *
 * @property {number} springConstant
 * @property {vec3} position
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleSpring_Tw2ParticleSpring =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  Tw2ParticleSpring_inherits(Tw2ParticleSpring, _Tw2ParticleForce);

  function Tw2ParticleSpring() {
    var _this;

    Tw2ParticleSpring_classCallCheck(this, Tw2ParticleSpring);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ParticleSpring_possibleConstructorReturn(this, Tw2ParticleSpring_getPrototypeOf(Tw2ParticleSpring).call(this, ...args));

    Tw2ParticleSpring_defineProperty(Tw2ParticleSpring_assertThisInitialized(Tw2ParticleSpring_assertThisInitialized(_this)), "springConstant", 0);

    Tw2ParticleSpring_defineProperty(Tw2ParticleSpring_assertThisInitialized(Tw2ParticleSpring_assertThisInitialized(_this)), "position", global["H" /* vec3 */].create());

    return _this;
  }

  Tw2ParticleSpring_createClass(Tw2ParticleSpring, [{
    key: "ApplyForce",

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */
    value: function ApplyForce(position, velocity, force) {
      force[0] += (this.position[0] - position.buffer[position.offset]) * this.springConstant;
      force[1] += (this.position[1] - position.buffer[position.offset + 1]) * this.springConstant;
      force[2] += (this.position[2] - position.buffer[position.offset + 2]) * this.springConstant;
    }
  }]);

  return Tw2ParticleSpring;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/Tw2ParticleTurbulenceForce.js
function Tw2ParticleTurbulenceForce_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2ParticleTurbulenceForce_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2ParticleTurbulenceForce_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2ParticleTurbulenceForce_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2ParticleTurbulenceForce_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2ParticleTurbulenceForce_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2ParticleTurbulenceForce_assertThisInitialized(self); }

function Tw2ParticleTurbulenceForce_getPrototypeOf(o) { Tw2ParticleTurbulenceForce_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2ParticleTurbulenceForce_getPrototypeOf(o); }

function Tw2ParticleTurbulenceForce_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2ParticleTurbulenceForce_setPrototypeOf(subClass, superClass); }

function Tw2ParticleTurbulenceForce_setPrototypeOf(o, p) { Tw2ParticleTurbulenceForce_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2ParticleTurbulenceForce_setPrototypeOf(o, p); }

function Tw2ParticleTurbulenceForce_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2ParticleTurbulenceForce_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tw2ParticleTurbulenceForce
 *
 * @property {number} noiseLevel
 * @property {number} noiseRatio
 * @property {vec3} amplitude
 * @property {quat} frequency
 * @property {number} _time
 * @inherits Tw2ParticleForce
 * @class
 */

let Tw2ParticleTurbulenceForce_Tw2ParticleTurbulenceForce =
/*#__PURE__*/
function (_Tw2ParticleForce) {
  Tw2ParticleTurbulenceForce_inherits(Tw2ParticleTurbulenceForce, _Tw2ParticleForce);

  function Tw2ParticleTurbulenceForce() {
    var _this;

    Tw2ParticleTurbulenceForce_classCallCheck(this, Tw2ParticleTurbulenceForce);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2ParticleTurbulenceForce_possibleConstructorReturn(this, Tw2ParticleTurbulenceForce_getPrototypeOf(Tw2ParticleTurbulenceForce).call(this, ...args));

    Tw2ParticleTurbulenceForce_defineProperty(Tw2ParticleTurbulenceForce_assertThisInitialized(Tw2ParticleTurbulenceForce_assertThisInitialized(_this)), "noiseLevel", 3);

    Tw2ParticleTurbulenceForce_defineProperty(Tw2ParticleTurbulenceForce_assertThisInitialized(Tw2ParticleTurbulenceForce_assertThisInitialized(_this)), "noiseRatio", 0.5);

    Tw2ParticleTurbulenceForce_defineProperty(Tw2ParticleTurbulenceForce_assertThisInitialized(Tw2ParticleTurbulenceForce_assertThisInitialized(_this)), "amplitude", global["H" /* vec3 */].fromValues(1, 1, 1));

    Tw2ParticleTurbulenceForce_defineProperty(Tw2ParticleTurbulenceForce_assertThisInitialized(Tw2ParticleTurbulenceForce_assertThisInitialized(_this)), "frequency", global["I" /* vec4 */].fromValues(1, 1, 1, 1));

    Tw2ParticleTurbulenceForce_defineProperty(Tw2ParticleTurbulenceForce_assertThisInitialized(Tw2ParticleTurbulenceForce_assertThisInitialized(_this)), "_time", 0);

    return _this;
  }

  Tw2ParticleTurbulenceForce_createClass(Tw2ParticleTurbulenceForce, [{
    key: "ApplyForce",

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */
    value: function ApplyForce(position, velocity, force) {
      if (this.noiseLevel === 0) return;
      let pos_0 = position.buffer[position.offset] * this.frequency[0],
          pos_1 = position.buffer[position.offset + 1] * this.frequency[1],
          pos_2 = position.buffer[position.offset + 2] * this.frequency[2],
          pos_3 = this._time * this.frequency[3];
      let sum = 0,
          power = 0.5,
          frequency = 1 / this.noiseRatio;
      const out = global["I" /* vec4 */].set(Tw2ParticleForce_Tw2ParticleForce.global.vec4_0, 0, 0, 0, 0);

      for (let i = 0; i < this.noiseLevel; ++i) {
        global["A" /* noise */].turbulence(out, pos_0, pos_1, pos_2, pos_3, power);
        sum += power;
        pos_0 *= frequency;
        pos_1 *= frequency;
        pos_2 *= frequency;
        pos_3 *= frequency;
        power *= this.noiseRatio;
      }

      force[0] += out[0] * this.amplitude[0] * sum;
      force[1] += out[1] * this.amplitude[1] * sum;
      force[2] += out[2] * this.amplitude[2] * sum;
    }
    /**
     * Per frame update (Called before ApplyForce)
     * @param {number} dt - delta Time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      this._time += dt;
    }
  }]);

  return Tw2ParticleTurbulenceForce;
}(Tw2ParticleForce_Tw2ParticleForce);
// CONCATENATED MODULE: ./particle/forces/index.js
/* concated harmony reexport Tw2ParticleAttractorForce */__webpack_require__.d(__webpack_exports__, "a", function() { return Tw2ParticleAttractorForce_Tw2ParticleAttractorForce; });
/* concated harmony reexport Tw2ParticleDirectForce */__webpack_require__.d(__webpack_exports__, "b", function() { return Tw2ParticleDirectForce_Tw2ParticleDirectForce; });
/* concated harmony reexport Tw2ParticleDragForce */__webpack_require__.d(__webpack_exports__, "c", function() { return Tw2ParticleDragForce; });
/* concated harmony reexport Tw2ParticleFluidDragForce */__webpack_require__.d(__webpack_exports__, "d", function() { return Tw2ParticleFluidDragForce_Tw2ParticleFluidDragForce; });
/* concated harmony reexport Tw2ParticleSpring */__webpack_require__.d(__webpack_exports__, "e", function() { return Tw2ParticleSpring_Tw2ParticleSpring; });
/* concated harmony reexport Tw2ParticleTurbulenceForce */__webpack_require__.d(__webpack_exports__, "f", function() { return Tw2ParticleTurbulenceForce_Tw2ParticleTurbulenceForce; });







/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// EXTERNAL MODULE: ./core/index.js + 60 modules
var core = __webpack_require__(1);

// CONCATENATED MODULE: ./particle/emitters/Tw2ParticleEmitter.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * Particle Emitter base class
 *
 * @property {number|string} id
 * @property {string} name
 * @property {Tw2ParticleSystem} particleSystem
 * @class
 */

let Tw2ParticleEmitter_Tw2ParticleEmitter =
/*#__PURE__*/
function () {
  function Tw2ParticleEmitter() {
    _classCallCheck(this, Tw2ParticleEmitter);

    _defineProperty(this, "_id", global["F" /* util */].generateID());

    _defineProperty(this, "name", '');

    _defineProperty(this, "particleSystem", null);
  }

  _createClass(Tw2ParticleEmitter, [{
    key: "Initialize",

    /**
     * Initializes the particle emitter
     */
    value: function Initialize() {}
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {}
  }]);

  return Tw2ParticleEmitter;
}();
// CONCATENATED MODULE: ./particle/emitters/Tw2StaticEmitter.js
function Tw2StaticEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2StaticEmitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2StaticEmitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2StaticEmitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2StaticEmitter_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2StaticEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2StaticEmitter
 *
 * @property {Tw2GeometryRes} geometryResource
 * @property {Number} geometryIndex
 * @property {Boolean} _spawned
 * @inherits Tw2ParticleEmitter
 * @class
 */

let Tw2StaticEmitter_Tw2StaticEmitter =
/*#__PURE__*/
function (_Tw2ParticleEmitter) {
  _inherits(Tw2StaticEmitter, _Tw2ParticleEmitter);

  function Tw2StaticEmitter() {
    var _this;

    Tw2StaticEmitter_classCallCheck(this, Tw2StaticEmitter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2StaticEmitter).call(this, ...args));

    Tw2StaticEmitter_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "geometryResourcePath", '');

    Tw2StaticEmitter_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "geometryResource", null);

    Tw2StaticEmitter_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "geometryIndex", 0);

    Tw2StaticEmitter_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_spawned", false);

    return _this;
  }

  Tw2StaticEmitter_createClass(Tw2StaticEmitter, [{
    key: "Initialize",

    /**
     * Initializes the particle emitter
     */
    value: function Initialize() {
      if (this.geometryResourcePath !== '') {
        this.geometryResource = global["D" /* resMan */].GetResource(this.geometryResourcePath);
        this.geometryResource.systemMirror = true;
        this.geometryResource.RegisterNotification(this);
      }

      this._spawned = false;
    }
    /**
     * Rebuilds cached data
     */

  }, {
    key: "RebuildCachedData",
    value: function RebuildCachedData() {
      if (this.geometryResource && this.geometryResource.meshes.length) {
        if (!this.geometryResource.meshes[0].bufferData) {
          this.geometryResource.systemMirror = true;
          this.geometryResource.Reload();
        }
      }
    }
    /**
     * Per frame update
     */

  }, {
    key: "Update",
    value: function Update() {
      const res = this.geometryResource;

      if (!this._spawned && this.particleSystem && res && res.IsGood() && res.meshes.length > this.geometryIndex && res.meshes[this.geometryIndex].bufferData) {
        this._spawned = true;
        const mesh = res.meshes[this.geometryIndex],
              elts = this.particleSystem.elements,
              inputs = new Array(elts.length);

        for (let i = 0; i < elts.length; ++i) {
          const d = elts[i].GetDeclaration(),
                input = mesh.declaration.FindUsage(d.usage, d.usageIndex - 8);

          if (input === null) {
            res.OnError(new core["ErrGeometryMeshMissingParticleElement"]({
              path: res.path,
              elementUsage: d.usage,
              elementUsageIndex: d.usageIndex
            }));
            return;
          }

          if (input.elements < d.elements) {
            res.OnError(new core["ErrGeometryMeshElementComponentsMissing"]({
              path: res.path,
              inputCount: input.elements,
              elementCount: d.elements,
              elementUsage: d.usage,
              elementUsageIndex: d.usageIndex
            }));
            return;
          }

          inputs[i] = input.offset / 4;
        }

        const vertexCount = mesh.bufferData.length / mesh.declaration.stride * 4;

        for (let i = 0; i < vertexCount; ++i) {
          const index = this.particleSystem.BeginSpawnParticle();
          if (index === null) break;

          for (let j = 0; j < this.particleSystem._elements.length; ++j) {
            const e = this.particleSystem._elements[j];

            for (let k = 0; k < e.dimension; ++k) {
              e.buffer[e.instanceStride * index + e.startOffset + k] = mesh.bufferData[inputs[j] + k + i * mesh.declaration.stride / 4];
            }
          }

          this.particleSystem.EndSpawnParticle();
        }
      }
    }
  }]);

  return Tw2StaticEmitter;
}(Tw2ParticleEmitter_Tw2ParticleEmitter);
// CONCATENATED MODULE: ./particle/emitters/Tw2DynamicEmitter.js
function Tw2DynamicEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2DynamicEmitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2DynamicEmitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2DynamicEmitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2DynamicEmitter_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2DynamicEmitter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2DynamicEmitter_assertThisInitialized(self); }

function Tw2DynamicEmitter_getPrototypeOf(o) { Tw2DynamicEmitter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2DynamicEmitter_getPrototypeOf(o); }

function Tw2DynamicEmitter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2DynamicEmitter_setPrototypeOf(subClass, superClass); }

function Tw2DynamicEmitter_setPrototypeOf(o, p) { Tw2DynamicEmitter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2DynamicEmitter_setPrototypeOf(o, p); }

function Tw2DynamicEmitter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2DynamicEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Tw2DynamicEmitter
 *
 * @property {string} name
 * @property {number} rate
 * @property {boolean} isValid
 * @property {number} _accumulatedRate
 * @property {Array<Tw2ParticleAttributeGenerator>}} generators
 * @inherits Tw2ParticleEmitter
 * @class
 */

let Tw2DynamicEmitter =
/*#__PURE__*/
function (_Tw2ParticleEmitter) {
  Tw2DynamicEmitter_inherits(Tw2DynamicEmitter, _Tw2ParticleEmitter);

  function Tw2DynamicEmitter() {
    var _this;

    Tw2DynamicEmitter_classCallCheck(this, Tw2DynamicEmitter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2DynamicEmitter_possibleConstructorReturn(this, Tw2DynamicEmitter_getPrototypeOf(Tw2DynamicEmitter).call(this, ...args));

    Tw2DynamicEmitter_defineProperty(Tw2DynamicEmitter_assertThisInitialized(Tw2DynamicEmitter_assertThisInitialized(_this)), "rate", 0);

    Tw2DynamicEmitter_defineProperty(Tw2DynamicEmitter_assertThisInitialized(Tw2DynamicEmitter_assertThisInitialized(_this)), "isValid", false);

    Tw2DynamicEmitter_defineProperty(Tw2DynamicEmitter_assertThisInitialized(Tw2DynamicEmitter_assertThisInitialized(_this)), "_accumulatedRate", 0);

    Tw2DynamicEmitter_defineProperty(Tw2DynamicEmitter_assertThisInitialized(Tw2DynamicEmitter_assertThisInitialized(_this)), "generators", []);

    return _this;
  }

  Tw2DynamicEmitter_createClass(Tw2DynamicEmitter, [{
    key: "Initialize",

    /**
     * Initializes the particle emitter
     */
    value: function Initialize() {
      this.Rebind();
    }
    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: "Update",
    value: function Update(dt) {
      this.SpawnParticles(null, null, Math.min(dt, 0.1));
    }
    /**
     * Rebinds the emitter's generators to it's particle system
     */

  }, {
    key: "Rebind",
    value: function Rebind() {
      this.isValid = false;
      if (!this.particleSystem) return;

      for (let i = 0; i < this.generators.length; ++i) {
        if (!this.generators[i].Bind(this.particleSystem)) return;
      }

      this.isValid = true;
    }
    /**
     * Spawn particles
     * @param position
     * @param velocity
     * @param rateModifier
     */

  }, {
    key: "SpawnParticles",
    value: function SpawnParticles(position, velocity, rateModifier) {
      if (!this.isValid) return;
      this._accumulatedRate += this.rate * rateModifier;
      const count = Math.floor(this._accumulatedRate);
      this._accumulatedRate -= count;

      for (let i = 0; i < count; ++i) {
        const index = this.particleSystem.BeginSpawnParticle();
        if (index === null) break;

        for (let j = 0; j < this.generators.length; ++j) {
          this.generators[j].Generate(position, velocity, index);
        }

        this.particleSystem.EndSpawnParticle();
      }
    }
  }]);

  return Tw2DynamicEmitter;
}(Tw2ParticleEmitter_Tw2ParticleEmitter);
// CONCATENATED MODULE: ./particle/emitters/Tw2GpuUniqueEmitter.js
function Tw2GpuUniqueEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2GpuUniqueEmitter_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2GpuUniqueEmitter_assertThisInitialized(self); }

function Tw2GpuUniqueEmitter_getPrototypeOf(o) { Tw2GpuUniqueEmitter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2GpuUniqueEmitter_getPrototypeOf(o); }

function Tw2GpuUniqueEmitter_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2GpuUniqueEmitter_setPrototypeOf(subClass, superClass); }

function Tw2GpuUniqueEmitter_setPrototypeOf(o, p) { Tw2GpuUniqueEmitter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2GpuUniqueEmitter_setPrototypeOf(o, p); }

function Tw2GpuUniqueEmitter_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2GpuUniqueEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Tr2GpuUniqueEmitter - not implemented yet
 *
 * @property {number} angle
 * @property {number} innerAngle
 * @property {number} drag
 * @property {number} rate
 * @property {number} radius
 * @property {number} gravity
 * @property {number} maxSpeed
 * @property {number} minSpeed
 * @property {number} minLifeTime
 * @property {number} maxLifeTime
 * @property {number} sizeVariance
 * @property {vec3} attractorPosition
 * @property {number} attractorStrength
 * @property {number} textureIndex
 * @property {number} turbulenceAmplitude
 * @property {number} turbulenceFrequency
 * @property {vec3} sizes
 * @property {vec4} color0
 * @property {vec4} color1
 * @property {vec4} color2
 * @property {vec4} color3
 * @class
 */

let Tw2GpuUniqueEmitter_Tw2GpuUniqueEmitter =
/*#__PURE__*/
function (_Tw2ParticleEmitter) {
  Tw2GpuUniqueEmitter_inherits(Tw2GpuUniqueEmitter, _Tw2ParticleEmitter);

  function Tw2GpuUniqueEmitter() {
    var _this;

    Tw2GpuUniqueEmitter_classCallCheck(this, Tw2GpuUniqueEmitter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2GpuUniqueEmitter_possibleConstructorReturn(this, Tw2GpuUniqueEmitter_getPrototypeOf(Tw2GpuUniqueEmitter).call(this, ...args));

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "angle", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "innerAngle", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "drag", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "rate", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "radius", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "gravity", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "maxSpeed", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "minSpeed", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "minLifeTime", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "maxLifeTime", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "sizeVariance", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "attractorPosition", global["H" /* vec3 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "attractorStrength", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "turbulenceAmplitude", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "turbulenceFrequency", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "textureIndex", 0);

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "sizes", global["H" /* vec3 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "position", global["H" /* vec3 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "color0", global["I" /* vec4 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "color1", global["I" /* vec4 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "color2", global["I" /* vec4 */].create());

    Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_assertThisInitialized(Tw2GpuUniqueEmitter_assertThisInitialized(_this)), "color3", global["I" /* vec4 */].create());

    return _this;
  }

  return Tw2GpuUniqueEmitter;
}(Tw2ParticleEmitter_Tw2ParticleEmitter);

Tw2GpuUniqueEmitter_defineProperty(Tw2GpuUniqueEmitter_Tw2GpuUniqueEmitter, "partialImplementation", true);
// CONCATENATED MODULE: ./particle/emitters/index.js
/* concated harmony reexport Tw2StaticEmitter */__webpack_require__.d(__webpack_exports__, "c", function() { return Tw2StaticEmitter_Tw2StaticEmitter; });
/* concated harmony reexport Tw2DynamicEmitter */__webpack_require__.d(__webpack_exports__, "a", function() { return Tw2DynamicEmitter; });
/* concated harmony reexport Tw2GpuUniqueEmitter */__webpack_require__.d(__webpack_exports__, "b", function() { return Tw2GpuUniqueEmitter_Tw2GpuUniqueEmitter; });




/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./global/index.js + 7 modules
var global = __webpack_require__(0);

// EXTERNAL MODULE: ./particle/Tw2ParticleElementDeclaration.js
var Tw2ParticleElementDeclaration = __webpack_require__(5);

// CONCATENATED MODULE: ./particle/generators/Tw2ParticleAttributeGenerator.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint no-unused-vars:0 */

/**
 * Tw2ParticleAttributeGenerator base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */

let Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator =
/*#__PURE__*/
function () {
  function Tw2ParticleAttributeGenerator() {
    _classCallCheck(this, Tw2ParticleAttributeGenerator);

    _defineProperty(this, "_id", global["F" /* util */].generateID());

    _defineProperty(this, "name", '');
  }

  _createClass(Tw2ParticleAttributeGenerator, [{
    key: "Bind",

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */
    value: function Bind(ps) {
      return false;
    }
    /**
     * Generates the attributes
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {number} index
     */

  }, {
    key: "Generate",
    value: function Generate(position, velocity, index) {}
    /**
     * Global and scratch variables
     * @type {*}
     */

  }]);

  return Tw2ParticleAttributeGenerator;
}();

_defineProperty(Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator, "global", {
  vec3_0: global["H" /* vec3 */].create()
});
// CONCATENATED MODULE: ./particle/generators/Tw2RandomIntegerAttributeGenerator.js
function Tw2RandomIntegerAttributeGenerator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RandomIntegerAttributeGenerator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RandomIntegerAttributeGenerator_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RandomIntegerAttributeGenerator_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RandomIntegerAttributeGenerator_defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RandomIntegerAttributeGenerator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2RandomIntegerAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */

let Tw2RandomIntegerAttributeGenerator_Tw2RandomIntegerAttributeGenerator =
/*#__PURE__*/
function (_Tw2ParticleAttribute) {
  _inherits(Tw2RandomIntegerAttributeGenerator, _Tw2ParticleAttribute);

  function Tw2RandomIntegerAttributeGenerator() {
    var _this;

    Tw2RandomIntegerAttributeGenerator_classCallCheck(this, Tw2RandomIntegerAttributeGenerator);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tw2RandomIntegerAttributeGenerator).call(this, ...args));

    Tw2RandomIntegerAttributeGenerator_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "elementType", Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.CUSTOM);

    Tw2RandomIntegerAttributeGenerator_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "customName", '');

    Tw2RandomIntegerAttributeGenerator_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "minRange", global["I" /* vec4 */].create());

    Tw2RandomIntegerAttributeGenerator_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "maxRange", global["I" /* vec4 */].create());

    Tw2RandomIntegerAttributeGenerator_defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_element", null);

    return _this;
  }

  Tw2RandomIntegerAttributeGenerator_createClass(Tw2RandomIntegerAttributeGenerator, [{
    key: "Bind",

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */
    value: function Bind(ps) {
      for (let i = 0; i < ps._elements.length; ++i) {
        if (ps._elements[i].elementType === this.elementType && (this.elementType !== Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.CUSTOM || ps._elements[i].customName === this.customName)) {
          this._element = ps._elements[i];
          return true;
        }
      }

      return false;
    }
    /**
     * Generates the attributes
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {number} index
     */

  }, {
    key: "Generate",
    value: function Generate(position, velocity, index) {
      for (let i = 0; i < this._element.dimension; ++i) {
        this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = Math.floor(this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]) + 0.5);
      }
    }
  }]);

  return Tw2RandomIntegerAttributeGenerator;
}(Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator);
// CONCATENATED MODULE: ./particle/generators/Tw2RandomUniformAttributeGenerator.js
function Tw2RandomUniformAttributeGenerator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2RandomUniformAttributeGenerator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2RandomUniformAttributeGenerator_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2RandomUniformAttributeGenerator_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2RandomUniformAttributeGenerator_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2RandomUniformAttributeGenerator_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2RandomUniformAttributeGenerator_assertThisInitialized(self); }

function Tw2RandomUniformAttributeGenerator_getPrototypeOf(o) { Tw2RandomUniformAttributeGenerator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2RandomUniformAttributeGenerator_getPrototypeOf(o); }

function Tw2RandomUniformAttributeGenerator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2RandomUniformAttributeGenerator_setPrototypeOf(subClass, superClass); }

function Tw2RandomUniformAttributeGenerator_setPrototypeOf(o, p) { Tw2RandomUniformAttributeGenerator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2RandomUniformAttributeGenerator_setPrototypeOf(o, p); }

function Tw2RandomUniformAttributeGenerator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2RandomUniformAttributeGenerator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2RandomUniformAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */

let Tw2RandomUniformAttributeGenerator_Tw2RandomUniformAttributeGenerator =
/*#__PURE__*/
function (_Tw2ParticleAttribute) {
  Tw2RandomUniformAttributeGenerator_inherits(Tw2RandomUniformAttributeGenerator, _Tw2ParticleAttribute);

  function Tw2RandomUniformAttributeGenerator() {
    var _this;

    Tw2RandomUniformAttributeGenerator_classCallCheck(this, Tw2RandomUniformAttributeGenerator);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2RandomUniformAttributeGenerator_possibleConstructorReturn(this, Tw2RandomUniformAttributeGenerator_getPrototypeOf(Tw2RandomUniformAttributeGenerator).call(this, ...args));

    Tw2RandomUniformAttributeGenerator_defineProperty(Tw2RandomUniformAttributeGenerator_assertThisInitialized(Tw2RandomUniformAttributeGenerator_assertThisInitialized(_this)), "elementType", Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.CUSTOM);

    Tw2RandomUniformAttributeGenerator_defineProperty(Tw2RandomUniformAttributeGenerator_assertThisInitialized(Tw2RandomUniformAttributeGenerator_assertThisInitialized(_this)), "customName", '');

    Tw2RandomUniformAttributeGenerator_defineProperty(Tw2RandomUniformAttributeGenerator_assertThisInitialized(Tw2RandomUniformAttributeGenerator_assertThisInitialized(_this)), "minRange", global["I" /* vec4 */].create());

    Tw2RandomUniformAttributeGenerator_defineProperty(Tw2RandomUniformAttributeGenerator_assertThisInitialized(Tw2RandomUniformAttributeGenerator_assertThisInitialized(_this)), "maxRange", global["I" /* vec4 */].create());

    Tw2RandomUniformAttributeGenerator_defineProperty(Tw2RandomUniformAttributeGenerator_assertThisInitialized(Tw2RandomUniformAttributeGenerator_assertThisInitialized(_this)), "_element", null);

    return _this;
  }

  Tw2RandomUniformAttributeGenerator_createClass(Tw2RandomUniformAttributeGenerator, [{
    key: "Bind",

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */
    value: function Bind(ps) {
      for (let i = 0; i < ps._elements.length; ++i) {
        if (ps._elements[i].elementType === this.elementType && (this.elementType !== Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.CUSTOM || ps._elements[i].customName === this.customName)) {
          this._element = ps._elements[i];
          return true;
        }
      }

      return false;
    }
    /**
     * Generates the attributes
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {number} index
     */

  }, {
    key: "Generate",
    value: function Generate(position, velocity, index) {
      for (let i = 0; i < this._element.dimension; ++i) {
        this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]);
      }
    }
  }]);

  return Tw2RandomUniformAttributeGenerator;
}(Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator);
// CONCATENATED MODULE: ./particle/generators/Tw2SphereShapeAttributeGenerator.js
function Tw2SphereShapeAttributeGenerator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Tw2SphereShapeAttributeGenerator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Tw2SphereShapeAttributeGenerator_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tw2SphereShapeAttributeGenerator_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tw2SphereShapeAttributeGenerator_defineProperties(Constructor, staticProps); return Constructor; }

function Tw2SphereShapeAttributeGenerator_possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return Tw2SphereShapeAttributeGenerator_assertThisInitialized(self); }

function Tw2SphereShapeAttributeGenerator_getPrototypeOf(o) { Tw2SphereShapeAttributeGenerator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tw2SphereShapeAttributeGenerator_getPrototypeOf(o); }

function Tw2SphereShapeAttributeGenerator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tw2SphereShapeAttributeGenerator_setPrototypeOf(subClass, superClass); }

function Tw2SphereShapeAttributeGenerator_setPrototypeOf(o, p) { Tw2SphereShapeAttributeGenerator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tw2SphereShapeAttributeGenerator_setPrototypeOf(o, p); }

function Tw2SphereShapeAttributeGenerator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Tw2SphereShapeAttributeGenerator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Tw2SphereShapeAttributeGenerator
 *
 * @property {number} minRadius
 * @property {number} maxRadius
 * @property {number} minPhi
 * @property {number} maxPhi
 * @property {number} minTheta
 * @property {number} maxTheta
 * @property {boolean} controlPosition
 * @property {boolean} controlVelocity
 * @property {number} minSpeed
 * @property {number} maxSpeed
 * @property {number} parentVelocityFactor
 * @property {vec3} position
 * @property {quat} rotation
 * @property {?Tw2ParticleElement} _position
 * @property {?Tw2ParticleElement}_velocity
 * @inherits Tw2ParticleAttributeGenerator
 */

let Tw2SphereShapeAttributeGenerator_Tw2SphereShapeAttributeGenerator =
/*#__PURE__*/
function (_Tw2ParticleAttribute) {
  Tw2SphereShapeAttributeGenerator_inherits(Tw2SphereShapeAttributeGenerator, _Tw2ParticleAttribute);

  function Tw2SphereShapeAttributeGenerator() {
    var _this;

    Tw2SphereShapeAttributeGenerator_classCallCheck(this, Tw2SphereShapeAttributeGenerator);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = Tw2SphereShapeAttributeGenerator_possibleConstructorReturn(this, Tw2SphereShapeAttributeGenerator_getPrototypeOf(Tw2SphereShapeAttributeGenerator).call(this, ...args));

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "minRadius", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "maxRadius", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "minPhi", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "maxPhi", 360);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "minTheta", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "maxTheta", 360);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "controlPosition", true);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "controlVelocity", true);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "minSpeed", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "maxSpeed", 0);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "parentVelocityFactor", 1);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "position", global["H" /* vec3 */].create());

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "rotation", global["C" /* quat */].create());

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "_position", null);

    Tw2SphereShapeAttributeGenerator_defineProperty(Tw2SphereShapeAttributeGenerator_assertThisInitialized(Tw2SphereShapeAttributeGenerator_assertThisInitialized(_this)), "_velocity", null);

    return _this;
  }

  Tw2SphereShapeAttributeGenerator_createClass(Tw2SphereShapeAttributeGenerator, [{
    key: "Bind",

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */
    value: function Bind(ps) {
      this._position = null;
      this._velocity = null;

      for (let i = 0; i < ps._elements.length; ++i) {
        if (ps._elements[i].elementType === Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.POSITION && this.controlPosition) {
          this._position = ps._elements[i];
        } else if (ps._elements[i].elementType === Tw2ParticleElementDeclaration["a" /* Tw2ParticleElementDeclaration */].Type.VELOCITY && this.controlVelocity) {
          this._velocity = ps._elements[i];
        }
      }

      return (!this.controlPosition || this._position !== null) && (!this.controlVelocity || this._velocity !== null);
    }
    /**
     * Generates the attributes
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {number} index
     */

  }, {
    key: "Generate",
    value: function Generate(position, velocity, index) {
      const phi = (this.minPhi + Math.random() * (this.maxPhi - this.minPhi)) / 180 * Math.PI,
            theta = (this.minTheta + Math.random() * (this.maxTheta - this.minTheta)) / 180 * Math.PI,
            rv = Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator.global.vec3_0;
      rv[0] = Math.sin(phi) * Math.cos(theta);
      rv[1] = -Math.cos(phi);
      rv[2] = Math.sin(phi) * Math.sin(theta);
      global["H" /* vec3 */].transformQuat(rv, rv, this.rotation);

      if (this._velocity) {
        const speed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed),
              offset = this._velocity.instanceStride * index + this._velocity.startOffset;
        this._velocity.buffer[offset] = rv[0] * speed;
        this._velocity.buffer[offset + 1] = rv[1] * speed;
        this._velocity.buffer[offset + 2] = rv[2] * speed;

        if (velocity) {
          this._velocity.buffer[offset] += velocity.buffer[velocity.offset] * this.parentVelocityFactor;
          this._velocity.buffer[offset + 1] += velocity.buffer[velocity.offset + 1] * this.parentVelocityFactor;
          this._velocity.buffer[offset + 2] += velocity.buffer[velocity.offset + 2] * this.parentVelocityFactor;
        }
      }

      if (this._position) {
        global["H" /* vec3 */].scale(rv, rv, this.minRadius + Math.random() * (this.maxRadius - this.minRadius));
        global["H" /* vec3 */].add(rv, rv, this.position);

        if (position) {
          rv[0] += position.buffer[position.offset];
          rv[1] += position.buffer[position.offset + 1];
          rv[2] += position.buffer[position.offset + 2];
        }

        const offset = this._position.instanceStride * index + this._position.startOffset;
        this._position.buffer[offset] = rv[0];
        this._position.buffer[offset + 1] = rv[1];
        this._position.buffer[offset + 2] = rv[2];
      }
    }
  }]);

  return Tw2SphereShapeAttributeGenerator;
}(Tw2ParticleAttributeGenerator_Tw2ParticleAttributeGenerator);
// CONCATENATED MODULE: ./particle/generators/index.js
/* concated harmony reexport Tw2RandomIntegerAttributeGenerator */__webpack_require__.d(__webpack_exports__, "a", function() { return Tw2RandomIntegerAttributeGenerator_Tw2RandomIntegerAttributeGenerator; });
/* concated harmony reexport Tw2RandomUniformAttributeGenerator */__webpack_require__.d(__webpack_exports__, "b", function() { return Tw2RandomUniformAttributeGenerator_Tw2RandomUniformAttributeGenerator; });
/* concated harmony reexport Tw2SphereShapeAttributeGenerator */__webpack_require__.d(__webpack_exports__, "c", function() { return Tw2SphereShapeAttributeGenerator_Tw2SphereShapeAttributeGenerator; });




/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _global_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _global_math__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _eve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _particle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["F"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "device", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["w"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "store", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["E"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resMan", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["x"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "consts", function() { return _global__WEBPACK_IMPORTED_MODULE_5__["u"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Error", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Error"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrHTTPRequest", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrHTTPRequest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrHTTPRequestSend", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrHTTPRequestSend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrHTTPInstance", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrHTTPInstance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrHTTPStatus", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrHTTPStatus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrHTTPReadyState", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrHTTPReadyState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrXMLBinaryFormat", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrXMLBinaryFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrXMLObjectTypeUndefined", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrXMLObjectTypeUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrGeometryMeshMissingParticleElement", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrGeometryMeshMissingParticleElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrGeometryMeshElementComponentsMissing", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrGeometryMeshElementComponentsMissing"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrGeometryMeshBoneNameInvalid", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrGeometryMeshBoneNameInvalid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrGeometryMeshEffectBinding", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrGeometryMeshEffectBinding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrGeometryFileType", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrGeometryFileType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrResourcePrefixUnregistered", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrResourcePrefixUnregistered"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrResourcePrefixUndefined", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrResourcePrefixUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrResourceExtensionUnregistered", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrResourceExtensionUnregistered"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrResourceExtensionUndefined", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrResourceExtensionUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrResourceFormat", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrResourceFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrShaderVersion", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrShaderVersion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrShaderHeaderSize", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrShaderHeaderSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrShaderPermutationValue", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrShaderPermutationValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrShaderCompile", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrShaderCompile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrShaderLink", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrShaderLink"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrDeclarationValueType", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrDeclarationValueType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrSingletonInstantiation", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrSingletonInstantiation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrAbstractClassMethod", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrAbstractClassMethod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrFeatureNotImplemented", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrFeatureNotImplemented"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrIndexBounds", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["ErrIndexBounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2EventEmitter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2EventEmitter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Float", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Float"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Frustum", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Frustum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RenderTarget", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2RenderTarget"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2BatchAccumulator", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2BatchAccumulator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ForwardingRenderBatch", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2ForwardingRenderBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryBatch", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryLineBatch", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryLineBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RenderBatch", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2RenderBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2InstancedMeshBatch", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2InstancedMeshBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2CurveSet", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2CurveSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ValueBinding", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2ValueBinding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2BasicPerObjectData", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2BasicPerObjectData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveBasicPerObjectData", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["EveBasicPerObjectData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PerObjectData", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2PerObjectData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RawData", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2RawData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2BlendShapeData", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2BlendShapeData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryAnimation", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryAnimation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryBone", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryBone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryCurve", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryMesh", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryMesh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryMeshArea", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryMeshArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryMeshBinding", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryMeshBinding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryModel", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometrySkeleton", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometrySkeleton"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryTrackGroup", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryTrackGroup"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryTransformTrack", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryTransformTrack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Effect", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Effect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2InstancedMesh", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2InstancedMesh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Mesh", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Mesh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MeshArea", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2MeshArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MeshLineArea", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2MeshLineArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Animation", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Animation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2AnimationController", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2AnimationController"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Bone", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Bone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Model", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Track", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Track"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2TrackGroup", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TrackGroup"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Parameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Parameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VectorParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VectorParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2FloatParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2FloatParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MatrixParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2MatrixParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2TransformParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TransformParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VariableParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VariableParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector2Parameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector2Parameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector3Parameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector3Parameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector4Parameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector4Parameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2TextureParameter", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PostEffect", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2PostEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PostEffectManager", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2PostEffectManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PostEffectStep", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2PostEffectStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PostProcess", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2PostProcess"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2BinaryReader", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2BinaryReader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ObjectReader", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2ObjectReader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2EffectRes", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2EffectRes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2GeometryRes", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryRes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2LoadingObject", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2LoadingObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Resource", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Resource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2TextureRes", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureRes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VideoRes", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VideoRes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2SamplerState", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2SamplerState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2SamplerOverride", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2SamplerOverride"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VertexDeclaration", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VertexDeclaration"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VertexElement", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VertexElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2CurveKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2CurveKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Curve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Curve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ColorKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ColorKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ColorCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ColorCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ColorKey2", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ColorKey2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ColorCurve2", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ColorCurve2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2EventKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2EventKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2EventCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2EventCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2PerlinCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2PerlinCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2QuaternionKey2", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2QuaternionKey2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2QuaternionCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2QuaternionCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RandomConstantCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2RandomConstantCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Torque", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Torque"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RigidOrientation", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2RigidOrientation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2QuaternionKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2QuaternionKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RotationCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2RotationCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ScalarKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ScalarKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ScalarCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ScalarCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ScalarKey2", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ScalarKey2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ScalarCurve2", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ScalarCurve2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2SineCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2SineCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector2Key", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Vector2Key"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector2Curve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Vector2Curve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector3Key", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Vector3Key"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2Vector3Curve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2Vector3Curve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VectorKey", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2VectorKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VectorCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2VectorCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ColorSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ColorSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2EulerRotation", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2EulerRotation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2QuaternionSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2QuaternionSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2RGBAScalarSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2RGBAScalarSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2ScalarSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2ScalarSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2VectorSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2VectorSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2XYZScalarSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2XYZScalarSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2YPRSequencer", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2YPRSequencer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2WbgTrack", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2WbgTrack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2WbgTransformTrack", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2WbgTransformTrack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2TransformTrack", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2TransformTrack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MayaEulerRotationCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2MayaEulerRotationCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MayaScalarCurve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2MayaScalarCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MayaVector3Curve", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2MayaVector3Curve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tw2MayaAnimationEngine", function() { return _curve__WEBPACK_IMPORTED_MODULE_2__["Tw2MayaAnimationEngine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpaceScene", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpaceScene"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSOF", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSOF"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChild", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChild"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildBillboard", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildBillboard"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildCloud", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildCloud"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildContainer", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildContainer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildExplosion", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildExplosion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildMesh", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildMesh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveChildParticleSystem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveChildParticleSystem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveLensflare", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveLensflare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveMeshOverlayEffect", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveMeshOverlayEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveOccluder", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveOccluder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveStretch", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveStretch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EvePerMuzzleData", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EvePerMuzzleData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveTurretFiringFX", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveTurretFiringFX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveStarfield", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveStarfield"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveObject", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveEffectRoot", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveEffectRoot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveMissileWarhead", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveMissileWarhead"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveMissile", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveMissile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EvePlanet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EvePlanet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveShip", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveShip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpaceObject", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpaceObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveStation", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveStation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveTransform", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveTransform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveObjectSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveObjectSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveObjectSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveObjectSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveBoosterBatch", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveBoosterBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveBoosterSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveBoosterSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveBoosterSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveBoosterSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveCurveLineSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveCurveLineSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveCurveLineSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveCurveLineSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveLocator", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveLocator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EvePlaneSetBatch", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EvePlaneSetBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EvePlaneSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EvePlaneSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EvePlaneSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EvePlaneSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpaceObjectDecal", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpaceObjectDecal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpotlightSetBatch", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpotlightSetBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpotlightSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpotlightSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpotlightSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpotlightSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpriteSetBatch", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpriteSetBatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpriteSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpriteSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveSpriteSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveSpriteSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveTurretSetItem", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveTurretSetItem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EveTurretSet", function() { return _eve__WEBPACK_IMPORTED_MODULE_3__["EveTurretSet"]; });

/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _particle__WEBPACK_IMPORTED_MODULE_4__) if(["math","util","device","store","resMan","logger","consts","Tw2Error","ErrHTTPRequest","ErrHTTPRequestSend","ErrHTTPInstance","ErrHTTPStatus","ErrHTTPReadyState","ErrXMLBinaryFormat","ErrXMLObjectTypeUndefined","ErrGeometryMeshMissingParticleElement","ErrGeometryMeshElementComponentsMissing","ErrGeometryMeshBoneNameInvalid","ErrGeometryMeshEffectBinding","ErrGeometryFileType","ErrResourcePrefixUnregistered","ErrResourcePrefixUndefined","ErrResourceExtensionUnregistered","ErrResourceExtensionUndefined","ErrResourceFormat","ErrShaderVersion","ErrShaderHeaderSize","ErrShaderPermutationValue","ErrShaderCompile","ErrShaderLink","ErrDeclarationValueType","ErrSingletonInstantiation","ErrAbstractClassMethod","ErrFeatureNotImplemented","ErrIndexBounds","Tw2EventEmitter","Tw2Float","Tw2Frustum","Tw2RenderTarget","Tw2BatchAccumulator","Tw2ForwardingRenderBatch","Tw2GeometryBatch","Tw2GeometryLineBatch","Tw2RenderBatch","Tw2InstancedMeshBatch","Tw2CurveSet","Tw2ValueBinding","Tw2BasicPerObjectData","EveBasicPerObjectData","Tw2PerObjectData","Tw2RawData","Tw2BlendShapeData","Tw2GeometryAnimation","Tw2GeometryBone","Tw2GeometryCurve","Tw2GeometryMesh","Tw2GeometryMeshArea","Tw2GeometryMeshBinding","Tw2GeometryModel","Tw2GeometrySkeleton","Tw2GeometryTrackGroup","Tw2GeometryTransformTrack","Tw2Effect","Tw2InstancedMesh","Tw2Mesh","Tw2MeshArea","Tw2MeshLineArea","Tw2Animation","Tw2AnimationController","Tw2Bone","Tw2Model","Tw2Track","Tw2TrackGroup","Tw2Parameter","Tw2VectorParameter","Tw2FloatParameter","Tw2MatrixParameter","Tw2TransformParameter","Tw2VariableParameter","Tw2Vector2Parameter","Tw2Vector3Parameter","Tw2Vector4Parameter","Tw2TextureParameter","Tw2PostEffect","Tw2PostEffectManager","Tw2PostEffectStep","Tw2PostProcess","Tw2BinaryReader","Tw2ObjectReader","Tw2EffectRes","Tw2GeometryRes","Tw2LoadingObject","Tw2Resource","Tw2TextureRes","Tw2VideoRes","Tw2SamplerState","Tw2SamplerOverride","Tw2VertexDeclaration","Tw2VertexElement","Tw2CurveKey","Tw2Curve","Tw2ColorKey","Tw2ColorCurve","Tw2ColorKey2","Tw2ColorCurve2","Tw2EventKey","Tw2EventCurve","Tw2PerlinCurve","Tw2QuaternionKey2","Tw2QuaternionCurve","Tw2RandomConstantCurve","Tw2Torque","Tw2RigidOrientation","Tw2QuaternionKey","Tw2RotationCurve","Tw2ScalarKey","Tw2ScalarCurve","Tw2ScalarKey2","Tw2ScalarCurve2","Tw2SineCurve","Tw2Vector2Key","Tw2Vector2Curve","Tw2Vector3Key","Tw2Vector3Curve","Tw2VectorKey","Tw2VectorCurve","Tw2ColorSequencer","Tw2EulerRotation","Tw2QuaternionSequencer","Tw2RGBAScalarSequencer","Tw2ScalarSequencer","Tw2VectorSequencer","Tw2XYZScalarSequencer","Tw2YPRSequencer","Tw2WbgTrack","Tw2WbgTransformTrack","Tw2TransformTrack","Tw2MayaEulerRotationCurve","Tw2MayaScalarCurve","Tw2MayaVector3Curve","Tw2MayaAnimationEngine","EveSpaceScene","EveSOF","EveChild","EveChildBillboard","EveChildCloud","EveChildContainer","EveChildExplosion","EveChildMesh","EveChildParticleSystem","EveLensflare","EveMeshOverlayEffect","EveOccluder","EveStretch","EvePerMuzzleData","EveTurretFiringFX","EveStarfield","EveObject","EveEffectRoot","EveMissileWarhead","EveMissile","EvePlanet","EveShip","EveSpaceObject","EveStation","EveTransform","EveObjectSetItem","EveObjectSet","EveBoosterBatch","EveBoosterSetItem","EveBoosterSet","EveCurveLineSetItem","EveCurveLineSet","EveLocator","EvePlaneSetBatch","EvePlaneSetItem","EvePlaneSet","EveSpaceObjectDecal","EveSpotlightSetBatch","EveSpotlightSetItem","EveSpotlightSet","EveSpriteSetBatch","EveSpriteSetItem","EveSpriteSet","EveTurretSetItem","EveTurretSet","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _particle__WEBPACK_IMPORTED_MODULE_4__[key]; }) }(__WEBPACK_IMPORT_KEY__));











const vec4 = _global_math__WEBPACK_IMPORTED_MODULE_0__["vec4"],
      mat4 = _global_math__WEBPACK_IMPORTED_MODULE_0__["mat4"];
/**
 * Register global configurations
 */

_global__WEBPACK_IMPORTED_MODULE_5__[/* store */ "E"].Register({
  resMan: {
    'systemMirror': false,
    'autoPurgeResources': true,
    'purgeTime': 60,
    'maxPrepareTime': 0.05
  },
  logger: {
    'name': 'CCPWGL',
    'history': 50,
    'throttle': 10,
    'display': true,
    'visible': {
      'error': true,
      'warning': true,
      'log': true,
      'info': false,
      'debug': false
    }
  },
  paths: {
    'res': 'https://developers.eveonline.com/ccpwgl/assetpath/1097993/'
  },
  extensions: {
    'sm_hi': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2EffectRes"],
    'sm_lo': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2EffectRes"],
    'wbg': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2GeometryRes"],
    'png': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureRes"],
    'dds': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureRes"],
    'cube': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureRes"],
    'mp4': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VideoRes"],
    'ogg': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VideoRes"],
    'webm': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2VideoRes"]
  },
  classes: [_core__WEBPACK_IMPORTED_MODULE_1__, _curve__WEBPACK_IMPORTED_MODULE_2__, _eve__WEBPACK_IMPORTED_MODULE_3__, _particle__WEBPACK_IMPORTED_MODULE_4__],
  types: {
    'float': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2FloatParameter"],
    'number': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2FloatParameter"],
    'texture': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2TextureParameter"],
    'vector2': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector2Parameter"],
    'vector3': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector3Parameter"],
    'vector4': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2Vector4Parameter"],
    'matrix4': _core__WEBPACK_IMPORTED_MODULE_1__["Tw2MatrixParameter"]
  },
  variables: {
    'WorldMat': mat4.create(),
    'ViewMat': mat4.create(),
    'ProjectionMat': mat4.create(),
    'ViewProjectionMat': mat4.create(),
    'ViewportSize': vec4.create(),
    'Time': vec4.create(),
    'u_DecalMatrix': mat4.create(),
    'u_InvDecalMatrix': mat4.create(),
    'EveSpaceSceneEnvMap': '',
    'EnvMap1': '',
    'EnvMap2': '',
    'EnvMap3': '',
    'ShadowLightness': 0,
    'OccluderValue': vec4.fromValues(1, 1, 0, 0),
    'LensflareFxOccScale': vec4.fromValues(1, 1, 0, 0),
    'LensflareFxDirectionScale': vec4.create()
  }
});

/***/ }),
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

//Ported to node by Marcin Ignac on 2016-05-20

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {
var window

//polyfill window in node
if (typeof(window) == 'undefined') {
    window = global;
}

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};


/**
 * Which arguments are enums based on the number of arguments to the function.
 * So
 *    'texImage2D': {
 *       9: { 0:true, 2:true, 6:true, 7:true },
 *       6: { 0:true, 2:true, 3:true, 4:true },
 *    },
 *
 * means if there are 9 arguments then 6 and 7 are enums, if there are 6
 * arguments 3 and 4 are enums
 *
 * @type {!Object.<number, !Object.<number, string>}
 */
var glValidEnumContexts = {
  // Generic setters and getters

  'enable': {1: { 0:true }},
  'disable': {1: { 0:true }},
  'getParameter': {1: { 0:true }},

  // Rendering

  'drawArrays': {3:{ 0:true }},
  'drawElements': {4:{ 0:true, 2:true }},

  // Shaders

  'createShader': {1: { 0:true }},
  'getShaderParameter': {2: { 1:true }},
  'getProgramParameter': {2: { 1:true }},
  'getShaderPrecisionFormat': {2: { 0: true, 1:true }},

  // Vertex attributes

  'getVertexAttrib': {2: { 1:true }},
  'vertexAttribPointer': {6: { 2:true }},

  // Textures

  'bindTexture': {2: { 0:true }},
  'activeTexture': {1: { 0:true }},
  'getTexParameter': {2: { 0:true, 1:true }},
  'texParameterf': {3: { 0:true, 1:true }},
  'texParameteri': {3: { 0:true, 1:true, 2:true }},
  // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints
  'copyTexImage2D': {8: { 0:true, 2:true }},
  'copyTexSubImage2D': {8: { 0:true }},
  'generateMipmap': {1: { 0:true }},
  // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints

  // Buffer objects

  'bindBuffer': {2: { 0:true }},
  // bufferData and bufferSubData are defined below with WebGL 2 entrypoints
  'getBufferParameter': {2: { 0:true, 1:true }},

  // Renderbuffers and framebuffers

  'pixelStorei': {2: { 0:true, 1:true }},
  // readPixels is defined below with WebGL 2 entrypoints
  'bindRenderbuffer': {2: { 0:true }},
  'bindFramebuffer': {2: { 0:true }},
  'checkFramebufferStatus': {1: { 0:true }},
  'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},
  'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},
  'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},
  'getRenderbufferParameter': {2: { 0:true, 1:true }},
  'renderbufferStorage': {4: { 0:true, 1:true }},

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},
  'depthFunc': {1: { 0:true }},
  'blendFunc': {2: { 0:true, 1:true }},
  'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},
  'blendEquation': {1: { 0:true }},
  'blendEquationSeparate': {2: { 0:true, 1:true }},
  'stencilFunc': {3: { 0:true }},
  'stencilFuncSeparate': {4: { 0:true, 1:true }},
  'stencilMaskSeparate': {2: { 0:true }},
  'stencilOp': {3: { 0:true, 1:true, 2:true }},
  'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},

  // Culling

  'cullFace': {1: { 0:true }},
  'frontFace': {1: { 0:true }},

  // ANGLE_instanced_arrays extension

  'drawArraysInstancedANGLE': {4: { 0:true }},
  'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},

  // EXT_blend_minmax extension

  'blendEquationEXT': {1: { 0:true }},

  // WebGL 2 Buffer objects

  'bufferData': {
    3: { 0:true, 2:true }, // WebGL 1
    4: { 0:true, 2:true }, // WebGL 2
    5: { 0:true, 2:true }  // WebGL 2
  },
  'bufferSubData': {
    3: { 0:true }, // WebGL 1
    4: { 0:true }, // WebGL 2
    5: { 0:true }  // WebGL 2
  },
  'copyBufferSubData': {5: { 0:true, 1:true }},
  'getBufferSubData': {3: { 0:true }, 4: { 0:true }, 5: { 0:true }},

  // WebGL 2 Framebuffer objects

  'blitFramebuffer': {10: { 8: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }, 9:true }},
  'framebufferTextureLayer': {5: { 0:true, 1:true }},
  'invalidateFramebuffer': {2: { 0:true }},
  'invalidateSubFramebuffer': {6: { 0:true }},
  'readBuffer': {1: { 0:true }},

  // WebGL 2 Renderbuffer objects

  'getInternalformatParameter': {3: { 0:true, 1:true, 2:true }},
  'renderbufferStorageMultisample': {5: { 0:true, 2:true }},

  // WebGL 2 Texture objects

  'texStorage2D': {5: { 0:true, 2:true }},
  'texStorage3D': {6: { 0:true, 2:true }},
  'texImage2D': {
    9: { 0:true, 2:true, 6:true, 7:true }, // WebGL 1 & 2
    6: { 0:true, 2:true, 3:true, 4:true }, // WebGL 1
    10: { 0:true, 2:true, 6:true, 7:true } // WebGL 2
  },
  'texImage3D': {
    10: { 0:true, 2:true, 7:true, 8:true },
    11: { 0:true, 2:true, 7:true, 8:true }
  },
  'texSubImage2D': {
    9: { 0:true, 6:true, 7:true }, // WebGL 1 & 2
    7: { 0:true, 4:true, 5:true }, // WebGL 1
    10: { 0:true, 6:true, 7:true } // WebGL 2
  },
  'texSubImage3D': {
    11: { 0:true, 8:true, 9:true },
    12: { 0:true, 8:true, 9:true }
  },
  'copyTexSubImage3D': {9: { 0:true }},
  'compressedTexImage2D': {
    7: { 0: true, 2:true }, // WebGL 1 & 2
    8: { 0: true, 2:true }, // WebGL 2
    9: { 0: true, 2:true }  // WebGL 2
  },
  'compressedTexImage3D': {
    8: { 0: true, 2:true },
    9: { 0: true, 2:true },
    10: { 0: true, 2:true }
  },
  'compressedTexSubImage2D': {
    8: { 0: true, 6:true }, // WebGL 1 & 2
    9: { 0: true, 6:true }, // WebGL 2
    10: { 0: true, 6:true } // WebGL 2
  },
  'compressedTexSubImage3D': {
    10: { 0: true, 8:true },
    11: { 0: true, 8:true },
    12: { 0: true, 8:true }
  },

  // WebGL 2 Vertex attribs

  'vertexAttribIPointer': {5: { 2:true }},

  // WebGL 2 Writing to the drawing buffer

  'drawArraysInstanced': {4: { 0:true }},
  'drawElementsInstanced': {5: { 0:true, 2:true }},
  'drawRangeElements': {6: { 0:true, 4:true }},

  // WebGL 2 Reading back pixels

  'readPixels': {
    7: { 4:true, 5:true }, // WebGL 1 & 2
    8: { 4:true, 5:true }  // WebGL 2
  },

  // WebGL 2 Multiple Render Targets

  'clearBufferfv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferuiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferfi': {4: { 0:true }},

  // WebGL 2 Query objects

  'beginQuery': {2: { 0:true }},
  'endQuery': {1: { 0:true }},
  'getQuery': {2: { 0:true, 1:true }},
  'getQueryParameter': {2: { 1:true }},

  // WebGL 2 Sampler objects

  'samplerParameteri': {3: { 1:true, 2:true }},
  'samplerParameterf': {3: { 1:true }},
  'getSamplerParameter': {2: { 1:true }},

  // WebGL 2 Sync objects

  'fenceSync': {2: { 0:true, 1: { 'enumBitwiseOr': [] } }},
  'clientWaitSync': {3: { 1: { 'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT'] } }},
  'waitSync': {3: { 1: { 'enumBitwiseOr': [] } }},
  'getSyncParameter': {2: { 1:true }},

  // WebGL 2 Transform Feedback

  'bindTransformFeedback': {2: { 0:true }},
  'beginTransformFeedback': {1: { 0:true }},
  'transformFeedbackVaryings': {3: { 2:true }},

  // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers

  'bindBufferBase': {3: { 0:true }},
  'bindBufferRange': {5: { 0:true }},
  'getIndexedParameter': {2: { 0:true }},
  'getActiveUniforms': {3: { 2:true }},
  'getActiveUniformBlockParameter': {3: { 2:true }}
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Map of names to numbers.
 * @type {Object}
 */
var enumStringToValue = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    enumStringToValue = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
        enumStringToValue[propertyName] = ctx[propertyName];
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? ("gl." + name) :
      ("/*UNKNOWN WebGL ENUM*/ 0x" + value.toString(16) + "");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} numArgs the number of arguments passed to the function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    var funcInfo = funcInfo[numArgs];
    if (funcInfo !== undefined) {
      if (funcInfo[argumentIndex]) {
        if (typeof funcInfo[argumentIndex] === 'object' &&
            funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {
          var enums = funcInfo[argumentIndex]['enumBitwiseOr'];
          var orResult = 0;
          var orEnums = [];
          for (var i = 0; i < enums.length; ++i) {
            var enumValue = enumStringToValue[enums[i]];
            if ((value & enumValue) !== 0) {
              orResult |= enumValue;
              orEnums.push(glEnumToString(enumValue));
            }
          }
          if (orResult === value) {
            return orEnums.join(' | ');
          } else {
            return glEnumToString(value);
          }
        } else {
          return glEnumToString(value);
        }
      }
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  var numArgs = args.length;
  for (var ii = 0; ii < numArgs; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, numArgs, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 * @param {!WebGLRenderingContext} opt_err_ctx The webgl context
 *        to call getError on if different than ctx.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {
  opt_err_ctx = opt_err_ctx || ctx;
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        var numArgs = args.length;
        for (var ii = 0; ii < numArgs; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, numArgs, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = opt_err_ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
      if (propertyName != 'getExtension') {
        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
      } else {
        var wrapped = makeErrorWrapper(ctx, propertyName);
        wrapper[propertyName] = function () {
          var result = wrapped.apply(ctx, arguments);
          if (!result) {
            return null;
          }
          return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);
        };
      }
    } else {
      makePropertyWrapper(wrapper, ctx, propertyName);
    }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var isWebGL2RenderingContext = !!ctx.createTransformFeedback;

  if (isWebGL2RenderingContext) {
    ctx.bindVertexArray(null);
  }

  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
    if (isWebGL2RenderingContext) {
      ctx.vertexAttribDivisor(ii, 0);
    }
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
    if (isWebGL2RenderingContext) {
      ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);
      ctx.bindTexture(ctx.TEXTURE_3D, null);
      ctx.bindSampler(ii, null);
    }
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  if (isWebGL2RenderingContext) {
    ctx.drawBuffers([ctx.BACK]);
    ctx.readBuffer(ctx.BACK);
    ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);
    ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);
    var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
    for (var ii = 0; ii < numTransformFeedbacks; ++ii) {
      ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);
    }
    var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);
    for (var ii = 0; ii < numUBOs; ++ii) {
      ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);
    }
    ctx.disable(ctx.RASTERIZER_DISCARD);
    ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);
    ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);
    ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);
    ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);
  }

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;
  var isWebGL2RenderingContext;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if ((ctx instanceof WebGLRenderingContext) || (window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext))) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          isWebGL2RenderingContext = window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext);
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k[ii]];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
      else if (isWebGL2RenderingContext) {
        if (resource instanceof WebGLQuery) {
          unwrappedContext_.deleteQuery(resource);
        } else if (resource instanceof WebGLSampler) {
          unwrappedContext_.deleteSampler(resource);
        } else if (resource instanceof WebGLSync) {
          unwrappedContext_.deleteSync(resource);
        } else if (resource instanceof WebGLTransformFeedback) {
          unwrappedContext_.deleteTransformFeedback(resource);
        } else if (resource instanceof WebGLVertexArrayObject) {
          unwrappedContext_.deleteVertexArray(resource);
        }
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    if (isWebGL2RenderingContext) {
      creationFunctions.push(
        "createQuery",
        "createSampler",
        "fenceSync",
        "createTransformFeedback",
        "createVertexArray"
      );
    }
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    if (isWebGL2RenderingContext) {
      functionsThatShouldReturnNull.push(
        "getInternalformatParameter",
        "getQuery",
        "getQueryParameter",
        "getSamplerParameter",
        "getSyncParameter",
        "getTransformFeedbackVarying",
        "getIndexedParameter",
        "getUniformIndices",
        "getActiveUniforms",
        "getActiveUniformBlockParameter",
        "getActiveUniformBlockName"
      );
    }
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    if (isWebGL2RenderingContext) {
      isFunctions.push(
        "isQuery",
        "isSampler",
        "isSync",
        "isTransformFeedback",
        "isVertexArray"
      );
    }
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    if (isWebGL2RenderingContext) {
      wrappedContext_.getFragDataLocation = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return -1;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getFragDataLocation);

      wrappedContext_.clientWaitSync = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.WAIT_FAILED;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.clientWaitSync);

      wrappedContext_.getUniformBlockIndex = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.INVALID_INDEX;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getUniformBlockIndex);
    }

    return wrappedContext_;
  }
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} numArgs The number of arguments
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

module.exports = WebGLDebugUtils;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(31)))

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })
/******/ ]);
});