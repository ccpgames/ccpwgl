(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ccpwgl_int"] = factory();
	else
		root["ccpwgl_int"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _num = __webpack_require__(28);

Object.keys(_num).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _num[key];
    }
  });
});

var _vec = __webpack_require__(53);

Object.keys(_vec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec[key];
    }
  });
});

var _vec2 = __webpack_require__(32);

Object.keys(_vec2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec2[key];
    }
  });
});

var _vec3 = __webpack_require__(33);

Object.keys(_vec3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec3[key];
    }
  });
});

var _quat = __webpack_require__(59);

Object.keys(_quat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _quat[key];
    }
  });
});

var _mat = __webpack_require__(60);

Object.keys(_mat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mat[key];
    }
  });
});

var _mat2 = __webpack_require__(61);

Object.keys(_mat2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mat2[key];
    }
  });
});

var _noise = __webpack_require__(62);

Object.keys(_noise).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _noise[key];
    }
  });
});

var _curve = __webpack_require__(63);

Object.keys(_curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _curve[key];
    }
  });
});

var _util = __webpack_require__(64);

Object.keys(_util).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _util[key];
    }
  });
});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Device = __webpack_require__(2);

Object.keys(_Tw2Device).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Device[key];
    }
  });
});

var _Tw2ResMan = __webpack_require__(4);

Object.keys(_Tw2ResMan).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ResMan[key];
    }
  });
});

var _Tw2VariableStore = __webpack_require__(16);

Object.keys(_Tw2VariableStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VariableStore[key];
    }
  });
});

var _data = __webpack_require__(67);

Object.keys(_data).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _data[key];
    }
  });
});

var _Tw2AnimationController = __webpack_require__(69);

Object.keys(_Tw2AnimationController).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2AnimationController[key];
    }
  });
});

var _Tw2BatchAccumulator = __webpack_require__(23);

Object.keys(_Tw2BatchAccumulator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2BatchAccumulator[key];
    }
  });
});

var _Tw2CurveSet = __webpack_require__(70);

Object.keys(_Tw2CurveSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2CurveSet[key];
    }
  });
});

var _Tw2Effect = __webpack_require__(20);

Object.keys(_Tw2Effect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Effect[key];
    }
  });
});

var _Tw2EffectRes = __webpack_require__(71);

Object.keys(_Tw2EffectRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EffectRes[key];
    }
  });
});

var _Tw2EventEmitter = __webpack_require__(6);

Object.keys(_Tw2EventEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EventEmitter[key];
    }
  });
});

var _Tw2Float = __webpack_require__(72);

Object.keys(_Tw2Float).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Float[key];
    }
  });
});

var _Tw2FloatParameter = __webpack_require__(36);

Object.keys(_Tw2FloatParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2FloatParameter[key];
    }
  });
});

var _Tw2Frustum = __webpack_require__(73);

Object.keys(_Tw2Frustum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Frustum[key];
    }
  });
});

var _Tw2GeometryRes = __webpack_require__(22);

Object.keys(_Tw2GeometryRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryRes[key];
    }
  });
});

var _Tw2InstancedMesh = __webpack_require__(74);

Object.keys(_Tw2InstancedMesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2InstancedMesh[key];
    }
  });
});

var _Tw2MatrixParameter = __webpack_require__(75);

Object.keys(_Tw2MatrixParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MatrixParameter[key];
    }
  });
});

var _Tw2Mesh = __webpack_require__(37);

Object.keys(_Tw2Mesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Mesh[key];
    }
  });
});

var _Tw2ObjectReader = __webpack_require__(34);

Object.keys(_Tw2ObjectReader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ObjectReader[key];
    }
  });
});

var _Tw2PostProcess = __webpack_require__(76);

Object.keys(_Tw2PostProcess).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2PostProcess[key];
    }
  });
});

var _Tw2RenderTarget = __webpack_require__(38);

Object.keys(_Tw2RenderTarget).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RenderTarget[key];
    }
  });
});

var _Tw2Resource = __webpack_require__(11);

Object.keys(_Tw2Resource).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Resource[key];
    }
  });
});

var _Tw2RuntimeInstanceData = __webpack_require__(77);

Object.keys(_Tw2RuntimeInstanceData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RuntimeInstanceData[key];
    }
  });
});

var _Tw2SamplerState = __webpack_require__(19);

Object.keys(_Tw2SamplerState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SamplerState[key];
    }
  });
});

var _Tw2TextureParameter = __webpack_require__(17);

Object.keys(_Tw2TextureParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TextureParameter[key];
    }
  });
});

var _Tw2TextureRes = __webpack_require__(24);

Object.keys(_Tw2TextureRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TextureRes[key];
    }
  });
});

var _Tw2TransformParameter = __webpack_require__(94);

Object.keys(_Tw2TransformParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TransformParameter[key];
    }
  });
});

var _Tw2ValueBinding = __webpack_require__(95);

Object.keys(_Tw2ValueBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ValueBinding[key];
    }
  });
});

var _Tw2VariableParameter = __webpack_require__(96);

Object.keys(_Tw2VariableParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VariableParameter[key];
    }
  });
});

var _Tw2Vector2Parameter = __webpack_require__(97);

Object.keys(_Tw2Vector2Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector2Parameter[key];
    }
  });
});

var _Tw2Vector3Parameter = __webpack_require__(98);

Object.keys(_Tw2Vector3Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector3Parameter[key];
    }
  });
});

var _Tw2Vector4Parameter = __webpack_require__(25);

Object.keys(_Tw2Vector4Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector4Parameter[key];
    }
  });
});

var _Tw2VertexDeclaration = __webpack_require__(12);

Object.keys(_Tw2VertexDeclaration).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VertexDeclaration[key];
    }
  });
});

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.device = undefined;

var _index = __webpack_require__(0);

var _Tw2VariableStore = __webpack_require__(16);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2TextureParameter = __webpack_require__(17);

var _Tw2Effect = __webpack_require__(20);

var _Tw2VertexDeclaration = __webpack_require__(12);

var WebGLDebugUtil = __webpack_require__(65);

/**
 * Tw2Device
 * - creates WebGL context
 * - stores global rendering variables
 * - contains utility functions
 * @constructor
 */
function Tw2Device() {
    this.gl = null;
    this.glVersion = Tw2Device.WebglVersion.NONE;
    this.ext = null;

    this.dt = 0;
    this.frameCounter = 0;
    this.startTime = new Date();
    this.currentTime = this.startTime;
    this.previousTime = null;

    this.eyePosition = _index.vec3.create();
    this.targetResolution = _index.vec4.create();
    this.world = _index.mat4.create();
    this.view = _index.mat4.create();
    this.viewInverse = _index.mat4.create();
    this.viewTranspose = _index.mat4.create();
    this.projection = _index.mat4.create();
    this.projectionInverse = _index.mat4.create();
    this.projectionTranspose = _index.mat4.create();
    this.viewProjection = _index.mat4.create();
    this.viewProjectionTranspose = _index.mat4.create();

    this.canvas = null;
    this.viewportAspect = 0;
    this.viewportWidth = 0;
    this.viewportHeight = 0;

    this.shadowHandles = null;
    this.wrapModes = [];
    this.perObjectData = null;
    this.effectDir = '/effect.gles2/';
    this.debugMode = false;

    this.mipLevelSkipCount = 0;
    this.shaderModel = 'hi';
    this.enableAnisotropicFiltering = true;

    this._scheduled = [];
    this._quadBuffer = null;
    this._cameraQuadBuffer = null;
    this._currentRenderMode = null;
    this._onResize = null;

    this.utils = WebGLDebugUtil;
}

/**
 * Creates gl Device
 * @param {HTMLCanvasElement} canvas
 * @param {Object} [params]
 * @returns {boolean}
 */
Tw2Device.prototype.CreateDevice = function (canvas, params) {
    this.gl = null;
    this.glVersion = Tw2Device.WebglVersion.NONE;
    this.effectDir = '/effect.gles2/';
    this.ext = {
        drawElementsInstanced: function drawElementsInstanced() {
            return false;
        },
        drawArraysInstanced: function drawArraysInstanced() {
            return false;
        },
        vertexAttribDivisor: function vertexAttribDivisor() {
            return false;
        },
        hasInstancedArrays: function hasInstancedArrays() {
            return false;
        }
    };

    // Try webgl2 if enabled
    if (params && params.webgl2) {
        this.gl = Tw2Device.CreateContext(canvas, params, Tw2Device.Webgl2ContextNames);
        if (this.gl) this.glVersion = Tw2Device.WebglVersion.WEBGL2;
    }
    // Fallback to webgl
    if (!this.gl) {
        this.gl = Tw2Device.CreateContext(canvas, params, Tw2Device.WebglContextNames);
        if (this.gl) this.glVersion = Tw2Device.WebglVersion.WEBGL;
    }

    var gl = this.gl;
    // Setup webgl compatibility (performance of closure is better than binding)
    switch (this.glVersion) {
        case Tw2Device.WebglVersion.WEBGL2:
            this.ext = {
                drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
                    gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
                },
                drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
                    gl.drawArraysInstanced(mode, first, count, instanceCount);
                },
                vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
                    gl.vertexAttribDivisor(location, divisor);
                },
                hasInstancedArrays: function hasInstancedArrays() {
                    return true;
                }
            };
            break;

        case Tw2Device.WebglVersion.WEBGL:
            this.GetExtension('OES_standard_derivatives');
            this.GetExtension('OES_element_index_uint');
            this.GetExtension('OES_texture_float');
            this.GetExtension('EXT_shader_texture_lod');
            var instancedArrays = this.GetExtension('ANGLE_instanced_arrays');
            if (instancedArrays) {
                this.ext = {
                    drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
                        instancedArrays['drawElementsInstancedANGLE'](mode, count, type, offset, instanceCount);
                    },
                    drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
                        instancedArrays['drawArraysInstancedANGLE'](mode, first, count, instanceCount);
                    },
                    vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
                        instancedArrays['vertexAttribDivisorANGLE'](location, divisor);
                    },
                    hasInstancedArrays: function hasInstancedArrays() {
                        return true;
                    }
                };
            }
            break;

        default:
            return false;
    }

    _Tw2EventEmitter.emitter.log('webgl', {
        log: 'warn',
        type: 'Context created',
        value: this.glVersion
    });

    // Optional extensions
    this.ext.CompressedTexture = this.GetExtension('compressed_texture_s3tc');
    this.ext.AnisotropicFilter = this.GetExtension('EXT_texture_filter_anisotropic');
    if (this.ext.AnisotropicFilter) {
        this.ext.AnisotropicFilter.maxAnisotropy = gl.getParameter(this.ext.AnisotropicFilter['MAX_TEXTURE_MAX_ANISOTROPY_EXT']);
    }

    // CCP mobile shader binary (is this depreciated?)
    var shaderBinary = this.GetExtension('CCP_shader_binary');
    if (shaderBinary) {
        var renderer = gl.getParameter(this.gl.RENDERER);
        var maliVer = renderer.match(/Mali-(\w+).*/);
        if (maliVer) {
            this.effectDir = '/effect.gles2.mali' + maliVer[1] + '/';
            this.ext.ShaderBinary = shaderBinary;
        }
    }

    if (this.debugMode) {
        this.gl = this.utils.makeDebugContext(this.gl);
    }

    // Quality
    this.alphaBlendBackBuffer = !params || typeof params.alpha === 'undefined' || params.alpha;
    this.msaaSamples = this.gl.getParameter(this.gl.SAMPLES);
    this.antialiasing = this.msaaSamples > 1;

    this.canvas = canvas;
    this.Resize();

    var vertices = [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0];

    this._quadBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._quadBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
    this._cameraQuadBuffer = this.gl.createBuffer();
    this._quadDecl = new _Tw2VertexDeclaration.Tw2VertexDeclaration();
    this._quadDecl.elements.push(new _Tw2VertexDeclaration.Tw2VertexElement(_Tw2VertexDeclaration.Tw2VertexDeclaration.Type.POSITION, 0, this.gl.FLOAT, 4, 0));
    this._quadDecl.elements.push(new _Tw2VertexDeclaration.Tw2VertexElement(_Tw2VertexDeclaration.Tw2VertexDeclaration.Type.TEXCOORD, 0, this.gl.FLOAT, 2, 16));
    this._quadDecl.RebuildHash();

    this.alphaTestState = {};
    this.alphaTestState.states = {};
    this.alphaTestState.states[this.RS_ALPHATESTENABLE] = 0;
    this.alphaTestState.states[this.RS_ALPHAREF] = -1;
    this.alphaTestState.states[this.RS_ALPHAFUNC] = this.CMP_GREATER;
    this.alphaTestState.states[this.RS_CLIPPING] = 0;
    this.alphaTestState.states[this.RS_CLIPPLANEENABLE] = 0;
    this.alphaTestState.dirty = false;

    this.alphaBlendState = {};
    this.alphaBlendState.states = {};
    this.alphaBlendState.states[this.RS_SRCBLEND] = this.BLEND_SRCALPHA;
    this.alphaBlendState.states[this.RS_DESTBLEND] = this.BLEND_INVSRCALPHA;
    this.alphaBlendState.states[this.RS_BLENDOP] = this.BLENDOP_ADD;
    this.alphaBlendState.states[this.RS_SEPARATEALPHABLENDENABLE] = 0;
    this.alphaBlendState.states[this.RS_BLENDOPALPHA] = this.BLENDOP_ADD;
    this.alphaBlendState.states[this.RS_SRCBLENDALPHA] = this.BLEND_SRCALPHA;
    this.alphaBlendState.states[this.RS_DESTBLENDALPHA] = this.BLEND_INVSRCALPHA;
    this.alphaBlendState.dirty = false;

    this.depthOffsetState = {};
    this.depthOffsetState.states = {};
    this.depthOffsetState.states[this.RS_SLOPESCALEDEPTHBIAS] = 0;
    this.depthOffsetState.states[this.RS_DEPTHBIAS] = 0;
    this.depthOffsetState.dirty = false;

    this.wrapModes = [];
    this.wrapModes[0] = 0;
    this.wrapModes[1] = this.gl.REPEAT;
    this.wrapModes[2] = this.gl.MIRRORED_REPEAT;
    this.wrapModes[3] = this.gl.CLAMP_TO_EDGE;
    this.wrapModes[4] = this.gl.CLAMP_TO_EDGE;
    this.wrapModes[5] = this.gl.CLAMP_TO_EDGE;

    this._shadowStateBuffer = new Float32Array(24);

    this._blendTable = [-1, // --
    this.gl.ZERO, // D3DBLEND_ZERO
    this.gl.ONE, // D3DBLEND_ONE
    this.gl.SRC_COLOR, // D3DBLEND_SRCCOLOR
    this.gl.ONE_MINUS_SRC_COLOR, // D3DBLEND_INVSRCCOLOR
    this.gl.SRC_ALPHA, // D3DBLEND_SRCALPHA
    this.gl.ONE_MINUS_SRC_ALPHA, // D3DBLEND_INVSRCALPHA
    this.gl.DST_ALPHA, // D3DBLEND_DESTALPHA
    this.gl.ONE_MINUS_DST_ALPHA, // D3DBLEND_INVDESTALPHA
    this.gl.DST_COLOR, // D3DBLEND_DESTCOLOR
    this.gl.ONE_MINUS_DST_COLOR, // D3DBLEND_INVDESTCOLOR
    this.gl.SRC_ALPHA_SATURATE, // D3DBLEND_SRCALPHASAT
    -1, // D3DBLEND_BOTHSRCALPHA
    -1, // D3DBLEND_BOTHINVSRCALPHA
    this.gl.CONSTANT_COLOR, // D3DBLEND_BLENDFACTOR
    this.gl.ONE_MINUS_CONSTANT_COLOR // D3DBLEND_INVBLENDFACTOR
    ];

    return this.glVersion;
};

/**
 * Schedule
 * @param render
 */
Tw2Device.prototype.Schedule = function (render) {
    this._scheduled[this._scheduled.length] = render;
};

/**
 * Handles resize events
 */
Tw2Device.prototype.Resize = function () {
    if (!this.canvas) return;

    if (this._onResize) this._onResize(this);else {
        this.canvas.width = this.canvas.clientWidth;
        this.canvas.height = this.canvas.clientHeight;
        this.viewportWidth = this.canvas.clientWidth;
        this.viewportHeight = this.canvas.clientHeight;
    }
    this.viewportAspect = this.viewportWidth / this.viewportHeight;
};

/**
 * Tick
 */
Tw2Device.prototype.Tick = function () {
    if (this.canvas.clientWidth !== this.viewportWidth || this.canvas.clientHeight !== this.viewportHeight) {
        this.Resize();
    }

    var now = this.Clock.now();
    this.currentTime = (now - this.startTime) * 0.001;
    this.dt = this.previousTime === null ? 0 : (now - this.previousTime) * 0.001;
    this.previousTime = now;

    var time = _Tw2VariableStore.store.GetVariable('Time').value;
    time[3] = time[0];
    time[0] = this.currentTime;
    time[1] = this.currentTime - Math.floor(this.currentTime);
    time[2] = this.frameCounter;

    var viewportSize = _Tw2VariableStore.store.GetVariable('ViewportSize').value;
    viewportSize[0] = this.viewportWidth;
    viewportSize[1] = this.viewportHeight;
    viewportSize[2] = this.viewportWidth;
    viewportSize[3] = this.viewportHeight;

    _Tw2ResMan.resMan.PrepareLoop(this.dt);

    for (var i = 0; i < this._scheduled.length; ++i) {
        if (!this._scheduled[i](this.dt)) {
            this._scheduled.splice(i, 1);
            --i;
        }
    }
    this.frameCounter++;
};

/**
 * Sets World transform matrix
 * @param {mat4} matrix
 */
Tw2Device.prototype.SetWorld = function (matrix) {
    _index.mat4.copy(this.world, matrix);
    //mat4.inverse(this.worldInverse, this.world);
};

/**
 * Sets view matrix
 * @param {mat4} matrix
 */
Tw2Device.prototype.SetView = function (matrix) {
    _index.mat4.copy(this.view, matrix);
    _index.mat4.invert(this.viewInverse, this.view);
    _index.mat4.transpose(this.viewTranspose, this.view);
    _index.mat4.getTranslation(this.eyePosition, this.viewInverse);
    this.UpdateViewProjection();
};

/**
 * Sets projection matrix
 *
 * @param {mat4} matrix
 * @param {boolean} [forceUpdateViewProjection]
 */
Tw2Device.prototype.SetProjection = function (matrix, forceUpdateViewProjection) {
    _index.mat4.copy(this.projection, matrix);
    _index.mat4.transpose(this.projectionTranspose, this.projection);
    _index.mat4.invert(this.projectionInverse, this.projection);
    this.GetTargetResolution(this.targetResolution);
    if (forceUpdateViewProjection) this.UpdateViewProjection();
};

/**
 * Updates the view projection matrix
 */
Tw2Device.prototype.UpdateViewProjection = function () {
    _index.mat4.multiply(this.viewProjection, this.projection, this.view);
    _index.mat4.transpose(this.viewProjectionTranspose, this.viewProjection);
    _index.mat4.copy(_Tw2VariableStore.store.GetVariable('ViewProjectionMat').value, this.viewProjection);
};
/**
 * Gets the device's target resolution
 * @param {vec4} out
 * @returns {vec4} out
 */
Tw2Device.prototype.GetTargetResolution = function (out) {
    var aspectRatio = this.projection[0] ? this.projection[5] / this.projection[0] : 0.0;
    var aspectAdjustment = 1.0;
    if (aspectRatio > 1.6) aspectAdjustment = aspectRatio / 1.6;
    var fov = 2.0 * Math.atan(aspectAdjustment / this.projection[5]);
    out[0] = this.viewportWidth;
    out[1] = this.viewportHeight;
    out[2] = fov;
    out[3] = fov * aspectRatio;
    return out;
};

/**
 * GetEyePosition
 * @return {vec3}
 */
Tw2Device.prototype.GetEyePosition = function () {
    return this.eyePosition;
};

/**
 * RenderFullScreenQuad
 * @param {Tw2Effect} effect
 */
Tw2Device.prototype.RenderFullScreenQuad = function (effect) {
    if (!effect) return;
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) return;

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._quadBuffer);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._quadDecl.SetDeclaration(effect.GetPassInput(pass), 24)) return;
        this.ApplyShadowState();
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
};

/**
 * Renders a Texture to the screen
 * @param texture
 */
Tw2Device.prototype.RenderTexture = function () {
    var blitEffect = null;
    return function RenderTexture(texture) {
        if (blitEffect === null) {
            blitEffect = new _Tw2Effect.Tw2Effect();
            blitEffect.effectFilePath = 'res:/graphics/effect/managed/space/system/blit.fx';
            var param = new _Tw2TextureParameter.Tw2TextureParameter();
            param.name = 'BlitSource';
            blitEffect.parameters[param.name] = param;
            blitEffect.Initialize();
        }
        blitEffect.parameters['BlitSource'].textureRes = texture;
        this.RenderFullScreenQuad(blitEffect);
    };
}();

/**
 * RenderCameraSpaceQuad
 * @param {Tw2Effect} effect
 */
Tw2Device.prototype.RenderCameraSpaceQuad = function (effect) {
    if (!effect) return;
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) return;

    var vertices = new Float32Array([1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0]);

    var projInv = this.projectionInverse;
    for (var i = 0; i < 4; ++i) {
        var vec = vertices.subarray(i * 6, i * 6 + 4);
        _index.vec4.transformMat4(vec, vec, projInv);
        _index.vec3.scale(vec, vec, 1 / vec[3]);
        vec[3] = 1;
    }

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._cameraQuadBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._quadDecl.SetDeclaration(effect.GetPassInput(pass), 24)) return;
        this.ApplyShadowState();
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
};

/**
 * Converts a Dword to Float
 * @param value
 * @return {Number}
 */
Tw2Device.prototype._DwordToFloat = function (value) {
    var b4 = value & 0xff;
    var b3 = (value & 0xff00) >> 8;
    var b2 = (value & 0xff0000) >> 16;
    var b1 = (value & 0xff000000) >> 24;
    var sign = 1 - 2 * (b1 >> 7); // sign = bit 0
    var exp = (b1 << 1 & 0xff | b2 >> 7) - 127; // exponent = bits 1..8
    var sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31
    if (sig === 0 && exp === -127) return 0.0;
    return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
};

/**
 * Returns whether or not Alpha Test is enabled
 * return {Boolean}
 */
Tw2Device.prototype.IsAlphaTestEnabled = function () {
    return this.alphaTestState.states[this.RS_ALPHATESTENABLE];
};

/**
 * Set a render state
 * @param state
 * @param value
 */
Tw2Device.prototype.SetRenderState = function (state, value) {
    this._currentRenderMode = this.RM_ANY;
    var gl = this.gl;
    switch (state) {
        case this.RS_ZENABLE:
            if (value) gl.enable(gl.DEPTH_TEST);else gl.disable(gl.DEPTH_TEST);
            return;

        case this.RS_ZWRITEENABLE:
            gl.depthMask(!!value);
            return;

        case this.RS_ALPHATESTENABLE:
        case this.RS_ALPHAREF:
        case this.RS_ALPHAFUNC:
        case this.RS_CLIPPING:
        case this.RS_CLIPPLANEENABLE:
            if (this.alphaTestState[state] !== value) {
                this.alphaTestState.states[state] = value;
                this.alphaTestState.dirty = true;
            }
            return;

        case this.RS_SRCBLEND:
        case this.RS_DESTBLEND:
        case this.RS_BLENDOP:
        case this.RS_SEPARATEALPHABLENDENABLE:
        case this.RS_BLENDOPALPHA:
        case this.RS_SRCBLENDALPHA:
        case this.RS_DESTBLENDALPHA:
            if (this.alphaBlendState[state] !== value) {
                this.alphaBlendState.states[state] = value;
                this.alphaBlendState.dirty = true;
            }
            return;

        case this.RS_CULLMODE:
            switch (value) {
                case this.CULL_NONE:
                    gl.disable(gl.CULL_FACE);
                    return;
                case this.CULL_CW:
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    return;
                case this.CULL_CCW:
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    return;
            }
            return;

        case this.RS_ZFUNC:
            gl.depthFunc(0x0200 + value - 1);
            return;

        case this.RS_ALPHABLENDENABLE:
            if (value) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);
            return;

        case this.RS_COLORWRITEENABLE:
            gl.colorMask((value & 1) !== 0, (value & 2) !== 0, (value & 4) !== 0, (value & 8) !== 0);
            return;

        case this.RS_SCISSORTESTENABLE:
            if (value) gl.enable(gl.SCISSOR_TEST);else gl.disable(gl.SCISSOR_TEST);
            return;

        case this.RS_SLOPESCALEDEPTHBIAS:
        case this.RS_DEPTHBIAS:
            value = this._DwordToFloat(value);
            if (this.depthOffsetState[state] !== value) {
                this.depthOffsetState.states[state] = value;
                this.depthOffsetState.dirty = true;
            }
            return;
    }
};

/**
 * ApplyShadowState
 */
Tw2Device.prototype.ApplyShadowState = function () {
    if (this.alphaBlendState.dirty) {
        var blendOp = this.gl.FUNC_ADD;
        if (this.alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_SUBTRACT) {
            blendOp = this.gl.FUNC_SUBTRACT;
        } else if (this.alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_REVSUBTRACT) {
            blendOp = this.gl.FUNC_REVERSE_SUBTRACT;
        }
        var srcBlend = this._blendTable[this.alphaBlendState.states[this.RS_SRCBLEND]];
        var destBlend = this._blendTable[this.alphaBlendState.states[this.RS_DESTBLEND]];

        if (this.alphaBlendState.states[this.RS_SEPARATEALPHABLENDENABLE]) {
            var blendOpAlpha = this.gl.FUNC_ADD;
            if (this.alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_SUBTRACT) {
                blendOpAlpha = this.gl.FUNC_SUBTRACT;
            } else if (this.alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_REVSUBTRACT) {
                blendOpAlpha = this.gl.FUNC_REVERSE_SUBTRACT;
            }
            var srcBlendAlpha = this._blendTable[this.alphaBlendState.states[this.RS_SRCBLENDALPHA]];
            var destBlendAlpha = this._blendTable[this.alphaBlendState.states[this.RS_DESTBLENDALPHA]];
            this.gl.blendEquationSeparate(blendOp, blendOpAlpha);
            this.gl.blendFuncSeparate(srcBlend, destBlend, srcBlendAlpha, destBlendAlpha);
        } else {
            this.gl.blendEquation(blendOp);
            this.gl.blendFunc(srcBlend, destBlend);
        }
        this.alphaBlendState.dirty = false;
    }
    if (this.depthOffsetState.dirty) {
        this.gl.polygonOffset(this.depthOffsetState.states[this.RS_SLOPESCALEDEPTHBIAS], this.depthOffsetState.states[this.RS_DEPTHBIAS]);
        this.depthOffsetState.dirty = false;
    }

    var alphaTestFunc, invertedAlphaTest, alphaTestRef;

    if (this.shadowHandles && this.alphaTestState.states[this.RS_ALPHATESTENABLE]) {
        switch (this.alphaTestState.states[this.RS_ALPHAFUNC]) {
            case this.CMP_NEVER:
                alphaTestFunc = 0;
                invertedAlphaTest = 1;
                alphaTestRef = -256;
                break;

            case this.CMP_LESS:
                alphaTestFunc = 0;
                invertedAlphaTest = -1;
                alphaTestRef = this.alphaTestState.states[this.RS_ALPHAREF] - 1;
                break;

            case this.CMP_EQUAL:
                alphaTestFunc = 1;
                invertedAlphaTest = 0;
                alphaTestRef = this.alphaTestState.states[this.RS_ALPHAREF];
                break;

            case this.CMP_LEQUAL:
                alphaTestFunc = 0;
                invertedAlphaTest = -1;
                alphaTestRef = this.alphaTestState.states[this.RS_ALPHAREF];
                break;

            case this.CMP_GREATER:
                alphaTestFunc = 0;
                invertedAlphaTest = 1;
                alphaTestRef = -this.alphaTestState.states[this.RS_ALPHAREF] - 1;
                break;

            /*case this.CMP_NOTEQUAL:
             var alphaTestFunc = 1;
             var invertedAlphaTest = 1;
             var alphaTestRef = this.alphaTestState.states[this.RS_ALPHAREF];
             break;*/

            case this.CMP_GREATEREQUAL:
                alphaTestFunc = 0;
                invertedAlphaTest = 1;
                alphaTestRef = -this.alphaTestState.states[this.RS_ALPHAREF];
                break;

            default:
                alphaTestFunc = 0;
                invertedAlphaTest = 0;
                alphaTestRef = 1;
                break;
        }

        var clipPlaneEnable = 0;
        this.gl.uniform4f(this.shadowHandles.shadowStateInt, invertedAlphaTest, alphaTestRef, alphaTestFunc, clipPlaneEnable);
        //this._shadowStateBuffers
    }
};

/**
 * Sets a render mode
 * @param {number} renderMode
 */
Tw2Device.prototype.SetStandardStates = function (renderMode) {
    if (this._currentRenderMode === renderMode) return;

    this.gl.frontFace(this.gl.CW);
    switch (renderMode) {
        case this.RM_OPAQUE:
        case this.RM_PICKABLE:
            this.SetRenderState(this.RS_ZENABLE, true);
            this.SetRenderState(this.RS_ZWRITEENABLE, true);
            this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
            this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
            this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_ALPHATESTENABLE, false);
            this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
            this.SetRenderState(this.RS_DEPTHBIAS, 0);
            this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
            break;

        case this.RM_DECAL:
            this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_ALPHATESTENABLE, true);
            this.SetRenderState(this.RS_ALPHAFUNC, this.CMP_GREATER);
            this.SetRenderState(this.RS_ALPHAREF, 127);
            this.SetRenderState(this.RS_ZENABLE, true);
            this.SetRenderState(this.RS_ZWRITEENABLE, true);
            this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
            this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
            this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
            this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
            this.SetRenderState(this.RS_DEPTHBIAS, 0);
            this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
            break;

        case this.RM_TRANSPARENT:
            this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
            this.SetRenderState(this.RS_ALPHABLENDENABLE, true);
            this.SetRenderState(this.RS_SRCBLEND, this.BLEND_SRCALPHA);
            this.SetRenderState(this.RS_DESTBLEND, this.BLEND_INVSRCALPHA);
            this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
            this.SetRenderState(this.RS_ZENABLE, true);
            this.SetRenderState(this.RS_ZWRITEENABLE, false);
            this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
            this.SetRenderState(this.RS_ALPHATESTENABLE, false);
            this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0); // -1.0
            this.SetRenderState(this.RS_DEPTHBIAS, 0);
            this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
            break;

        case this.RM_ADDITIVE:
            this.SetRenderState(this.RS_CULLMODE, this.CULL_NONE);
            this.SetRenderState(this.RS_ALPHABLENDENABLE, true);
            this.SetRenderState(this.RS_SRCBLEND, this.BLEND_ONE);
            this.SetRenderState(this.RS_DESTBLEND, this.BLEND_ONE);
            this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
            this.SetRenderState(this.RS_ZENABLE, true);
            this.SetRenderState(this.RS_ZWRITEENABLE, false);
            this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
            this.SetRenderState(this.RS_ALPHATESTENABLE, false);
            this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
            this.SetRenderState(this.RS_DEPTHBIAS, 0);
            this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
            break;

        case this.RM_FULLSCREEN:
            this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_ALPHATESTENABLE, false);
            this.SetRenderState(this.RS_CULLMODE, this.CULL_NONE);
            this.SetRenderState(this.RS_ZENABLE, false);
            this.SetRenderState(this.RS_ZWRITEENABLE, false);
            this.SetRenderState(this.RS_ZFUNC, this.CMP_ALWAYS);
            this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
            this.SetRenderState(this.RS_DEPTHBIAS, 0);
            this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
            this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
            break;

        default:
            return;
    }
    this._currentRenderMode = renderMode;
};

/**
 * Gets a fallback texture
 * @returns {*}
 */
Tw2Device.prototype.GetFallbackTexture = function () {
    var whiteTexture = null;
    return function GetFallbackTexture() {
        if (whiteTexture === null) {
            whiteTexture = this.CreateSolidTexture([0, 0, 0, 0]);
        }
        return whiteTexture;
    };
}();

/**
 * Gets a fallback cube map
 * @returns {*}
 */
Tw2Device.prototype.GetFallbackCubeMap = function () {
    var whiteCube = null;
    return function GetFallbackCubeMap() {
        if (whiteCube === null) {
            whiteCube = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, whiteCube);
            for (var j = 0; j < 6; ++j) {
                this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));
            }
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            //this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);
        }
        return whiteCube;
    };
}();

/**
 * Checks if a frame buffer is complete
 *
 * @param frameBuffer
 * @returns {boolean}
 */
Tw2Device.prototype.IsFrameBufferComplete = function (frameBuffer) {
    return this.gl.checkFramebufferStatus(frameBuffer) === this.gl.FRAMEBUFFER_COMPLETE;
};

/**
 * Gets a gl extension
 * @param {string} extension - The gl extension name
 * @returns{*}
 */
Tw2Device.prototype.GetExtension = function (extension) {
    for (var prefix in Tw2Device.WebglVendorPrefixes) {
        if (Tw2Device.WebglVendorPrefixes.hasOwnProperty(prefix)) {
            var ext = this.gl.getExtension(Tw2Device.WebglVendorPrefixes[prefix] + extension);
            if (ext) return ext;
        }
    }

    return null;
};

/**
 * Creates a solid colored texture
 * @param {vec4|Array} [rgba] - The colour to create, if obmitted defaults to completely transparent
 * @returns {WebGLTexture}
 */
Tw2Device.prototype.CreateSolidTexture = function (rgba) {
    rgba = rgba || [0, 0, 0, 0];
    var texture = this.gl.createTexture();
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array(rgba));
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return texture;
};

/**
 * Device clock
 * - Todo: Add performance timing (Currently doesn't work with boosterSets)
 */
Tw2Device.prototype.Clock = Date; //window['performance'] && window['performance'].now ? window['performance'] : Date;

var timeOuts;

/**
 * Requests and animation frame
 * @param {Function} callback
 * @param {HTMLElement} element
 * @returns {number} id
 */
Tw2Device.prototype.RequestAnimationFrame = function () {
    var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback, /* DOMElement Element */element) {
        if (!timeOuts) timeOuts = [];
        timeOuts.push(window.setTimeout(callback, 1000 / 60));
        return timeOuts.length - 1;
    };

    return function RequestAnimationFrame(callback, element) {
        return requestFrame(callback, element);
    };
}();

/**
 * Cancels an animation frame by it's id
 * @param {number} id
 */
Tw2Device.prototype.CancelAnimationFrame = function () {
    var cancelFrame = window.cancelAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (id) {
        if (!timeOuts) timeOuts = [];
        if (timeOuts[id] !== undefined) {
            window.clearTimeout(timeOuts[id]);
            timeOuts[id] = undefined;
            return true;
        }
    };

    return function CancelAnimationFrame(id) {
        cancelFrame(id);
    };
}();

/**
 * Creates a gl context
 *
 * @param {HTMLCanvasElement} canvas
 * @param {*} [params]
 * @param {*} [contextNames]
 * @returns {*}
 */
Tw2Device.CreateContext = function (canvas, params, contextNames) {
    contextNames = Array.isArray(contextNames) ? contextNames : [contextNames];
    for (var i = 0; i < contextNames.length; i++) {
        try {
            return canvas.getContext(contextNames[i], params);
        } catch (err) {}
    }
    return null;
};

// Webgl details
Tw2Device.WebglVendorPrefixes = ['', 'MOZ_', 'WEBKIT_', 'WEBGL_'];
Tw2Device.WebglContextNames = ['webgl', 'experimental-webgl'];
Tw2Device.Webgl2ContextNames = ['webgl2', 'experimental-webgl2'];
Tw2Device.WebglVersion = {
    NONE: 0,
    WEBGL: 1,
    WEBGL2: 2
};

// Render Modes
Tw2Device.prototype.RM_ANY = -1;
Tw2Device.prototype.RM_OPAQUE = 0;
Tw2Device.prototype.RM_DECAL = 1;
Tw2Device.prototype.RM_TRANSPARENT = 2;
Tw2Device.prototype.RM_ADDITIVE = 3;
Tw2Device.prototype.RM_DEPTH = 4;
Tw2Device.prototype.RM_FULLSCREEN = 5;
Tw2Device.prototype.RM_PICKABLE = 6;

// Render States
Tw2Device.prototype.RS_ZENABLE = 7; // D3DZBUFFERTYPE (or TRUE/FALSE for legacy)
Tw2Device.prototype.RS_FILLMODE = 8; // D3DFILLMODE
Tw2Device.prototype.RS_SHADEMODE = 9; // D3DSHADEMODE
Tw2Device.prototype.RS_ZWRITEENABLE = 14; // TRUE to enable z writes
Tw2Device.prototype.RS_ALPHATESTENABLE = 15; // TRUE to enable alpha tests
Tw2Device.prototype.RS_LASTPIXEL = 16; // TRUE for last-pixel on lines
Tw2Device.prototype.RS_SRCBLEND = 19; // D3DBLEND
Tw2Device.prototype.RS_DESTBLEND = 20; // D3DBLEND
Tw2Device.prototype.RS_CULLMODE = 22; // D3DCULL
Tw2Device.prototype.RS_ZFUNC = 23; // D3DCMPFUNC
Tw2Device.prototype.RS_ALPHAREF = 24; // D3DFIXED
Tw2Device.prototype.RS_ALPHAFUNC = 25; // D3DCMPFUNC
Tw2Device.prototype.RS_DITHERENABLE = 26; // TRUE to enable dithering
Tw2Device.prototype.RS_ALPHABLENDENABLE = 27; // TRUE to enable alpha blending
Tw2Device.prototype.RS_FOGENABLE = 28; // TRUE to enable fog blending
Tw2Device.prototype.RS_SPECULARENABLE = 29; // TRUE to enable specular
Tw2Device.prototype.RS_FOGCOLOR = 34; // D3DCOLOR
Tw2Device.prototype.RS_FOGTABLEMODE = 35; // D3DFOGMODE
Tw2Device.prototype.RS_FOGSTART = 36; // Fog start (for both vertex and pixel fog)
Tw2Device.prototype.RS_FOGEND = 37; // Fog end
Tw2Device.prototype.RS_FOGDENSITY = 38; // Fog density
Tw2Device.prototype.RS_RANGEFOGENABLE = 48; // Enables range-based fog
Tw2Device.prototype.RS_STENCILENABLE = 52; // BOOL enable/disable stenciling
Tw2Device.prototype.RS_STENCILFAIL = 53; // D3DSTENCILOP to do if stencil test fails
Tw2Device.prototype.RS_STENCILZFAIL = 54; // D3DSTENCILOP to do if stencil test passes and Z test fails
Tw2Device.prototype.RS_STENCILPASS = 55; // D3DSTENCILOP to do if both stencil and Z tests pass
Tw2Device.prototype.RS_STENCILFUNC = 56; // D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
Tw2Device.prototype.RS_STENCILREF = 57; // Reference value used in stencil test
Tw2Device.prototype.RS_STENCILMASK = 58; // Mask value used in stencil test
Tw2Device.prototype.RS_STENCILWRITEMASK = 59; // Write mask applied to values written to stencil buffer
Tw2Device.prototype.RS_TEXTUREFACTOR = 60; // D3DCOLOR used for multi-texture blend
Tw2Device.prototype.RS_WRAP0 = 128; // wrap for 1st texture coord. set
Tw2Device.prototype.RS_WRAP1 = 129; // wrap for 2nd texture coord. set
Tw2Device.prototype.RS_WRAP2 = 130; // wrap for 3rd texture coord. set
Tw2Device.prototype.RS_WRAP3 = 131; // wrap for 4th texture coord. set
Tw2Device.prototype.RS_WRAP4 = 132; // wrap for 5th texture coord. set
Tw2Device.prototype.RS_WRAP5 = 133; // wrap for 6th texture coord. set
Tw2Device.prototype.RS_WRAP6 = 134; // wrap for 7th texture coord. set
Tw2Device.prototype.RS_WRAP7 = 135; // wrap for 8th texture coord. set
Tw2Device.prototype.RS_CLIPPING = 136;
Tw2Device.prototype.RS_LIGHTING = 137;
Tw2Device.prototype.RS_AMBIENT = 139;
Tw2Device.prototype.RS_FOGVERTEXMODE = 140;
Tw2Device.prototype.RS_COLORVERTEX = 141;
Tw2Device.prototype.RS_LOCALVIEWER = 142;
Tw2Device.prototype.RS_NORMALIZENORMALS = 143;
Tw2Device.prototype.RS_DIFFUSEMATERIALSOURCE = 145;
Tw2Device.prototype.RS_SPECULARMATERIALSOURCE = 146;
Tw2Device.prototype.RS_AMBIENTMATERIALSOURCE = 147;
Tw2Device.prototype.RS_EMISSIVEMATERIALSOURCE = 148;
Tw2Device.prototype.RS_VERTEXBLEND = 151;
Tw2Device.prototype.RS_CLIPPLANEENABLE = 152;
Tw2Device.prototype.RS_POINTSIZE = 154; // float point size
Tw2Device.prototype.RS_POINTSIZE_MIN = 155; // float point size min threshold
Tw2Device.prototype.RS_POINTSPRITEENABLE = 156; // BOOL point texture coord control
Tw2Device.prototype.RS_POINTSCALEENABLE = 157; // BOOL point size scale enable
Tw2Device.prototype.RS_POINTSCALE_A = 158; // float point attenuation A value
Tw2Device.prototype.RS_POINTSCALE_B = 159; // float point attenuation B value
Tw2Device.prototype.RS_POINTSCALE_C = 160; // float point attenuation C value
Tw2Device.prototype.RS_MULTISAMPLEANTIALIAS = 161; // BOOL - set to do FSAA with multisample buffer
Tw2Device.prototype.RS_MULTISAMPLEMASK = 162; // DWORD - per-sample enable/disable
Tw2Device.prototype.RS_PATCHEDGESTYLE = 163; // Sets whether patch edges will use float style tessellation
Tw2Device.prototype.RS_DEBUGMONITORTOKEN = 165; // DEBUG ONLY - token to debug monitor
Tw2Device.prototype.RS_POINTSIZE_MAX = 166;
// float point size max threshold
Tw2Device.prototype.RS_INDEXEDVERTEXBLENDENABLE = 167;
Tw2Device.prototype.RS_COLORWRITEENABLE = 168; // per-channel write enable
Tw2Device.prototype.RS_TWEENFACTOR = 170; // float tween factor
Tw2Device.prototype.RS_BLENDOP = 171; // D3DBLENDOP setting
Tw2Device.prototype.RS_POSITIONDEGREE = 172; // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
Tw2Device.prototype.RS_NORMALDEGREE = 173; // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
Tw2Device.prototype.RS_SCISSORTESTENABLE = 174;
Tw2Device.prototype.RS_SLOPESCALEDEPTHBIAS = 175;
Tw2Device.prototype.RS_ANTIALIASEDLINEENABLE = 176;
Tw2Device.prototype.RS_TWOSIDEDSTENCILMODE = 185; // BOOL enable/disable 2 sided stenciling
Tw2Device.prototype.RS_CCW_STENCILFAIL = 186; // D3DSTENCILOP to do if ccw stencil test fails
Tw2Device.prototype.RS_CCW_STENCILZFAIL = 187; // D3DSTENCILOP to do if ccw stencil test passes and Z test fails
Tw2Device.prototype.RS_CCW_STENCILPASS = 188; // D3DSTENCILOP to do if both ccw stencil and Z tests pass
Tw2Device.prototype.RS_CCW_STENCILFUNC = 189; // D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
Tw2Device.prototype.RS_COLORWRITEENABLE1 = 190; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_COLORWRITEENABLE2 = 191; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_COLORWRITEENABLE3 = 192; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_BLENDFACTOR = 193; // D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR
Tw2Device.prototype.RS_SRGBWRITEENABLE = 194; // Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE)
Tw2Device.prototype.RS_DEPTHBIAS = 195;
Tw2Device.prototype.RS_SEPARATEALPHABLENDENABLE = 206; // TRUE to enable a separate blending function for the alpha channel
Tw2Device.prototype.RS_SRCBLENDALPHA = 207; // SRC blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE
Tw2Device.prototype.RS_DESTBLENDALPHA = 208; // DST blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE
Tw2Device.prototype.RS_BLENDOPALPHA = 209; // Blending operation for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE */// Cull Modes
Tw2Device.prototype.CULL_NONE = 1;
Tw2Device.prototype.CULL_CW = 2;
Tw2Device.prototype.CULL_CCW = 3;
// Compare
Tw2Device.prototype.CMP_NEVER = 1;
Tw2Device.prototype.CMP_LESS = 2;
Tw2Device.prototype.CMP_EQUAL = 3;
Tw2Device.prototype.CMP_LEQUAL = 4;
Tw2Device.prototype.CMP_GREATER = 5;
Tw2Device.prototype.CMP_NOTEQUAL = 6;
Tw2Device.prototype.CMP_GREATEREQUAL = 7;
Tw2Device.prototype.CMP_ALWAYS = 8;
// Blend
Tw2Device.prototype.BLEND_ZERO = 1;
Tw2Device.prototype.BLEND_ONE = 2;
Tw2Device.prototype.BLEND_SRCCOLOR = 3;
Tw2Device.prototype.BLEND_INVSRCCOLOR = 4;
Tw2Device.prototype.BLEND_SRCALPHA = 5;
Tw2Device.prototype.BLEND_INVSRCALPHA = 6;
Tw2Device.prototype.BLEND_DESTALPHA = 7;
Tw2Device.prototype.BLEND_INVDESTALPHA = 8;
Tw2Device.prototype.BLEND_DESTCOLOR = 9;
Tw2Device.prototype.BLEND_INVDESTCOLOR = 10;
Tw2Device.prototype.BLEND_SRCALPHASAT = 11;
Tw2Device.prototype.BLEND_BOTHSRCALPHA = 12;
Tw2Device.prototype.BLEND_BOTHINVSRCALPHA = 13;
Tw2Device.prototype.BLEND_BLENDFACTOR = 14;
Tw2Device.prototype.BLEND_INVBLENDFACTOR = 15;
// Blend Operations
Tw2Device.prototype.BLENDOP_ADD = 1;
Tw2Device.prototype.BLENDOP_SUBTRACT = 2;
Tw2Device.prototype.BLENDOP_REVSUBTRACT = 3;
Tw2Device.prototype.BLENDOP_MIN = 4;
Tw2Device.prototype.BLENDOP_MAX = 5;

var device = exports.device = new Tw2Device();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Curve = exports.Tw2CurveKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint no-unused-vars:0 */


/**
 * Tw2CurveKey base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {number} time
 * @class
 */
var Tw2CurveKey = exports.Tw2CurveKey = function Tw2CurveKey() {
    _classCallCheck(this, Tw2CurveKey);

    this._id = _math.util.generateID();
    this.name = '';
    this.time = 0;
};

/**
 * Tw2Curve base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @class
 */


var Tw2Curve = exports.Tw2Curve = function () {
    function Tw2Curve() {
        _classCallCheck(this, Tw2Curve);

        this._id = _math.util.generateID();
        this.name = '';
    }

    /**
     * Initializes the Curve
     */


    _createClass(Tw2Curve, [{
        key: 'Initialize',
        value: function Initialize() {
            this.Sort();
        }

        /**
         * Sorts the curve
         */

    }, {
        key: 'Sort',
        value: function Sort() {}

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return 0;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {}

        /**
         * Compares curve keys
         * @param {Tw2CurveKey} a
         * @param {Tw2CurveKey} b
         * @returns {number}
         */

    }], [{
        key: 'Compare',
        value: function Compare(a, b) {
            if (a.time < b.time) return -1;
            if (a.time > b.time) return 1;
            return 0;
        }

        /**
         * Sorts legacy curve keys
         * @param {*} curve
         * @param {Array.<Tw2CurveKey>} [keys=curve.keys] - Optional keys override
         */

    }, {
        key: 'Sort',
        value: function Sort(curve) {
            var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : curve.keys;

            if (keys && keys.length) {
                keys.sort(Tw2Curve.Compare);
                curve.length = keys[keys.length - 1].time;
            }
        }

        /**
         * Sorts curve keys
         * @param {*} curve
         */

    }, {
        key: 'Sort2',
        value: function Sort2(curve) {
            if (curve.keys && curve.keys.length) {
                curve.keys.sort(Tw2Curve.Compare);
                var back = curve.keys[curve.keys.length - 1];

                if (back.time > curve.length) {
                    var preLength = curve.length,
                        endValue = curve.endValue,
                        endTangent = curve.endTangent;

                    curve.length = back.time;
                    curve.endValue = back.value;
                    curve.endTangent = back.leftTangent;

                    if (preLength > 0) {
                        back.time = preLength;
                        back.value = endValue;
                        back.leftTangent = endTangent;
                    }
                }
            }
        }
    }]);

    return Tw2Curve;
}();

/**
 * The curve's key dimension
 * @type {?number}
 */


Tw2Curve.inputDimension = null;

/**
 * The curve's dimension
 * @type {?number}
 */
Tw2Curve.outputDimension = null;

/**
 * The curve's current value property
 * @type {?string}
 */
Tw2Curve.valueProperty = null;

/**
 * The curve's type
 * @type {?number}
 */
Tw2Curve.curveType = null;

/**
 * The curve's Key constructor
 * @type {?Tw2CurveKey}
 */
Tw2Curve.Key = null;

/**
 * Interpolation types
 * @type {?{ string: number}}
 */
Tw2Curve.Interpolation = null;

/**
 * Extrapolation types
 * @type {?{ string: number}}
 */
Tw2Curve.Extrapolation = null;

/**
 * Curve types
 * @type {{CURVE: number, CURVE2: number, CURVE_MAYA: number, SEQUENCER: number, SEQUENCER2: number}}
 */
Tw2Curve.Type = {
    CURVE: 1,
    CURVE2: 2,
    CURVE_MAYA: 3,
    CURVE_NO_KEYS: 4,
    SEQUENCER: 100,
    SEQUENCER2: 101
};

/**
 * Class globals
 * @type {*}
 */
Tw2Curve.global = {
    vec3_0: _math.vec3.create(),
    vec4_0: _math.vec4.create(),
    quat_0: _math.quat.create(),
    quat_1: _math.quat.create()
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resMan = exports.Tw2LoadingObject = undefined;

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2Resource2 = __webpack_require__(11);

var _Tw2ObjectReader = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Manages loaded resources
 * @property {Object} _loadedObjects
 * @constructor
 */
function Tw2MotherLode() {
    this._loadedObjects = {};

    /**
     * Finds a loaded object by it's file path
     * @param {string} path
     * @returns {Tw2LoadingObject}
     */
    this.Find = function (path) {
        if (path in this._loadedObjects) {
            return this._loadedObjects[path];
        }
        return null;
    };

    /**
     * Adds a loaded object
     * @param {string} path
     * @param {Tw2LoadingObject} obj
     */
    this.Add = function (path, obj) {
        this._loadedObjects[path] = obj;
    };

    /**
     * Removes a loaded object by it's file path
     * @param {string} path
     */
    this.Remove = function (path) {
        delete this._loadedObjects[path];
    };

    /**
     * Clears the loaded object object
     */
    this.Clear = function () {
        this._loadedObjects = {};
    };

    /**
     * Unloads all loaded objects and then clears the loadedObject object
     */
    this.UnloadAndClear = function () {
        for (var path in this._loadedObjects) {
            if (this._loadedObjects.hasOwnProperty(path)) {
                this._loadedObjects[path].Unload();
            }
        }
        this._loadedObjects = {};
    };

    /**
     * Purges inactive loaded objects (resources that have been loaded but are not being actively used)
     * - Loaded objects can flagged with `doNotPurge` to ensure they are never removed
     * - Resource auto purging can be managed in `ccpwgl` or `ccpwgl_int.resMan` - {@link Tw2ResMan}
     *     ccpwgl.setResourceUnloadPolicy()
     *     ccpwgl_int.resMan.autoPurgeResources=true
     *     ccpwgl_int.resMan.purgeTime=30
     * @param {Number} curFrame - the current frame count
     * @param {Number} frameLimit - how many frames the object can stay alive for before being purged
     * @param {Number} frameDistance - how long the resource has been alive for
     */
    this.PurgeInactive = function (curFrame, frameLimit, frameDistance) {
        for (var path in this._loadedObjects) {
            if (this._loadedObjects.hasOwnProperty(path)) {
                var obj = this._loadedObjects[path];
                if (!obj.doNotPurge) {
                    if (obj._isPurged) {
                        _Tw2EventEmitter.emitter.log('res.event', {
                            msg: 'Unloaded  ',
                            path: obj.path,
                            type: 'purged'
                        });

                        delete this._loadedObjects[path];
                    }
                    if (obj._isGood && (curFrame - obj.activeFrame) % frameLimit >= frameDistance) {
                        if (obj.Unload()) {
                            _Tw2EventEmitter.emitter.log('res.event', {
                                msg: 'Unloaded  ',
                                path: obj.path,
                                type: 'unused'
                            });
                            delete this._loadedObjects[path];
                        }
                    }
                }
            }
        }
    };
}

/**
 * Tw2LoadingObject
 * @property {object} object
 * @property {string} _redContents - object's .red file xml contents
 * @property {Number} _inPrepare
 * @property {Array.<Object>} _objects
 * @property {Tw2ObjectReader} _constructor
 * @property {function} _constructorFunction - The constructor used to create the object once it's red contents have loaded
 * @inherit Tw2Resource
 * @class
 */

var Tw2LoadingObject = exports.Tw2LoadingObject = function (_Tw2Resource) {
    _inherits(Tw2LoadingObject, _Tw2Resource);

    function Tw2LoadingObject() {
        _classCallCheck(this, Tw2LoadingObject);

        var _this = _possibleConstructorReturn(this, (Tw2LoadingObject.__proto__ || Object.getPrototypeOf(Tw2LoadingObject)).call(this));

        _this.object = null;
        _this._redContents = null;
        _this._inPrepare = null;
        _this._objects = [];
        _this._constructor = null;
        _this._constructorFunction = null;
        return _this;
    }

    return Tw2LoadingObject;
}(_Tw2Resource2.Tw2Resource);

/**
 * AddObject
 * @param {Object} object
 * @param {Function} callback
 * @param {Boolean} initialize
 * @returns {Boolean}
 */


Tw2LoadingObject.prototype.AddObject = function (object, callback, initialize) {
    object._loadCallback = callback;
    object._initialize = initialize;
    this._objects.push(object);
    return false;
};

/**
 * Prepare
 * @param text
 */
Tw2LoadingObject.prototype.Prepare = function (text) {
    if (text === null) {
        _Tw2EventEmitter.emitter.log('res.error', {
            log: 'error',
            src: ['Tw2LoadingObject', 'Prepare'],
            msg: 'Invalid XML',
            path: this.path,
            type: 'xml.invalid'
        });
        this.PrepareFinished(false);
        return;
    }

    if (this._inPrepare === null) {
        this._redContents = text;
        this._constructor = new _Tw2ObjectReader.Tw2ObjectReader(this._redContents);
        this._constructorFunction = null;
        this._inPrepare = 0;
    }

    while (this._inPrepare < this._objects.length) {
        try {
            this._objects[this._inPrepare]._loadCallback(this._constructor.Construct());
        } catch (e) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2LoadingObject', 'Prepare'],
                msg: 'Error preparing resource',
                path: this.path,
                type: 'prepare',
                err: e
            });
        }

        this._inPrepare++;
    }

    resMan.motherLode.Remove(this.path);

    _Tw2EventEmitter.emitter.log('res.event', {
        msg: 'Prepared  ',
        path: this.path,
        type: 'prepared'
    });

    this.PrepareFinished(true);
};

/**
 * Resource Manager
 * @property {Boolean} systemMirror - Toggles whether {@link GeometryResource} Index and Buffer data arrays are visible
 * @property {Object.<string, string>} resourcePaths
 * @property {Object} resourcePaths.res - Default resource path for current ccpwgl version
 * @property {Object.<string, Function>} _extensions - an object of registered extensions and their constructors
 * @property {Tw2MotherLode} motherLode
 * @property {Number} maxPrepareTime
 * @property {Number} prepareBudget
 * @property {Array} _prepareQueue
 * @property {Boolean} autoPurgeResources=true - Sets whether resources should be purged automatically
 * @property {Number} purgeTime=30 = Sets how long resources can remain inactive before they are purged
 * @property {Number} activeFrame
 * @property {Number} _purgeTime
 * @property {Number} _purgeFrame
 * @property {Number} _purgeFrameLimit
 * @property {Number} _pendingLoads - a count of how many things are pending load
 * @property {Number} _noLoadFrames
 * @constructor
 */
function Tw2ResMan() {
    this.motherLode = new Tw2MotherLode();

    this.systemMirror = false;
    this.maxPrepareTime = 0.05;
    this.prepareBudget = 0;
    this.autoPurgeResources = true;
    this.activeFrame = 0;
    this.purgeTime = 30;

    this._extensions = {};
    this._resourcePaths = {};
    this._constructors = {};
    this._missingConstructors = [];

    this._prepareQueue = [];
    this._purgeTime = 0;
    this._purgeFrame = 0;
    this._purgeFrameLimit = 1000;
    this._pendingLoads = 0;
    this._noLoadFrames = 0;

    /**
     * IsLoading
     * @returns {Boolean}
     *
     */
    this.IsLoading = function () {
        return this._noLoadFrames < 2;
    };

    /**
     * Creates an Http request
     * @returns {XMLHttpRequest|ActiveXObject}
     * @private
     */
    this._CreateHttpRequest = function () {
        var httpRequest = null;

        if (window.XMLHttpRequest) {
            // Mozilla, Safari, ...
            httpRequest = new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            // IE
            try {
                httpRequest = new window['ActiveXObject']('Msxml2.XMLHTTP');
            } catch (e) {
                try {
                    httpRequest = new window['ActiveXObject']('Microsoft.XMLHTTP');
                } catch (e) {}
            }
        }

        if (!httpRequest) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2LoadingObject', 'Prepare'],
                msg: 'Could not create an XMLHTTP instance',
                type: 'http.instance'
            });
        }
        return httpRequest;
    };

    /**
     * Normalizes a file path by making it lower case and replaces all '\\' with '/'
     * @param {string} path
     * @returns {string}
     * @private
     */
    function _NormalizePath(path) {
        if (path.substr(0, 5) === 'str:/') {
            return path;
        }
        path = path.toLowerCase();
        path.replace('\\', '/');
        return path;
    }

    /**
     * _GetPathExt
     * @param path
     * @returns {string}
     * @private
     */
    function _GetPathExt(path) {
        if (path.substr(0, 5) === 'str:/') {
            var slash = path.indexOf('/', 5);
            if (slash === -1) {
                return null;
            }
            return path.substr(5, slash - 5);
        } else {
            var dot = path.lastIndexOf('.');
            if (dot === -1) {
                return null;
            }
            return path.substr(dot + 1);
        }
    }

    /**
     * Returns a path suitable for logging by truncating really long file names
     * @param {string} path
     * @returns {string}
     */
    this.LogPathString = function (path) {
        if (path.substr(0, 5) === 'str:/' && path.length > 64) {
            return path.substr(0, 64) + '...';
        }
        return path;
    };

    /**
     * Internal update function. It is called every frame.
     * @param {Number} dt - deltaTime
     * @returns {Boolean}
     */
    this.PrepareLoop = function (dt) {
        if (this._prepareQueue.length === 0 && this._pendingLoads === 0) {
            if (this._noLoadFrames < 2) {
                this._noLoadFrames++;
            }
        } else {
            this._noLoadFrames = 0;
        }

        resMan.prepareBudget = resMan.maxPrepareTime;

        var startTime = Date.now();
        var now;

        while (resMan._prepareQueue.length) {
            try {
                var result = resMan._prepareQueue[0][0].Prepare(resMan._prepareQueue[0][1], resMan._prepareQueue[0][2]);
            } catch (e) {
                resMan._prepareQueue.shift();
                throw e;
            }
            if (!result) {
                now = Date.now();

                _Tw2EventEmitter.emitter.log('res.event', {
                    msg: 'Prepared  ',
                    path: resMan._prepareQueue[0][0].path,
                    time: (now - startTime) * 0.001,
                    type: 'prepared'
                });

                resMan._prepareQueue.shift();
            }

            now = Date.now();
            resMan.prepareBudget -= (now - startTime) * 0.001;

            if (resMan.prepareBudget < 0) {
                break;
            }
        }

        this._purgeTime += dt;

        if (this._purgeTime > 1) {
            this.activeFrame += 1;
            this._purgeTime -= Math.floor(this._purgeTime);
            this._purgeFrame += 1;

            if (this._purgeFrame >= 5) {
                if (this.autoPurgeResources) {
                    this.motherLode.PurgeInactive(this._purgeFrame, this._purgeFrameLimit, this.purgeTime);
                }
            }
        }

        return true;
    };

    /**
     * _DoLoadResource
     * @param obj
     * @private
     */
    function _DoLoadResource(obj) {
        return function () {
            var readyState = 0;

            try {
                readyState = this.readyState;
            } catch (e) {
                _Tw2EventEmitter.emitter.log('res.error', {
                    log: 'error',
                    src: ['Tw2ResMan', '_DoLoadResource'],
                    msg: 'Communication error loading',
                    path: obj.path,
                    type: 'http.readystate',
                    value: readyState
                });

                obj.LoadFinished(false);
                resMan._pendingLoads--;
                return;
            }

            if (readyState === 4) {
                if (this.status === 200) {
                    obj.LoadFinished(true);
                    var data = null;
                    var xml = null;

                    try {
                        data = this.responseText;
                        xml = this.responseXML;
                    } catch (e) {
                        data = this.response;
                    }

                    resMan._prepareQueue.push([obj, data, xml]);
                } else {
                    _Tw2EventEmitter.emitter.log('res.error', {
                        log: 'error',
                        src: ['Tw2ResMan', '_DoLoadResource'],
                        msg: 'Communication error loading',
                        path: obj.path,
                        type: 'http.status',
                        value: this.status
                    });
                    obj.LoadFinished(false);
                }
                resMan._pendingLoads--;
            }
        };
    }

    /**
     * Builds a url from a resource path
     * - the prefix in the resource path is replaced with it's string value from `this._resourcePaths`
     * @param {string} resPath
     * @returns {string}
     */
    this.BuildUrl = function (resPath) {
        var prefixIndex = resPath.indexOf(':/');
        if (prefixIndex === -1) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'warn',
                src: ['Tw2ResMan', 'BuildUrl'],
                msg: 'Invalid path',
                type: 'prefix.undefined',
                path: resPath
            });
            return resPath;
        }

        var prefix = resPath.substr(0, prefixIndex);

        if (!(prefix in this._resourcePaths)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'warn',
                src: ['Tw2ResMan', 'BuildUrl'],
                msg: 'Unregistered path',
                path: resPath,
                type: 'prefix.unregistered',
                value: prefix
            });
            return resPath;
        }

        return this._resourcePaths[prefix] + resPath.substr(prefixIndex + 2);
    };

    /**
     * _LoadResource
     * @param obj
     * @returns {*}
     * @private
     */
    this._LoadResource = function (obj) {
        obj._isPurged = false;
        var path = obj.path;
        this.motherLode.Add(path, obj);

        if ('DoCustomLoad' in obj && obj.DoCustomLoad(path)) {
            return obj;
        }

        var httpRequest = this._CreateHttpRequest();
        httpRequest.onreadystatechange = _DoLoadResource(obj);

        _Tw2EventEmitter.emitter.log('res.event', {
            msg: 'Requesting',
            path: path,
            type: 'request'
        });

        httpRequest.open('GET', this.BuildUrl(path));

        if (obj.requestResponseType) {
            httpRequest.responseType = obj.requestResponseType;
        }

        obj.LoadStarted();

        try {
            httpRequest.send();
            this._pendingLoads++;
        } catch (e) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2ResMan', '_LoadResource'],
                msg: 'Error requesting',
                path: path,
                type: 'http.request',
                err: e
            });
        }
    };

    /**
     * Reloads a specific resource
     * @param {Tw2LoadingObject} resource
     * @returns {Tw2LoadingObject} resource
     */
    this.ReloadResource = function (resource) {
        var path = resource.path;

        _Tw2EventEmitter.emitter.log('res.event', {
            msg: 'Reloading ',
            path: path,
            type: 'reload'
        });

        var obj = this.motherLode.Find(path);

        if (obj !== null && !obj.IsPurged()) {
            return obj;
        }

        this._LoadResource(resource);
        return resource;
    };

    /**
     * Gets a resource
     * @param {String} path
     * @returns resource
     */
    this.GetResource = function (path) {
        var obj;

        path = _NormalizePath(path);
        obj = this.motherLode.Find(path);

        if (obj !== null) {
            if (obj.IsPurged()) {
                obj.Reload();
            }
            return obj;
        }

        var ext = _GetPathExt(path);

        if (ext === null) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2ResMan', 'ReloadResource'],
                msg: 'Undefined extension',
                type: 'extension.undefined',
                path: this.LogPathString(path)
            });
            return null;
        }

        if (!(ext in this._extensions)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2ResMan', 'ReloadResource'],
                msg: 'Unregistered extension',
                type: 'extension.unregistered',
                path: this.LogPathString(path),
                value: ext
            });
            return null;
        }

        obj = new this._extensions[ext]();
        obj.path = path;
        this._LoadResource(obj);
        return obj;
    };

    /**
     * Gets an object (with initialization)
     * @param {string} path
     * @param {Function} callback
     */
    this.GetObject = function (path, callback) {
        this._GetObject(path, callback, true);
    };

    /**
     * Gets an object (without initialization)
     * @param {string} path
     * @param {Function} callback
     */
    this.GetObjectNoInitialize = function (path, callback) {
        this._GetObject(path, callback, false);
    };

    /**
     * Core function for managing the processing and loading of an object
     * @param {string} path
     * @param {Function} callback
     * @param {Boolean} initialize
     * @private
     */
    this._GetObject = function (path, callback, initialize) {
        path = _NormalizePath(path);

        var obj = {};
        var res = this.motherLode.Find(path);

        if (res !== null) {
            res.AddObject(obj, callback, initialize);
            return;
        }

        res = new Tw2LoadingObject();
        res.path = path;
        res.AddObject(obj, callback, initialize);

        this.motherLode.Add(path, res);

        var httpRequest = this._CreateHttpRequest();
        httpRequest.onreadystatechange = _DoLoadResource(res);

        _Tw2EventEmitter.emitter.log('res.event', {
            msg: 'Requesting',
            path: this.BuildUrl(path),
            _path: path,
            type: 'requesting'
        });

        httpRequest.open('GET', this.BuildUrl(path));
        httpRequest.responseType = 'arraybuffer';
        res.LoadStarted();
        obj._objectLoaded = false;

        try {
            httpRequest.send();
            this._pendingLoads++;
        } catch (e) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2ResMan', '_GetObject'],
                msg: 'Error sending object HTTP request',
                path: this.BuildUrl(path),
                _path: path,
                type: 'http.request',
                err: e
            });
        }
    };

    /**
     * Clears the motherLode {@link Tw2MotherLode}
     */
    this.Clear = function () {
        this.motherLode.Clear();
    };

    /**
     * Unloads and Clears the motherLode {@link Tw2MotherLode}
     */
    this.UnloadAndClear = function () {
        this.motherLode.UnloadAndClear();
    };

    /**
     * Passes key:values from an object or array of objects to an internal function
     * @param {*} target
     * @param {string} funcName
     * @param {Array|{}} obj
     * @returns {boolean}
     */
    var _toKeyValue = function _toKeyValue(target, funcName, obj) {
        if (obj && funcName && funcName in target) {
            obj = Array.isArray(obj) ? obj : [obj];
            for (var i = 0; i < obj.length; i++) {
                for (var key in obj[i]) {
                    if (obj[i].hasOwnProperty(key)) {
                        target[funcName](key, obj[i][key]);
                    }
                }
            }
            return true;
        }
        return false;
    };

    /**
     * Registers a library constructor
     * @param {string} name
     * @param {function} Constructor
     * @returns {?Function}}
     */
    this.RegisterConstructor = function (name, Constructor) {
        if (name && Constructor && typeof Constructor === 'function') {
            this._constructors[name] = Constructor;
            return Constructor;
        }
        return null;
    };

    /**
     * Registers library constructors from an object or array of objects
     * @param obj
     */
    this.RegisterConstructors = function (obj) {
        _toKeyValue(this, 'RegisterConstructor', obj);
    };

    /**
     * Gets a library constructor by name
     * @param {string} name
     * @param {boolean} [skipDebug]
     * @returns {?Function}
     */
    this.GetConstructor = function (name, skipDebug) {
        if (name && name in this._constructors) {
            return this._constructors[name];
        } else if (name && !skipDebug) {
            if (this._missingConstructors.indexOf(name) === -1) {
                this._missingConstructors.push(name);
            }

            if (name.includes('Tw2')) {
                return this.GetConstructor(name.replace('Tw2', 'Tr2'), true);
            } else if (name.includes('Tr2')) {
                return this.GetConstructor(name.replace('Tr2', 'Tw2'), true);
            }
        }
        return null;
    };

    /**
     * Registers extension's and their constructors
     * @param {string} extension
     * @param {Function} Constructor
     * @returns {boolean}
     */
    this.RegisterExtension = function (extension, Constructor) {
        if (!extension || !Constructor || typeof Constructor !== 'function') {
            return false;
        }

        this._extensions[extension] = Constructor;
        return true;
    };

    /**
     * Registers extensions from an object or array of objects
     * @param obj
     */
    this.RegisterExtensions = function (obj) {
        _toKeyValue(this, 'RegisterExtension', obj);
    };

    /**
     * Gets a resource constructor from it's extension
     * @param {string} extension
     * @returns {?Function}}
     */
    this.GetExtension = function (extension) {
        return extension && extension in this._extensions ? this._extensions[extension] : null;
    };

    /**
     * Registers a resource path
     * @param {string} prefix
     * @param {Function} path
     * @returns {boolean}
     */
    this.RegisterResourcePath = function (prefix, path) {
        if (!prefix || !path) {
            return false;
        }

        this._resourcePaths[prefix] = path;
        return true;
    };

    /**
     * Registers resource paths from an object or array of objects
     * @param obj
     */
    this.RegisterResourcePaths = function (obj) {
        _toKeyValue(this, 'RegisterResourcePath', obj);
    };

    /**
     * Gets a resource path from its prefix
     * @param {string} prefix
     * @returns {?string}}
     */
    this.GetResourcePath = function (prefix) {
        return prefix && prefix in this._resourcePaths ? this._resourcePaths[prefix] : null;
    };

    /**
     * Register
     * @param {{}} opt
     * @param {{}} opt.resMan
     * @param {boolean} opt.systemMirror
     * @param {boolean} opt.autoPurgeResources
     * @param {number} opt.autoPurgeTimer
     * @param {{}} opt.resourcePaths
     * @param {{}} opt.extensions
     * @param {{}} opt.constructors
     */
    this.Register = function (opt) {
        if (opt) {
            this.RegisterConstructors(opt.constructors);
            this.RegisterResourcePaths(opt.resourcePaths);
            this.RegisterExtensions(opt.extensions);
        }
    };
}

// Global instance of Tw2ResMan
var resMan = exports.resMan = new Tw2ResMan();

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Event Emitter
 *
 * @property {{}} _events
 * @returns {Tw2EventEmitter}
 */
var Tw2EventEmitter = exports.Tw2EventEmitter = function Tw2EventEmitter() {
    _classCallCheck(this, Tw2EventEmitter);

    Tw2EventEmitter.Define(this);
};

/**
 * Adds a listener to an event
 * - The first argument of a called listener is always the event name
 * - Event names are forced to lowercase
 * - Listeners can only be on an event once, unless using the 'once' method
 *
 * @param {String} eventName  - the event to fire the listener on
 * @param {Function} listener - the listener
 * @returns {*} emitter       - the emitter object
 *
 * @example
 * var myListener1 = function(eventName, arg1, arg2, arg3){ .... };
 * myEmitter.on('someEvent', myListener1);
 * // myListener1 will be called whenever 'someEvent' is emitted
 */


Tw2EventEmitter.prototype.on = function (eventName, listener) {
    eventName = Tw2EventEmitter.Register(this, eventName);
    if (this._events[eventName].indexOf(listener) === -1) {
        this._events[eventName].push(listener);
    }
    return this;
};

/**
 * Adds a listener to an event and removes it after it's first emit
 * - Creates a temporary version of the listener which removes itself after one emit
 * - Caveat: It is possible to have the same listener on the same event multiple times when using `once`
 *
 * @param {String} eventName  - the target event
 * @param {Function} listener - the listener to add for one emit only
 * @returns {*} emitter       - the emitter object
 *
 * @example
 * myEmitter.once('someEvent', myListener1);
 * // myListener will be fired one time only before being removed from the event
 */
Tw2EventEmitter.prototype.once = function (eventName, listener) {
    eventName = Tw2EventEmitter.Register(this, eventName);
    var self = this;
    var once = function once() {
        listener.apply(undefined, arguments);
        self.off(eventName, once);
    };
    this.on(eventName, once);
    return this;
};

/**
 * Emits an event and calls any of it's listeners
 * - An event's listeners are called with the event name, and then any other supplied arguments
 *
 * @param {String} eventName - the event to emit
 * @param {*} [arguments]    - any arguments to be passed to the event's listeners
 * @returns {*} emitter      - the emitter object
 *
 * @example
 * var myListener1 = function(eventName, arg1, arg2, arg3){ .... };
 * var myListener2 = function(eventName, arg1){ .... };
 * myEmitter.on('someEvent', myListener);
 * myEmitter.emit('someEvent', arg1, arg2, arg3)
 * // myListener1 called with ('someEvent', arg1, arg2, arg3)
 * // myListener2 called with ('someEvent', arg1);
 */
Tw2EventEmitter.prototype.emit = function (eventName) {
    eventName = Tw2EventEmitter.Register(this, eventName);
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i < this._events[eventName].length; i++) {
        this._events[eventName][i].apply(undefined, args);
    }
    return this;
};

/**
 * Removes a listener from a specific event
 *
 * @param {String} eventName  - the target event
 * @param {Function} listener - the listener to remove
 * @returns {*} emitter       - the emitter object
 */
Tw2EventEmitter.prototype.off = function (eventName, listener) {
    eventName = eventName.toLowerCase();
    if ('_events' in this && eventName in this._events) {
        var index = this._events[eventName].indexOf(listener);
        if (index !== -1) this._events[eventName].splice(index, 1);
    }
    return this;
};

/**
 * Removes the supplied listener(s) from any of the emitter's events
 *
 * @param {*} [arguments] - the listener(s) to remove
 * @returns {*} emitter   - the emitter object
 *
 * @example
 * myEmitter.del(myListener1, myListener2)
 * // myListener1 and myListener2 are removed from any of the emitter's events
 */
Tw2EventEmitter.prototype.remove = function () {
    var args = Array.prototype.slice.call(arguments);
    if (this._events) {
        for (var i = 0; i < args.length; i++) {
            Tw2EventEmitter.RemoveListener(this, args[i]);
        }
    }
    return this;
};

/**
 * Internal helper that defines an event emitter's un-writable properties
 *
 * @param {*} emitter - target emitter
 */
Tw2EventEmitter.Define = function (emitter) {
    Object.defineProperty(emitter, '_events', {
        value: {},
        writable: false
    });
};

/**
 * Internal helper that registers an event on an emitter
 * - Adds the `_event` property to objects that don't already have it (allows for usage of Object.assign)
 * - Ensures that eventName is lower case
 * - Adds the event if it doesn't already exist
 *
 * @param {*} emitter          - target emitter
 * @param {String} eventName   - event to register
 * @returns {String} eventName - the event name, in lower case
 */
Tw2EventEmitter.Register = function (emitter, eventName) {
    if (!('_events' in emitter)) Tw2EventEmitter.Define(emitter);
    eventName = eventName.toLowerCase();
    if (!(eventName in emitter._events)) emitter._events[eventName] = [];
    return eventName;
};

/**
 * Checks if an emitter's event has any listeners on it
 *
 * @param {*} emitter        - target emitter
 * @param {String} eventName - event to check
 * @returns {boolean}
 */
Tw2EventEmitter.HasListeners = function (emitter, eventName) {
    if (!('_events' in emitter) || !(eventName in emitter._events)) return false;
    return emitter._events[eventName].length;
};

/**
 * Gets an array of an emitter's events that a listener is on
 *
 * @param {*} emitter         - target emitter
 * @param {Function} listener - listener to check
 * @returns {Array.<String>}  - an array of event names the listener is on
 */
Tw2EventEmitter.HasListener = function (emitter, listener) {
    var result = [];
    if ('_events' in emitter) {
        for (var eventName in emitter._events) {
            if (emitter._events.hasOwnProperty(eventName)) {
                var index = emitter._events[eventName].indexOf(listener);
                if (index !== -1) result.push(eventName);
            }
        }
    }
    return result;
};

/**
 * Removes a listener completely from an emitter
 *
 * @param {*} emitter         - target emitter
 * @param {Function} listener - listener to remove
 */
Tw2EventEmitter.RemoveListener = function (emitter, listener) {
    if ('_events' in emitter) {
        for (var eventName in emitter._events) {
            if (emitter._events.hasOwnProperty(eventName)) {
                var index = emitter._events[eventName].indexOf(listener);
                if (index !== -1) {
                    emitter._events[eventName].splice(index, 1);
                }
            }
        }
    }
};

/**
 * Removes an event from an emitter, and all of it's listeners
 *
 * @param {*} emitter        - target emitter
 * @param {String} eventName - the event to purge
 */
Tw2EventEmitter.RemoveEvent = function (emitter, eventName) {
    if ('_events' in emitter) {
        eventName = eventName.toLowerCase();
        if (eventName in emitter._events) delete emitter._events[eventName];
    }
};

/**
 * Adds bound emitter functions to a target object
 * - No checks are made to see if these methods or property names already exist in the target object
 *
 * @param {*} emitter                   - source emitter
 * @param {{}} target                   - target object
 * @param {boolean} [excludeEmit=false] - Optional control for excluding the `emit` method
 * @return {*}
 */
Tw2EventEmitter.Inherit = function (emitter, target, excludeEmit) {
    target['on'] = emitter.on.bind(emitter);
    target['off'] = emitter.off.bind(emitter);
    target['once'] = emitter.once.bind(emitter);
    if (!excludeEmit) target['emit'] = emitter.emit.bind(emitter);
    return target;
};

/**
 * Global emitter
 *
 * @emit (res.event, eventData) - Resource events (prepare, load, unload, request)
 * @emit (res.error, eventData) - Resource errors (any resource error)
 *
 * @example:
 * var myResErrorHandler = function(eventName, eventData){ .... };
 * ccpwgl_int.emitter.on('res.error', myErrorHandler);
 *
 * @example:
 * var myResEventHandler = function(eventName, eventData){ .... };
 * ccpwgl_int.emitter.on('res.event', myResEventHandler);
 *
 * @property {string}  consolePrefix
 * @property {boolean} consoleErrors
 * @property {boolean} consoleLogs
 * @property {string} consoleDefault
 * @inherits {Tw2EventEmitter}
 */
var emitter = exports.emitter = new Tw2EventEmitter();
emitter.consolePrefix = 'CCPWGL';
emitter.consoleErrors = true;
emitter.consoleLogs = true;
emitter.consoleDefault = 'log';

/**
 * Creates a console output from an event name and event object, then re-emits the event.
 * - The console outputs can be disabled by setting the `consoleErrors` and `consoleLogs` properties to false
 * - The event is re-emitted after any console output
 *
 * @param {String}  eventName              - The event to emit
 * @param {{}}      eventData              - event data
 * @param {String} [eventData.msg=]        - event message
 * @param {String} [eventData.log=]        - desired console output type (log, info, debug, warn, error, throw)
 * @param {String} [eventData.path=]       - the unmodified path for the file related to the event
 * @param {number} [eventData.time=]       - the time it took to process the event path (rounds to 3 decimal places)
 * @param {String} [eventData.type=]       - a string representing the unique event type
 * @param {Object} [eventData.data=]       - data relevant to the event type
 * @param {*}      [eventData.value=]      - a single value relevant to the event type
 * @param {Error}  [eventData.err=]        - Error Event object, if supplied the stack trace will be displayed
 * @param {Array.<String>} [eventData.src] - an array of the functions involved in the event
 */
emitter.log = function (eventName, eventData) {
    var output = true;
    var logType = eventData.log;

    switch (logType) {
        case 'throw':
            logType = 'error'; // throws use 'console.error'
            if (!this.consoleErrors) output = false;
            break;

        case 'error':
        case 'warn':
            if (!this.consoleErrors) output = false;
            break;

        case 'debug':
        case 'log':
        case 'info':
            if (!this.consoleLogs) output = false;
            break;

        default:
            logType = this.consoleDefault; // default log type
            if (!this.consoleLogs) output = false;
    }

    if (output) {
        var d = eventData;
        var header = this.consolePrefix.concat(': {', eventName, '}');
        var body = d.msg || '';
        if (d.path) body = body.concat(' \'', d.path, '\'', 'time' in d ? ' in ' + d.time.toFixed(3) + 'secs' : '');
        if (d.type && (logType === 'error' || logType === 'warn')) {
            body = body.concat(' (', d.type, d.value !== undefined ? ':' + d.value : '', ')');
        }

        if ('data' in d || 'err' in d) {
            console.group(header);
            console[logType](body);
            if ('data' in d) console.dir(d.data);
            // Correctly output error stacks
            if ('err' in d) console.debug(d.err.stack || d.err.toString());
            console.groupEnd();
        } else {
            console[logType](header, body);
        }
    }

    this.emit(eventName, eventData);
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2CurveSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _curves = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2CurveSequencer base class
 *
 * @class
 */
var Tw2CurveSequencer = exports.Tw2CurveSequencer = function (_Tw2Curve) {
    _inherits(Tw2CurveSequencer, _Tw2Curve);

    function Tw2CurveSequencer() {
        _classCallCheck(this, Tw2CurveSequencer);

        return _possibleConstructorReturn(this, (Tw2CurveSequencer.__proto__ || Object.getPrototypeOf(Tw2CurveSequencer)).call(this));
    }

    /**
     * Legacy sequencer sorting
     * @param {Tw2CurveSequencer} sequencer
     */


    _createClass(Tw2CurveSequencer, null, [{
        key: 'Sort',
        value: function Sort(sequencer) {
            var curves = sequencer['functions'];
            if (curves && curves.length) {
                for (var i = 0; i < curves.length; i++) {
                    if (curves[i] && 'Sort' in curves[i]) curves[i].Sort();
                }
            }
        }

        /**
         * Standard sequencer sorting
         * @param {Tw2CurveSequencer} sequencer
         */

    }, {
        key: 'Sort2',
        value: function Sort2(sequencer) {
            var names = sequencer.constructor.childProperties;
            if (names) {
                for (var i = 0; i < names.length; i++) {
                    var curve = sequencer[names[i]];
                    if (curve && 'Sort' in curve) curve.Sort();
                }
            }
        }
    }]);

    return Tw2CurveSequencer;
}(_curves.Tw2Curve);

/**
 * The sequencer's curve property names
 * @type {?Array.<string>}
 */


Tw2CurveSequencer.childProperties = null;

/**
 * The sequencer's curve array
 * @type {?string}
 */
Tw2CurveSequencer.childArray = null;

/**
 * Operator types
 * @type {null}
 */
Tw2CurveSequencer.Operator = null;

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(31);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleForce base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @class
 */
var Tw2ParticleForce = exports.Tw2ParticleForce = function () {
    function Tw2ParticleForce() {
        _classCallCheck(this, Tw2ParticleForce);

        this._id = _math.util.generateID();
        this.name = '';
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     * @param {number} dt
     * @param {number} mass
     */


    _createClass(Tw2ParticleForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force, dt, mass) {}

        /**
         * Per frame update (Called before ApplyForce)
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {}
    }]);

    return Tw2ParticleForce;
}();

/**
 * Class globals
 * @type {*}
 */


Tw2ParticleForce.global = {
    vec3_0: _math.vec3.create(),
    vec3_1: _math.vec3.create(),
    vec4_0: _math.vec3.create()
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChild = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveChild base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {boolean} useSRT
 * @property {number} lowestLodVisible
 * @property {boolean} staticTransform
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {vec3} scaling
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformLast
 * @property {?|Tw2BasicPerObjectData|Tw2PerObjectData} _perObjectData
 * @class
 */
var EveChild = exports.EveChild = function () {
    function EveChild() {
        _classCallCheck(this, EveChild);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.useSRT = true;
        this.lowestLodVisible = 2;
        this.staticTransform = false;
        this.rotation = _math.quat.create();
        this.translation = _math.vec3.create();
        this.scaling = _math.vec3.fromValues(1, 1, 1);
        this.localTransform = _math.mat4.create();
        this.worldTransform = _math.mat4.create();
        this.worldTransformLast = _math.mat4.create();
        this._perObjectData = null;
        this.isEffectChild = true;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */


    _createClass(EveChild, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            if (this.useSRT) {
                _math.quat.normalize(this.rotation, this.rotation);
                _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
            }

            _math.mat4.copy(this.worldTransformLast, this.worldTransform);
            _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {}
    }]);

    return EveChild;
}();

/**
 * PerObjectData declarations
 * @type {{FFEData: *[]}}
 */


EveChild.perObjectDataDecl = {
    FFEData: [{ name: 'world', size: 16 }, { name: 'worldInverseTranspose', size: 16 }]
};

/**
 * Class globals and scratch variables
 * @type {Object}
 */
EveChild.global = {
    mat4_0: _math.mat4.create(),
    vec3_0: _math.vec3.create()
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Resource = undefined;

var _Tw2ResMan = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Resource - A Tw2Resource
 * @typedef {(Tw2Resource|Tw2EffectRes|Tw2GeometryRes|Tw2TextureRes)} Resource
 */

/**
 * Tw2Resource
 * @property {string} path
 * @property {boolean} _isLoading
 * @property {boolean} _isGood
 * @property {boolean} _isPurged
 * @property {Array} _notifications
 * @property {number} activeFrame
 * @property {number} doNotPurge
 * @property {null|Function} _onLoadStarted - optional callback fired on res loading: callback(this)
 * @property {null|Function} _onLoadFinished - optional callback fired on res loaded: callback(this, success)
 * @property {null|Function} _onLoadPrepareFinished - optional callback fired on res prepare finish: callback(this, success)
 * @constructor
 */
var Tw2Resource = exports.Tw2Resource = function Tw2Resource() {
    _classCallCheck(this, Tw2Resource);

    this.path = '';
    this._isLoading = false;
    this._isGood = false;
    this._isPurged = false;
    this._notifications = [];
    this.activeFrame = 0;
    this.doNotPurge = 0;
    this._onLoadStarted = null;
    this._onLoadFinished = null;
    this._onPrepareFinished = null;
};

/**
 * Checks to see if the resource is loading
 * @returns {boolean}
 * @prototype
 */


Tw2Resource.prototype.IsLoading = function () {
    this.KeepAlive();
    return this._isLoading;
};

/**
 * Checks to see if the resource is good
 * @returns {boolean}
 * @prototype
 */
Tw2Resource.prototype.IsGood = function () {
    this.KeepAlive();
    return this._isGood;
};

/**
 * Checks to see if the resource is purged
 * @returns {boolean}
 * @prototype
 */
Tw2Resource.prototype.IsPurged = function () {
    return this._isPurged;
};

/**
 * LoadStarted
 * @prototype
 */
Tw2Resource.prototype.LoadStarted = function () {
    this._isLoading = true;

    for (var i = 0; i < this._notifications.length; ++i) {
        this._notifications[i].ReleaseCachedData(this);
    }

    if (this._onLoadStarted) {
        this._onLoadStarted(this);
    }
};

/**
 * LoadFinished
 * @param {boolean} success
 * @prototype
 */
Tw2Resource.prototype.LoadFinished = function (success) {
    this._isLoading = false;

    if (!success) {
        this._isGood = false;
    }

    if (this._onLoadFinished) {
        this._onLoadFinished(this, success);
    }
};

/**
 * PrepareFinished
 * @param {boolean} success
 * @prototype
 */
Tw2Resource.prototype.PrepareFinished = function (success) {
    this._isLoading = false;
    this._isGood = success;

    for (var i = 0; i < this._notifications.length; ++i) {
        this._notifications[i].RebuildCachedData(this);
    }

    if (this._onPrepareFinished) {
        this._onPrepareFinished(this, success);
    }
};

/**
 * Sets resource's isGood property
 * @param {boolean} success
 * @prototype
 */
Tw2Resource.prototype.SetIsGood = function (success) {
    this._isGood = success;
};

/**
 * Unload
 * @prototype
 */
Tw2Resource.prototype.Unload = function () {};

/**
 * Reloads the resource
 * @prototype
 */
Tw2Resource.prototype.Reload = function () {
    this.Unload();
    _Tw2ResMan.resMan.ReloadResource(this);
};

/**
 * Keeps the resource from being purged
 * @prototype
 */
Tw2Resource.prototype.KeepAlive = function () {
    this.activeFrame = _Tw2ResMan.resMan.activeFrame;
    if (this._isPurged) {
        this.Reload();
    }
};

/**
 * Registers a notification
 * @param notification
 * @prototype
 */
Tw2Resource.prototype.RegisterNotification = function (notification) {
    for (var i = 0; i < this._notifications.length; ++i) {
        if (this._notifications[i] === notification) {
            return;
        }
    }

    this._notifications[this._notifications.length] = notification;

    if (this._isGood) {
        notification.RebuildCachedData(this);
    }
};

/**
 * Deregisters a notification
 * @param notification
 * @prototype
 */
Tw2Resource.prototype.UnregisterNotification = function (notification) {
    for (var i = 0; i < this._notifications.length; ++i) {
        if (this._notifications[i] === notification) {
            this._notifications.splice(i, 1);
            return;
        }
    }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VertexElement = Tw2VertexElement;
exports.Tw2VertexDeclaration = Tw2VertexDeclaration;

var _Tw2Device = __webpack_require__(2);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Tw2VertexElement
 * @param {number} usage - vertex data type
 * @param {number} usageIndex
 * @param {number} type
 * @param {number} elements - How many variables this vertex data type uses
 * @param {number} [offset=0]
 * @property {number} usage
 * @property {number} usageIndex
 * @property {number} type
 * @property {number} elements
 * @property {number} offset
 * @property location
 * @property customSetter
 * @constructor
 */
function Tw2VertexElement(usage, usageIndex, type, elements) {
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    this.usage = usage;
    this.usageIndex = usageIndex;
    this.type = type;
    this.elements = elements;
    this.offset = offset;
    this.location = null;
    this.customSetter = null;
}

/**
 * Tw2VertexDeclaration
 * @param {Array<Array>|Array<Object>} [declarations]
 * @param {number} [stride]
 * @property {Array.<Tw2VertexElement>} elements
 * @property {Array.<Tw2VertexElement>} _elementsSorted
 * @constructor
 */
function Tw2VertexDeclaration(declarations, stride) {
    this.elements = [];
    this._elementsSorted = [];

    if (stride !== undefined) this.stride = stride;
    if (declarations) this.DeclareFromArray(declarations);
}

/**
 * Tw2 Vertex Declaration Types
 */
Tw2VertexDeclaration.Type = {
    POSITION: 0,
    COLOR: 1,
    NORMAL: 2,
    TANGENT: 3,
    BINORMAL: 4,
    TEXCOORD: 5,
    BLENDWEIGHT: 6,
    BLENDINDICES: 7
};

/**
 * CompareDeclarationElements
 * @param {Tw2VertexElement} a
 * @param {Tw2VertexElement} b
 * @param {number} [usageOffset=0]
 * @returns {number}
 * @function
 */
Tw2VertexDeclaration.CompareDeclarationElements = function (a, b) {
    var usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (a.usage < b.usage) return -1;
    if (a.usage > b.usage) return 1;
    if (a.usageIndex + usageOffset < b.usageIndex) return -1;
    if (a.usageIndex + usageOffset > b.usageIndex) return 1;
    return 0;
};

/**
 * Re-sorts elements and then returns the declaration
 * @returns {Tw2VertexDeclaration}
 * @prototype
 */
Tw2VertexDeclaration.prototype.RebuildHash = function () {
    this._elementsSorted = [];
    for (var i = 0; i < this.elements.length; ++i) {
        this._elementsSorted[i] = this.elements[i];
    }
    this._elementsSorted.sort(Tw2VertexDeclaration.CompareDeclarationElements);
    return this;
};

/**
 * Finds an element by it's usage type and usage index
 * @param {number} usage
 * @param {number} usageIndex
 * @returns {Tw2VertexElement|null}
 * @prototype
 */
Tw2VertexDeclaration.prototype.FindUsage = function (usage, usageIndex) {
    for (var i = 0; i < this._elementsSorted.length; ++i) {
        var e = this._elementsSorted[i];
        if (e.usage === usage) {
            if (e.usageIndex === usageIndex) {
                return e;
            } else if (e.usageIndex > usageIndex) {
                return null;
            }
        }
        if (e.usage > usage) {
            return null;
        }
    }
    return null;
};

/**
 * SetDeclaration
 * @param {Tw2VertexDeclaration} inputDecl
 * @param {number} stride
 * @returns {boolean}
 * @prototype
 */
Tw2VertexDeclaration.prototype.SetDeclaration = function (inputDecl, stride) {
    var index = 0;
    for (var i = 0; i < inputDecl._elementsSorted.length; ++i) {
        var el = inputDecl._elementsSorted[i];
        if (el.location < 0) {
            continue;
        }
        while (true) {
            if (index >= this._elementsSorted.length) {
                _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                break;
            }
            var input = this._elementsSorted[index];
            var cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el);
            if (cmp > 0) {
                _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                break;
            }
            if (cmp === 0) {
                if (input.customSetter) {
                    input.customSetter(el);
                } else {
                    _Tw2Device.device.gl.enableVertexAttribArray(el.location);
                    _Tw2Device.device.gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
                }
                break;
            }
            index++;
        }
    }
    return true;
};

/**
 * SetPartialDeclaration
 * @param {Tw2VertexDeclaration} inputDecl
 * @param {number} stride
 * @param {number} [usageOffset=0]
 * @param {number} [divisor=0]
 * @returns {Array} ResetData
 * @prototype
 */
Tw2VertexDeclaration.prototype.SetPartialDeclaration = function (inputDecl, stride) {
    var usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var divisor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var resetData = [];
    divisor = divisor || 0;
    var index = 0;
    for (var i = 0; i < inputDecl._elementsSorted.length; ++i) {
        var el = inputDecl._elementsSorted[i];
        if (el.location < 0) {
            continue;
        }
        while (true) {
            var input = this._elementsSorted[index];
            var cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el, usageOffset);
            if (cmp === 0) {
                if (input.customSetter) {
                    input.customSetter(el);
                } else {
                    _Tw2Device.device.gl.enableVertexAttribArray(el.location);
                    _Tw2Device.device.gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
                    _Tw2Device.device.ext.vertexAttribDivisor(el.location, divisor);
                    if (divisor) {
                        resetData.push(el.location);
                    }
                }
                break;
            } else if (cmp > 0) {
                if (!divisor) {
                    _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                    _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                }
                break;
            }
            index++;
            if (index >= this._elementsSorted.length) {
                if (!divisor) {
                    _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                    _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                }
                return resetData;
            }
        }
    }
    return resetData;
};

/**
 * ResetInstanceDivisors
 * @param {Array} resetData
 * @prototype
 */
Tw2VertexDeclaration.prototype.ResetInstanceDivisors = function (resetData) {
    if (resetData) {
        for (var i = 0; i < resetData.length; ++i) {
            _Tw2Device.device.ext.vertexAttribDivisor(resetData[i], 0);
        }
    }
};

/**
 * Declares elements from an array
 * @param {Array} declarations
 */
Tw2VertexDeclaration.prototype.DeclareFromArray = function (declarations) {
    if (this.elements.length) {
        this.elements.splice(0, this.elements.length);
    }

    for (var i = 0; i < declarations.length; i++) {
        var el = declarations[i];

        if (Array.isArray(el)) {
            this.AddElement.apply(this, _toConsumableArray(el));
        } else {
            this.AddElement(el.usage, el.usageIndex, el.type, el.elements, el.offset);
        }
    }

    this.RebuildHash();
};

/**
 * Creates and adds a Tw2VertexElement from arguments
 * @param {number|string} usage
 * @param {number} usageIndex
 * @param {number|string} type
 * @param {number} elements
 * @param {number} offset
 * @returns {Tw2VertexDeclaration}
 */
Tw2VertexDeclaration.prototype.AddElement = function (usage, usageIndex, type, elements, offset) {
    if (typeof usage === 'string') {
        usage = Tw2VertexDeclaration.Type[usage.toUpperCase()];
    }

    if (typeof type === 'string') {
        type = _Tw2Device.device.gl[type.toUpperCase()];
    }

    this.elements.push(new Tw2VertexElement(usage, usageIndex, type, elements, offset));
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleElementDeclaration = exports.Tw2ParticleElement = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleElement
 *
 * @param {Tw2ParticleElementDeclaration} decl
 * @property {number} elementType
 * @property {string} customName
 * @property {number} dimension
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @property buffer
 * @property {number} startOffset
 * @property {number} offset
 * @property {number} instanceStride
 * @property {number} vertexStride
 * @property {boolean} dirty
 * @class
 */
var Tw2ParticleElement = exports.Tw2ParticleElement = function Tw2ParticleElement(decl) {
    _classCallCheck(this, Tw2ParticleElement);

    this.elementType = decl.elementType;
    this.customName = decl.customName;
    this.dimension = decl.GetDimension();
    this.usageIndex = decl.usageIndex;
    this.usedByGPU = decl.usedByGPU;
    this.buffer = null;
    this.startOffset = 0;
    this.offset = 0;
    this.instanceStride = 0;
    this.vertexStride = 0;
    this.dirty = false;
};

/**
 * Tw2ParticleElementDeclaration
 *
 * @property {number} elementType=4
 * @property {string} customName
 * @property {number} dimension=1
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @class
 */


var Tw2ParticleElementDeclaration = exports.Tw2ParticleElementDeclaration = function () {
    function Tw2ParticleElementDeclaration() {
        _classCallCheck(this, Tw2ParticleElementDeclaration);

        this.elementType = 4;
        this.customName = '';
        this.dimension = 1;
        this.usageIndex = 0;
        this.usedByGPU = true;
    }

    /**
     * Gets the dimension of an element type
     * @returns {number}
     */


    _createClass(Tw2ParticleElementDeclaration, [{
        key: 'GetDimension',
        value: function GetDimension() {
            switch (this.elementType) {
                case Tw2ParticleElementDeclaration.Type.LIFETIME:
                    return 2;

                case Tw2ParticleElementDeclaration.Type.POSITION:
                    return 3;

                case Tw2ParticleElementDeclaration.Type.VELOCITY:
                    return 3;

                case Tw2ParticleElementDeclaration.Type.MASS:
                    return 1;
            }
            return this.dimension;
        }

        /**
         * GetDeclaration
         * @returns {Tw2VertexElement}
         */

    }, {
        key: 'GetDeclaration',
        value: function GetDeclaration() {
            var usage = void 0;
            switch (this.elementType) {
                case Tw2ParticleElementDeclaration.Type.LIFETIME:
                    usage = _core.Tw2VertexDeclaration.Type.TANGENT;
                    break;

                case Tw2ParticleElementDeclaration.Type.POSITION:
                    usage = _core.Tw2VertexDeclaration.Type.POSITION;
                    break;

                case Tw2ParticleElementDeclaration.Type.VELOCITY:
                    usage = _core.Tw2VertexDeclaration.Type.NORMAL;
                    break;

                case Tw2ParticleElementDeclaration.Type.MASS:
                    usage = _core.Tw2VertexDeclaration.Type.BINORMAL;
                    break;

                default:
                    usage = _core.Tw2VertexDeclaration.Type.TEXCOORD;
            }

            return new _core.Tw2VertexElement(usage, this.usageIndex, _core.device.gl.FLOAT, this.GetDimension());
        }
    }]);

    return Tw2ParticleElementDeclaration;
}();

/**
 * Particle element declaration types
 * @type {{LIFETIME: number, POSITION: number, VELOCITY: number, MASS: number, CUSTOM: number}}
 */


Tw2ParticleElementDeclaration.Type = {
    LIFETIME: 0,
    POSITION: 1,
    VELOCITY: 2,
    MASS: 3,
    CUSTOM: 4
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Curve = __webpack_require__(3);

Object.keys(_Tw2Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Curve[key];
    }
  });
});

var _Tw2ColorCurve = __webpack_require__(99);

Object.keys(_Tw2ColorCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorCurve[key];
    }
  });
});

var _Tw2ColorCurve2 = __webpack_require__(100);

Object.keys(_Tw2ColorCurve2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorCurve2[key];
    }
  });
});

var _Tw2EventCurve = __webpack_require__(101);

Object.keys(_Tw2EventCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EventCurve[key];
    }
  });
});

var _Tw2PerlinCurve = __webpack_require__(102);

Object.keys(_Tw2PerlinCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2PerlinCurve[key];
    }
  });
});

var _Tw2QuaternionCurve = __webpack_require__(103);

Object.keys(_Tw2QuaternionCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2QuaternionCurve[key];
    }
  });
});

var _Tw2RandomConstantCurve = __webpack_require__(104);

Object.keys(_Tw2RandomConstantCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomConstantCurve[key];
    }
  });
});

var _Tw2RigidOrientation = __webpack_require__(105);

Object.keys(_Tw2RigidOrientation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RigidOrientation[key];
    }
  });
});

var _Tw2RotationCurve = __webpack_require__(106);

Object.keys(_Tw2RotationCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RotationCurve[key];
    }
  });
});

var _Tw2ScalarCurve = __webpack_require__(107);

Object.keys(_Tw2ScalarCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarCurve[key];
    }
  });
});

var _Tw2ScalarCurve2 = __webpack_require__(108);

Object.keys(_Tw2ScalarCurve2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarCurve2[key];
    }
  });
});

var _Tw2SineCurve = __webpack_require__(109);

Object.keys(_Tw2SineCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SineCurve[key];
    }
  });
});

var _Tw2Vector2Curve = __webpack_require__(110);

Object.keys(_Tw2Vector2Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector2Curve[key];
    }
  });
});

var _Tw2Vector3Curve = __webpack_require__(111);

Object.keys(_Tw2Vector3Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector3Curve[key];
    }
  });
});

var _Tw2VectorCurve = __webpack_require__(112);

Object.keys(_Tw2VectorCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VectorCurve[key];
    }
  });
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveObject base class
 * Todo: Normalize transforms, use get/set for compatibility
 *
 * @property {number} _id
 * @property {string} name
 * @property {boolean} display
 * @class
 */
var EveObject = exports.EveObject = function () {
    function EveObject() {
        _classCallCheck(this, EveObject);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
    }

    /**
     * Initializes the object
     */


    _createClass(EveObject, [{
        key: 'Initialize',
        value: function Initialize() {}

        /**
         * Gets object resources
         * @param {Array} [out=[]]
         * @returns {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            return out;
        }

        /**
         * Update view dependant data
         */

    }, {
        key: 'UpdateViewDependantData',
        value: function UpdateViewDependantData() {}

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {}

        /**
         * Accumulates batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {}
    }]);

    return EveObject;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveObject.global = null;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.store = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2EventEmitter = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2VariableStore
 * 
 * @property {Object.< string, Parameter>} _variables
 * @property {Object.< string, Function>} _types
 * @class
 */
var Tw2VariableStore = function () {
    function Tw2VariableStore() {
        _classCallCheck(this, Tw2VariableStore);

        this._variables = {};
        this._types = {};
    }

    /**
     * Gets a variable by it's name
     * @param {string} name
     * @returns {?Parameter}
     */


    _createClass(Tw2VariableStore, [{
        key: 'GetVariable',
        value: function GetVariable(name) {
            return name && name in this._variables ? this._variables[name] : null;
        }

        /**
         * Checks if a variable of a given name exists
         * @param {string} name
         * @returns {boolean}
         */

    }, {
        key: 'HasVariable',
        value: function HasVariable(name) {
            return name && name in this._variables;
        }

        /**
         * Gets a type by it's name
         * @param {string} name
         * @returns {?Function}
         */

    }, {
        key: 'GetType',
        value: function GetType(name) {
            name = name.toLowerCase();
            return name && name in this._types ? this._types[name] : null;
        }

        /**
         * Gets a type by value
         * @param {*} value
         * @returns {?Function}}
         */

    }, {
        key: 'GetTypeFromValue',
        value: function GetTypeFromValue(value) {
            for (var type in this._types) {
                if (this._types.hasOwnProperty(type)) {
                    var Type = this._types[type];
                    if (Type.is && Type.is(value)) return Type;
                }
            }
            return null;
        }

        /**
         * Creates A Tw2 parameter from a supplied value and/or Type
         * @param {string} name
         * @param {*} [value]
         * @param {string|Function} [Type]
         * @returns {?Parameter}
         */

    }, {
        key: 'CreateType',
        value: function CreateType(name, value, Type) {
            if (Type) {
                if (typeof Type === 'string') {
                    Type = this.GetType(Type);
                }
            } else {
                Type = this.GetTypeFromValue(value);
            }

            return Type ? new Type(name, value) : null;
        }

        /**
         * Registers a variable if it hasn't already been registered
         * @param {string} name
         * @param {*} value
         * @param {Function} [Type]
         * @returns {?Parameter} The parameter registered with the given name
         */

    }, {
        key: 'RegisterVariable',
        value: function RegisterVariable(name, value, Type) {
            if (!this.HasVariable(name)) {
                var variable = this.CreateType(name, value, Type);
                if (variable) {
                    this._variables[name] = variable;
                    _Tw2EventEmitter.emitter.log('store.registered', {
                        log: 'debug',
                        msg: 'Registered Variable: ' + name
                    });
                }
            }

            return name in this._variables ? this._variables[name] : null;
        }

        /**
         * Registers a variable type if it hasn't already been registered
         * @param {string} name
         * @param {Function} Constructor
         * @returns {?Function} The type registered with the given name
         */

    }, {
        key: 'RegisterType',
        value: function RegisterType(name, Constructor) {
            name = name.toLowerCase();
            if (name && typeof Constructor === 'function' && !this._types[name]) {
                this._types[name] = Constructor;
                _Tw2EventEmitter.emitter.log('store.registered', {
                    log: 'debug',
                    msg: 'Registered Type: ' + name
                });
            }
            return name in this._types ? this._types[name] : null;
        }

        /**
         * Registers variables from an object or array of objects
         * @param {{string:*}} obj
         */

    }, {
        key: 'RegisterVariables',
        value: function RegisterVariables(obj) {
            Tw2VariableStore.toKeyValue(this, 'RegisterVariable', obj);
        }

        /**
         * Registers variable Types
         * @param {{string: Function}} obj
         */

    }, {
        key: 'RegisterTypes',
        value: function RegisterTypes(obj) {
            Tw2VariableStore.toKeyValue(this, 'RegisterType', obj);
        }

        /**
         * Register
         * @param {*} [opt={}]
         */

    }, {
        key: 'Register',
        value: function Register(opt) {
            if (opt) {
                if (opt['uuid']) {
                    _math.util.generateID = _math.util.generateUUID;
                }

                this.RegisterTypes(opt.types);
                this.RegisterVariables(opt.variables);

                _Tw2ResMan.resMan.Register(opt);
            }
        }

        /**
         * Passes key:values from an object or array of objects to an internal function
         * @param {*} target
         * @param {string} funcName
         * @param {Array|{}} obj
         * @returns {boolean}
         */

    }], [{
        key: 'toKeyValue',
        value: function toKeyValue(target, funcName, obj) {
            if (obj && funcName && funcName in target) {
                obj = Array.isArray(obj) ? obj : [obj];
                for (var i = 0; i < obj.length; i++) {
                    for (var key in obj[i]) {
                        if (obj[i].hasOwnProperty(key)) {
                            target[funcName](key, obj[i][key]);
                        }
                    }
                }
            }
        }
    }]);

    return Tw2VariableStore;
}();

var store = exports.store = new Tw2VariableStore();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TextureParameter = Tw2TextureParameter;

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Device = __webpack_require__(2);

var _Tw2SamplerState = __webpack_require__(19);

/**
 * Tw2TextureParameter
 * @param {string} [name=''] - Name of the texture parameter
 * @param {string} [texturePath=''] - The texture's resource path
 * @property {string} name
 * @property {boolean} useAllOverrides
 * @property {number} addressUMode
 * @property {number} addressVMode
 * @property {number} addressWMode
 * @property {number} filterMode
 * @property {number} mapFilterMode
 * @property {number} maxAnisotropy
 * @property {Tw2TextureRes} textureRes
 * @property {Tw2SamplerState} _sampler
 * @constructor
 */
function Tw2TextureParameter(name, texturePath) {
    if (typeof name !== 'undefined') {
        this.name = name;
    } else {
        this.name = '';
    }

    this.useAllOverrides = false;
    this.addressUMode = 1;
    this.addressVMode = 1;
    this.addressWMode = 1;
    this.filterMode = 2;
    this.mipFilterMode = 2;
    this.maxAnisotropy = 4;
    this.textureRes = null;
    this._sampler = null;

    if (typeof texturePath !== 'undefined') {
        this.resourcePath = texturePath;
        this.Initialize();
    } else {
        this.resourcePath = '';
    }
}

/**
 * Gets texture res object
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2TextureRes>} [out]
 */
Tw2TextureParameter.prototype.GetResource = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.textureRes !== null) {
        if (out.indexOf(this.textureRes) === -1) {
            out.push(this.textureRes);
        }
    }

    return out;
};

/**
 * Sets the texture's resource path
 * @param {string} texturePath
 * @constructor
 */
Tw2TextureParameter.prototype.SetTexturePath = function (texturePath) {
    this.resourcePath = texturePath;
    if (this.resourcePath !== '') {
        this.textureRes = _Tw2ResMan.resMan.GetResource(this.resourcePath);
    }
};

/**
 * Initializes the texture parameter
 * @prototype
 */
Tw2TextureParameter.prototype.Initialize = function () {
    if (this.resourcePath !== '') {
        this.textureRes = _Tw2ResMan.resMan.GetResource(this.resourcePath);
    }

    if (this.useAllOverrides) {
        this._sampler = new _Tw2SamplerState.Tw2SamplerState();
        if (this.filterMode === 1) {
            switch (this.mipFilterMode) {
                case 0:
                    this._sampler.minFilter = _Tw2Device.device.gl.NEAREST;
                    break;
                case 1:
                    this._sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_NEAREST;
                    break;
                default:
                    this._sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_LINEAR;
            }
            this._sampler.minFilterNoMips = _Tw2Device.device.gl.NEAREST;
            this._sampler.magFilter = _Tw2Device.device.gl.NEAREST;
        } else {
            switch (this.mipFilterMode) {
                case 0:
                    this._sampler.minFilter = _Tw2Device.device.gl.LINEAR;
                    break;
                case 1:
                    this._sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_NEAREST;
                    break;
                default:
                    this._sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_LINEAR;
            }
            this._sampler.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
            this._sampler.magFilter = _Tw2Device.device.gl.LINEAR;
        }

        this._sampler.addressU = _Tw2Device.device.wrapModes[this.addressUMode];
        this._sampler.addressV = _Tw2Device.device.wrapModes[this.addressVMode];
        this._sampler.addressW = _Tw2Device.device.wrapModes[this.addressWMode];
        this._sampler.anisotropy = this.maxAnisotropy;
        this._sampler.ComputeHash();
    }
};

/**
 * Apply
 * @param stage
 * @param sampler
 * @param slices
 * @prototype
 */
Tw2TextureParameter.prototype.Apply = function (stage, sampler, slices) {
    if (this.textureRes) {
        if (this.useAllOverrides) {
            this._sampler.samplerType = sampler.samplerType;
            this._sampler.isVolume = sampler.isVolume;
            this._sampler.registerIndex = sampler.registerIndex;
            sampler = this._sampler;
        }
        _Tw2Device.device.gl.activeTexture(_Tw2Device.device.gl.TEXTURE0 + stage);
        this.textureRes.Bind(sampler, slices);
    }
};

/**
 * Get Value
 * @return {string}
 */
Tw2TextureParameter.prototype.GetValue = function () {
    if (this.textureRes) {
        return this.textureRes.path;
    }

    return this.resourcePath;
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2TextureParameter.is = function (value) {
    return typeof value === 'string';
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2BinaryReader = Tw2BinaryReader;
/**
 * Tw2BinaryReader
 * @param data
 * @constructor
 */
function Tw2BinaryReader(data) {
    this.data = data;
    this.cursor = 0;
}

/**
 * ReadUInt8
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadUInt8 = function () {
    return this.data[this.cursor++];
};

/**
 * ReadInt8
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadInt8 = function () {
    var val = this.data[this.cursor++];
    if (val > 0x7F) {
        val = val - 0xff - 1;
    }
    return val;
};

/**
 * ReadUInt16
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadUInt16 = function () {
    return this.data[this.cursor++] + (this.data[this.cursor++] << 8);
};

/**
 * ReadInt16
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadInt16 = function () {
    var val = this.data[this.cursor++] + (this.data[this.cursor++] << 8);
    if (val > 0x7FFF) {
        val = val - 0xffff - 1;
    }
    return val;
};

/**
 * ReadUInt32
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadUInt32 = function () {
    return this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
};

/**
 * ReadInt32
 * @returns {*}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadInt32 = function () {
    var val = this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
    if (val > 0x7FFFFFFF) {
        val = val - 0xffffffff - 1;
    }
    return val;
};

/**
 * ReadFloat16
 * @returns {number}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadFloat16 = function () {
    var b2 = this.data[this.cursor++],
        b1 = this.data[this.cursor++];
    var sign = 1 - 2 * (b1 >> 7); // sign = bit 0
    var exp = (b1 >> 2 & 0x1f) - 15; // exponent = bits 1..5
    var sig = (b1 & 3) << 8 | b2; // significand = bits 6..15
    if (sig === 0 && exp === -15) return 0.0;
    return sign * (1 + sig * Math.pow(2, -10)) * Math.pow(2, exp);
};

/**
 * ReadFloat32
 * @returns {number}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadFloat32 = function () {
    var b4 = this.data[this.cursor++],
        b3 = this.data[this.cursor++],
        b2 = this.data[this.cursor++],
        b1 = this.data[this.cursor++];
    var sign = 1 - 2 * (b1 >> 7); // sign = bit 0
    var exp = (b1 << 1 & 0xff | b2 >> 7) - 127; // exponent = bits 1..8
    var sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31
    if (sig === 0 && exp === -127) return 0.0;
    return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
};

/**
 * ReadString
 * @returns {string}
 * @prototype
 */
Tw2BinaryReader.prototype.ReadString = function () {
    var length = this.data[this.cursor++];
    var str = '';
    for (var i = 0; i < length; ++i) {
        str += String.fromCharCode(this.data[this.cursor++]);
    }
    return str;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2SamplerOverride = Tw2SamplerOverride;
exports.Tw2SamplerState = Tw2SamplerState;

var _Tw2Device = __webpack_require__(2);

/**
 * Tw2SamplerOverride
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} filter
 * @property {number} mipFilter
 * @property {number} lodBias
 * @property {number} maxMipLevel
 * @property {number} maxAnisotropy
 * @constructor
 */
function Tw2SamplerOverride() {
    this.name = '';

    this.addressU = 0;
    this.addressV = 0;
    this.addressW = 0;
    this.filter = 0;
    this.mipFilter = 0;
    this.lodBias = 0;
    this.maxMipLevel = 0;
    this.maxAnisotropy = 0;

    var sampler = null;

    /**
     * GetSampler
     * @param originalSampler
     * @returns {*}
     * @method
     */
    this.GetSampler = function (originalSampler) {
        if (!sampler) {
            sampler = new Tw2SamplerState();
            sampler.registerIndex = originalSampler.registerIndex;
            sampler.name = originalSampler.name;
            if (this.filter === 1) {
                switch (this.mipFilter) {
                    case 0:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST;
                        break;
                    case 1:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_NEAREST;
                        break;
                    default:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_LINEAR;
                }
                sampler.minFilterNoMips = _Tw2Device.device.gl.NEAREST;
            } else {
                switch (this.mipFilter) {
                    case 0:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR;
                        break;
                    case 1:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_NEAREST;
                        break;
                    default:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_LINEAR;
                }
                sampler.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
            }
            if (this.filter === 1) {
                sampler.magFilter = _Tw2Device.device.gl.NEAREST;
            } else {
                sampler.magFilter = _Tw2Device.device.gl.LINEAR;
            }
            var wrapModes = [0, _Tw2Device.device.gl.REPEAT, _Tw2Device.device.gl.MIRRORED_REPEAT, _Tw2Device.device.gl.CLAMP_TO_EDGE, _Tw2Device.device.gl.CLAMP_TO_EDGE, _Tw2Device.device.gl.CLAMP_TO_EDGE];
            sampler.addressU = wrapModes[this.addressU];
            sampler.addressV = wrapModes[this.addressV];
            sampler.addressW = wrapModes[this.addressW];
            if (this.filter === 3 || this.mipFilter === 3) {
                sampler.anisotropy = Math.max(this.maxAnisotropy, 1);
            }
            sampler.samplerType = originalSampler.samplerType;
            sampler.isVolume = originalSampler.isVolume;
            sampler.ComputeHash();
        }
        return sampler;
    };
}

/**
 * Tw2SamplerState
 * @property {number} registerIndex
 * @property {string} name
 * @property {number} minFilter
 * @property {number} maxFilter
 * @property {number} minFilterNoMips
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} anisotropy
 * @property samplerType
 * @property {boolean} isVolume
 * @property {number} hash
 * @constructor
 */
function Tw2SamplerState() {
    this.registerIndex = 0;
    this.name = '';
    this.minFilter = _Tw2Device.device.gl.LINEAR;
    this.maxFilter = _Tw2Device.device.gl.LINEAR;
    this.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
    this.addressU = _Tw2Device.device.gl.REPEAT;
    this.addressV = _Tw2Device.device.gl.REPEAT;
    this.addressW = _Tw2Device.device.gl.REPEAT;
    this.anisotropy = 1;
    this.samplerType = _Tw2Device.device.gl.TEXTURE_2D;
    this.isVolume = false;
    this.hash = 0;
}

/**
 * Computes the sampler hash
 * @prototype
 */
Tw2SamplerState.prototype.ComputeHash = function () {
    this.hash = 2166136261;
    this.hash *= 16777619;
    this.hash ^= this.minFilter;
    this.hash *= 16777619;
    this.hash ^= this.maxFilter;
    this.hash *= 16777619;
    this.hash ^= this.addressU;
    this.hash *= 16777619;
    this.hash ^= this.addressV;
    this.hash *= 16777619;
    this.hash ^= this.anisotropy;
};

/**
 * Apply
 * @param {boolean} hasMipMaps
 * @prototype
 */
Tw2SamplerState.prototype.Apply = function (hasMipMaps) {
    var targetType = this.samplerType;
    var d = _Tw2Device.device;
    var gl = d.gl;
    gl.texParameteri(targetType, gl.TEXTURE_WRAP_S, hasMipMaps ? this.addressU : gl.CLAMP_TO_EDGE);
    gl.texParameteri(targetType, gl.TEXTURE_WRAP_T, hasMipMaps ? this.addressV : gl.CLAMP_TO_EDGE);
    gl.texParameteri(targetType, gl.TEXTURE_MIN_FILTER, hasMipMaps ? this.minFilter : this.minFilterNoMips);
    gl.texParameteri(targetType, gl.TEXTURE_MAG_FILTER, this.magFilter);
    if (d.ext.AnisotropicFilter && d.enableAnisotropicFiltering) {
        gl.texParameterf(targetType, d.ext.AnisotropicFilter.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.anisotropy, d.ext.AnisotropicFilter.maxAnisotropy));
    }
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Effect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Device = __webpack_require__(2);

var _Tw2VariableStore = __webpack_require__(16);

var _Tw2TextureParameter = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Effect
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {string} effectFilePath
 * @property {Tw2EffectRes|null} effectRes
 * @property {Object.<string, Parameter>} parameters
 * @property {Array} passes
 * @property {Array} samplerOverrides
 * @property {boolean} autoParameter
 * @property {Function} _onModified
 * @class
 */
var Tw2Effect = exports.Tw2Effect = function () {
    function Tw2Effect() {
        _classCallCheck(this, Tw2Effect);

        this._id = _math.util.generateID();
        this.name = '';
        this.effectFilePath = '';
        this.effectRes = null;
        this.parameters = {};
        this.passes = [];
        this.samplerOverrides = [];
        this.autoParameter = false;
    }

    /**
     * Initializes the Tw2Effect
     */


    _createClass(Tw2Effect, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.effectFilePath !== '') {
                this.effectFilePath = this.effectFilePath.toLowerCase();
                var path = Tw2Effect.ToEffectResPath(this.effectFilePath);
                this.effectRes = _Tw2ResMan.resMan.GetResource(path);
                this.effectRes.RegisterNotification(this);
            }
        }

        /**
         * Checks if the effect's effect resource is good
         * @returns {boolean}
         */

    }, {
        key: 'IsGood',
        value: function IsGood() {
            return this.effectRes && this.effectRes.IsGood();
        }

        /**
         * Gets effect resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.effectRes && !out.includes(this.effectRes)) {
                out.push(this.effectRes);
            }

            for (var param in this.parameters) {
                if (this.parameters.hasOwnProperty(param)) {
                    if ('GetResources' in this.parameters[param]) {
                        this.parameters[param].GetResources(out);
                    }
                }
            }

            return out;
        }

        /**
         * Gets the effect's resource
         * @returns {?Tw2EffectRes}
         */

    }, {
        key: 'GetEffectRes',
        value: function GetEffectRes() {
            return this.effectRes;
        }

        /**
         * Rebuilds Cached Data
         * @param resource
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData(resource) {
            if (resource.IsGood()) {
                this.effectRes = resource;
                this.BindParameters();
            }
        }

        /**
         * Unbinds parameters
         * @returns {boolean}
         */

    }, {
        key: 'UnbindParameters',
        value: function UnbindParameters() {
            for (var i = 0; i < this.passes.length; ++i) {
                for (var j = 0; j < this.passes[i].stages.length; ++j) {
                    for (var k = 0; k < this.passes[i].stages[j].reroutedParameters.length; ++k) {
                        var parameter = this.passes[i].stages[j].reroutedParameters[k];
                        if (parameter.Unbind) parameter.Unbind();
                    }
                }
            }
            this.passes = [];
        }

        /**
         * Binds parameters
         * @returns {boolean}
         */

    }, {
        key: 'BindParameters',
        value: function BindParameters() {
            this.UnbindParameters();

            if (!this.IsGood()) return false;

            for (var i = 0; i < this.effectRes.passes.length; ++i) {
                var pass = [];
                pass.stages = [];
                for (var j = 0; j < this.effectRes.passes[i].stages.length; ++j) {
                    var stageRes = this.effectRes.passes[i].stages[j];
                    var stage = {};
                    stage.constantBuffer = new Float32Array(stageRes.constantSize);
                    stage.reroutedParameters = [];
                    stage.parameters = [];
                    stage.textures = [];
                    stage.constantBuffer.set(stageRes.constantValues);

                    for (var k = 0; k < stageRes.constants.length; ++k) {
                        if (Tw2Effect.ConstantIgnore.includes(stageRes.constants[k].name)) continue;

                        var constant = stageRes.constants[k],
                            name = constant.name;

                        if (name in this.parameters) {
                            var param = this.parameters[name];
                            if (param.Bind(stage.constantBuffer, constant.offset, constant.size)) {
                                stage.reroutedParameters.push(param);
                            } else {
                                var p = {};
                                p.parameter = param;
                                p.constantBuffer = stage.constantBuffer;
                                p.offset = constant.offset;
                                p.size = constant.size;
                                stage.parameters.push(p);
                            }
                        } else if (_Tw2VariableStore.store.HasVariable(name)) {
                            var _p = {};
                            _p.parameter = _Tw2VariableStore.store.GetVariable(name);
                            _p.constantBuffer = stage.constantBuffer;
                            _p.offset = constant.offset;
                            _p.size = constant.size;
                            stage.parameters.push(_p);
                        } else if (constant.isAutoregister) {
                            var variable = _Tw2VariableStore.store.RegisterVariable(name, undefined, constant.Type);
                            if (variable) {
                                var _p2 = {};
                                _p2.parameter = variable;
                                _p2.constantBuffer = stage.constantBuffer;
                                _p2.offset = constant.offset;
                                _p2.size = constant.size;
                                stage.parameters.push(_p2);
                            }
                        } else if (this.autoParameter && constant.elements === 1) {
                            var value = stageRes.constantValues.subarray(constant.offset, constant.offset + constant.size),
                                _param = _Tw2VariableStore.store.CreateType(name, value, constant.Type);

                            // Parameter is not on/ enabled by default
                            if (!_param) {
                                var Type = _Tw2VariableStore.store.GetTypeFromValue(constant.size === 1 ? 1 : new Array(constant.size));
                                if (Type) _param = new Type(name);
                            }

                            if (_param) {
                                console.dir(_param);
                                this.parameters[name] = _param;
                                var _p3 = {};
                                _p3.parameter = _param;
                                _p3.constantBuffer = stage.constantBuffer;
                                _p3.offset = constant.offset;
                                _p3.size = constant.size;
                                stage.parameters.push(_p3);
                            }
                        }
                    }

                    for (var _k = 0; _k < stageRes.textures.length; ++_k) {
                        var _name = stageRes.textures[_k].name;
                        var _param2 = void 0;

                        if (_name in this.parameters) {
                            _param2 = this.parameters[_name];
                        } else if (_Tw2VariableStore.store.HasVariable(_name)) {
                            _param2 = _Tw2VariableStore.store.GetVariable(_name);
                        } else if (stageRes.textures[_k].isAutoregister) {
                            _param2 = _Tw2VariableStore.store.RegisterVariable(_name, undefined, _Tw2TextureParameter.Tw2TextureParameter);
                        } else if (this.autoParameter) {
                            this.parameters[_name] = new _Tw2TextureParameter.Tw2TextureParameter(_name);
                            _param2 = this.parameters[_name];
                        } else {
                            continue;
                        }

                        var _p4 = {};
                        _p4.parameter = _param2;
                        _p4.slot = stageRes.textures[_k].registerIndex;
                        _p4.sampler = null;

                        for (var n = 0; n < stageRes.samplers.length; ++n) {
                            if (stageRes.samplers[n].registerIndex === _p4.slot) {
                                if (stageRes.samplers[n].name in this.samplerOverrides) {
                                    _p4.sampler = this.samplerOverrides[stageRes.samplers[n].name].GetSampler(stageRes.samplers[n]);
                                } else {
                                    _p4.sampler = stageRes.samplers[n];
                                }
                                break;
                            }
                        }

                        if (j === 0) _p4.slot += 12;
                        stage.textures.push(_p4);
                    }
                    pass.stages.push(stage);
                }
                this.passes.push(pass);
            }

            if (_Tw2Device.device['effectObserver']) {
                _Tw2Device.device['effectObserver']['OnEffectChanged'](this);
            }

            return true;
        }

        /**
         * ApplyPass
         * @param pass
         */

    }, {
        key: 'ApplyPass',
        value: function ApplyPass(pass) {
            if (!this.IsGood() || pass >= this.passes.length) return;

            this.effectRes.ApplyPass(pass);

            var p = this.passes[pass],
                rp = this.effectRes.passes[pass],
                d = _Tw2Device.device;

            var program = d.IsAlphaTestEnabled() && rp.shadowShaderProgram ? rp.shadowShaderProgram : rp.shaderProgram;

            for (var i = 0; i < 2; ++i) {
                var stages = p.stages[i];

                for (var j = 0; j < stages.parameters.length; ++j) {
                    var pp = stages.parameters[j];
                    pp.parameter.Apply(pp.constantBuffer, pp.offset, pp.size);
                }

                for (var _j = 0; _j < stages.textures.length; ++_j) {
                    var tex = stages.textures[_j];
                    tex.parameter.Apply(tex.slot, tex.sampler, program.volumeSlices[tex.sampler.registerIndex]);
                }
            }

            var cbh = program.constantBufferHandles;
            if (cbh[0]) d.gl.uniform4fv(cbh[0], p.stages[0].constantBuffer);
            if (cbh[7]) d.gl.uniform4fv(cbh[7], p.stages[1].constantBuffer);
            if (d.perFrameVSData && cbh[1]) d.gl.uniform4fv(cbh[1], d.perFrameVSData.data);
            if (d.perFramePSData && cbh[2]) d.gl.uniform4fv(cbh[2], d.perFramePSData.data);
            if (d.perObjectData) d.perObjectData.SetPerObjectDataToDevice(cbh);
        }

        /**
         * GetPassCount
         * @returns {number}
         */

    }, {
        key: 'GetPassCount',
        value: function GetPassCount() {
            return this.IsGood() ? this.passes.length : 0;
        }

        /**
         * GetPassInput
         * @param {number} pass
         * @returns {*}
         */

    }, {
        key: 'GetPassInput',
        value: function GetPassInput(pass) {
            if (!this.IsGood() || pass >= this.passes.length) return null;

            if (_Tw2Device.device.IsAlphaTestEnabled() && this.effectRes.passes[pass].shadowShaderProgram) {
                return this.effectRes.passes[pass].shadowShaderProgram.input;
            } else {
                return this.effectRes.passes[pass].shaderProgram.input;
            }
        }

        /**
         * Render
         * @param {function} cb - callback
         */

    }, {
        key: 'Render',
        value: function Render(cb) {
            var count = this.GetPassCount();
            for (var i = 0; i < count; ++i) {
                this.ApplyPass(i);
                cb(this, i);
            }
        }

        /**
         * Gets an object containing effect's texture resource paths
         * @param {{}} [out={}]
         * @returns {Object.<string, string>} out
         */

    }, {
        key: 'GetTextures',
        value: function GetTextures() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key) && this.parameters[key] instanceof _Tw2TextureParameter.Tw2TextureParameter) {
                    var resourcePath = this.parameters[key].GetValue();
                    if (resourcePath) out[key] = resourcePath;
                }
            }
            return out;
        }

        /**
         * Sets textures from an object
         * @param {{string:string}} options
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetTextures',
        value: function SetTextures() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false,
                rebindParameters = false;

            for (var key in options) {
                if (options.hasOwnProperty(key)) {
                    if (key in this.parameters) {
                        if (this.parameters.SetValue(options[key])) updated = true;
                    } else {
                        this.parameters[key] = new _Tw2TextureParameter.Tw2TextureParameter(key, options[key]);
                        updated = true;
                        rebindParameters = true;
                    }
                }
            }

            if (this.IsGood() && rebindParameters) this.BindParameters();
            return updated;
        }

        /**
         * Gets an object containing all non texture parameters values
         * - Matches sof parameter object
         * @param {{}} [out={}]
         * @returns {Object.<string, *>}
         */

    }, {
        key: 'GetParameters',
        value: function GetParameters() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key) && !(this.parameters[key] instanceof _Tw2TextureParameter.Tw2TextureParameter)) {
                    out[key] = this.parameters[key].GetValue(true);
                }
            }
            return out;
        }

        /**
         * Sets parameters from an object
         * @param {{string:*}} [options={}]
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetParameters',
        value: function SetParameters() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false,
                rebindParameters = false;

            for (var key in options) {
                if (options.hasOwnProperty(key)) {
                    if (key in this.parameters) {
                        if (this.parameters[key].SetValue(options[key])) updated = true;
                    } else {
                        var parameter = _Tw2VariableStore.store.CreateType(key, options[key]);
                        if (parameter) {
                            this.parameters[key] = parameter;
                            rebindParameters = true;
                            updated = true;
                        }
                    }
                }
            }

            if (rebindParameters) this.BindParameters();
            return updated;
        }

        /**
         * Sets texture overrides from an object
         * @param {*} options
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetOverrides',
        value: function SetOverrides() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false;
            for (var key in options) {
                if (options.hasOwnProperty(key) && key in this.parameters && 'SetOverrides' in this.parameters[key]) {
                    this.parameters[key].SetOverrides(options[key]);
                    updated = true;
                }
            }
            return updated;
        }

        /**
         * Gets texture overrides as an object
         * @param {{ string: {}}} out
         */

    }, {
        key: 'GetOverrides',
        value: function GetOverrides() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key) && 'GetOverrides' in this.parameters[key]) {
                    if (this.parameters[key].useAllOverrides) {
                        out[key] = this.parameters[key].GetOverrides();
                    }
                }
            }
            return out;
        }

        /**
         * Converts a effect file path into one suitable for an effect resource
         * @param {string} path
         * @returns {string}
         */

    }], [{
        key: 'ToEffectResPath',
        value: function ToEffectResPath(path) {
            return path ? path.substr(0, path.lastIndexOf('.')).replace('/effect/', _Tw2Device.device.effectDir) + '.sm_' + _Tw2Device.device.shaderModel : '';
        }

        /**
         * Converts an effect resource path back into a normal effect file path
         * @param {string} path
         * @param {string} [ext='fx']
         * @returns {string}
         */

    }, {
        key: 'FromEffectResPath',
        value: function FromEffectResPath(path) {
            var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fx';

            return path.substr(0, path.lastIndexOf('.')).replace(_Tw2Device.device.effectDir, '/effect/') + '.' + ext;
        }

        /**
         * Creates a Tw2Effect from an object
         * @param {{}} [opt={}]
         * @param {string} [opt.name='']
         * @param {string} [opt.effectFilePath='']
         * @param {boolean} [opt.autoParameter]
         * @param {{string: *}} [opt.parameters]
         * @param {{string: string}} [opt.textures]
         * @param {{string: {}}} [opt.overrides]
         * @returns {Tw2Effect}
         */

    }, {
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var effect = new Tw2Effect();
            if (opt.name) effect.name = opt.name;
            if (opt.effectFilePath) effect.effectFilePath = opt.effectFilePath;
            if (opt.parameters) effect.SetParameters(opt.parameters);
            if (opt.textures) effect.SetTextures(opt.textures);
            if (opt.overrides) effect.SetOverrides(opt.overrides);
            if ('autoParameter' in opt) effect.autoParameter = opt.autoParameter;
            effect.Initialize();
            return effect;
        }
    }]);

    return Tw2Effect;
}();

/**
 * Constant parameters which are ignored when creating an effect
 * @type {string[]}
 */


Tw2Effect.ConstantIgnore = ['PerFrameVS', 'PerObjectVS', 'PerFramePS', 'PerObjectPS', 'PerObjectPSInt'];

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Stores raw data for {@link Tw2PerObjectData} perObject objects and {@link EveSpaceScene} perFrame objects
 *
 * @param {[]} [declarationArray]
 * @param {boolean} [skipCreate]
 * @property {number} nextOffset
 * @property {Float32Array} data
 * @property {{}} elements
 */

var Tw2RawData = exports.Tw2RawData = function () {
    function Tw2RawData(declarationArray, skipCreate) {
        _classCallCheck(this, Tw2RawData);

        this.nextOffset = 0;
        this.data = null;
        this.elements = {};

        if (declarationArray) {
            this.DeclareFromArray(declarationArray, skipCreate);
        }
    }

    /**
     * Sets an element's value
     * @param {string|Object} name
     * @param {Float32Array|Array} [value]
     */


    _createClass(Tw2RawData, [{
        key: 'Set',
        value: function Set(name, value) {
            var el = this.elements[name];

            if (typeof value !== 'number' && value.length > el.size) {
                value = 'subarray' in value ? value.subarray(0, el.size) : value.splice(0, el.size);
            }

            this.data.set(value, el.offset);
        }

        /**
         * Gets an element's array value
         * @param {string} name
         * @return {Float32Array}
         */

    }, {
        key: 'Get',
        value: function Get(name) {
            return this.elements[name].array;
        }

        /**
         * Gets an element's array value from the share data array
         * @param {string} name
         * @return {Float32Array}
         */

    }, {
        key: 'GetData',
        value: function GetData(name) {
            return this.data.subarray(this.elements[name].offset, this.elements[name].offset + this.elements[name].array.length);
        }

        /**
         * Declares a raw data element and then returns the raw data element
         * @param {String} name
         * @param {number} size
         * @param {Array|Float32Array} [value=null] optional value to set on raw data creation
         * @returns {Tw2RawData}
         */

    }, {
        key: 'Declare',
        value: function Declare(name, size) {
            var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            this.elements[name] = {
                'offset': this.nextOffset,
                'size': size,
                'array': null,
                'value': value
            };
            this.nextOffset += size;
        }

        /**
         * Creates the raw data element arrays and then returns the raw data element
         * @returns {Tw2RawData}
         */

    }, {
        key: 'Create',
        value: function Create() {
            this.data = new Float32Array(this.nextOffset);
            for (var name in this.elements) {
                if (this.elements.hasOwnProperty(name)) {
                    var el = this.elements[name];
                    el.array = this.data.subarray(el.offset, el.offset + el.size);

                    if (el.value !== null) {
                        if (el.size === 1) {
                            el.array[0] = el.value;
                        } else {
                            for (var i = 0; i < el.size; i++) {
                                el.array[i] = el.value[i];
                            }
                        }
                        el.value = null;
                    }
                }
            }
        }

        /**
         * Declares elements from an array
         * @param {[]} declarationArray
         * @param {boolean} [skipCreate]
         * @returns {Tw2RawData}
         */

    }, {
        key: 'DeclareFromArray',
        value: function DeclareFromArray(declarationArray, skipCreate) {
            if (declarationArray) {
                for (var i = 0; i < declarationArray.length; i++) {
                    var el = declarationArray[i];
                    this.Declare(el.name, el.size, el.value);
                }
                if (!skipCreate) this.Create();
            }
        }
    }]);

    return Tw2RawData;
}();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryRes = exports.Tw2GeometryLineBatch = exports.Tw2GeometryBatch = undefined;
exports.Tw2GeometryMeshArea = Tw2GeometryMeshArea;
exports.Tw2GeometryMeshBinding = Tw2GeometryMeshBinding;
exports.Tw2GeometryModel = Tw2GeometryModel;
exports.Tw2GeometrySkeleton = Tw2GeometrySkeleton;
exports.Tw2GeometryBone = Tw2GeometryBone;
exports.Tw2GeometryAnimation = Tw2GeometryAnimation;
exports.Tw2GeometryTrackGroup = Tw2GeometryTrackGroup;
exports.Tw2GeometryTransformTrack = Tw2GeometryTransformTrack;
exports.Tw2GeometryCurve = Tw2GeometryCurve;
exports.Tw2BlendShapeData = Tw2BlendShapeData;
exports.Tw2GeometryMesh = Tw2GeometryMesh;

var _math = __webpack_require__(0);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Device = __webpack_require__(2);

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2Resource2 = __webpack_require__(11);

var _Tw2BinaryReader = __webpack_require__(18);

var _Tw2BatchAccumulator = __webpack_require__(23);

var _Tw2VertexDeclaration = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2GeometryBatch
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect} effect
 * @inherit Tw2RenderBatch
 * @class
 */
var Tw2GeometryBatch = exports.Tw2GeometryBatch = function (_Tw2RenderBatch) {
    _inherits(Tw2GeometryBatch, _Tw2RenderBatch);

    function Tw2GeometryBatch() {
        _classCallCheck(this, Tw2GeometryBatch);

        var _this = _possibleConstructorReturn(this, (Tw2GeometryBatch.__proto__ || Object.getPrototypeOf(Tw2GeometryBatch)).call(this));

        _this.geometryRes = null;
        _this.meshIx = 0;
        _this.start = 0;
        _this.count = 1;
        _this.effect = null;
        return _this;
    }

    return Tw2GeometryBatch;
}(_Tw2BatchAccumulator.Tw2RenderBatch);

/**
 * Commits the Geometry Batch for rendering
 * @param {Tw2Effect} [overrideEffect]
 */


Tw2GeometryBatch.prototype.Commit = function (overrideEffect) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (this.geometryRes && effect) {
        this.geometryRes.RenderAreas(this.meshIx, this.start, this.count, effect);
    }
};

/**
 * Tw2GeometryLineBatch
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect|null} effect
 * @inherit Tw2RenderBatch
 * @class
 */

var Tw2GeometryLineBatch = exports.Tw2GeometryLineBatch = function (_Tw2RenderBatch2) {
    _inherits(Tw2GeometryLineBatch, _Tw2RenderBatch2);

    function Tw2GeometryLineBatch() {
        _classCallCheck(this, Tw2GeometryLineBatch);

        var _this2 = _possibleConstructorReturn(this, (Tw2GeometryLineBatch.__proto__ || Object.getPrototypeOf(Tw2GeometryLineBatch)).call(this));

        _this2.geometryRes = null;
        _this2.meshIx = 0;
        _this2.start = 0;
        _this2.count = 1;
        _this2.effect = null;
        return _this2;
    }

    return Tw2GeometryLineBatch;
}(_Tw2BatchAccumulator.Tw2RenderBatch);

/**
 * Commits the Geometry Line Batch for rendering
 * @param {Tw2Effect} [overrideEffect]
 */


Tw2GeometryLineBatch.prototype.Commit = function (overrideEffect) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (this.geometryRes && effect) {
        this.geometryRes.RenderLines(this.meshIx, this.start, this.count, effect);
    }
};

/**
 * Tw2GeometryMeshArea
 * @property {string} name
 * @property {Number} start
 * @property {Number} count
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @constructor
 */
function Tw2GeometryMeshArea() {
    this.name = '';
    this.start = 0;
    this.count = 0;
    this.minBounds = _math.vec3.create();
    this.maxBounds = _math.vec3.create();
    this.boundsSpherePosition = _math.vec3.create();
    this.boundsSphereRadius = 0;
}

/**
 * Tw2GeometryMeshBinding
 * @property {Tw2GeometryMesh} mesh
 * @property {Array.<Tw2GeometryBone>} bones
 * @constructor
 */
function Tw2GeometryMeshBinding() {
    this.mesh = null;
    this.bones = [];
}

/**
 * Tw2GeometryModel
 * @property {string} name
 * @property {Array.<Tw2GeometryMeshBinding>} meshBindings
 * @property {Tw2GeometrySkeleton} skeleton
 * @constructor
 */
function Tw2GeometryModel() {
    this.name = '';
    this.meshBindings = [];
    this.skeleton = null;
}

/**
 * Finds a bone by it's name
 * @param {string} name
 * @returns {Tw2GeometryBone|null}
 * @constructor
 */
Tw2GeometryModel.prototype.FindBoneByName = function (name) {
    if (this.skeleton === null) {
        return null;
    }
    for (var b = 0; b < this.skeleton.bones.length; ++b) {
        if (this.skeleton.bones[b].name === name) {
            return this.skeleton.bones[b];
        }
    }
    return null;
};

/**
 * Tw2GeometrySkeleton
 * @property {Array.<Tw2GeometryBone>} bones
 * @constructor
 */
function Tw2GeometrySkeleton() {
    this.bones = [];
}

/**
 * Tw2GeometryBone
 * @property {string} name
 * @property {Number} parentIndex
 * @property {vec3} position
 * @property {quat} orientation
 * @property {mat3} scaleShear
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformInv
 * @constructor
 */
function Tw2GeometryBone() {
    this.name = '';
    this.parentIndex = -1;
    this.position = _math.vec3.create();
    this.orientation = _math.quat.create();
    this.scaleShear = _math.mat3.create();
    this.localTransform = _math.mat4.create();
    this.worldTransform = _math.mat4.create();
    this.worldTransformInv = _math.mat4.create();
}

/**
 * Scratch variables
 */
Tw2GeometryBone.scratch = {
    mat4_0: _math.mat4.create()
};

/**
 * Updates the Bone's transform
 * @returns {mat4}
 */
Tw2GeometryBone.prototype.UpdateTransform = function () {
    // Mat4 to mat4
    var l = this.localTransform,
        scale = this.scaleShear;

    l[0] = scale[0];
    l[1] = scale[1];
    l[2] = scale[2];
    l[4] = scale[3];
    l[5] = scale[4];
    l[6] = scale[5];
    l[8] = scale[6];
    l[9] = scale[7];
    l[10] = scale[8];
    l[3] = l[7] = l[11] = l[12] = l[13] = l[14] = 0;
    l[15] = 1;

    _math.quat.normalize(this.orientation, this.orientation);
    var rm = _math.mat4.fromQuat(Tw2GeometryBone.scratch.mat4_0, this.orientation);
    _math.mat4.multiply(this.localTransform, this.localTransform, rm);
    this.localTransform[12] = this.position[0];
    this.localTransform[13] = this.position[1];
    this.localTransform[14] = this.position[2];
    return this.localTransform;
};

/**
 * Tw2GeometryAnimation
 * @property {string} name
 * @property {Number} duration
 * @property {Array.<Tw2GeometryTrackGroup>} trackGroups
 * @constructor
 */
function Tw2GeometryAnimation() {
    this.name = '';
    this.duration = 0;
    this.trackGroups = [];
}

/**
 * Tw2GeometryTrackGroup
 * @property {string} name
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2GeometryTransformTrack>} transformTracks
 * @constructor
 */
function Tw2GeometryTrackGroup() {
    this.name = '';
    this.model = null;
    this.transformTracks = [];
}

/**
 * Tw2GeometryTransformTrack
 * @property {string} name
 * @property {Tw2GeometryCurve} position
 * @property {Tw2GeometryCurve} orientation
 * @property scaleShear
 * @constructor
 */
function Tw2GeometryTransformTrack() {
    this.name = '';
    this.position = null;
    this.orientation = null;
    this.scaleShear = null;
}

/**
 * Tw2GeometryCurve
 * @property {Number} dimension
 * @property {Number} degree
 * @property {Float32Array} knots
 * @property {Float32Array} controls
 * @constructor
 */
function Tw2GeometryCurve() {
    this.dimension = 0;
    this.degree = 0;
    this.knots = null;
    this.controls = null;
}

/**
 * Tw2BlendShapeData
 * @property {String} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array} buffers
 * @property indexes
 * @property weightProxy
 * @constructor
 */
function Tw2BlendShapeData() {
    this.name = '';
    this.declaration = new _Tw2VertexDeclaration.Tw2VertexDeclaration();
    this.buffers = [];
    this.indexes = null;
    this.weightProxy = null;
}

/**
 * Tw2GeometryMesh
 * @property {string} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array.<Tw2GeometryMeshArea>} areas
 * @property {WebGLBuffer} buffer
 * @property {Number} bufferLength
 * @property bufferData
 * @property {WebGLBuffer} indexes
 * @property indexData
 * @property {Number} indexType
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @property {Array} bones
 * @property {Array.<string>} boneBindings
 * @constructor
 */
function Tw2GeometryMesh() {
    this.name = '';
    this.declaration = new _Tw2VertexDeclaration.Tw2VertexDeclaration();
    this.areas = [];
    this.buffer = null;
    this.bufferLength = 0;
    this.bufferData = null;
    this.indexes = null;
    this.indexData = null;
    this.indexType = 0;
    this.minBounds = _math.vec3.create();
    this.maxBounds = _math.vec3.create();
    this.boundsSpherePosition = _math.vec3.create();
    this.boundsSphereRadius = 0;
    this.bones = [];
    this.boneBindings = [];
}

/**
 * Tw2GeometryRes
 * @property {Array} meshes
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @property {Array} models
 * @property {Array} animations
 * @property {Boolean} systemMirror
 * @inherit Tw2Resource
 * @class
 */

var Tw2GeometryRes = exports.Tw2GeometryRes = function (_Tw2Resource) {
    _inherits(Tw2GeometryRes, _Tw2Resource);

    function Tw2GeometryRes() {
        _classCallCheck(this, Tw2GeometryRes);

        var _this3 = _possibleConstructorReturn(this, (Tw2GeometryRes.__proto__ || Object.getPrototypeOf(Tw2GeometryRes)).call(this));

        _this3.meshes = [];
        _this3.minBounds = _math.vec3.create();
        _this3.maxBounds = _math.vec3.create();
        _this3.boundsSpherePosition = _math.vec3.create();
        _this3.boundsSphereRadius = 0;
        _this3.models = [];
        _this3.animations = [];
        _this3.systemMirror = _Tw2ResMan.resMan.systemMirror;
        return _this3;
    }

    return Tw2GeometryRes;
}(_Tw2Resource2.Tw2Resource);

/**
 * Request Response Type
 * @type {string}
 */


Tw2GeometryRes.prototype.requestResponseType = 'arraybuffer';

/**
 * GetInstanceBuffer
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceBuffer = function (meshIndex) {
    return meshIndex < this.meshes.length ? this.meshes[meshIndex].buffer : undefined;
};

/**
 * GetInstanceDeclaration
 * @param {Number} meshIndex
 * @returns {Tw2VertexDeclaration}
 */
Tw2GeometryRes.prototype.GetInstanceDeclaration = function (meshIndex) {
    return this.meshes[meshIndex].declaration;
};

/**
 * GetInstanceStride
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceStride = function (meshIndex) {
    return this.meshes[meshIndex].declaration.stride;
};

/**
 * GetInstanceCount
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceCount = function (meshIndex) {
    return this.meshes[meshIndex].bufferLength * 4 / this.meshes[meshIndex].declaration.stride;
};

/**
 * Prepare
 * @param data
 */
Tw2GeometryRes.prototype.Prepare = function (data) {
    var reader = new _Tw2BinaryReader.Tw2BinaryReader(new Uint8Array(data));
    var self = this;

    /**
     * ReadVertexBuffer
     * @param declaration
     * @returns {Float32Array}
     * @private
     */
    function ReadVertexBuffer(declaration) {
        var declCount = reader.ReadUInt8();
        var vertexSize = 0;
        var declIx, i;
        for (declIx = 0; declIx < declCount; ++declIx) {
            var element = new _Tw2VertexDeclaration.Tw2VertexElement();
            element.usage = reader.ReadUInt8();
            element.usageIndex = reader.ReadUInt8();
            element.fileType = reader.ReadUInt8();
            element.type = _Tw2Device.device.gl.FLOAT;
            element.elements = (element.fileType >> 5) + 1;
            element.offset = vertexSize * 4;
            declaration.elements[declIx] = element;
            vertexSize += element.elements;
        }
        declaration.RebuildHash();
        declaration.stride = vertexSize * 4;
        var vertexCount = reader.ReadUInt32();
        if (vertexCount === 0) {
            return null;
        }
        var buffer = new Float32Array(vertexSize * vertexCount);
        var index = 0;
        for (var vtxIx = 0; vtxIx < vertexCount; ++vtxIx) {
            for (declIx = 0; declIx < declCount; ++declIx) {
                var el = declaration.elements[declIx];
                switch (el.fileType & 0xf) {
                    case 0:
                        if (el.fileType & 0x10) {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadInt8() / 127.0;
                            }
                        } else {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadInt8();
                            }
                        }
                        break;

                    case 1:
                        if (el.fileType & 0x10) {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadInt8() / 32767.0;
                            }
                        } else {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadInt16();
                            }
                        }
                        break;

                    case 2:
                        for (i = 0; i < el.elements; ++i) {
                            buffer[index++] = reader.ReadInt32();
                        }
                        break;

                    case 3:
                        for (i = 0; i < el.elements; ++i) {
                            buffer[index++] = reader.ReadFloat16();
                        }
                        break;

                    case 4:
                        for (i = 0; i < el.elements; ++i) {
                            buffer[index++] = reader.ReadFloat32();
                        }
                        break;

                    case 8:
                        if (el.fileType & 0x10) {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadUInt8() / 255.0;
                            }
                        } else {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadUInt8();
                            }
                        }
                        break;

                    case 9:
                        if (el.fileType & 0x10) {
                            for (i = 0; i < declaration.elements[declIx].elements; ++i) {
                                buffer[index++] = reader.ReadUInt8() / 65535.0;
                            }
                        } else {
                            for (i = 0; i < el.elements; ++i) {
                                buffer[index++] = reader.ReadUInt16();
                            }
                        }
                        break;

                    case 10:
                        for (i = 0; i < el.elements; ++i) {
                            buffer[index++] = reader.ReadUInt32();
                        }
                        break;

                    default:
                        _Tw2EventEmitter.emitter.log('res.error', {
                            log: 'error',
                            src: ['Tw2GeometryRes', 'ReadVertexBuffer'],
                            msg: 'Error loading wbg data',
                            path: self.path,
                            type: 'geometry.filetype',
                            value: el.fileType & 0xf
                        });
                        throw 1;
                }
            }
        }
        return buffer;
    }

    /**
     * ReadIndexBuffer
     * @returns {Uint16Array|Uint32Array}
     * @private
     */
    function ReadIndexBuffer() {
        var ibType = reader.ReadUInt8();
        var indexCount = reader.ReadUInt32();
        var indexes, i;
        if (ibType === 0) {
            indexes = new Uint16Array(indexCount);
            for (i = 0; i < indexCount; ++i) {
                indexes[i] = reader.ReadUInt16();
            }
            return indexes;
        } else {
            indexes = new Uint32Array(indexCount);
            for (i = 0; i < indexCount; ++i) {
                indexes[i] = reader.ReadUInt32();
            }
            return indexes;
        }
    }

    /* var fileVersion = */
    reader.ReadUInt8();
    var meshCount = reader.ReadUInt8();
    for (var meshIx = 0; meshIx < meshCount; ++meshIx) {
        var mesh = new Tw2GeometryMesh();
        mesh.name = reader.ReadString();

        var buffer = ReadVertexBuffer(mesh.declaration);
        var i, j, k;
        if (buffer) {
            mesh.bufferLength = buffer.length;
            mesh.buffer = _Tw2Device.device.gl.createBuffer();
            _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ARRAY_BUFFER, mesh.buffer);
            _Tw2Device.device.gl.bufferData(_Tw2Device.device.gl.ARRAY_BUFFER, buffer, _Tw2Device.device.gl.STATIC_DRAW);
        } else {
            mesh.buffer = null;
        }

        var indexes = ReadIndexBuffer();
        if (indexes) {
            mesh.indexes = _Tw2Device.device.gl.createBuffer();
            mesh.indexType = indexes.BYTES_PER_ELEMENT === 2 ? _Tw2Device.device.gl.UNSIGNED_SHORT : _Tw2Device.device.gl.UNSIGNED_INT;
            _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);
            _Tw2Device.device.gl.bufferData(_Tw2Device.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _Tw2Device.device.gl.STATIC_DRAW);
        } else {
            mesh.indexes = null;
        }

        var areaCount = reader.ReadUInt8();
        for (i = 0; i < areaCount; ++i) {
            mesh.areas[i] = new Tw2GeometryMeshArea();
            mesh.areas[i].name = reader.ReadString();
            mesh.areas[i].start = reader.ReadUInt32() * indexes.BYTES_PER_ELEMENT;
            mesh.areas[i].count = reader.ReadUInt32() * 3;
            mesh.areas[i].minBounds = _math.vec3.fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
            mesh.areas[i].maxBounds = _math.vec3.fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
        }

        var boneBindingCount = reader.ReadUInt8();
        mesh.boneBindings = [];
        for (i = 0; i < boneBindingCount; ++i) {
            mesh.boneBindings[i] = reader.ReadString();
        }

        var annotationSetCount = reader.ReadUInt16();
        if (annotationSetCount || this.systemMirror) {
            mesh.bufferData = buffer;
            mesh.indexData = indexes;
        }
        if (annotationSetCount) {
            mesh.blendShapes = [];
            for (i = 0; i < annotationSetCount; ++i) {
                mesh.blendShapes[i] = new Tw2BlendShapeData();
                mesh.blendShapes[i].name = reader.ReadString();
                mesh.blendShapes[i].buffer = ReadVertexBuffer(mesh.blendShapes[i].declaration);
                mesh.blendShapes[i].indexes = ReadIndexBuffer();
            }
        }
        this.meshes[meshIx] = mesh;
    }

    var modelCount = reader.ReadUInt8();
    for (var modelIx = 0; modelIx < modelCount; ++modelIx) {
        var model = new Tw2GeometryModel();
        model.name = reader.ReadString();

        model.skeleton = new Tw2GeometrySkeleton();
        var boneCount = reader.ReadUInt8();
        for (j = 0; j < boneCount; ++j) {
            var bone = new Tw2GeometryBone();
            bone.name = reader.ReadString();
            var flags = reader.ReadUInt8();
            bone.parentIndex = reader.ReadUInt8();
            if (bone.parentIndex === 255) {
                bone.parentIndex = -1;
            }
            if (flags & 1) {
                _math.vec3.set(bone.position, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
            } else {
                _math.vec3.set(bone.position, 0, 0, 0);
            }
            if (flags & 2) {
                _math.quat.set(bone.orientation, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
            } else {
                _math.quat.identity(bone.orientation);
            }
            if (flags & 4) {
                for (k = 0; k < 9; ++k) {
                    bone.scaleShear[k] = reader.ReadFloat32();
                }
            } else {
                _math.mat3.identity(bone.scaleShear);
            }
            model.skeleton.bones[j] = bone;
        }
        for (j = 0; j < model.skeleton.bones.length; ++j) {
            model.skeleton.bones[j].UpdateTransform();
            if (model.skeleton.bones[j].parentIndex !== -1) {
                _math.mat4.multiply(model.skeleton.bones[j].worldTransform, model.skeleton.bones[model.skeleton.bones[j].parentIndex].worldTransform, model.skeleton.bones[j].localTransform);
            } else {
                _math.mat4.copy(model.skeleton.bones[j].worldTransform, model.skeleton.bones[j].localTransform);
            }
            _math.mat4.invert(model.skeleton.bones[j].worldTransformInv, model.skeleton.bones[j].worldTransform);
        }

        var meshBindingCount = reader.ReadUInt8();
        for (j = 0; j < meshBindingCount; ++j) {
            mesh = reader.ReadUInt8();
            if (mesh < this.meshes.length) {
                Tw2GeometryRes.BindMeshToModel(this.meshes[mesh], model);
            }
        }
        this.models[this.models.length] = model;
    }

    /**
     * ReadCurve
     * @returns {Tw2GeometryCurve}
     * @private
     */
    function ReadCurve() {
        var type = reader.ReadUInt8();
        if (type === 0) {
            return null;
        }
        var dimension = reader.ReadUInt8();
        var curve = new Tw2GeometryCurve();
        curve.dimension = dimension;
        curve.degree = reader.ReadUInt8();
        var knotCount = reader.ReadUInt32();
        curve.knots = new Float32Array(knotCount);
        for (var i = 0; i < knotCount; ++i) {
            curve.knots[i] = reader.ReadFloat32();
        }
        var controlCount = reader.ReadUInt32();
        curve.controls = new Float32Array(controlCount);
        for (i = 0; i < controlCount; ++i) {
            curve.controls[i] = reader.ReadFloat32();
        }
        return curve;
    }

    var animationCount = reader.ReadUInt8();
    for (i = 0; i < animationCount; ++i) {
        var animation = new Tw2GeometryAnimation();
        animation.name = reader.ReadString();
        animation.duration = reader.ReadFloat32();
        var groupCount = reader.ReadUInt8();
        for (j = 0; j < groupCount; ++j) {
            var group = new Tw2GeometryTrackGroup();
            group.name = reader.ReadString();
            for (var m = 0; m < this.models.length; ++m) {
                if (this.models[m].name === group.name) {
                    group.model = this.models[m];
                    break;
                }
            }
            var transformTrackCount = reader.ReadUInt8();
            for (k = 0; k < transformTrackCount; ++k) {
                var track = new Tw2GeometryTransformTrack();
                track.name = reader.ReadString();
                track.orientation = ReadCurve();
                track.position = ReadCurve();
                track.scaleShear = ReadCurve();
                if (track.orientation) {
                    var lastX = 0;
                    var lastY = 0;
                    var lastZ = 0;
                    var lastW = 0;
                    for (var n = 0; n < track.orientation.controls.length; n += 4) {
                        var x = track.orientation.controls[n];
                        var y = track.orientation.controls[n + 1];
                        var z = track.orientation.controls[n + 2];
                        var w = track.orientation.controls[n + 3];
                        if (lastX * x + lastY * y + lastZ * z + lastW * w < 0) {
                            track.orientation.controls[n] = -x;
                            track.orientation.controls[n + 1] = -y;
                            track.orientation.controls[n + 2] = -z;
                            track.orientation.controls[n + 3] = -w;
                        }
                        lastX = x;
                        lastY = y;
                        lastZ = z;
                        lastW = w;
                    }
                }
                group.transformTracks[group.transformTracks.length] = track;
            }
            animation.trackGroups[animation.trackGroups.length] = group;
        }
        this.animations[this.animations.length] = animation;
    }
    this.PrepareFinished(true);
};

/**
 * BindMeshToModel
 * @param {Tw2GeometryMesh} mesh
 * @param {Tw2GeometryModel} model
 */
Tw2GeometryRes.BindMeshToModel = function (mesh, model) {
    var binding = new Tw2GeometryMeshBinding();
    binding.mesh = mesh;
    for (var b = 0; b < binding.mesh.boneBindings.length; ++b) {
        var name = binding.mesh.boneBindings[b];
        var bone = model.FindBoneByName(name);
        if (bone === null) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2GeometryRes', 'BindMeshToModel'],
                msg: 'Mesh has invalid bone name for model',
                path: this.path,
                type: 'geometry.invalidbone',
                data: {
                    mesh: binding.mesh.name,
                    bone: name,
                    model: model.name
                }
            });
        } else {
            binding.bones[binding.bones.length] = bone;
        }
    }
    model.meshBindings[model.meshBindings.length] = binding;
};

/**
 * RenderAreasInstanced
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param instanceVB
 * @param instanceDecl
 * @param instanceStride
 * @param instanceCount
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderAreasInstanced = function (meshIx, start, count, effect, instanceVB, instanceDecl, instanceStride, instanceCount) {
    this.KeepAlive();
    if (!this._isGood) {
        return false;
    }

    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood) {
        return false;
    }
    var d = _Tw2Device.device;
    var mesh = this.meshes[meshIx];
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (passInput.elements.length === 0) {
            continue;
        }
        d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
        mesh.declaration.SetPartialDeclaration(passInput, mesh.declaration.stride);
        d.gl.bindBuffer(d.gl.ARRAY_BUFFER, instanceVB);
        var resetData = instanceDecl.SetPartialDeclaration(passInput, instanceStride, 8, 1);
        d.ApplyShadowState();

        for (i = 0; i < count; ++i) {
            if (i + start < mesh.areas.length) {
                area = mesh.areas[i + start];
                var areaStart = area.start;
                var acount = area.count;
                while (i + 1 < count) {
                    area = mesh.areas[i + 1 + start];
                    if (area.start !== areaStart + acount * 2) {
                        break;
                    }
                    acount += area.count;
                    ++i;
                }
                d.ext.drawElementsInstanced(d.gl.TRIANGLES, acount, mesh.indexType, areaStart, instanceCount);
            }
        }
        instanceDecl.ResetInstanceDivisors(resetData);
    }
    return true;
};

/**
 * RenderAreas
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param {callback} cb - callback[pass, drawElements]
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderAreas = function (meshIx, start, count, effect, cb) {
    this.KeepAlive();
    if (!this._isGood) {
        return false;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood) {
        return false;
    }
    var d = _Tw2Device.device;
    var mesh = this.meshes[meshIx] || this.meshes[0];
    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2GeometryRes', 'RenderLines'],
                msg: 'Error binding mesh to effect',
                path: this.path,
                type: 'geometry.meshbind',
                data: {
                    pass: pass,
                    passInput: passInput,
                    meshStride: mesh.declaration.stride
                }
            });
            return false;
        }
        d.ApplyShadowState();

        if (typeof cb !== 'undefined') {
            var drawElements = [];
            for (i = 0; i < count; ++i) {
                if (i + start < mesh.areas.length) {
                    area = mesh.areas[i + start];
                    drawElements.push([d.gl.TRIANGLES, area.count, mesh.indexType, area.start]);
                }
            }
            cb(pass, drawElements);
        } else {
            for (i = 0; i < count; ++i) {
                if (i + start < mesh.areas.length) {
                    area = mesh.areas[i + start];
                    var areaStart = area.start;
                    var acount = area.count;
                    while (i + 1 < count) {
                        area = mesh.areas[i + 1 + start];
                        if (area.start !== areaStart + acount * 2) {
                            break;
                        }
                        acount += area.count;
                        ++i;
                    }
                    d.gl.drawElements(d.gl.TRIANGLES, acount, mesh.indexType, areaStart);
                }
            }
        }
    }
    return true;
};

/**
 * RenderLines
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param {function} cb - callback[pass, drawElements]
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderLines = function (meshIx, start, count, effect, cb) {
    this.KeepAlive();
    if (!this._isGood) {
        return false;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood) {
        return false;
    }
    if (meshIx >= this.meshes.length) {
        return false;
    }
    var d = _Tw2Device.device;
    var mesh = this.meshes[meshIx];
    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2GeometryRes', 'RenderLines'],
                msg: 'Error binding mesh to effect',
                path: this.path,
                type: 'geometry.meshbind',
                data: {
                    pass: pass,
                    passInput: passInput,
                    meshStride: mesh.declaration.stride
                }
            });
            return false;
        }

        d.ApplyShadowState();

        if (typeof cb !== 'undefined') {
            var drawElements = [];
            for (i = 0; i < count; ++i) {
                if (i + start < mesh.areas.length) {
                    area = mesh.areas[i + start];
                    drawElements.push([d.gl.LINES, area.count, mesh.indexType, area.start]);
                }
            }
            cb(pass, drawElements);
        } else {
            for (i = 0; i < count; ++i) {
                if (i + start < mesh.areas.length) {
                    area = mesh.areas[i + start];
                    var areaStart = area.start;
                    var acount = area.count;
                    while (i + 1 < count) {
                        area = mesh.areas[i + 1 + start];
                        if (area.start !== areaStart + acount * 2) {
                            break;
                        }
                        acount += area.count;
                        ++i;
                    }
                    d.gl.drawElements(d.gl.LINES, acount, mesh.indexType, areaStart);
                }
            }
        }
    }
    return true;
};

/**
 * RenderDebugInfo
 * @param {function} debugHelper
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderDebugInfo = function (debugHelper) {
    if (!this.IsGood()) {
        return false;
    }
    for (var i = 0; i < this.models.length; ++i) {
        if (this.models[i].skeleton) {
            for (var j = 0; j < this.models[i].skeleton.bones.length; ++j) {
                var b0 = this.models[i].skeleton.bones[j];
                if (b0.parentIndex >= 0) {
                    var b1 = this.models[i].skeleton.bones[b0.parentIndex];
                    debugHelper.AddLine([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]], [0, 0.7, 0, 1], [0, 0.7, 0, 1]);
                }
            }
        }
    }
};

/**
 * Unloads webgl and javascript resources
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.Unload = function () {
    for (var i = 0; i < this.meshes.length; ++i) {
        if (this.meshes[i].buffer) {
            _Tw2Device.device.gl.deleteBuffer(this.meshes[i].buffer);
            this.meshes[i].buffer = null;
        }
        if (this.meshes[i].indexes) {
            _Tw2Device.device.gl.deleteBuffer(this.meshes[i].indexes);
            this.meshes[i].indexes = null;
        }
    }
    this._isPurged = true;
    this._isGood = false;
    return true;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ForwardingRenderBatch = exports.Tw2RenderBatch = undefined;
exports.Tw2BatchAccumulator = Tw2BatchAccumulator;

var _Tw2Device = __webpack_require__(2);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Render Batches
 * @typedef {(Tw2RenderBatch|Tw2ForwardingRenderBatch|Tw2GeometryBatch|Tw2GeometryLineBatch|Tw2InstancedMeshBatch|EvePlaneSetBatch|EveBoosterBatch|EveSpotlightSetBatch|EveSpriteSetBatch)} RenderBatch
 */

/**
 * Accumulates render batches for rendering
 * @param {function} [sorting] - An optional function for sorting the collected render batches
 * @property {Array.<RenderBatch>} batches
 * @property {number} count - How many batch array elements will be processed
 * @property {function} _sortMethod - the stored sorting function
 * @constructor
 */
function Tw2BatchAccumulator(sorting) {
    this.batches = [];
    this.count = 0;
    this._sortMethod = sorting ? sorting : undefined;
}

/**
 * Commits a batch to accumulation
 * @param {RenderBatch} batch
 * @prototype
 */
Tw2BatchAccumulator.prototype.Commit = function (batch) {
    this.batches[this.count++] = batch;
};

/**
 * Clears any accumulated render batches
 * @prototype
 */
Tw2BatchAccumulator.prototype.Clear = function () {
    this.count = 0;
    this.batches = [];
};

/**
 * Renders the accumulated render batches
 * - If a sorting function has been defined the render batches will be sorted before rendering
 * @param {Tw2Effect} [overrideEffect]
 * @prototype
 */
Tw2BatchAccumulator.prototype.Render = function (overrideEffect) {
    if (typeof this._sortMethod !== 'undefined') {
        this.batches.sort(this._sortMethod);
    }
    for (var i = 0; i < this.count; ++i) {
        if (this.batches[i].renderMode !== _Tw2Device.device.RM_ANY) {
            _Tw2Device.device.SetStandardStates(this.batches[i].renderMode);
        }
        _Tw2Device.device.perObjectData = this.batches[i].perObjectData;
        this.batches[i].Commit(overrideEffect);
    }
};

/**
 * A standard render batch
 * @property {number} renderMode
 * @property {Tw2PerObjectData} perObjectData
 * @class
 */

var Tw2RenderBatch = exports.Tw2RenderBatch = function Tw2RenderBatch() {
    _classCallCheck(this, Tw2RenderBatch);

    this.renderMode = _Tw2Device.device.RM_ANY;
    this.perObjectData = null;
};

/**
 * A render batch that uses geometry provided from an external source
 * @property {*} geometryProvider
 * @inherits Tw2RenderBatch
 * @class
 */


var Tw2ForwardingRenderBatch = exports.Tw2ForwardingRenderBatch = function (_Tw2RenderBatch) {
    _inherits(Tw2ForwardingRenderBatch, _Tw2RenderBatch);

    function Tw2ForwardingRenderBatch() {
        _classCallCheck(this, Tw2ForwardingRenderBatch);

        var _this = _possibleConstructorReturn(this, (Tw2ForwardingRenderBatch.__proto__ || Object.getPrototypeOf(Tw2ForwardingRenderBatch)).call(this));

        _this.geometryProvider = null;
        return _this;
    }

    return Tw2ForwardingRenderBatch;
}(Tw2RenderBatch);

/**
 * Commits the batch for rendering
 * @param {Tw2Effect} [overrideEffect]
 * @prototype
 */


Tw2ForwardingRenderBatch.prototype.Commit = function (overrideEffect) {
    if (this.geometryProvider) {
        this.geometryProvider.Render(this, overrideEffect);
    }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TextureRes = undefined;

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2Device = __webpack_require__(2);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Resource2 = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2TextureRes
 * @property {WebglTexture} texture
 * @property {boolean} isCube
 * @property {Array} images
 * @property {number} width
 * @property {number} height
 * @property {number} _facesLoaded
 * @property {boolean} hasMipMaps
 * @property {number} _currentSampler
 * @inherit Tw2Resource
 * @class
 */
var Tw2TextureRes = exports.Tw2TextureRes = function (_Tw2Resource) {
    _inherits(Tw2TextureRes, _Tw2Resource);

    function Tw2TextureRes() {
        _classCallCheck(this, Tw2TextureRes);

        var _this = _possibleConstructorReturn(this, (Tw2TextureRes.__proto__ || Object.getPrototypeOf(Tw2TextureRes)).call(this));

        _this.texture = null;
        _this.isCube = false;
        _this.images = [];
        _this.width = 0;
        _this.height = 0;
        _this._facesLoaded = 0;
        _this.hasMipMaps = false;
        _this._currentSampler = 0;
        return _this;
    }

    return Tw2TextureRes;
}(_Tw2Resource2.Tw2Resource);

/**
 * Prepare
 * @param {string} text - Used to identify the type of image, options are 'cube' or anything else
 * @prototype
 */


Tw2TextureRes.prototype.Prepare = function (text) {
    var format = _Tw2Device.device.gl.RGBA;

    if (this.images[0].ccpGLFormat) {
        format = this.images[0].ccpGLFormat;
    }

    if (text === 'cube') {
        this.texture = _Tw2Device.device.gl.createTexture();
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_CUBE_MAP, this.texture);

        var canvas = document.createElement('canvas');
        canvas.width = canvas.height = this.images[0].height;
        var ctx = canvas.getContext('2d');
        for (var j = 0; j < 6; ++j) {
            ctx.drawImage(this.images[0], j * canvas.width, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
            _Tw2Device.device.gl.texImage2D(_Tw2Device.device.gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, format, format, _Tw2Device.device.gl.UNSIGNED_BYTE, canvas);
        }
        _Tw2Device.device.gl.generateMipmap(_Tw2Device.device.gl.TEXTURE_CUBE_MAP);
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_CUBE_MAP, null);
        this.width = canvas.width;
        this.height = canvas.height;
        this.hasMipMaps = true;
        this.PrepareFinished(true);
    } else {
        this.texture = _Tw2Device.device.gl.createTexture();
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, this.texture);
        _Tw2Device.device.gl.texImage2D(_Tw2Device.device.gl.TEXTURE_2D, 0, format, format, _Tw2Device.device.gl.UNSIGNED_BYTE, this.images[0]);
        this.hasMipMaps = this.IsPowerOfTwo(this.images[0].width) && this.IsPowerOfTwo(this.images[0].height);
        if (this.hasMipMaps) {
            _Tw2Device.device.gl.generateMipmap(_Tw2Device.device.gl.TEXTURE_2D);
        }
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, null);
        this.width = this.images[0].width;
        this.height = this.images[0].height;
        this.PrepareFinished(true);
    }
    delete this.images;
};

/**
 * Finds out if a number is to the power of 2
 * @param {number} x
 * @returns {boolean}
 * @prototype
 */
Tw2TextureRes.prototype.IsPowerOfTwo = function (x) {
    return (x & x - 1) === 0;
};

/**
 * An optional method Tw2objects can have that allows them to take over the construction of it's components during resource loading
 * @param {string} path - texture resource path
 * @returns {boolean}
 * @prototype
 */
Tw2TextureRes.prototype.DoCustomLoad = function (path) {
    var index;

    this.LoadStarted();
    this.images = [];
    var self = this;

    path = _Tw2ResMan.resMan.BuildUrl(path);

    var mipExt = '';
    if (_Tw2Device.device.mipLevelSkipCount > 0) {
        mipExt = '.' + _Tw2Device.device.mipLevelSkipCount.toString();
    }

    if (path.substr(-5) === '.cube') {
        _Tw2ResMan.resMan._pendingLoads++;
        this.isCube = true;
        this.images[0] = new Image();
        this.images[0].crossOrigin = 'anonymous';
        this.images[0].onerror = function () {
            _Tw2ResMan.resMan._pendingLoads--;
            self.LoadFinished(false);
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2TextureRes', 'DoCustomLoad'],
                msg: 'Error loading resource',
                type: 'http.error',
                path: self.path
            });
            delete self.images;
        };
        this.images[0].onload = function () {
            _Tw2ResMan.resMan._pendingLoads--;
            self.LoadFinished(true);
            _Tw2ResMan.resMan._prepareQueue.push([self, 'cube', null]);
        };
        path = path.substr(0, path.length - 5) + '.png';
        if (_Tw2Device.device.mipLevelSkipCount > 0) {
            index = path.lastIndexOf('.');
            if (index >= 0) {
                path = path.substr(0, index - 2) + mipExt + path.substr(index);
            }
        }
        this.images[0].src = path;
    } else {
        _Tw2ResMan.resMan._pendingLoads++;
        this.isCube = false;
        this.images[0] = new Image();
        this.images[0].crossOrigin = 'anonymous';
        this.images[0].onerror = function () {
            _Tw2ResMan.resMan._pendingLoads--;
            self.LoadFinished(false);
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2TextureRes', 'DoCustomLoad'],
                msg: 'Error loading resource',
                type: 'http.error',
                path: self.path
            });
            delete self.images;
        };
        this.images[0].onload = function () {
            _Tw2ResMan.resMan._pendingLoads--;
            self.LoadFinished(true);
            _Tw2ResMan.resMan._prepareQueue.push([self, '', null]);
        };
        if (_Tw2Device.device.mipLevelSkipCount > 0) {
            index = path.lastIndexOf('.');
            if (index >= 0) {
                path = path.substr(0, index - 2) + mipExt + path.substr(index);
            }
        }
        this.images[0].src = path;
    }
    return true;
};

/**
 * Unloads the texture from memory
 * @returns {boolean}
 * @constructor
 */
Tw2TextureRes.prototype.Unload = function () {
    if (this.texture) {
        _Tw2Device.device.gl.deleteTexture(this.texture);
        this.texture = null;
        this.isPurged = true;
    }
    this._isPurged = true;
    this._isGood = false;
    return true;
};

/**
 * Attach
 * @param {WebglTexture} texture
 * @constructor
 */
Tw2TextureRes.prototype.Attach = function (texture) {
    this.texture = texture;
    this.LoadFinished(true);
    this.PrepareFinished(true);
};

/**
 * Bind
 * @param sampler
 * @param slices
 * @constructor
 */
Tw2TextureRes.prototype.Bind = function (sampler, slices) {
    this.KeepAlive();
    var targetType = sampler.samplerType;
    if (targetType !== (this.isCube ? _Tw2Device.device.gl.TEXTURE_CUBE_MAP : _Tw2Device.device.gl.TEXTURE_2D)) {
        return;
    }
    if (this.texture === null) {
        _Tw2Device.device.gl.bindTexture(targetType, targetType === _Tw2Device.device.gl.TEXTURE_2D ? _Tw2Device.device.GetFallbackTexture() : _Tw2Device.device.GetFallbackCubeMap());
        return;
    }
    if (sampler.isVolume) {
        _Tw2Device.device.gl.uniform1f(slices, this.height / this.width);
    }
    _Tw2Device.device.gl.bindTexture(targetType, this.texture);
    if (sampler.hash !== this._currentSampler) {
        sampler.Apply(this.hasMipMaps);
        this._currentSampler = sampler.hash;
    }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector4Parameter = Tw2Vector4Parameter;

var _math = __webpack_require__(0);

/**
 * Tw2Vector4Parameter
 * @param {string} [name='']
 * @param {vec4|Float32Array} [value=[1,1,1,1]]
 * @property {string} name
 * @property {vec4|Float32Array} value
 * @property {Float32Array} constantBuffer
 * @property {number} offset
 * @constructor
 */
function Tw2Vector4Parameter(name, value) {
    this.name = name !== 'undefined' ? name : '';
    this.value = value !== undefined ? _math.vec4.clone(value) : _math.vec4.fromValues(1, 1, 1);
    this.constantBuffer = null;
    this.offset = 0;
}

/**
 * Bind
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @returns {boolean}
 * @prototype
 */
Tw2Vector4Parameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 4) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
    return true;
};

/**
 * Unbind
 * @prototype
 */
Tw2Vector4Parameter.prototype.Unbind = function () {
    this.constantBuffer = null;
};

/**
 * Sets a supplied value
 * @param {vec4|Float32Array|Array} value - Vector4 Array
 * @prototype
 */
Tw2Vector4Parameter.prototype.SetValue = function (value) {
    _math.vec4.copy(this.value, value);
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Updates the constant buffer to the current value
 * @prototype
 */
Tw2Vector4Parameter.prototype.OnValueChanged = function () {
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Applies the current value to the supplied constant buffer at the supplied offset
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @prototype
 */
Tw2Vector4Parameter.prototype.Apply = function (constantBuffer, offset) {
    constantBuffer.set(this.value, offset);
};

/**
 * Gets the current value array
 * @return {vec4|Float32Array} Vector4 Array
 * @prototype
 */
Tw2Vector4Parameter.prototype.GetValue = function () {
    if (this.constantBuffer !== null) {
        return _math.vec4.clone(this.constantBuffer.subarray(this.offset, this.offset + this.value.length));
    }

    return _math.vec4.clone(this.value);
};

/**
 * Returns a value from a specific index of the value array
 * @param {number} index
 * @returns {number}
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector4Parameter.prototype.GetIndexValue = function (index) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    if (this.constantBuffer !== null) {
        return this.constantBuffer[this.offset + index];
    }

    return this.value[index];
};

/**
 * Sets a value at a specific index of the value array
 * @param {number} index
 * @param {number} value
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector4Parameter.prototype.SetIndexValue = function (index, value) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    this.value[index] = value;

    if (this.constantBuffer !== null) {
        this.constantBuffer[this.offset + index] = value;
    }
};

/**
 * Sets all value array elements to a single value
 * @param {number} value - The value to fill the value array elements with
 * @prototype
 */
Tw2Vector4Parameter.prototype.FillWith = function (value) {
    this.SetValue([value, value, value, value]);
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2Vector4Parameter.is = function (value) {
    return _math.util.isArrayLike(value) && value.length === 4;
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleAttributeGenerator base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @class
 */
var Tw2ParticleAttributeGenerator = exports.Tw2ParticleAttributeGenerator = function () {
    function Tw2ParticleAttributeGenerator() {
        _classCallCheck(this, Tw2ParticleAttributeGenerator);

        this._id = _math.util.generateID();
        this.name = '';
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2ParticleAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {}
    }]);

    return Tw2ParticleAttributeGenerator;
}();

Tw2ParticleAttributeGenerator.global = {
    vec3_0: _math.vec3.create()
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpaceObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveSpaceObject
 *
 * @parameter {String} name
 * @parameter {boolean} display                             - Enables/ disables visibility
 * @parameter {{}} visible                                  - Visibility options for the space object's elements
 * @parameter {boolean} visible.mesh                        - Enables/ disables mesh visibility
 * @parameter {boolean} visible.children                    - Enables/ disables child visibility
 * @parameter {boolean} visible.effectChildren              - Enables/ disables effect child visibility
 * @parameter {boolean} visible.spriteSets                  - Enables/ disables sprite visibility
 * @parameter {boolean} visible.decals                      - Enables/ disables decal visibility
 * @parameter {boolean} visible.spotlightSets               - Enables/ disables spotlight visibility
 * @parameter {boolean} visible.planeSets                   - Enables/ disables plane visibility
 * @parameter {boolean} visible.lineSets                    - Enables/ disables lines visibility
 * @parameter {boolean} visible.overlayEffects              - Enables/ disables overlay effect visibility
 * @parameter {boolean} visible.killmarks                   - Enables/ disables killmark visibility
 * @parameter {boolean} visible.customMasks                 - Enables/ disables custom mask visibility
 * @parameter {Number} lod
 * @parameter {Tw2Mesh} mesh
 * @parameter {Array.<EveLocator>} locators
 * @parameter {Array.<EveSpriteSet>} spriteSets
 * @parameter {Array.<EveTurretSet>} turretSets
 * @parameter {Array.<EveSpaceObjectDecal>} decals
 * @parameter {Array.<EveSpotlightSet>} spotlightSets
 * @parameter {Array.<EvePlaneSet>} planeSets
 * @parameter {Array.<Tw2CurveSet>} curveSets
 * @parameter {Array.<EveCurveLineSet>} lineSets
 * @parameter {Array.<EveMeshOverlayEffect>} overlayEffects
 * @parameter {Array.<{}>} children
 * @parameter {vec3} boundingSphereCenter
 * @parameter {Number} boundingSphereRadius
 * @parameter {vec3} shapeEllipsoidRadius
 * @parameter {vec3} shapeEllipsoidCenter
 * @parameter {mat4} transform
 * @parameter {Tw2AnimationController} animation
 * @parameter {number} killCount                            - number of kills to show on kill counter decals
 * @parameter {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveSpaceObject = exports.EveSpaceObject = function (_EveObject) {
    _inherits(EveSpaceObject, _EveObject);

    function EveSpaceObject() {
        _classCallCheck(this, EveSpaceObject);

        var _this = _possibleConstructorReturn(this, (EveSpaceObject.__proto__ || Object.getPrototypeOf(EveSpaceObject)).call(this));

        _this.visible = {};
        _this.visible.mesh = true;
        _this.visible.children = true;
        _this.visible.effectChildren = true;
        _this.visible.planeSets = true;
        _this.visible.spotlightSets = true;
        _this.visible.decals = true;
        _this.visible.spriteSets = true;
        _this.visible.overlayEffects = true;
        _this.visible.lineSets = true;
        _this.visible.killmarks = true;
        _this.visible.customMasks = true;
        _this.mesh = null;
        _this.animation = new _core.Tw2AnimationController();
        _this.locators = [];
        _this.spriteSets = [];
        _this.turretSets = [];
        _this.decals = [];
        _this.spotlightSets = [];
        _this.planeSets = [];
        _this.curveSets = [];
        _this.lineSets = [];
        _this.overlayEffects = [];
        _this.children = [];
        _this.effectChildren = [];
        _this.customMasks = [];
        _this.lod = 3;
        _this.killCount = 0;
        _this.transform = _math.mat4.create();
        _this.boundingSphereCenter = _math.vec3.create();
        _this.boundingSphereRadius = 0;
        _this.shapeEllipsoidRadius = _math.vec3.create();
        _this.shapeEllipsoidCenter = _math.vec3.create();
        _this._perObjectData = new _core.Tw2PerObjectData(EveSpaceObject.perObjectDataDecl);
        return _this;
    }

    /**
     * Initializes the EveSpaceObject
     */


    _createClass(EveSpaceObject, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.mesh) {
                this.animation.SetGeometryResource(this.mesh.geometryResource);

                for (var i = 0; i < this.decals.length; ++i) {
                    this.decals[i].SetParentGeometry(this.mesh.geometryResource);
                }
            }
        }

        /**
         * Resets the lod
         */

    }, {
        key: 'ResetLod',
        value: function ResetLod() {
            this.lod = 3;
        }

        /**
         * Updates the lod
         * @param {Tw2Frustum} frustum
         */

    }, {
        key: 'UpdateLod',
        value: function UpdateLod(frustum) {
            var center = _math.vec3.transformMat4(EveSpaceObject.global.vec3_0, this.boundingSphereCenter, this.transform);

            if (frustum.IsSphereVisible(center, this.boundingSphereRadius)) {
                if (frustum.GetPixelSizeAcross(center, this.boundingSphereRadius) < 100) {
                    this.lod = 1;
                } else {
                    this.lod = 2;
                }
            } else {
                this.lod = 0;
            }
        }

        /**
         * Adds a custom mask
         * @param {vec3} position
         * @param {vec3} scaling
         * @param {quat} rotation
         * @param {vec4} isMirrored
         * @param {vec4} sourceMaterial
         * @param {vec4} targetMaterials
         */

    }, {
        key: 'AddCustomMask',
        value: function AddCustomMask(position, scaling, rotation, isMirrored, sourceMaterial, targetMaterials) {
            var transform = _math.mat4.fromRotationTranslationScale(_math.mat4.create(), rotation, position, scaling);
            _math.mat4.invert(transform, transform);
            _math.mat4.transpose(transform, transform);

            this.customMasks.push({
                transform: transform,
                maskData: _math.vec4.fromValues(1, isMirrored ? 1 : 0, 0, 0),
                materialID: _math.vec4.fromValues(sourceMaterial, 0, 0, 0),
                targets: targetMaterials
            });
        }

        /**
         * Gets locator count for a specific locator group
         * @param {String} prefix
         * @returns {number}
         */

    }, {
        key: 'GetLocatorCount',
        value: function GetLocatorCount(prefix) {
            var count = 0;
            for (var i = 0; i < this.locators.length; ++i) {
                if (this.locators[i].name.substr(0, prefix.length) === prefix) {
                    ++count;
                }
            }
            return count;
        }

        /**
         * Finds a locator joint by it's name
         * @param {String} name
         * @returns {null|mat4}
         */

    }, {
        key: 'FindLocatorJointByName',
        value: function FindLocatorJointByName(name) {
            var model = this.animation.FindModelForMesh(0);
            if (model) {
                for (var i = 0; i < model.bones.length; ++i) {
                    if (model.bones[i].boneRes.name === name) {
                        return model.bones[i].worldTransform;
                    }
                }
            }
            return null;
        }

        /**
         * Finds a locator transform by it's name
         * @param {String} name
         * @returns {null|mat4}
         */

    }, {
        key: 'FindLocatorTransformByName',
        value: function FindLocatorTransformByName(name) {
            for (var i = 0; i < this.locators.length; ++i) {
                if (this.locators[i].name === name) {
                    return this.locators[i].transform;
                }
            }
            return null;
        }

        /**
         * Finds locators with a given prefix
         * @param {string} prefix
         * @returns {Array}
         */

    }, {
        key: 'FindLocatorsByPrefix',
        value: function FindLocatorsByPrefix(prefix) {
            var locators = [];
            for (var i = 0; i < this.locators.length; i++) {
                if (this.locators[i].name.indexOf(prefix) === 0) {
                    locators.push(this.locators[i]);
                }
            }
            return locators;
        }

        /**
         * Gets object's res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} excludeChildren - True to exclude children's res objects
         * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            if (this.mesh) this.mesh.GetResources(out);
            if (this.animation) this.animation.GetResources(out);

            _math.util.perArrayChild(this.spriteSets, 'GetResources', out);
            _math.util.perArrayChild(this.turretSets, 'GetResources', out);
            _math.util.perArrayChild(this.decals, 'GetResources', out);
            _math.util.perArrayChild(this.spotlightSets, 'GetResources', out);
            _math.util.perArrayChild(this.planeSets, 'GetResources', out);
            _math.util.perArrayChild(this.lineSets, 'GetResources', out);
            _math.util.perArrayChild(this.overlayEffects, 'GetResources', out);
            _math.util.perArrayChild(this.effectChildren, 'GetResources', out);

            if (!excludeChildren) {
                _math.util.perArrayChild(this.children, 'GetResources', out);
            }

            return out;
        }

        /**
         * A Per frame function that updates view dependent data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].UpdateViewDependentData(this.transform);
            }

            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);

            var center = this._perObjectData.perObjectVSData.Get('EllipsoidCenter'),
                radii = this._perObjectData.perObjectVSData.Get('EllipsoidRadii');

            if (this.shapeEllipsoidRadius[0] > 0) {
                center[0] = this.shapeEllipsoidCenter[0];
                center[1] = this.shapeEllipsoidCenter[1];
                center[2] = this.shapeEllipsoidCenter[2];
                radii[0] = this.shapeEllipsoidRadius[0];
                radii[1] = this.shapeEllipsoidRadius[1];
                radii[2] = this.shapeEllipsoidRadius[2];
            } else if (this.mesh && this.mesh.geometryResource && this.mesh.geometryResource.IsGood()) {
                _math.vec3.subtract(center, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
                _math.vec3.scale(center, center, 0.5 * 1.732050807);
                _math.vec3.add(radii, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
                _math.vec3.scale(radii, radii, 0.5);
            }

            for (var _i = 0; _i < this.customMasks.length; ++_i) {
                var targets = this.visible.customMasks ? this.customMasks[_i].targets : [0, 0, 0, 0];
                this._perObjectData.perObjectVSData.Set(_i ? 'CustomMaskMatrix1' : 'CustomMaskMatrix0', this.customMasks[_i].transform);
                this._perObjectData.perObjectVSData.Set(_i ? 'CustomMaskData1' : 'CustomMaskData0', this.customMasks[_i].maskData);
                this._perObjectData.perObjectPSData.Set(_i ? 'CustomMaskMaterialID1' : 'CustomMaskMaterialID0', this.customMasks[_i].materialID);
                this._perObjectData.perObjectPSData.Set(_i ? 'CustomMaskTarget1' : 'CustomMaskTarget0', targets);
            }

            if (this.animation.animations.length) {
                this._perObjectData.perObjectVSData.Set('JointMat', this.animation.GetBoneMatrices(0));
            }

            for (var _i2 = 0; _i2 < this.lineSets.length; ++_i2) {
                this.lineSets[_i2].UpdateViewDependentData(this.transform);
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this.lod > 0) {
                for (var i = 0; i < this.spriteSets.length; ++i) {
                    this.spriteSets[i].Update(dt);
                }

                for (var _i3 = 0; _i3 < this.planeSets.length; _i3++) {
                    this.planeSets[_i3].Update(dt);
                }

                /*
                for (let i = 0; i < this.spotlightSets.length; i++)
                {
                    this.spotlightSets[i].Update(dt);
                }
                */

                for (var _i4 = 0; _i4 < this.children.length; ++_i4) {
                    this.children[_i4].Update(dt);
                }

                for (var _i5 = 0; _i5 < this.effectChildren.length; ++_i5) {
                    this.effectChildren[_i5].Update(dt, this.transform);
                }

                for (var _i6 = 0; _i6 < this.curveSets.length; ++_i6) {
                    this.curveSets[_i6].Update(dt);
                }

                for (var _i7 = 0; _i7 < this.overlayEffects.length; ++_i7) {
                    this.overlayEffects[_i7].Update(dt);
                }

                this.animation.Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display) {
                var show = this.visible;

                if (show.mesh && this.mesh && this.lod > 0) {
                    this.mesh.GetBatches(mode, accumulator, this._perObjectData);
                }

                if (this.lod > 1) {
                    if (show.spriteSets) {
                        for (var i = 0; i < this.spriteSets.length; i++) {
                            this.spriteSets[i].GetBatches(mode, accumulator, this._perObjectData, this.transform);
                        }
                    }

                    if (show.spotlightSets) {
                        for (var _i8 = 0; _i8 < this.spotlightSets.length; _i8++) {
                            this.spotlightSets[_i8].GetBatches(mode, accumulator, this._perObjectData);
                        }
                    }

                    if (show.planeSets) {
                        for (var _i9 = 0; _i9 < this.planeSets.length; _i9++) {
                            this.planeSets[_i9].GetBatches(mode, accumulator, this._perObjectData);
                        }
                    }

                    if (show.decals) {
                        for (var _i10 = 0; _i10 < this.decals.length; _i10++) {
                            this.decals[_i10].GetBatches(mode, accumulator, this._perObjectData, show.killmarks ? this.killCount : 0);
                        }
                    }

                    if (show.lineSets) {
                        for (var _i11 = 0; _i11 < this.lineSets.length; _i11++) {
                            this.lineSets[_i11].GetBatches(mode, accumulator);
                        }
                    }
                }

                if (show.children) {
                    for (var _i12 = 0; _i12 < this.children.length; _i12++) {
                        this.children[_i12].GetBatches(mode, accumulator, this._perObjectData);
                    }
                }

                if (show.effectChildren) {
                    for (var _i13 = 0; _i13 < this.effectChildren.length; _i13++) {
                        this.effectChildren[_i13].GetBatches(mode, accumulator, this._perObjectData);
                    }
                }

                if (show.overlayEffects) {
                    for (var _i14 = 0; _i14 < this.overlayEffects.length; _i14++) {
                        this.overlayEffects[_i14].GetBatches(mode, accumulator, this._perObjectData, this.mesh);
                    }
                }
            }
        }

        /**
         * RenderDebugInfo
         * @param debugHelper
         */

    }, {
        key: 'RenderDebugInfo',
        value: function RenderDebugInfo(debugHelper) {
            this.animation.RenderDebugInfo(debugHelper);
        }
    }]);

    return EveSpaceObject;
}(_EveObject2.EveObject);

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveSpaceObject.global = {
    vec3_0: _math.vec3.create()
};

/**
 * Per object data declarations
 * @type {{VSData: *[], PSData: *[]}}
 */
EveSpaceObject.perObjectDataDecl = {
    VSData: [{ name: 'WorldMat', size: 16 }, { name: 'WorldMatLast', size: 16 }, { name: 'Shipdata', size: 4, value: [0, 1, 0, -10] }, { name: 'Clipdata1', size: 4 }, { name: 'EllipsoidRadii', size: 4 }, { name: 'EllipsoidCenter', size: 4 }, { name: 'CustomMaskMatrix0', size: 16, value: _math.mat4.create() }, { name: 'CustomMaskMatrix1', size: 16, value: _math.mat4.create() }, { name: 'CustomMaskData0', size: 4 }, { name: 'CustomMaskData1', size: 4 }, { name: 'JointMat', size: 696 }],
    PSData: [{ name: 'Shipdata', size: 4, value: [0, 1, 0, 1] }, { name: 'Clipdata1', size: 4 }, { name: 'Clipdata2', size: 4 }, { name: 'ShLighting', size: 4 * 7 }, { name: 'CustomMaskMaterialID0', size: 4 }, { name: 'CustomMaskMaterialID1', size: 4 }, { name: 'CustomMaskTarget0', size: 4 }, { name: 'CustomMaskTarget1', size: 4 }]
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var num = exports.num = {};

/**
 * biCumulative
 *
 * @param {number} t
 * @param {number} order
 * @returns {number}
 */
num.biCumulative = function (t, order) {
    if (order === 1) {
        var some = 1.0 - t;
        return 1.0 - some * some * some;
    } else if (order === 2) {
        return 3.0 * t * t - 2.0 * t * t * t;
    } else {
        return t * t * t;
    }
};

/**
 * Exponential decay
 * 
 * @param {number} omega0
 * @param {number} torque
 * @param {number} I - inertia
 * @param {number} d - drag
 * @param {number} time - time
 * @returns {number}
 */
num.exponentialDecay = function (omega0, torque, I, d, time) {
    return torque * time / d + I * (omega0 * d - torque) / (d * d) * (1.0 - Math.pow(Math.E, -d * time / I));
};

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vec3 = undefined;

var _glMatrix = __webpack_require__(8);

var _num = __webpack_require__(28);

exports.vec3 = _glMatrix.vec3;

/**
 * Sets a vec3 with cartesian coordinates converted from a vec3 containing spherical coordinate values
 * @param {vec3} out            - receiving vec3
 * @param {vec3} spherical      - source vec3 with spherical coordinates (phi, theta, radius)
 * @returns {vec3} out          - receiving vec3
 */

_glMatrix.vec3.cartFromSpherical = function (out, spherical) {
    var phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];

    out[0] = radius * Math.sin(phi) * Math.sin(theta);
    out[1] = radius * Math.cos(theta);
    out[2] = radius * Math.cos(phi) * Math.sin(theta);
    return out;
};

/**
 * Sets a vec3 with cartesian coordinates from a vec3 containing spherical coordinate values, and a center point
 * @param {vec3} out            - receiving vec3
 * @param {vec3} spherical      - source vec3 with spherical coordinates (phi, theta, radius)
 * @param {vec3} center         - center
 * @returns {vec3} out          - receiving vec3
 */
_glMatrix.vec3.cartFromSphericalAndCenter = function (out, spherical, center) {
    var phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];

    out[0] = radius * Math.sin(phi) * Math.sin(theta) + center[0];
    out[1] = radius * Math.cos(theta) + center[1];
    out[2] = radius * Math.cos(phi) * Math.sin(theta) + center[2];
    return out;
};

/**
 * Exponential decay
 *
 * @param {vec3} out
 * @param {vec3} omega0
 * @param {vec3} torque
 * @param {number} I
 * @param {number} drag
 * @param {number} time
 * @returns {vec3} out
 */
_glMatrix.vec3.exponentialDecay = function (out, omega0, torque, I, drag, time) {
    out[0] = _num.num.exponentialDecay(omega0[0], torque[0], I, drag, time);
    out[1] = _num.num.exponentialDecay(omega0[1], torque[1], I, drag, time);
    out[2] = _num.num.exponentialDecay(omega0[2], torque[2], I, drag, time);
    return out;
};

/**
 * Projects a local vec3 to screen space with viewport settings
 * @param {vec3} out           - receiving vec3
 * @param {vec3} a             - local vec3
 * @param {mat4} m             - model view projection matrix
 * @param {vec4} viewport      - view port settings (x, y, width, height)
 * @returns {vec3} out         - receiving vec3 (x, y, perspectiveDivide)
 */
_glMatrix.vec3.project = function (out, a, m, viewport) {
    var x = a[0],
        y = a[1],
        z = a[2];

    var outX = m[0] * x + m[4] * y + m[8] * z + m[12],
        outY = m[1] * x + m[5] * y + m[9] * z + m[13],
        perD = m[3] * x + m[7] * y + m[11] * z + m[15];

    var projectionX = (outX / perD + 1) / 2;
    var projectionY = 1 - (outY / perD + 1) / 2;

    out[0] = projectionX * viewport[2] + viewport[0];
    out[1] = projectionY * viewport[3] + viewport[1];
    out[2] = perD;
    return out;
};

/**
 * Unprojects a vec3 with canvas coordinates to world space
 * @param {vec3} out            - receiving vec3
 * @param {vec3} a              - vec3 to unproject
 * @param {mat4} invViewProj    - inverse view projection matrix
 * @param {vec4|Array} viewport - [ x, y, width, height ]
 * @returns {vec3} out
 * @throw On perspective divide error
 */
_glMatrix.vec3.unproject = function () {
    var vec4_0 = void 0;

    return function unProject(out, a, invViewProj, viewport) {
        if (!vec4_0) vec4_0 = _glMatrix.vec4.create();

        var x = a[0],
            y = a[1],
            z = a[2];

        vec4_0[0] = (x - viewport[0]) * 2.0 / viewport[2] - 1.0;
        vec4_0[1] = (y - viewport[1]) * 2.0 / viewport[3] - 1.0;
        vec4_0[2] = 2.0 * z - 1.0;
        vec4_0[3] = 1.0;

        _glMatrix.vec4.transformMat4(vec4_0, vec4_0, invViewProj);

        if (vec4_0[3] === 0.0) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            throw new Error('Perspective divide error');
        }

        out[0] = vec4_0[0] / vec4_0[3];
        out[1] = vec4_0[1] / vec4_0[3];
        out[2] = vec4_0[2] / vec4_0[3];
        return out;
    };
}();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = undefined;

var _glMatrix = __webpack_require__(8);

exports.vec4 = _glMatrix.vec4;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ObjectReader = Tw2ObjectReader;

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2BinaryReader = __webpack_require__(18);

/**
 * Tw2ObjectReader
 * @param xmlNode
 * @property xmlNode
 * @property {null|Array} _inputStack
 * @property {null|Array} _initializeObjects
 * @property {null|Array} _ids
 * @constructor
 */
function Tw2ObjectReader(xmlNode) {
    this.xmlNode = xmlNode;
    this._inputStack = null;
    this._initializeObjects = null;
    this._ids = {};
    this._reader = null;

    if (String.fromCharCode.apply(null, new Uint8Array(xmlNode).subarray(0, 6)) !== 'binred') {
        _Tw2EventEmitter.emitter.log('res.error', {
            log: 'error',
            src: ['Tw2ObjectReader', 'constructor'],
            msg: 'Invalid Binary',
            path: this.path,
            type: 'redbin.invalid',
            data: xmlNode
        });
        return;
    }
    this._reader = new _Tw2BinaryReader.Tw2BinaryReader(new Uint8Array(xmlNode));
    this._reader.cursor += 6;

    this._stringTable = [];
    var count = this._reader.ReadUInt32();
    for (var i = 0; i < count; ++i) {
        var len = this._reader.ReadUInt16();
        this._stringTable.push(String.fromCharCode.apply(null, this._reader.data.subarray(this._reader.cursor, this._reader.cursor + len)));
        this._reader.cursor += len;
    }

    this._start = this._reader.cursor;
}

Tw2ObjectReader.ElementRawType = {
    NULL: 0,
    BOOL: 1,
    INT: 2,
    UINT: 3,
    FLOAT: 4,
    STRING: 5,
    ARRAY: 6,
    MAPPING: 7,
    OBJECT: 8,
    TYPED_ARRAY: 9,
    TYPED_MAPPING: 10
};

Tw2ObjectReader.ElementSize = {
    SMALL: 0,
    MEDIUM: 1 << 4,
    LARGE: 2 << 4
};

Tw2ObjectReader.ID_BIT = 1 << 6;
Tw2ObjectReader.REFERENCE_BIT = 1 << 7;

Tw2ObjectReader.ElementTypes = {
    NULL: Tw2ObjectReader.ElementRawType.NULL | Tw2ObjectReader.ElementSize.SMALL,

    BOOL: Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.SMALL,
    FALSE: Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.MEDIUM,
    TRUE: Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.LARGE,

    INT8: Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.SMALL,
    UINT8: Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.SMALL,
    INT16: Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.MEDIUM,
    UINT16: Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.MEDIUM,
    INT32: Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.LARGE,
    UINT32: Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.LARGE,

    FLOAT16: Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.SMALL,
    FLOAT32: Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.MEDIUM,
    FLOAT64: Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_STRING: Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_STRING: Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_STRING: Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_ARRAY: Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_ARRAY: Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_ARRAY: Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_MAPPING: Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_MAPPING: Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_MAPPING: Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_OBJECT: Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_OBJECT: Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_OBJECT: Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_TYPED_ARRAY: Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_TYPED_ARRAY: Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_TYPED_ARRAY: Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.LARGE,

    SHORT_TYPED_MAPPING: Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.SMALL,
    MEDIUM_TYPED_MAPPING: Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.MEDIUM,
    LARGE_TYPED_MAPPING: Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.LARGE
};

Tw2ObjectReader.TypedArrays = {
    2: Int8Array,
    3: Uint8Array,
    18: Int16Array,
    19: Uint16Array,
    34: Int32Array,
    35: Uint32Array,
    4: Float32Array,
    20: Float32Array,
    36: Float64Array
};

Tw2ObjectReader.prototype._ConstructObject = function (data) {
    var object;

    if (data.type === 'json') {
        return data;
    }

    try {
        var Constructor = _Tw2ResMan.resMan.GetConstructor(data.type);
        object = new Constructor();
    } catch (e) {
        _Tw2EventEmitter.emitter.log('res.error', {
            log: 'throw',
            src: ['Tw2ObjectReader', '_ConstructObject'],
            msg: 'Object with undefined type',
            type: 'xml.type',
            value: data.type
        });

        throw new Error('YAML: object with undefined type \'' + data.type + '\'');
    }

    for (var k in data) {
        if (data.hasOwnProperty(k) && k !== 'type') {
            if (object[k] && data[k].constructor === Object) {
                for (var key in data[k]) {
                    if (data[k].hasOwnProperty(key)) {
                        object[k][key] = data[k][key];
                    }
                }
            } else {
                object[k] = data[k];
            }
        }
    }

    if ('Initialize' in object) {
        object.Initialize();
    }
    return object;
};

Tw2ObjectReader.prototype._ReadUint = function (type) {
    switch (type & 0x30) {
        case Tw2ObjectReader.ElementSize.SMALL:
            return this._reader.ReadUInt8();
        case Tw2ObjectReader.ElementSize.MEDIUM:
            return this._reader.ReadUInt16();
        default:
            return this._reader.ReadUInt32();
    }
};

Tw2ObjectReader.prototype._ReadElementData = function (type) {
    var offset, i, result, count, elementType;
    switch (type & 0xf) {
        case Tw2ObjectReader.ElementRawType.NULL:
            return null;
        case Tw2ObjectReader.ElementRawType.BOOL:
            switch (type & 0x30) {
                case Tw2ObjectReader.ElementSize.SMALL:
                    return this._reader.ReadUInt8() !== 0;
                case Tw2ObjectReader.ElementSize.MEDIUM:
                    return false;
                default:
                    return true;
            }
        case Tw2ObjectReader.ElementRawType.INT:
            switch (type & 0x30) {
                case Tw2ObjectReader.ElementSize.SMALL:
                    return this._reader.ReadInt8();
                case Tw2ObjectReader.ElementSize.MEDIUM:
                    return this._reader.ReadInt16();
                default:
                    return this._reader.ReadInt32();
            }
        case Tw2ObjectReader.ElementRawType.UINT:
            return this._ReadUint(type);
        case Tw2ObjectReader.ElementRawType.FLOAT:
            switch (type & 0x30) {
                case Tw2ObjectReader.ElementSize.SMALL:
                    return this._reader.ReadFloat16();
                case Tw2ObjectReader.ElementSize.MEDIUM:
                    return this._reader.ReadFloat32();
                default:
                    throw Error('float64 values are not yet supported');
            }
        case Tw2ObjectReader.ElementRawType.STRING:
            offset = this._ReadUint(type);
            return this._stringTable[offset];
        case Tw2ObjectReader.ElementRawType.ARRAY:
            count = this._ReadUint(type);
            result = [];
            for (i = 0; i < count; ++i) {
                result.push(this._ReadElement());
            }return result;
        case Tw2ObjectReader.ElementRawType.MAPPING:
            count = this._ReadUint(type);
            result = {};
            for (i = 0; i < count; ++i) {
                result[this._stringTable[this._ReadUint(type)]] = this._ReadElement();
            }return result;
        case Tw2ObjectReader.ElementRawType.OBJECT:
            count = this._ReadUint(type);
            result = {};
            for (i = 0; i < count; ++i) {
                result[this._stringTable[this._ReadUint(type)]] = this._ReadElement();
            }return this._ConstructObject(result);
        case Tw2ObjectReader.ElementRawType.TYPED_ARRAY:
            count = this._ReadUint(type);
            elementType = this._reader.ReadUInt8();
            result = [];
            for (i = 0; i < count; ++i) {
                result.push(this._ReadElementData(elementType));
            }if (elementType in Tw2ObjectReader.TypedArrays) {
                result = new Tw2ObjectReader.TypedArrays[elementType](result);
            }
            return result;
        case Tw2ObjectReader.ElementRawType.TYPED_MAPPING:
            count = this._ReadUint(type);
            elementType = this._reader.ReadUInt8();
            result = {};
            for (i = 0; i < count; ++i) {
                result[this._stringTable[this._ReadUint(type)]] = this._ReadElementData(elementType);
            }return result;
    }
};

Tw2ObjectReader.prototype._ReadElement = function () {
    var type = this._reader.ReadUInt8();
    if (type === Tw2ObjectReader.REFERENCE_BIT) {
        return this._ids[this._reader.ReadUInt16()];
    }
    var id;
    if ((type & Tw2ObjectReader.ID_BIT) !== 0) {
        id = this._reader.ReadUInt16();
    }
    var result = this._ReadElementData(type & 0x3F);
    if ((type & Tw2ObjectReader.ID_BIT) !== 0) {
        this._ids[id] = result;
    }
    return result;
};

Tw2ObjectReader.prototype.Construct = function () {
    this._reader.cursor = this._start;
    return this._ReadElement();
};

/**
 * Construct
 * @param initialize
 * @returns {Function}
 */
/*Tw2ObjectReader.prototype.Construct = function(initialize)
{
    this._inputStack = [];
    this._inputStack.push([this.xmlNode.documentElement, this, 'result']);
    this._initializeObjects = [];
    this._ids = [];
    var self = this;
    return function()
    {
        return self.ConstructFromNode(initialize, true);
    };
};
*/

/**
 * ConstructFromNode
 * @param initialize
 * @param async
 * @returns {Boolean}
 */
Tw2ObjectReader.prototype.ConstructFromNode = function (initialize, async) {
    var startTime = Date.now();
    while (this._inputStack.length) {
        var endTime = Date.now();
        if (async && _Tw2ResMan.resMan.prepareBudget < (endTime - startTime) * 0.001) {
            return false;
        }
        var inputData = this._inputStack.pop();
        var xmlNode = inputData[0];
        var parent = inputData[1];
        var index = inputData[2];
        if (xmlNode === null) {
            if (initialize && typeof parent.Initialize !== 'undefined') {
                this._initializeObjects.push(parent);
                //parent.Initialize();
            }
            continue;
        }
        var ref = xmlNode.attributes.getNamedItem('ref');
        if (ref) {
            var object = this._ids[ref.value];
            //this._inputStack.push([null, object, null]);
            parent[index] = object;
            continue;
        }
        var type = xmlNode.attributes.getNamedItem('type');
        if (type) {
            var object = null;
            if (type.value === 'dict') {
                object = {};
            } else {
                try {
                    var Constructor = _Tw2ResMan.resMan.GetConstructor(type.value);
                    object = new Constructor();
                } catch (e) {
                    _Tw2EventEmitter.emitter.log('res.error', {
                        log: 'throw',
                        src: ['Tw2ObjectReader', 'ConstructFromNode'],
                        msg: 'Object with undefined type',
                        type: 'xml.type',
                        value: type.value
                    });

                    throw new Error('YAML: object with undefined type \'' + type.value + '\'');
                }
            }
            this._inputStack.push([null, object, null]);
            for (var i = 0; i < xmlNode.childNodes.length; ++i) {
                var child = xmlNode.childNodes[xmlNode.childNodes.length - 1 - i];
                if (child.nodeName === '#text') {
                    continue;
                }
                if (type.value !== 'dict') {
                    if (typeof object[child.nodeName] === 'undefined') {
                        _Tw2EventEmitter.emitter.log('res.error', {
                            log: 'warn',
                            src: ['Tw2ObjectReader', 'ConstructFromNode'],
                            msg: 'Object "' + type.value + '" missing property: ' + child.nodeName,
                            value: child.nodeName,
                            type: 'xml.property'
                        });

                        continue;
                    }
                }
                this._inputStack.push([child, object, child.nodeName]);
            }
            var id = xmlNode.attributes.getNamedItem('id');
            if (id) {
                this._ids[id.value] = object;
            }
            parent[index] = object;
            continue;
        }

        var list = xmlNode.attributes.getNamedItem('list');
        if (list) {
            object = [];
            var arrayIndex = 0;
            this._inputStack.push([null, object, null]);
            for (var i = 0; i < xmlNode.childNodes.length; ++i) {
                var child = xmlNode.childNodes[xmlNode.childNodes.length - 1 - i];
                if (child.nodeName === '#text') {
                    continue;
                }
                arrayIndex++;
            }
            for (var i = 0; i < xmlNode.childNodes.length; ++i) {
                var child = xmlNode.childNodes[xmlNode.childNodes.length - 1 - i];
                if (child.nodeName === '#text') {
                    continue;
                }
                this._inputStack.push([child, object, --arrayIndex]);
            }
            var id = xmlNode.attributes.getNamedItem('id');
            if (id) {
                this._ids[id.value] = object;
            }
            parent[index] = object;
            continue;
        }

        var value = '';
        for (var i = 0; i < xmlNode.childNodes.length; ++i) {
            var child = xmlNode.childNodes[i];
            if (child.nodeName === '#text') {
                value += child.data;
            }
        }

        var json = xmlNode.attributes.getNamedItem('json');
        if (json) {
            try {
                parent[index] = JSON.parse(value);
            } catch (e) {
                _Tw2EventEmitter.emitter.log('res.error', {
                    log: 'throw',
                    src: ['Tw2ObjectReader', 'ConstructFromNode'],
                    msg: 'Invalid JSON property',
                    type: 'xml.json',
                    value: value,
                    data: e
                });

                throw new Error('YAML: property \'' + value + '\' is not a valid JSON property');
            }
            if (!xmlNode.attributes.getNamedItem('notnum')) {
                try {
                    parent[index] = new Float32Array(parent[index]);
                } catch (e) {}
            }
            var id = xmlNode.attributes.getNamedItem('id');
            if (id) {
                this._ids[id.value] = parent[index];
            }
            continue;
        }

        var capture = /^(\-?\d+\.\d+(?:e|E\-?\d+)?)/.exec(value);
        if (capture) {
            parent[index] = parseFloat(capture[1]);
            continue;
        }

        capture = /^(\-?\d+)/.exec(value);
        if (capture) {
            parent[index] = parseInt(capture[1], 10);
            continue;
        }

        capture = /^\b(enabled|true|yes|on)\b/.exec(value);
        if (capture) {
            parent[index] = true;
            continue;
        }

        capture = /^\b(disabled|false|no|off)\b/.exec(value);
        if (capture) {
            parent[index] = false;
            continue;
        }

        parent[index] = value;
    }
    while (this._initializeObjects.length) {
        var endTime = Date.now();
        if (async && _Tw2ResMan.resMan.prepareBudget < (endTime - startTime) * 0.001) {
            return false;
        }
        var object = this._initializeObjects.shift();
        object.Initialize();
    }
    return true;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2PerObjectData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

var _Tw2RawData = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2PerObjectData
 *
 * @param {{}} [declarations]
 * @param {Tw2RawData} [decl.VSData]
 * @param {Tw2RawData} [decl.PSData]
 * @property {?Tw2RawData} perObjectVSData - Per object vertex shader data
 * @property {?Tw2RawData} perObjectPSData - Per object pixel shader data
 * @class
 */
var Tw2PerObjectData = exports.Tw2PerObjectData = function () {
    function Tw2PerObjectData(declarations, skipCreate) {
        _classCallCheck(this, Tw2PerObjectData);

        this.perObjectVSData = null;
        this.perObjectPSData = null;

        if (declarations) {
            this.DeclareFromObject(declarations, skipCreate);
        }
    }

    /**
     * Sets per object data to the device
     * @param constantBufferHandles
     */


    _createClass(Tw2PerObjectData, [{
        key: 'SetPerObjectDataToDevice',
        value: function SetPerObjectDataToDevice(constantBufferHandles) {
            if (this.perObjectVSData && constantBufferHandles[3]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[3], this.perObjectVSData.data);
            }

            if (this.perObjectPSData && constantBufferHandles[4]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[4], this.perObjectPSData.data);
            }
        }

        /**
         * Declares raw data from an object
         * @param {{}} declarations
         * @param {{}} [declarations.VSData]
         * @param {{}} [declarations.PSData]
         * @param {boolean} [skipCreate]
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject(declarations, skipCreate) {
            if (declarations.VSData) {
                this.perObjectVSData = new _Tw2RawData.Tw2RawData(declarations.VSData, skipCreate);
            }

            if (declarations.PSData) {
                this.perObjectPSData = new _Tw2RawData.Tw2RawData(declarations.PSData, skipCreate);
            }
        }
    }]);

    return Tw2PerObjectData;
}();

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2FloatParameter = Tw2FloatParameter;
/**
 * A Tw2 Parameter
 * @typedef {(Tw2FloatParameter|Tw2TextureParameter|Tw2VariableParameter|Tw2Vector2Parameter|Tw2Vector3Parameter|Tw2Vector4Parameter|Tw2MatrixParameter)} Parameter
 */

/**
 * Tw2FloatParameter
 * @param {string} [name='']
 * @param {number} [value=1]
 * @property {string} name
 * @property {number} value
 * @property {null|Array} constantBuffer
 * @property {null|number} offset
 * @constructor
 */
function Tw2FloatParameter(name, value) {
    if (typeof name !== 'undefined') {
        this.name = name;
    } else {
        this.name = '';
    }
    if (typeof value !== 'undefined') {
        if (value.constructor.name.toUpperCase().includes('ARRAY')) {
            this.value = value[0];
        } else {
            this.value = value;
        }
    } else {
        this.value = 1;
    }
    this.constantBuffer = null;
    this.offset = null;
}

/**
 * Binds the parameter to a constant buffer
 * @param {Array} constantBuffer
 * @param {number} offset
 * @param {number} [size=] - unused
 * @returns {boolean}
 * @prototype
 */
Tw2FloatParameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 1) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
};

/**
 * Unbinds the parameter from it's constant buffer
 * @prototype
 */
Tw2FloatParameter.prototype.Unbind = function () {
    this.constantBuffer = null;
};

/**
 * Updates the constant buffer to the current value
 * @prototype
 */
Tw2FloatParameter.prototype.OnValueChanged = function () {
    if (this.constantBuffer !== null) {
        this.constantBuffer[this.offset] = this.value;
    }
};

/**
 * Applies the current value to the supplied constant buffer at the supplied offset
 * @param {Array} constantBuffer
 * @param {number} offset
 * @prototype
 */
Tw2FloatParameter.prototype.Apply = function (constantBuffer, offset) {
    constantBuffer[offset] = this.value;
};

/**
 * Gets the current value
 * @prototype
 */
Tw2FloatParameter.prototype.GetValue = function () {
    if (this.constantBuffer !== null) {
        return this.constantBuffer[this.offset];
    }

    return this.value;
};

/**
 * Sets a supplied value
 * @prototype
 */
Tw2FloatParameter.prototype.SetValue = function (value) {
    this.value = value;
    if (this.constantBuffer !== null) {
        this.constantBuffer[this.offset] = this.value;
    }
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2FloatParameter.is = function (value) {
    return typeof value === 'number';
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Mesh = undefined;
exports.Tw2MeshArea = Tw2MeshArea;
exports.Tw2MeshLineArea = Tw2MeshLineArea;

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Device = __webpack_require__(2);

var _Tw2GeometryRes = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2MeshArea
 * @property {string} name
 * @property {Tw2Effect} effect
 * @property {number} meshIndex
 * @property {number} index
 * @property {number} count
 * @property {boolean} display
 * @constructor
 */
function Tw2MeshArea() {
    this.name = '';
    this.effect = null;
    this.meshIndex = 0;
    this.index = 0;
    this.count = 1;
    this.display = true;
}

/**
 * Render Batch Constructor
 * @type {RenderBatch}
 * @prototype
 */
Tw2MeshArea.batchType = _Tw2GeometryRes.Tw2GeometryBatch;

/**
 * Tw2MeshLineArea
 * @property {string} name
 * @property {Tw2Effect} effect
 * @property {number} meshIndex
 * @property {number} index
 * @property {number} count
 * @property {Boolean} display
 * @constructor
 */
function Tw2MeshLineArea() {
    this.name = '';
    this.effect = null;
    this.meshIndex = 0;
    this.index = 0;
    this.count = 1;
    this.display = true;
}

/**
 * Render Batch Constructor
 * @type {RenderBatch}
 * @prototype
 */
Tw2MeshLineArea.batchType = _Tw2GeometryRes.Tw2GeometryLineBatch;

/**
 * Tw2Mesh
 * @property {string} name
 * @property {number} meshIndex
 * @property {string} geometryResPath
 * @property {string} lowDetailGeometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @property {Array.<Tw2MeshArea>} opaqueAreas
 * @property {Array.<Tw2MeshArea>} transparentAreas
 * @property {Array.<Tw2MeshArea>} additiveAreas
 * @property {Array.<Tw2MeshArea>} pickableAreas
 * @property {Array.<Tw2MeshArea>} decalAreas
 * @property {Array.<Tw2MeshArea>} depthAreas       - Not supported
 * @property {boolean} display                      - Enables/ disables all mesh batch accumulations
 * @parameter {{}} visible                          - Batch accumulation options for the mesh's elements
 * @property {boolean} visible.opaqueAreas          - Enables/ disables opaque area batch accumulation
 * @property {boolean} visible.transparentAreas     - Enables/ disables transparent area batch accumulation
 * @property {boolean} visible.additiveAreas        - Enables/ disables additive area batch accumulation
 * @property {boolean} visible.pickableAreas        - Enables/ disables pickable area batch accumulation
 * @property {boolean} visible.decalAreas           - Enables/ disables decal area batch accumulation
 * @property {boolean} visible.depthAreas           - Not supported
 * @class
 */

var Tw2Mesh = exports.Tw2Mesh = function Tw2Mesh() {
    _classCallCheck(this, Tw2Mesh);

    this.name = '';
    this.meshIndex = 0;
    this.geometryResPath = '';
    this.lowDetailGeometryResPath = '';
    this.geometryResource = null;

    this.opaqueAreas = [];
    this.transparentAreas = [];
    this.additiveAreas = [];
    this.pickableAreas = [];
    this.decalAreas = [];
    this.depthAreas = [];

    this.display = true;
    this.visible = {};
    this.visible.opaqueAreas = true;
    this.visible.transparentAreas = true;
    this.visible.additiveAreas = true;
    this.visible.pickableAreas = true;
    this.visible.decalAreas = true;
    this.visible.depthAreas = true;
};

/**
 * Initializes the Tw2Mesh
 * @prototype
 */


Tw2Mesh.prototype.Initialize = function () {
    if (this.geometryResPath !== '') {
        this.geometryResource = _Tw2ResMan.resMan.GetResource(this.geometryResPath);
    }
};

/**
 * Gets Mesh res Objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
Tw2Mesh.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (out.indexOf(this.geometryResource) === -1) {
        out.push(this.geometryResource);
    }

    for (var type in this.visible) {
        if (this.visible.hasOwnProperty(type) && this[type].length) {
            for (var i = 0; i < this[type].length; i++) {
                this[type][i].effect.GetResources(out);
            }
        }
    }

    return out;
};

/**
 * Gets render batches from a mesh area array and commits them to an accumulator
 * @param {Array.<Tw2MeshArea>} areas
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @private
 */
Tw2Mesh.prototype._GetAreaBatches = function (areas, mode, accumulator, perObjectData) {
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.effect === null || !area.display) {
            continue;
        }
        var batch = new area.constructor.batchType();
        batch.renderMode = mode;
        batch.perObjectData = perObjectData;
        batch.geometryRes = this.geometryResource;
        batch.meshIx = this.meshIndex;
        batch.start = area.index;
        batch.count = area.count;
        batch.effect = area.effect;
        accumulator.Commit(batch);
    }
};

/**
 * Gets render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @returns {boolean}
 * @prototype
 */
Tw2Mesh.prototype.GetBatches = function (mode, accumulator, perObjectData) {
    if (this.geometryResource === null) {
        return false;
    }

    if (this.display) {

        if (mode === _Tw2Device.device.RM_OPAQUE && this.visible.opaqueAreas) {
            this._GetAreaBatches(this.opaqueAreas, mode, accumulator, perObjectData);
        } else if (mode === _Tw2Device.device.RM_DECAL && this.visible.decalAreas) {
            this._GetAreaBatches(this.decalAreas, mode, accumulator, perObjectData);
        } else if (mode === _Tw2Device.device.RM_TRANSPARENT && this.visible.transparentAreas) {
            this._GetAreaBatches(this.transparentAreas, mode, accumulator, perObjectData);
        } else if (mode === _Tw2Device.device.RM_ADDITIVE && this.visible.additiveAreas) {
            this._GetAreaBatches(this.additiveAreas, mode, accumulator, perObjectData);
        } else if (mode === _Tw2Device.device.RM_PICKABLE && this.visible.pickableAreas) {
            this._GetAreaBatches(this.pickableAreas, mode, accumulator, perObjectData);
        }
    }

    return true;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RenderTarget = Tw2RenderTarget;

var _Tw2Device = __webpack_require__(2);

var _Tw2TextureRes = __webpack_require__(24);

/**
 * Tw2RenderTarget
 * @property {Tw2TextureRes} texture
 * @property {WebGLFramebuffer} _frameBuffer
 * @property {WebGLRenderbuffer} _renderBuffer
 * @property {number} width - width of the resulting texture
 * @property {number} height - height of the resulting texture
 * @property {boolean} hasDepth - Controls whether depth is considered when creating the webgl buffers
 * @constructor
 */
function Tw2RenderTarget() {
    this.texture = null;
    this._frameBuffer = null;
    this._renderBuffer = null;
    this.width = null;
    this.height = null;
    this.hasDepth = null;
}

/**
 * Destroys the render target's webgl buffers and textures
 * @prototype
 */
Tw2RenderTarget.prototype.Destroy = function () {
    if (this.texture) {
        _Tw2Device.device.gl.deleteTexture(this.texture.texture);
        this.texture = null;
    }
    if (this._renderBuffer) {
        _Tw2Device.device.gl.deleteRenderbuffer(this._renderBuffer);
        this._renderBuffer = null;
    }
    if (this._frameBuffer) {
        _Tw2Device.device.gl.deleteFramebuffer(this._frameBuffer);
        this._frameBuffer = null;
    }
};

/**
 * Creates the render target's texture
 * @param {number} width     - The resulting texture's width
 * @param {number} height    - The resulting texture's height
 * @param {boolean} hasDepth - Optional flag to enable a depth buffer
 * @prototype
 */
Tw2RenderTarget.prototype.Create = function (width, height, hasDepth) {
    this.Destroy();
    this.texture = new _Tw2TextureRes.Tw2TextureRes();
    this.texture.Attach(_Tw2Device.device.gl.createTexture());

    this._frameBuffer = _Tw2Device.device.gl.createFramebuffer();
    _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, this._frameBuffer);

    _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, this.texture.texture);
    _Tw2Device.device.gl.texImage2D(_Tw2Device.device.gl.TEXTURE_2D, 0, _Tw2Device.device.gl.RGBA, width, height, 0, _Tw2Device.device.gl.RGBA, _Tw2Device.device.gl.UNSIGNED_BYTE, null);
    _Tw2Device.device.gl.texParameteri(_Tw2Device.device.gl.TEXTURE_2D, _Tw2Device.device.gl.TEXTURE_MAG_FILTER, _Tw2Device.device.gl.LINEAR);
    _Tw2Device.device.gl.texParameteri(_Tw2Device.device.gl.TEXTURE_2D, _Tw2Device.device.gl.TEXTURE_MIN_FILTER, _Tw2Device.device.gl.LINEAR);
    _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, null);

    this._renderBuffer = null;

    if (hasDepth) {
        this._renderBuffer = _Tw2Device.device.gl.createRenderbuffer();
        _Tw2Device.device.gl.bindRenderbuffer(_Tw2Device.device.gl.RENDERBUFFER, this._renderBuffer);
        _Tw2Device.device.gl.renderbufferStorage(_Tw2Device.device.gl.RENDERBUFFER, _Tw2Device.device.gl.DEPTH_COMPONENT16, width, height);
    }

    _Tw2Device.device.gl.framebufferTexture2D(_Tw2Device.device.gl.FRAMEBUFFER, _Tw2Device.device.gl.COLOR_ATTACHMENT0, _Tw2Device.device.gl.TEXTURE_2D, this.texture.texture, 0);

    if (hasDepth) {
        _Tw2Device.device.gl.framebufferRenderbuffer(_Tw2Device.device.gl.FRAMEBUFFER, _Tw2Device.device.gl.DEPTH_ATTACHMENT, _Tw2Device.device.gl.RENDERBUFFER, this._renderBuffer);
    }

    _Tw2Device.device.gl.bindRenderbuffer(_Tw2Device.device.gl.RENDERBUFFER, null);
    _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, null);

    this.texture.width = this.width = width;
    this.texture.height = this.height = height;
    this.hasDepth = hasDepth;
};

/**
 * Sets the render target as the current frame buffer
 * @prototype
 */
Tw2RenderTarget.prototype.Set = function () {
    _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, this._frameBuffer);
    _Tw2Device.device.gl.viewport(0, 0, this.width, this.height);
};

/**
 * Unsets the render target as the current frame buffer
 * @prototype
 */
Tw2RenderTarget.prototype.Unset = function () {
    _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, null);
    _Tw2Device.device.gl.viewport(0, 0, _Tw2Device.device.viewportWidth, _Tw2Device.device.viewportHeight);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _emitters = __webpack_require__(78);

Object.keys(_emitters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _emitters[key];
    }
  });
});

var _forces = __webpack_require__(81);

Object.keys(_forces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _forces[key];
    }
  });
});

var _generators = __webpack_require__(88);

Object.keys(_generators).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generators[key];
    }
  });
});

var _constraints = __webpack_require__(92);

Object.keys(_constraints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constraints[key];
    }
  });
});

var _Tw2ParticleSystem = __webpack_require__(93);

Object.keys(_Tw2ParticleSystem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleSystem[key];
    }
  });
});

var _Tw2ParticleElement = __webpack_require__(13);

Object.keys(_Tw2ParticleElement).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleElement[key];
    }
  });
});

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Particle Emitter base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {Tw2ParticleSystem} particleSystem
 * @class
 */
var Tw2ParticleEmitter = exports.Tw2ParticleEmitter = function () {
    function Tw2ParticleEmitter() {
        _classCallCheck(this, Tw2ParticleEmitter);

        this._id = _math.util.generateID();
        this.name = '';
        this.particleSystem = null;
    }

    /**
     * Initializes the particle emitter
     */


    _createClass(Tw2ParticleEmitter, [{
        key: 'Initialize',
        value: function Initialize() {}

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {}
    }]);

    return Tw2ParticleEmitter;
}();

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curves = __webpack_require__(14);

Object.keys(_curves).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _curves[key];
    }
  });
});

var _sequencers = __webpack_require__(113);

Object.keys(_sequencers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _sequencers[key];
    }
  });
});

var _tracks = __webpack_require__(122);

Object.keys(_tracks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _tracks[key];
    }
  });
});

var _maya = __webpack_require__(125);

Object.keys(_maya).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _maya[key];
    }
  });
});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildMesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Mesh attachment to space object
 *
 * @property {boolean} useSpaceObjectData
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @class
 */
var EveChildMesh = exports.EveChildMesh = function (_EveChild) {
    _inherits(EveChildMesh, _EveChild);

    function EveChildMesh() {
        _classCallCheck(this, EveChildMesh);

        var _this = _possibleConstructorReturn(this, (EveChildMesh.__proto__ || Object.getPrototypeOf(EveChildMesh)).call(this));

        _this.useSpaceObjectData = true;
        _this.mesh = null;
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildMesh, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display || !this.mesh) return;

            if (this.useSpaceObjectData) {
                if (!this._perObjectData) {
                    this._perObjectData = new _core.Tw2PerObjectData();

                    this._perObjectData.perObjectVSData = new _core.Tw2RawData();
                    this._perObjectData.perObjectVSData.data = new Float32Array(perObjectData.perObjectVSData.data.length);
                    this._perObjectData.perObjectVSData.data[33] = 1;
                    this._perObjectData.perObjectVSData.data[35] = 1;

                    this._perObjectData.perObjectPSData = new _core.Tw2RawData();
                    this._perObjectData.perObjectPSData.data = new Float32Array(perObjectData.perObjectPSData.data.length);
                    this._perObjectData.perObjectPSData.data[1] = 1;
                    this._perObjectData.perObjectPSData.data[3] = 1;
                }

                this._perObjectData.perObjectVSData.data.set(perObjectData.perObjectVSData.data);
                this._perObjectData.perObjectPSData.data.set(perObjectData.perObjectPSData.data);

                _math.mat4.transpose(this._perObjectData.perObjectVSData.data, this.worldTransform);
                _math.mat4.transpose(this._perObjectData.perObjectVSData.data.subarray(16), this.worldTransformLast);
            } else {
                if (!this._perObjectData) {
                    this._perObjectData = new _core.Tw2BasicPerObjectData(_EveChild2.EveChild.perObjectDataDecl);
                }

                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
            }

            this.mesh.GetBatches(mode, accumulator, this._perObjectData);
        }
    }]);

    return EveChildMesh;
}(_EveChild2.EveChild);

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTransform = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveTransform
 *
 * @property {String} name
 * @property {Boolean} display                                      - Enables/ disables all batch accumulations
 * @property {{}} visible                                           - Batch accumulation options for the transforms's elements
 * @property {Boolean} visible.mesh                                 - Enables/ disables mesh batch accumulation
 * @property {Boolean} visible.children                             - Enables/ disables child batch accumulation
 * @property {Tw2Mesh} mesh
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {Array} children
 * @property {Array.<Tw2ParticleSystem>} particleSystems
 * @property {Array.<Tw2StaticEmitter|Tw2DynamicEmitter>} particleEmitters
 * @property {Number} Modifier
 * @property {Number} sortValueMultiplier
 * @property {Number} distanceBasedScaleArg1
 * @property {Number} distanceBasedScaleArg2
 * @property {Boolean} useDistanceBasedScale
 * @property {vec3} scaling
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {Array.<mat4>} _mat4Cache
 * @property {Array.<vec3>} _vec3Cache
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveTransform = exports.EveTransform = function (_EveObject) {
    _inherits(EveTransform, _EveObject);

    function EveTransform() {
        _classCallCheck(this, EveTransform);

        var _this = _possibleConstructorReturn(this, (EveTransform.__proto__ || Object.getPrototypeOf(EveTransform)).call(this));

        _this.visible = {};
        _this.visible.mesh = true;
        _this.visible.children = true;
        _this.mesh = null;
        _this.curveSets = [];
        _this.children = [];
        _this.particleSystems = [];
        _this.particleEmitters = [];
        _this.modifier = EveTransform.Modifier.NONE;
        _this.sortValueMultiplier = 1.0;
        _this.distanceBasedScaleArg1 = 0.2;
        _this.distanceBasedScaleArg2 = 0.63;
        _this.useDistanceBasedScale = false;
        _this.scaling = _math.vec3.fromValues(1, 1, 1);
        _this.translation = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this.localTransform = _math.mat4.create();
        _this.worldTransform = _math.mat4.create();
        _this._perObjectData = new _core.Tw2BasicPerObjectData(EveTransform.perObjectDataDecl);

        EveTransform.init();
        return _this;
    }

    /**
     * Initializes the EveTransform
     */


    _createClass(EveTransform, [{
        key: 'Initialize',
        value: function Initialize() {
            _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
        }

        /**
         * Gets transform res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} [excludeChildren] - True to exclude children's res objects
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            if (this.mesh) this.mesh.GetResources(out);

            if (!excludeChildren) {
                for (var i = 0; i < this.children; i++) {
                    this.children[i].GetResources(out);
                }
            }

            return out;
        }

        /**
         * Per frame update
         * @param {mat4} parentTransform
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData(parentTransform) {
            var g = EveTransform.global,
                finalScale = g.vec3_0,
                parentScale = g.vec3_1,
                dir = g.vec3_2,
                viewInv = _core.device.viewInverse;

            _math.quat.normalize(this.rotation, this.rotation);
            _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
            _math.mat4.getScaling(parentScale, parentTransform);

            switch (this.modifier) {
                case EveTransform.Modifier.BILLBOARD:
                case EveTransform.Modifier.SIMPLE_HALO:
                    var dirNorm = g.vec3_3;
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
                    _math.vec3.multiply(finalScale, this.scaling, parentScale);

                    if (this.modifier === EveTransform.Modifier.SIMPLE_HALO) {
                        _math.vec3.subtract(dir, _core.device.GetEyePosition(), this.worldTransform.subarray(12));
                        _math.vec3.normalize(dirNorm, this.worldTransform.subarray(8));
                        _math.vec3.normalize(dir, dir);
                        var scale = _math.vec3.dot(dir, dirNorm);
                        if (scale < 0) scale = 0;
                        _math.vec3.scale(finalScale, finalScale, scale * scale);
                    }

                    this.worldTransform[0] = viewInv[0] * finalScale[0];
                    this.worldTransform[1] = viewInv[1] * finalScale[0];
                    this.worldTransform[2] = viewInv[2] * finalScale[0];
                    this.worldTransform[4] = viewInv[4] * finalScale[1];
                    this.worldTransform[5] = viewInv[5] * finalScale[1];
                    this.worldTransform[6] = viewInv[6] * finalScale[1];
                    this.worldTransform[8] = viewInv[8] * finalScale[2];
                    this.worldTransform[9] = viewInv[9] * finalScale[2];
                    this.worldTransform[10] = viewInv[10] * finalScale[2];
                    break;

                case EveTransform.Modifier.EVE_CAMERA_ROTATION:
                    var translation = g.vec3_3;
                    _math.vec3.transformMat4(translation, this.translation, parentTransform);
                    _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, translation, this.scaling);
                    _math.mat4.multiply(this.worldTransform, viewInv, this.localTransform);
                    this.worldTransform[12] = this.localTransform[12];
                    this.worldTransform[13] = this.localTransform[13];
                    this.worldTransform[14] = this.localTransform[14];
                    break;

                case EveTransform.Modifier.EVE_CAMERA_ROTATION_ALIGNED:
                case EveTransform.Modifier.EVE_SIMPLE_HALO:
                    var camPos = _core.device.GetEyePosition(),
                        camFwd = g.vec3_3,
                        right = g.vec3_4,
                        up = g.vec3_5,
                        forward = g.vec3_6,
                        dirToCamNorm = g.vec3_7,
                        parentT = g.mat4_0,
                        alignMat = g.mat4_1,
                        rotationT = g.mat4_2;

                    // 3 4 3 3 3 4 3 3
                    _math.mat4.translate(this.worldTransform, parentTransform, this.translation);
                    _math.mat4.transpose(parentT, parentTransform);

                    dir[0] = camPos[0] - this.worldTransform[12];
                    dir[1] = camPos[1] - this.worldTransform[13];
                    dir[2] = camPos[2] - this.worldTransform[14];

                    _math.vec3.copy(camFwd, dir);
                    _math.vec3.transformMat4(camFwd, camFwd, parentT);
                    _math.vec3.divide(camFwd, camFwd, parentScale);
                    _math.vec3.normalize(camFwd, camFwd);

                    _math.vec3.set(right, _core.device.view[0], _core.device.view[4], _core.device.view[8]);
                    _math.vec3.transformMat4(right, right, parentT);
                    _math.vec3.normalize(right, right);

                    _math.vec3.cross(up, camFwd, right);
                    _math.vec3.normalize(up, up);
                    _math.vec3.cross(right, up, camFwd);

                    alignMat[0] = right[0];
                    alignMat[1] = right[1];
                    alignMat[2] = right[2];
                    alignMat[4] = up[0];
                    alignMat[5] = up[1];
                    alignMat[6] = up[2];
                    alignMat[8] = camFwd[0];
                    alignMat[9] = camFwd[1];
                    alignMat[10] = camFwd[2];
                    alignMat[15] = 1;

                    _math.mat4.fromQuat(rotationT, this.rotation);
                    _math.mat4.multiply(alignMat, alignMat, rotationT);

                    if (this.modifier === EveTransform.Modifier.EVE_SIMPLE_HALO) {
                        _math.vec3.normalize(forward, this.worldTransform.subarray(8));
                        _math.vec3.normalize(dirToCamNorm, dir);
                        var _scale = -_math.vec3.dot(dirToCamNorm, forward);
                        if (_scale < 0) _scale = 0;
                        _math.mat4.multiply(this.worldTransform, this.worldTransform, alignMat);
                        _math.mat4.scale(this.worldTransform, this.worldTransform, [this.scaling[0] * _scale, this.scaling[1] * _scale, this.scaling[2] * _scale]);
                    } else {
                        _math.mat4.scale(this.worldTransform, this.worldTransform, this.scaling);
                        _math.mat4.multiply(this.worldTransform, this.worldTransform, alignMat);
                    }
                    break;

                case EveTransform.Modifier.LOOK_AT_CAMERA:
                    var lookAt = g.mat4_0;
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
                    _math.mat4.lookAt(lookAt, viewInv.subarray(12), this.worldTransform.subarray(12), [0, 1, 0]);
                    _math.mat4.transpose(lookAt, lookAt);
                    _math.vec3.multiply(finalScale, this.scaling, parentScale);
                    this.worldTransform[0] = lookAt[0] * finalScale[0];
                    this.worldTransform[1] = lookAt[1] * finalScale[0];
                    this.worldTransform[2] = lookAt[2] * finalScale[0];
                    this.worldTransform[4] = lookAt[4] * finalScale[1];
                    this.worldTransform[5] = lookAt[5] * finalScale[1];
                    this.worldTransform[6] = lookAt[6] * finalScale[1];
                    this.worldTransform[8] = lookAt[8] * finalScale[2];
                    this.worldTransform[9] = lookAt[9] * finalScale[2];
                    this.worldTransform[10] = lookAt[10] * finalScale[2];
                    break;

                default:
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
            }

            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].UpdateViewDependentData(this.worldTransform);
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].Update(dt);
            }

            for (var _i = 0; _i < this.particleEmitters.length; ++_i) {
                this.particleEmitters[_i].Update(dt);
            }

            for (var _i2 = 0; _i2 < this.particleSystems.length; ++_i2) {
                this.particleSystems[_i2].Update(dt);
            }

            for (var _i3 = 0; _i3 < this.curveSets.length; ++_i3) {
                this.curveSets[_i3].Update(dt);
            }
        }

        /**
         * Gets render batches for accumulation
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData|Tw2BasicPerObjectData} [perObjectData]
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display) return;

            if (this.visible.mesh && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('World'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('WorldInverseTranspose'), this.worldTransform);
                if (perObjectData) {
                    this._perObjectData.perObjectVSData = perObjectData.perObjectVSData;
                    this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
                }
                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }

            if (this.visible.children) {
                for (var i = 0; i < this.children.length; ++i) {
                    this.children[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }

        /**
         * multiply3x3
         */

    }], [{
        key: 'Multiply3x3',
        value: function Multiply3x3(a, b, c) {
            c || (c = b);
            var d = b[0],
                e = b[1];
            b = b[2];
            c[0] = a[0] * d + a[4] * e + a[8] * b;
            c[1] = a[1] * d + a[5] * e + a[9] * b;
            c[2] = a[2] * d + a[6] * e + a[10] * b;
            return c;
        }

        /**
         * Initializes class global and scratch variables
         */

    }, {
        key: 'init',
        value: function init() {
            if (!EveTransform.global) {
                EveTransform.global = {
                    vec3_0: _math.vec3.create(),
                    vec3_1: _math.vec3.create(),
                    vec3_2: _math.vec3.create(),
                    vec3_3: _math.vec3.create(),
                    vec3_4: _math.vec3.create(),
                    vec3_5: _math.vec3.create(),
                    vec3_6: _math.vec3.create(),
                    vec3_7: _math.vec3.create(),
                    mat4_0: _math.mat4.create(),
                    mat4_1: _math.mat4.create(),
                    mat4_2: _math.mat4.create()
                };
            }
        }
    }]);

    return EveTransform;
}(_EveObject2.EveObject);

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveTransform.global = null;

/**
 * Modifier states
 * @type {{string:Number}}
 */
EveTransform.Modifier = {
    NONE: 0,
    BILLBOARD: 1,
    TRANSLATE_WITH_CAMERA: 2,
    LOOK_AT_CAMERA: 3,
    SIMPLE_HALO: 4,
    EVE_CAMERA_ROTATION_ALIGNED: 100,
    EVE_BOOSTER: 101,
    EVE_SIMPLE_HALO: 102,
    EVE_CAMERA_ROTATION: 103
};

/**
 * Per object data declarations
 * @type {{FFEData: *[]}}
 */
EveTransform.perObjectDataDecl = {
    FFEData: [{ name: 'World', size: 16 }, { name: 'WorldInverseTranspose', size: 16 }]
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveShip = exports.EveTurretSetLocatorInfo = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _EveSpaceObject2 = __webpack_require__(27);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Eve Turret Set Locator Info
 * @property {boolean} isJoint
 * @property {Array.<mat4>} locatorTransforms
 */
var EveTurretSetLocatorInfo = exports.EveTurretSetLocatorInfo = function EveTurretSetLocatorInfo() {
    _classCallCheck(this, EveTurretSetLocatorInfo);

    this.isJoint = false;
    this.locatorTransforms = [];
};

/**
 * EveShip
 *
 * @property {number} boosterGain
 * @property {Array.<EveBoosterSet>} boosters
 * @property {Array.<EveTurretSet>} turretSets
 * @property {Array} _turretSetsLocatorInfo
 * @property {boolean} visible.turretSets      - Enables/ disables turret set batch accumulation
 * @property {boolean} visible.turretEffects   - Enabled/ disables turret set effects
 * @property {boolean} visible.boosters        - Enables/ disables booster batch accumulation
 * @class
 */


var EveShip = exports.EveShip = function (_EveSpaceObject) {
    _inherits(EveShip, _EveSpaceObject);

    function EveShip() {
        _classCallCheck(this, EveShip);

        var _this = _possibleConstructorReturn(this, (EveShip.__proto__ || Object.getPrototypeOf(EveShip)).call(this));

        _this.visible.turretSets = true;
        _this.visible.boosters = true;
        _this.boosters = null;
        _this.turretSets = [];
        _this._turretSetsLocatorInfo = [];
        _this.boosterGain = 1;
        return _this;
    }

    /**
     * Initializes the ship
     */


    _createClass(EveShip, [{
        key: 'Initialize',
        value: function Initialize() {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'Initialize', this).call(this);

            if (this.boosters) {
                this.RebuildBoosterSet();
            }
        }

        /**
         * Rebuilds the ship's booster set
         */

    }, {
        key: 'RebuildBoosterSet',
        value: function RebuildBoosterSet() {
            if (this.boosters) {
                this.boosters.Clear();
                var locators = this.FindLocatorsByPrefix('locator_booster');
                for (var i = 0; i < locators.length; ++i) {
                    this.boosters.Add(locators[i].transform, locators[i].atlasIndex0, locators[i].atlasIndex1, locators[i].name);
                }
                this.boosters.Rebuild();
            }
        }

        /**
         * Rebuilds turret positions
         */

    }, {
        key: 'RebuildTurretPositions',
        value: function RebuildTurretPositions() {
            this._turretSetsLocatorInfo = [];
            for (var i = 0; i < this.turretSets.length; ++i) {
                var name = this.turretSets[i].locatorName,
                    locatorCount = this.GetLocatorCount(name),
                    locator = new EveTurretSetLocatorInfo();

                for (var j = 0; j < locatorCount; ++j) {
                    var locatorName = name + String.fromCharCode('a'.charCodeAt(0) + j);

                    var locatorTransform = this.FindLocatorJointByName(locatorName);
                    if (locatorTransform !== null) {
                        locator.isJoint = true;
                    } else {
                        locatorTransform = this.FindLocatorTransformByName(locatorName);
                    }

                    if (locatorTransform !== null) {
                        this.turretSets[i].SetLocalTransform(j, locatorTransform, locatorName);
                        locator.locatorTransforms.push(locatorTransform);
                    }
                }
                this._turretSetsLocatorInfo.push(locator);
            }
        }

        /**
         * Gets ship's resources
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} [excludeChildren] - True to exclude children's res objects
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'GetResources', this).call(this, out, excludeChildren);

            for (var i = 0; i < this.turretSets.length; i++) {
                this.turretSets[i].GetResources(out);
            }

            if (this.boosters) {
                this.boosters.GetResources(out);
            }

            return out;
        }

        /**
         * Updates view dependant data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'UpdateViewDependentData', this).call(this);
            for (var i = 0; i < this.turretSets.length; ++i) {
                this.turretSets[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {number} dt - deltaTime
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'Update', this).call(this, dt);

            if (this.boosters) {
                if (this.boosters.rebuildPending) {
                    this.RebuildBoosterSet();
                }
                this.boosters.Update(dt, this.transform);
            }

            for (var i = 0; i < this.turretSets.length; ++i) {
                if (i < this._turretSetsLocatorInfo.length) {
                    if (this._turretSetsLocatorInfo[i].isJoint) {
                        var locatorInfo = this._turretSetsLocatorInfo[i];
                        for (var j = 0; j < locatorInfo.locatorTransforms.length; ++j) {
                            this.turretSets[i].SetLocalTransform(j, locatorInfo.locatorTransforms[j]);
                        }
                    }
                }
            }

            for (var _i = 0; _i < this.turretSets.length; ++_i) {
                this.turretSets[_i].Update(dt, this.transform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display) return;

            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'GetBatches', this).call(this, mode, accumulator);

            this._perObjectData.perObjectVSData.Get('Shipdata')[0] = this.boosterGain;
            this._perObjectData.perObjectPSData.Get('Shipdata')[0] = this.boosterGain;

            for (var i = 0; i < this.turretSets.length; ++i) {
                if (this.lod > 1 && this.visible.turretSets) {
                    this.turretSets[i].GetBatches(mode, accumulator, this._perObjectData, this.visible.turretEffects);
                } else if (this.visible.turretEffects) {
                    this.turretSets[i].GetEffectBatches(mode, accumulator, this._perObjectData);
                }
            }

            if (this.boosters && this.visible.boosters) {
                this.boosters.GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveShip;
}(_EveSpaceObject2.EveSpaceObject);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveOccluder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveOccluder
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {boolean} display
 * @property {number} value
 * @property {Array.<EveSpriteSet>} sprites
 * @class
 */
var EveOccluder = exports.EveOccluder = function () {
    function EveOccluder() {
        _classCallCheck(this, EveOccluder);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.value = 1;
        this.sprites = [];

        EveOccluder.init();
    }

    /**
     * UpdateValues
     * @param {mat4} parentTransform
     * @param {number} index
     */


    _createClass(EveOccluder, [{
        key: 'UpdateValue',
        value: function UpdateValue(parentTransform, index) {
            if (!this.display || !_core.device.alphaBlendBackBuffer) return;

            var g = EveOccluder.global,
                worldViewProj = g.mat4_0,
                center = g.vec4_0;

            g.accumulator.Clear();

            for (var i = 0; i < this.sprites.length; ++i) {
                this.sprites[i].UpdateViewDependentData(parentTransform);
                this.sprites[i].GetBatches(_core.device.RM_DECAL, g.accumulator);
            }

            _core.store.GetVariable('OccluderValue').value.set([(1 << index * 2) / 255.0, (2 << index * 2) / 255.0, 0, 0]);
            g.accumulator.Render();

            _math.mat4.multiply(worldViewProj, _core.device.viewProjection, this.sprites[0].worldTransform);
            _math.vec4.transformMat4(center, [0, 0, 0, 1], worldViewProj);

            var x0 = (center[0] / center[3] + 1) * 0.5,
                y0 = (center[1] / center[3] + 1) * 0.5;

            _math.vec4.set(center, 0.5, 0.5, 0, 1);
            _math.vec4.transformMat4(center, center, worldViewProj);

            var x1 = (center[0] / center[3] + 1) * 0.5,
                y1 = (center[1] / center[3] + 1) * 0.5;

            center[0] = x0;
            center[1] = y0;
            center[2] = x1 - x0;
            center[3] = y1 - y0;

            g.effect.parameters.OccluderPosition.SetValue(center);
        }

        /**
         * CollectSamples
         * @param {Tw2TextureRes} tex
         * @param {number} index
         * @param {number} total
         * @param {number} samples
         * @returns boolean
         */

    }], [{
        key: 'CollectSamples',
        value: function CollectSamples(tex, index, total, samples) {
            var g = this.global,
                effect = g.effect,
                vertexBuffer = g.vertexBuffer,
                decl = g.decl;

            if (!effect.IsGood()) return false;

            effect.parameters.BackBuffer.textureRes = tex;
            effect.parameters.OccluderIndex.SetValue([index, total, samples]);

            _core.device.SetStandardStates(_core.device.RM_ADDITIVE);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, vertexBuffer);

            for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
                effect.ApplyPass(pass);
                if (decl.SetDeclaration(effect.GetPassInput(pass), 16)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawArrays(_core.device.gl.TRIANGLES, 0, 255 * 6);
            }
            return true;
        }

        /**
         * Initializes class globals and scratch variables
         */

    }, {
        key: 'init',
        value: function init() {
            if (EveOccluder.global) return;

            var g = EveOccluder.global = {};
            g.mat4_0 = _math.mat4.create();
            g.vec4_0 = _math.vec4.create();
            g.accumulator = new _core.Tw2BatchAccumulator();

            g.effect = _core.Tw2Effect.create({
                name: 'Occluder sampler collector',
                effectFilePath: 'res:/graphics/effect/managed/space/specialfx/lensflares/collectsamples.fx',
                parameters: {
                    OccluderPosition: _math.vec4.fromValues(1, 1, 1, 1),
                    OccluderIndex: _math.vec3.fromValues(1, 1, 1)
                },
                textures: {
                    BackBuffer: ''
                }
            });

            g.vertexBuffer = null;
            g.decl = new _core.Tw2VertexDeclaration([['POSITION', 0, 'FLOAT', 2, 0], ['TEXCOORD', 0, 'FLOAT', 2, 8]]);

            var vb = new Float32Array(255 * 6 * 4);
            var index = 0;
            for (var i = 0; i < 16; ++i) {
                for (var j = 0; j < 16; ++j) {
                    var x = (i + Math.random()) / 16 * 2 - 1,
                        y = (j + Math.random()) / 16 * 2 - 1;

                    vb[index++] = 1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = -1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = 1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;

                    vb[index++] = -1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = 1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = -1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;
                }
            }

            g.vertexBuffer = _core.device.gl.createBuffer();
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, g.vertexBuffer);
            _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, vb, _core.device.gl.STATIC_DRAW);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);
        }
    }]);

    return EveOccluder;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveOccluder.global = null;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveBoosterBatch = EveBoosterBatch;
exports.EveBoosterSet = EveBoosterSet;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * EveObjectSet
 * @typedef {EveBoosterSet|EvePlaneSet|EveSpotlightSet|EveTurretSet|EveSpaceObjectDecal} EveObjectSet
 */

/**
 * Booster render batch
 * @constructor
 */
function EveBoosterBatch() {
    this.renderMode = _core.device.RM_ANY;
    this.perObjectData = null;
    this.boosters = null;
}

/**
 * Commits the batch
 * @param {Tw2Effect} [overrideEffect]
 */
EveBoosterBatch.prototype.Commit = function (overrideEffect) {
    this.boosters.Render(overrideEffect);
};

/**
 * EveBoosterSet
 * @property {boolean} display
 * @property {Tw2Effect} effect
 * @property {Tw2Effect} glows
 * @property {number} glowScale
 * @property {vec4} glowColor
 * @property {vec4} warpGlowColor
 * @property {vec4} warpHaloColor
 * @property {number} symHaloScale
 * @property {number} haloScaleX
 * @property {number} haloScaleY
 * @property {number} maxVel
 * @property {vec4} haloColor
 * @property {boolean} alwaysOn
 * @property {vec4} trailSize
 * @property {vec4} trailColor
 * @property {mat4} _parentTransform
 * @property {mat4} _wavePhase
 * @property {Array.<{}>} _boosterTransforms
 * @property {WebGLBuffer} _positions
 * @property {Tw2VertexDeclaration} _decl
 * @property {Tw2PerObjectData} _perObjectData
 * @property {boolean} rebuildPending
 * @constructor
 */
function EveBoosterSet() {
    this.display = true;
    this.effect = null;
    this.glows = null;
    this.glowScale = 1.0;
    this.glowColor = _math.vec4.create();
    this.warpGlowColor = _math.vec4.create();
    this.warpHaloColor = _math.vec4.create();
    this.symHaloScale = 1.0;
    this.haloScaleX = 1.0;
    this.haloScaleY = 1.0;
    this.maxVel = 250;
    this.haloColor = _math.vec4.create();
    this.alwaysOn = true;

    this.trailColor = _math.vec4.create();
    this.trailSize = _math.vec4.create();

    this._parentTransform = _math.mat4.create();
    this._wavePhase = _math.mat4.create();
    this._boosterTransforms = [];

    this._positions = _core.device.gl.createBuffer();

    this._decl = new _core.Tw2VertexDeclaration();
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 2, 12));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 20));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 36));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 4, 52));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 4, 68));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 4, 84));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 6, _core.device.gl.FLOAT, 1, 100));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 7, _core.device.gl.FLOAT, 2, 104));
    this._decl.RebuildHash();

    this._perObjectData = new _core.Tw2PerObjectData();
    this._perObjectData.perObjectVSData = new _core.Tw2RawData();
    this._perObjectData.perObjectVSData.Declare('WorldMat', 16);
    this._perObjectData.perObjectVSData.Declare('Shipdata', 4);
    this._perObjectData.perObjectVSData.Create();

    this.rebuildPending = false;
}

/**
 * Initializes the booster set
 */
EveBoosterSet.prototype.Initialize = function () {
    this.rebuildPending = true;
};

/**
 * Gets booster set res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes>} [out]
 */
EveBoosterSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.effect !== null) {
        this.effect.GetResources(out);
    }

    if (this.glows !== null && this.glows.effect !== null) {
        this.glows.effect.GetResources(out);
    }

    return out;
};

/**
 * Clears the booster set
 */
EveBoosterSet.prototype.Clear = function () {
    this._boosterTransforms = [];
    this._wavePhase = _math.mat4.create();
    if (this.glows) {
        this.glows.Clear();
    }
};

/**
 * Scratch variables
 */
EveBoosterSet.scratch = {
    vec3_0: _math.vec3.create(),
    vec3_1: _math.vec3.create(),
    vec3_2: _math.vec3.create()
};

/**
 * Adds a booster
 * @param {mat4} localMatrix
 * @param {number} atlas0
 * @param {number} atlas1
 * @param {string} name
 */
EveBoosterSet.prototype.Add = function (localMatrix, atlas0, atlas1, name) {
    var scratch = EveBoosterSet.scratch;

    this._boosterTransforms[this._boosterTransforms.length] = {
        name: name,
        transform: _math.mat4.clone(localMatrix),
        atlas0: atlas0,
        atlas1: atlas1
    };
    this._wavePhase[this._wavePhase.length] = Math.random();
    if (this.glows) {
        var pos = _math.vec3.set(scratch.vec3_0, localMatrix[12], localMatrix[13], localMatrix[14]);
        var dir = _math.vec3.set(scratch.vec3_1, localMatrix[8], localMatrix[9], localMatrix[10]);
        var scale = Math.max(_math.vec3.length([localMatrix[0], localMatrix[1], localMatrix[2]]), _math.vec3.length([localMatrix[4], localMatrix[5], localMatrix[6]]));
        _math.vec3.normalize(dir, dir);
        if (scale < 3) _math.vec3.scale(dir, dir, scale / 3);
        var seed = Math.random() * 0.7;
        var spritePos = scratch.vec3_2;
        _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, 2.5));
        this.glows.Add(spritePos, seed, seed, scale * this.glowScale, scale * this.glowScale, 0, this.glowColor, this.warpGlowColor);
        _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, 3));
        this.glows.Add(spritePos, seed, 1 + seed, scale * this.symHaloScale, scale * this.symHaloScale, 0, this.haloColor, this.warpGlowColor);
        _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, 3.01));
        this.glows.Add(spritePos, seed, 1 + seed, scale * this.haloScaleX, scale * this.haloScaleY, 0, this.haloColor, this.warpGlowColor);
    }
};

/**
 * Rebuilds the boosters
 */
EveBoosterSet.prototype.Rebuild = function () {
    var data = new Float32Array(this._boosterTransforms.length * EveBoosterSet._box.length * 6 * 28);
    var order = [0, 3, 1, 3, 2, 1];
    var index = 0;
    for (var booster = 0; booster < this._boosterTransforms.length; ++booster) {
        for (var i = 0; i < EveBoosterSet._box.length; ++i) {
            for (var j = 0; j < order.length; ++j) {
                data[index++] = EveBoosterSet._box[i][order[j]][0];
                data[index++] = EveBoosterSet._box[i][order[j]][1];
                data[index++] = EveBoosterSet._box[i][order[j]][2];
                data[index++] = 0;
                data[index++] = 0;
                data.set(this._boosterTransforms[booster].transform, index);
                index += 16;
                data[index++] = 0;
                data[index++] = 1;
                data[index++] = 1;
                data[index++] = 1;
                data[index++] = this._wavePhase[booster];
                data[index++] = this._boosterTransforms[booster].atlas0;
                data[index++] = this._boosterTransforms[booster].atlas1;
            }
        }
    }
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._positions);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, data, _core.device.gl.STATIC_DRAW);

    this.rebuildPending = false;
    if (this.glows) {
        this.glows.RebuildBuffers();
    }
};

/**
 * Per frame update
 * @param {number} dt - DeltaTime
 * @param {mat4} parentMatrix
 * @constructor
 */
EveBoosterSet.prototype.Update = function (dt, parentMatrix) {
    if (this.glows) {
        this.glows.Update(dt);
    }
    this._parentTransform = parentMatrix;
};

/**
 * Gets render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 */
EveBoosterSet.prototype.GetBatches = function (mode, accumulator, perObjectData) {
    if (!this.display || mode !== _core.device.RM_ADDITIVE) {
        return;
    }
    if (this.effect && this._boosterTransforms.length) {
        var batch = new EveBoosterBatch();
        _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this._parentTransform);
        this._perObjectData.perObjectVSData.Set('Shipdata', perObjectData.perObjectVSData.Get('Shipdata'));
        this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
        batch.perObjectData = this._perObjectData;
        batch.boosters = this;
        batch.renderMode = _core.device.RM_ADDITIVE;
        accumulator.Commit(batch);
    }
    if (this.glows) {
        this.glows.GetBoosterGlowBatches(mode, accumulator, perObjectData, this._parentTransform, perObjectData.perObjectVSData.Get('Shipdata')[0], 0);
    }
};

/**
 * Renders the accumulated batches
 * @param {Tw2Effect} [overrideEffect]
 * @returns {boolean}
 */
EveBoosterSet.prototype.Render = function (overrideEffect) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return false;
    }

    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._positions);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._decl.SetDeclaration(effect.GetPassInput(pass), 112)) {
            return false;
        }
        _core.device.ApplyShadowState();
        _core.device.gl.drawArrays(_core.device.gl.TRIANGLES, 0, this._boosterTransforms.length * 12 * 3);
    }
    return true;
};

/**
 * Internal helper
 * @type {Array}
 * @private
 */
EveBoosterSet._box = [[[-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0]], [[-1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [1.0, 1.0, -1.0], [1.0, -1.0, -1.0]], [[-1.0, -1.0, 0.0], [-1.0, 1.0, 0.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, -1.0]], [[1.0, -1.0, 0.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [1.0, 1.0, 0.0]], [[-1.0, -1.0, 0.0], [-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, -1.0, 0.0]], [[-1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0]]];

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveLocator = undefined;

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains transform information for Boosters, Turrets and XLTurrets
 *
 * @property {string} name
 * @property {?number} atlasIndex0
 * @property {?number} atlasIndex1
 * @property {mat4} transform
 * @class
 */
var EveLocator = exports.EveLocator = function EveLocator() {
    _classCallCheck(this, EveLocator);

    this.name = '';
    this.atlasIndex0 = null;
    this.atlasIndex1 = null;
    this.transform = _math.mat4.create();
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvePlaneSetBatch = EvePlaneSetBatch;
exports.EvePlaneSetItem = EvePlaneSetItem;
exports.EvePlaneSet = EvePlaneSet;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * Plane set render batch
 * @constructor
 */
function EvePlaneSetBatch() {
    this.renderMode = _core.device.RM_ANY;
    this.perObjectData = null;
    this.planeSet = null;
}

/**
 * Commits the plan set
 * @param {Tw2Effect} [overrideEffect]
 * @constructor
 */
EvePlaneSetBatch.prototype.Commit = function (overrideEffect) {
    this.planeSet.Render(overrideEffect);
};

/**
 * EvePlaneSetItem
 * @property {string} name
 * @property {vec3} position
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec4} color
 * @property {vec4} layer1Transform
 * @property {vec4} layer2Transform
 * @property {vec4} layer1Scroll
 * @property {vec4} layer2Scroll
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @constructor
 */
function EvePlaneSetItem() {
    this.display = true;
    this.name = '';
    this.position = _math.vec3.create();
    this.scaling = _math.vec3.fromValues(1, 1, 1);
    this.rotation = _math.quat.create();
    this.color = _math.vec4.fromValues(1, 1, 1, 1);
    this.layer1Transform = _math.vec4.fromValues(1, 1, 0, 0);
    this.layer2Transform = _math.vec4.fromValues(1, 1, 0, 0);
    this.layer1Scroll = _math.quat.create();
    this.layer2Scroll = _math.quat.create();
    this.boneIndex = 0;
    this.groupIndex = -1;
    this.maskAtlasID = 0;
}

/**
 * EvePlaneSet
 * @property {String} name
 * @property {Array.<EvePlaneSetItem>} planes
 * @property {Tw2Effect} effect
 * @property {boolean} display
 * @property {boolean} hideOnLowQuality
 * @property {number} _time
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 * @constructor
 */
function EvePlaneSet() {
    this.name = '';
    this.planes = [];
    this.effect = null;
    this.display = true;
    this.hideOnLowQuality = false;
    this._time = 0;

    this._vertexBuffer = null;
    this._indexBuffer = null;
    this._decl = new _core.Tw2VertexDeclaration();
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 0));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 16));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 32));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 48));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 4, 64));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 4, 80));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 4, 96));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 6, _core.device.gl.FLOAT, 4, 112));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 7, _core.device.gl.FLOAT, 3, 128));
    this._decl.RebuildHash();
}

/**
 * Initializes the plane set
 */
EvePlaneSet.prototype.Initialize = function () {
    this.RebuildBuffers();
};

/**
 * Gets plane set res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array} {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
EvePlaneSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.effect !== null) {
        this.effect.GetResources(out);
    }

    return out;
};

/**
 * Rebuilds the plane set's buffers
 */
EvePlaneSet.prototype.RebuildBuffers = function () {
    var vertexSize = 35;
    var visibleItems = [];
    var mat4_0 = EvePlaneSet.scratch.mat4_0;

    for (var n = 0; n < this.planes.length; n++) {
        if (this.planes[n].display) {
            visibleItems.push(this.planes[n]);
        }
    }

    var array = new Float32Array(visibleItems.length * 4 * vertexSize);
    for (var i = 0; i < visibleItems.length; ++i) {
        var offset = i * 4 * vertexSize;
        array[offset + vertexSize - 3] = 0;
        array[offset + vertexSize + vertexSize - 3] = 1;
        array[offset + 2 * vertexSize + vertexSize - 3] = 2;
        array[offset + 3 * vertexSize + vertexSize - 3] = 3;

        var itemTransform = _math.mat4.fromRotationTranslationScale(mat4_0, visibleItems[i].rotation, visibleItems[i].position, visibleItems[i].scaling);

        for (var j = 0; j < 4; ++j) {
            vtxOffset = offset + j * vertexSize;
            array[vtxOffset + 0] = itemTransform[0];
            array[vtxOffset + 1] = itemTransform[4];
            array[vtxOffset + 2] = itemTransform[8];
            array[vtxOffset + 3] = itemTransform[12];
            array[vtxOffset + 4] = itemTransform[1];
            array[vtxOffset + 5] = itemTransform[5];
            array[vtxOffset + 6] = itemTransform[9];
            array[vtxOffset + 7] = itemTransform[13];
            array[vtxOffset + 8] = itemTransform[2];
            array[vtxOffset + 9] = itemTransform[6];
            array[vtxOffset + 10] = itemTransform[10];
            array[vtxOffset + 11] = itemTransform[14];

            array[vtxOffset + 12] = visibleItems[i].color[0];
            array[vtxOffset + 13] = visibleItems[i].color[1];
            array[vtxOffset + 14] = visibleItems[i].color[2];
            array[vtxOffset + 15] = visibleItems[i].color[3];

            array[vtxOffset + 16] = visibleItems[i].layer1Transform[0];
            array[vtxOffset + 17] = visibleItems[i].layer1Transform[1];
            array[vtxOffset + 18] = visibleItems[i].layer1Transform[2];
            array[vtxOffset + 19] = visibleItems[i].layer1Transform[3];

            array[vtxOffset + 20] = visibleItems[i].layer2Transform[0];
            array[vtxOffset + 21] = visibleItems[i].layer2Transform[1];
            array[vtxOffset + 22] = visibleItems[i].layer2Transform[2];
            array[vtxOffset + 23] = visibleItems[i].layer2Transform[3];

            array[vtxOffset + 24] = visibleItems[i].layer1Scroll[0];
            array[vtxOffset + 25] = visibleItems[i].layer1Scroll[1];
            array[vtxOffset + 26] = visibleItems[i].layer1Scroll[2];
            array[vtxOffset + 27] = visibleItems[i].layer1Scroll[3];

            array[vtxOffset + 28] = visibleItems[i].layer2Scroll[0];
            array[vtxOffset + 29] = visibleItems[i].layer2Scroll[1];
            array[vtxOffset + 30] = visibleItems[i].layer2Scroll[2];
            array[vtxOffset + 31] = visibleItems[i].layer2Scroll[3];

            array[vtxOffset + 33] = visibleItems[i].boneIndex;
            array[vtxOffset + 34] = visibleItems[i].maskAtlasID;
        }
    }
    this._vertexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);

    var indexes = new Uint16Array(visibleItems.length * 6);
    for (i = 0; i < visibleItems.length; ++i) {
        var offset = i * 6;
        var vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 2;
        indexes[offset + 2] = vtxOffset + 1;
        indexes[offset + 3] = vtxOffset + 0;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset + 2;
    }
    this._indexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, null);
    this._indexBuffer.count = visibleItems.length * 6;
};

/**
 * Gets the plane set's render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 */
EvePlaneSet.prototype.GetBatches = function (mode, accumulator, perObjectData) {
    if (this.display && mode === _core.device.RM_ADDITIVE) {
        var batch = new EvePlaneSetBatch();
        batch.renderMode = _core.device.RM_ADDITIVE;
        batch.planeSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
    }
};

/**
 * Renders the plane set
 * @param {Tw2Effect} [overrideEffect]
 * @constructor
 */
EvePlaneSet.prototype.Render = function (overrideEffect) {
    var effect = !overrideEffect ? this.effect : overrideEffect;
    if (!effect || !this._vertexBuffer) {
        return;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return;
    }
    _core.device.SetStandardStates(_core.device.RM_ADDITIVE);

    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._decl.SetDeclaration(effect.GetPassInput(pass), 140)) {
            return;
        }
        _core.device.ApplyShadowState();
        _core.device.gl.drawElements(_core.device.gl.TRIANGLES, this._indexBuffer.count, _core.device.gl.UNSIGNED_SHORT, 0);
    }
};

/**
 * Per frame update
 * @param {number} dt - Delta Time
 */
EvePlaneSet.prototype.Update = function (dt) {
    this._time += dt;
};

/**
 * Clears the plane set's plane items
 */
EvePlaneSet.prototype.Clear = function () {
    this.planes = [];
};

/**
 * Scratch variables
 */
EvePlaneSet.scratch = {
    mat4_0: _math.mat4.create()
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpaceObjectDecal = EveSpaceObjectDecal;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * EveSpaceObjectDecal
 * @property {boolean} display
 * @property {Tw2Effect} decalEffect
 * @property {Tw2Effect} pickEffect
 * @property {String} name=''
 * @property {number} groupIndex
 * @property {boolean} pickable
 * @property {vec3} position
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} decalMatrix
 * @property {mat4} invDecalMatrix
 * @property {Tw2GeometryRes} parentGeometry
 * @property {Array} indexBuffer
 * @property {*} _indexBuffer
 * @property {number} parentBoneIndex
 * @property {Tw2PerObjectData} _perObjectData
 * @constructor
 */
function EveSpaceObjectDecal() {
    this.display = true;
    this.decalEffect = null;
    this.pickEffect = null;
    this.name = '';
    this.groupIndex = -1;

    this.pickable = true;

    this.position = _math.vec3.create();
    this.rotation = _math.quat.create();
    this.scaling = _math.vec3.create();

    this.decalMatrix = _math.mat4.create();
    this.invDecalMatrix = _math.mat4.create();
    this.parentGeometry = null;
    this.indexBuffer = [];
    this._indexBuffer = null;
    this.parentBoneIndex = -1;

    this._perObjectData = new _core.Tw2PerObjectData();
    this._perObjectData.perObjectVSData = new _core.Tw2RawData();
    this._perObjectData.perObjectVSData.Declare('worldMatrix', 16);
    this._perObjectData.perObjectVSData.Declare('invWorldMatrix', 16);
    this._perObjectData.perObjectVSData.Declare('decalMatrix', 16);
    this._perObjectData.perObjectVSData.Declare('invDecalMatrix', 16);
    this._perObjectData.perObjectVSData.Declare('parentBoneMatrix', 16);
    this._perObjectData.perObjectVSData.Create();

    this._perObjectData.perObjectPSData = new _core.Tw2RawData();
    this._perObjectData.perObjectPSData.Declare('displayData', 4);
    this._perObjectData.perObjectPSData.Declare('shipData', 4 * 3);
    this._perObjectData.perObjectPSData.Create();

    _math.mat4.identity(this._perObjectData.perObjectVSData.Get('parentBoneMatrix'));
}

/**
 * Initializes the decal
 */
EveSpaceObjectDecal.prototype.Initialize = function () {
    var indexes = new Uint16Array(this.indexBuffer);
    this._indexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);

    _math.mat4.fromRotationTranslationScale(this.decalMatrix, this.rotation, this.position, this.scaling);
    _math.mat4.invert(this.invDecalMatrix, this.decalMatrix);
};

/**
 * Gets decal res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
EveSpaceObjectDecal.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.parentGeometry !== null) {
        if (out.indexOf(this.parentGeometry) === -1) {
            out.push(this.parentGeometry);
        }
    }

    if (this.decalEffect !== null) {
        this.decalEffect.GetResources(out);
    }

    return out;
};

/**
 * Sets the parent geometry
 * @param {Tw2GeometryRes} geometryRes
 */
EveSpaceObjectDecal.prototype.SetParentGeometry = function (geometryRes) {
    this.parentGeometry = geometryRes;
};

/**
 * Gets batches for rendering
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @param {number} [counter=0]
 */
EveSpaceObjectDecal.prototype.GetBatches = function (mode, accumulator, perObjectData, counter) {
    switch (mode) {
        case _core.device.RM_DECAL:
            if (!this.decalEffect) return;
            break;

        case _core.device.RM_PICKABLE:
            if (!this.pickEffect || !this.pickable) return;
            break;

        default:
            return;
    }

    if (this.display && this.indexBuffer.length && this.parentGeometry && this.parentGeometry.IsGood()) {
        var batch = new _core.Tw2ForwardingRenderBatch();
        this._perObjectData.perObjectVSData.Set('worldMatrix', perObjectData.perObjectVSData.Get('WorldMat'));
        if (this.parentBoneIndex >= 0) {
            var bones = perObjectData.perObjectVSData.Get('JointMat');
            var offset = this.parentBoneIndex * 12;
            if (bones[offset + 0] || bones[offset + 4] || bones[offset + 8]) {
                var bone = this._perObjectData.perObjectVSData.Get('parentBoneMatrix');
                bone[0] = bones[offset + 0];
                bone[1] = bones[offset + 4];
                bone[2] = bones[offset + 8];
                bone[3] = 0;
                bone[4] = bones[offset + 1];
                bone[5] = bones[offset + 5];
                bone[6] = bones[offset + 9];
                bone[7] = 0;
                bone[8] = bones[offset + 2];
                bone[9] = bones[offset + 6];
                bone[10] = bones[offset + 10];
                bone[11] = 0;
                bone[12] = bones[offset + 3];
                bone[13] = bones[offset + 7];
                bone[14] = bones[offset + 11];
                bone[15] = 1;
                _math.mat4.transpose(bone, bone);
            }
        }
        _math.mat4.invert(this._perObjectData.perObjectVSData.Get('invWorldMatrix'), this._perObjectData.perObjectVSData.Get('worldMatrix'));
        _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('decalMatrix'), this.decalMatrix);
        _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('invDecalMatrix'), this.invDecalMatrix);

        this._perObjectData.perObjectPSData.Get('displayData')[0] = counter || 0;
        this._perObjectData.perObjectPSData.Set('shipData', perObjectData.perObjectPSData.data);

        batch.perObjectData = this._perObjectData;
        batch.geometryProvider = this;
        batch.renderMode = mode;
        accumulator.Commit(batch);
    }
};

/**
 * Renders the decal
 * @param {Tw2ForwardingRenderBatch} batch
 * @param {Tw2Effect} overrideEffect
 */
EveSpaceObjectDecal.prototype.Render = function (batch, overrideEffect) {
    var bkIB = this.parentGeometry.meshes[0].indexes;
    var bkStart = this.parentGeometry.meshes[0].areas[0].start;
    var bkCount = this.parentGeometry.meshes[0].areas[0].count;
    var bkIndexType = this.parentGeometry.meshes[0].indexType;
    _math.mat4.copy(_core.store.GetVariable('u_DecalMatrix').value, this.decalMatrix);
    _math.mat4.copy(_core.store.GetVariable('u_InvDecalMatrix').value, this.invDecalMatrix);
    this.parentGeometry.meshes[0].indexes = this._indexBuffer;
    this.parentGeometry.meshes[0].areas[0].start = 0;
    this.parentGeometry.meshes[0].areas[0].count = this.indexBuffer.length;
    this.parentGeometry.meshes[0].indexType = _core.device.gl.UNSIGNED_SHORT;

    this.parentGeometry.RenderAreas(0, 0, 1, overrideEffect ? overrideEffect : batch.renderMode === _core.device.RM_DECAL ? this.decalEffect : this.pickEffect);
    this.parentGeometry.meshes[0].indexes = bkIB;
    this.parentGeometry.meshes[0].areas[0].start = bkStart;
    this.parentGeometry.meshes[0].areas[0].count = bkCount;
    this.parentGeometry.meshes[0].indexType = bkIndexType;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpotlightSetItem = EveSpotlightSetItem;
exports.EveSpotlightSet = EveSpotlightSet;
exports.EveSpotlightSetBatch = EveSpotlightSetBatch;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * Spotlight Item
 * - If a spotlight's properties are changed, it's parent's RebuildBuffers method must be called to apply these changes
 *
 * @property {string} name                  - The spotlight's name
 * @property {mat4} transform               - The spotlight's transform
 * @property {vec4} coneColor              - Colour of the spotlight's cone
 * @property {vec4} spriteColor            - Colour of the spotlight's sprite texture
 * @property {vec4} flareColor             - Colour of the spotlight's flare
 * @property {vec4} spriteScale            - The size of the spotlight
 * @property {boolean} boosterGainInfluence - If true, the spotlight can change size on booster gain
 * @property {number} boneIndex             - The spotlight's bone index
 * @property {number} groupIndex            - The sof faction group that the spotlight belongs to
 * @property {number} coneIntensity         - Scales the spotlight's cone colour, set by an object's sof Faction
 * @property {number} spriteIntensity       - Scales the spotlight's sprite colour, set by an object's sof Faction
 * @property {number} flareIntensity        - Scales the spotlight's flare colour, set by an object's sof Faction
 * @constructor
 */
function EveSpotlightSetItem() {
    this.display = true;
    this.name = '';
    this.transform = _math.mat4.create();
    this.coneColor = _math.vec4.create();
    this.spriteColor = _math.vec4.create();
    this.flareColor = _math.vec4.create();
    this.spriteScale = _math.vec3.create();
    this.boosterGainInfluence = false;
    this.boneIndex = 0;
    this.groupIndex = -1;
    this.coneIntensity = 1;
    this.spriteIntensity = 1;
    this.flareIntensity = 1;
}

/**
 * EveSpotlightSet
 *
 * @property {string} name                               - The spotlight set's name
 * @property {boolean} display                           - controls the visibility of the spotlight set, and all it's children
 * @property {Tw2Effect} coneEffect                      - The spotlight set's cone effect
 * @property {Tw2Effect} glowEffect                      - The spotlight set's glow effect
 * @property {Array.<EveSpotlightSetItem) spotlightItems - The spotlight set's children
 * @property {WebGLBuffer} _coneVertexBuffer             - Webgl buffer for the spotlight set's cone vertices
 * @property {WebGLBuffer} _spriteVertexBuffer           - Webgl buffer for the spotlight set's sprite/glow vertices
 * @property {WebGLBuffer} _indexBuffer                  - Webgl buffer for the spotlight set
 * @property {Tw2VertexDeclaration} _decl                - The spotlight set's vertex declarations
 * @constructor
 */
function EveSpotlightSet() {
    this.name = '';
    this.display = true;
    this.coneEffect = null;
    this.glowEffect = null;
    this.spotlightItems = [];

    this._coneVertexBuffer = null;
    this._spriteVertexBuffer = null;
    this._indexBuffer = null;

    this._decl = new _core.Tw2VertexDeclaration();
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 0));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 16));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 32));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 48));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 3, 64));
    this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 3, 76));
    this._decl.RebuildHash();
}

/**
 * Initializes the spotlight set
 */
EveSpotlightSet.prototype.Initialize = function () {
    this.RebuildBuffers();
};

/**
 * Gets the spotlight set's resources
 *
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
EveSpotlightSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.coneEffect !== null) {
        this.coneEffect.GetResources(out);
    }

    if (this.glowEffect !== null) {
        this.glowEffect.GetResources(out);
    }
    return out;
};

/**
 * Rebuilds the spotlight set's buffers
 */
EveSpotlightSet.prototype.RebuildBuffers = function () {
    var visibleItems = [];
    for (var i = 0; i < this.spotlightItems.length; i++) {
        if (this.spotlightItems[i].display) {
            visibleItems.push(this.spotlightItems[i]);
        }
    }

    var itemCount = visibleItems.length;
    if (itemCount === 0) {
        return;
    }
    var vertCount = 4;
    var coneQuadCount = 4;
    var coneVertexCount = itemCount * coneQuadCount * vertCount;

    var vertexSize = 22;
    var array = new Float32Array(coneVertexCount * vertexSize);

    var indexes = [1, 0, 2, 3];

    for (var i = 0; i < itemCount; ++i) {
        var item = visibleItems[i];
        for (var q = 0; q < coneQuadCount; ++q) {
            for (var v = 0; v < vertCount; ++v) {
                var offset = (i * coneQuadCount * vertCount + vertCount * q + v) * vertexSize;
                array[offset + 0] = item.coneColor[0] * item.coneIntensity;
                array[offset + 1] = item.coneColor[1] * item.coneIntensity;
                array[offset + 2] = item.coneColor[2] * item.coneIntensity;
                array[offset + 3] = item.coneColor[3];

                array[offset + 4] = item.transform[0];
                array[offset + 5] = item.transform[4];
                array[offset + 6] = item.transform[8];
                array[offset + 7] = item.transform[12];

                array[offset + 8] = item.transform[1];
                array[offset + 9] = item.transform[5];
                array[offset + 10] = item.transform[9];
                array[offset + 11] = item.transform[13];

                array[offset + 12] = item.transform[2];
                array[offset + 13] = item.transform[6];
                array[offset + 14] = item.transform[10];
                array[offset + 15] = item.transform[14];

                array[offset + 16] = 1;
                array[offset + 17] = 1;
                array[offset + 18] = 1;

                array[offset + 19] = q * vertCount + indexes[v];
                array[offset + 20] = item.boneIndex;
                array[offset + 21] = item.boosterGainInfluence ? 255 : 0;
            }
        }
    }

    this._coneVertexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._coneVertexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.STATIC_DRAW);
    this._coneVertexBuffer.count = itemCount * coneQuadCount * 6;

    var spriteQuadCount = 2;
    var spriteVertexCount = itemCount * spriteQuadCount * vertCount;
    array = new Float32Array(spriteVertexCount * vertexSize);

    var indexes = [1, 0, 2, 3];

    for (var i = 0; i < itemCount; ++i) {
        var item = visibleItems[i];
        for (var q = 0; q < spriteQuadCount; ++q) {
            for (var v = 0; v < vertCount; ++v) {
                var offset = (i * spriteQuadCount * vertCount + vertCount * q + v) * vertexSize;
                if (q % 2 === 0) {
                    array[offset + 0] = item.spriteColor[0] * item.spriteIntensity;
                    array[offset + 1] = item.spriteColor[1] * item.spriteIntensity;
                    array[offset + 2] = item.spriteColor[2] * item.spriteIntensity;
                    array[offset + 3] = item.spriteColor[3];

                    array[offset + 16] = item.spriteScale[0];
                    array[offset + 17] = 1;
                    array[offset + 18] = 1;
                } else {
                    array[offset + 0] = item.flareColor[0] * item.flareIntensity;
                    array[offset + 1] = item.flareColor[1] * item.flareIntensity;
                    array[offset + 2] = item.flareColor[2] * item.flareIntensity;
                    array[offset + 3] = item.flareColor[3];

                    array[offset + 16] = 1;
                    array[offset + 17] = item.spriteScale[1];
                    array[offset + 18] = item.spriteScale[2];
                }

                array[offset + 4] = item.transform[0];
                array[offset + 5] = item.transform[4];
                array[offset + 6] = item.transform[8];
                array[offset + 7] = item.transform[12];

                array[offset + 8] = item.transform[1];
                array[offset + 9] = item.transform[5];
                array[offset + 10] = item.transform[9];
                array[offset + 11] = item.transform[13];

                array[offset + 12] = item.transform[2];
                array[offset + 13] = item.transform[6];
                array[offset + 14] = item.transform[10];
                array[offset + 15] = item.transform[14];

                array[offset + 19] = q * vertCount + indexes[v];
                array[offset + 20] = item.boneIndex;
                array[offset + 21] = item.boosterGainInfluence ? 255 : 0;
            }
        }
    }

    this._spriteVertexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._spriteVertexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.STATIC_DRAW);
    this._spriteVertexBuffer.count = itemCount * spriteQuadCount * 6;

    var indexes = new Uint16Array(itemCount * coneQuadCount * 6);
    for (var i = 0; i < itemCount * coneQuadCount; ++i) {
        var offset = i * 6;
        var vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 1;
        indexes[offset + 2] = vtxOffset + 2;
        indexes[offset + 3] = vtxOffset + 2;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset + 0;
    }
    this._indexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, null);
};

/**
 * EveSpotlightSetBatch
 *
 * @inherits Tw2RenderBatch
 * @constructor
 */
function EveSpotlightSetBatch() {
    this.renderMode = _core.device.RM_ANY;
    this.perObjectData = null;
    this.spotlightSet = null;
}

/**
 * Commits the spotlight set for rendering
 *
 * @param {Tw2Effect} overrideEffect
 */
EveSpotlightSetBatch.prototype.Commit = function (overrideEffect) {
    this.spotlightSet.RenderCones(overrideEffect);
    this.spotlightSet.RenderGlow(overrideEffect);
};

/**
 * Gets the spotlight set's render batches
 *
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 */
EveSpotlightSet.prototype.GetBatches = function (mode, accumulator, perObjectData) {
    if (this.display && mode === _core.device.RM_ADDITIVE) {
        var batch = new EveSpotlightSetBatch();
        batch.renderMode = _core.device.RM_ADDITIVE;
        batch.spotlightSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
    }
};

/**
 * Renders the spotlight set's cone effect
 *
 * @param {Tw2Effect} [overrideEffect] - An optional Tw2Effect which can be passed to override the current cone effect
 */
EveSpotlightSet.prototype.RenderCones = function (overrideEffect) {
    var effect = !overrideEffect ? this.coneEffect : overrideEffect;
    this._Render(effect, this._coneVertexBuffer);
};

/**
 * Renders the spotlight set's glow effect
 *
 * @param {Tw2Effect} overrideEffect - An optional Tw2Effect which can be passed to override the current glow effect
 */
EveSpotlightSet.prototype.RenderGlow = function (overrideEffect) {
    var effect = !overrideEffect ? this.glowEffect : overrideEffect;
    this._Render(effect, this._spriteVertexBuffer);
};

/**
 * Internal render function
 *
 * @param {Tw2Effect} effect   - The Tw2Effect to render
 * @param {WebGLBuffer} buffer - A webgl buffer (ie. cone or glow buffer)
 * @private
 */
EveSpotlightSet.prototype._Render = function (effect, buffer) {
    if (!effect || !buffer || !this._indexBuffer) {
        return;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return;
    }

    _core.device.SetStandardStates(_core.device.RM_ADDITIVE);

    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, buffer);
    var stride = 22 * 4;
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._decl.SetDeclaration(effect.GetPassInput(pass), stride)) {
            return;
        }
        _core.device.ApplyShadowState();
        _core.device.gl.drawElements(_core.device.gl.TRIANGLES, buffer.count, _core.device.gl.UNSIGNED_SHORT, 0);
    }
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpriteSetItem = EveSpriteSetItem;
exports.EveSpriteSetBatch = EveSpriteSetBatch;
exports.EveSpriteSet = EveSpriteSet;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * EveSpriteSetItem
 * @property {string} name
 * @property {vec3} position
 * @property {number} blinkRate
 * @property {number} minScale
 * @property {number} falloff
 * @property {vec4} color
 * @property {vec4} warpColor
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @constructor
 */
function EveSpriteSetItem() {
    this.display = true;
    this.name = '';
    this.position = _math.vec3.create();
    this.blinkRate = 0;
    this.blinkPhase = 0;
    this.minScale = 1;
    this.maxScale = 1;
    this.falloff = 0;
    this.color = _math.vec4.create();
    this.warpColor = _math.vec4.create();
    this.boneIndex = 0;
    this.groupIndex = -1;
}

/**
 * Sprite set render batch
 * @constructor
 */
function EveSpriteSetBatch() {
    this.renderMode = _core.device.RM_ANY;
    this.perObjectData = null;
    this.boosterGlow = false;
    this.spriteSet = null;
    this.world = null;
    this.boosterGain = 0;
    this.warpIntensity = 0;
}

/**
 * Commits the sprite set
 * @param {Tw2Effect} overrideEffect
 */
EveSpriteSetBatch.prototype.Commit = function (overrideEffect) {
    if (this.boosterGlow) {
        this.spriteSet.RenderBoosterGlow(overrideEffect, this.world, this.boosterGain, this.warpIntensity);
    } else {
        this.spriteSet.Render(overrideEffect, this.world, this.perObjectData);
    }
};

/**
 * EveSpriteSet
 * @property {string} name
 * @property {Array.<EveSpriteSetItem>} sprites
 * @property {Tw2Effect} effect
 * @property {boolean} display
 * @property {number} _time
 * @property {boolean} useQuads Use quad rendering (CPU transform)
 * @property {boolean} isSkinned Use bone transforms (when useQuads is true)
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 * @param {boolean} useQuads Use quad rendering (CPU transform)
 * @param {boolean} isSkinned Use bone transforms (when useQuads is true)
 * @constructor
 */
function EveSpriteSet(useQuads, isSkinned) {
    this.name = '';
    this.sprites = [];
    this.effect = null;
    this.display = true;
    this._time = 0;
    this.useQuads = useQuads;
    this.isSkinned = isSkinned;

    this._vertexBuffer = null;
    this._indexBuffer = null;
    this._instanceBuffer = null;
    this._decl = new _core.Tw2VertexDeclaration();
    if (!useQuads) {
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 2, 0));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 8));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 3, 20));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 1, 32));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 1, 36));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 1, 40));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 1, 44));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 1, 48));
    } else {
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 12));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 2, 28));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 36));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 1, _core.device.gl.FLOAT, 4, 52));
    }
    this._decl.RebuildHash();

    this._vdecl = new _core.Tw2VertexDeclaration();
    this._vdecl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 1, 0));
    this._vdecl.RebuildHash();
}

/**
 * Initializes the sprite set
 */
EveSpriteSet.prototype.Initialize = function () {
    this.RebuildBuffers();
};

/**
 * Use instanced rendering or 'quad' rendering
 * @param {boolean} useQuads Use quad rendering (CPU transform)
 * @param {boolean} isSkinned Use bone transforms (when useQuads is true)
 */
EveSpriteSet.prototype.UseQuads = function (useQuads, isSkinned) {
    if (this.useQuads === useQuads) {
        return;
    }

    this.useQuads = useQuads;
    this.isSkinned = isSkinned;

    this._decl.elements.splice(0, this._decl.elements.length);
    if (!useQuads) {
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 2, 0));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 8));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 3, 20));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 1, 32));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 1, 36));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 1, 40));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 1, 44));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 1, 48));
    } else {
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 12));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 2, 28));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 36));
        this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 1, _core.device.gl.FLOAT, 4, 52));
    }
    this._decl.RebuildHash();
    this.RebuildBuffers();
};

/**
 * Gets Sprite Set Resource Objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
EveSpriteSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.effect !== null) {
        this.effect.GetResources(out);
    }

    return out;
};

/**
 * Rebuilds the sprite set's buffers
 */
EveSpriteSet.prototype.RebuildBuffers = function () {
    if (this.useQuads) {
        this._vertexBuffer = _core.device.gl.createBuffer();
        _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
        _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, new Float32Array([0, 1, 2, 2, 3, 0]), _core.device.gl.STATIC_DRAW);
        this._instanceBuffer = _core.device.gl.createBuffer();
        return;
    }

    var visibleItems = [];
    for (var i = 0; i < this.sprites.length; i++) {
        if (this.sprites[i].display) {
            visibleItems.push(this.sprites[i]);
        }
    }

    var offset, vtxOffset;
    var vertexSize = 13;
    var array = new Float32Array(visibleItems.length * 4 * vertexSize);
    for (i = 0; i < visibleItems.length; ++i) {
        offset = i * 4 * vertexSize;
        array[offset] = 0;
        array[offset + vertexSize] = 1;
        array[offset + 2 * vertexSize] = 2;
        array[offset + 3 * vertexSize] = 3;
        for (var j = 0; j < 4; ++j) {
            vtxOffset = offset + j * vertexSize;
            array[vtxOffset + 1] = visibleItems[i].boneIndex;
            array[vtxOffset + 2] = visibleItems[i].position[0];
            array[vtxOffset + 3] = visibleItems[i].position[1];
            array[vtxOffset + 4] = visibleItems[i].position[2];
            array[vtxOffset + 5] = visibleItems[i].color[0];
            array[vtxOffset + 6] = visibleItems[i].color[1];
            array[vtxOffset + 7] = visibleItems[i].color[2];
            array[vtxOffset + 8] = visibleItems[i].blinkPhase;
            array[vtxOffset + 9] = visibleItems[i].blinkRate;
            array[vtxOffset + 10] = visibleItems[i].minScale;
            array[vtxOffset + 11] = visibleItems[i].maxScale;
            array[vtxOffset + 12] = visibleItems[i].falloff;
        }
    }
    this._vertexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);

    var indexes = new Uint16Array(visibleItems.length * 6);
    for (i = 0; i < visibleItems.length; ++i) {
        offset = i * 6;
        vtxOffset = i * 4;
        indexes[offset] = vtxOffset;
        indexes[offset + 1] = vtxOffset + 2;
        indexes[offset + 2] = vtxOffset + 1;
        indexes[offset + 3] = vtxOffset + 0;
        indexes[offset + 4] = vtxOffset + 3;
        indexes[offset + 5] = vtxOffset + 2;
    }
    this._indexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, null);
    this._indexBuffer.count = visibleItems.length * 6;
};

/**
 * Gets render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @param {mat4} world
 */
EveSpriteSet.prototype.GetBatches = function (mode, accumulator, perObjectData, world) {
    if (this.display && mode === _core.device.RM_ADDITIVE) {
        var batch = new EveSpriteSetBatch();
        batch.world = world;
        batch.renderMode = _core.device.RM_ADDITIVE;
        batch.spriteSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
    }
};

/**
 * Gets render batches for booster glows
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @param {mat4} world
 * @param {Number} boosterGain
 * @param {Number} warpIntensity
 */
EveSpriteSet.prototype.GetBoosterGlowBatches = function (mode, accumulator, perObjectData, world, boosterGain, warpIntensity) {
    if (this.display && mode === _core.device.RM_ADDITIVE) {
        var batch = new EveSpriteSetBatch();
        batch.boosterGlow = true;
        batch.world = world;
        batch.boosterGain = boosterGain;
        batch.warpIntensity = warpIntensity;
        batch.renderMode = _core.device.RM_ADDITIVE;
        batch.spriteSet = this;
        batch.perObjectData = perObjectData;
        accumulator.Commit(batch);
    }
};

/**
 * Renders the sprite set
 * @param {Tw2Effect} overrideEffect
 * @param {mat4} world
 * @param {Tw2PerObjectData} perObjectData
 */
EveSpriteSet.prototype.Render = function (overrideEffect, world, perObjectData) {
    if (this.useQuads) {
        return this.RenderQuads(overrideEffect, world, perObjectData);
    }
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (!effect || !this._vertexBuffer) {
        return;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return;
    }
    _core.device.SetStandardStates(_core.device.RM_ADDITIVE);

    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
    _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        if (!this._decl.SetDeclaration(effect.GetPassInput(pass), 52)) {
            return;
        }
        _core.device.ApplyShadowState();
        _core.device.gl.drawElements(_core.device.gl.TRIANGLES, this._indexBuffer.count, _core.device.gl.UNSIGNED_SHORT, 0);
    }
};

/**
 * Scratch variables
 */
EveSpriteSet.scratch = {
    vec3_0: _math.vec3.create()
};

/**
 * Renders the sprite set as booster glow
 * @param {Tw2Effect} overrideEffect
 * @param {mat4} world
 * @param {Number} boosterGain
 * @param {Number} warpIntensity
 */
EveSpriteSet.prototype.RenderBoosterGlow = function (overrideEffect, world, boosterGain, warpIntensity) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (!effect || !this._vertexBuffer) {
        return;
    }

    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return;
    }

    _core.device.SetStandardStates(_core.device.RM_ADDITIVE);

    var array = new Float32Array(17 * this.sprites.length);
    var index = 0;
    var pos = EveSpriteSet.scratch.vec3_0;
    for (var i = 0; i < this.sprites.length; ++i) {
        _math.vec3.transformMat4(pos, this.sprites[i].position, world);
        array[index++] = pos[0];
        array[index++] = pos[1];
        array[index++] = pos[2];
        array[index++] = world[8];
        array[index++] = this.sprites[i].blinkPhase;
        array[index++] = world[9];
        array[index++] = this.sprites[i].minScale;
        array[index++] = this.sprites[i].maxScale;
        array[index++] = world[10];
        array[index++] = this.sprites[i].color[0];
        array[index++] = this.sprites[i].color[1];
        array[index++] = this.sprites[i].color[2];
        array[index++] = boosterGain;
        array[index++] = this.sprites[i].warpColor[0];
        array[index++] = this.sprites[i].warpColor[1];
        array[index++] = this.sprites[i].warpColor[2];
        array[index++] = warpIntensity;
    }
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._instanceBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.DYNAMIC_DRAW);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
        this._vdecl.SetPartialDeclaration(passInput, 4);
        _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._instanceBuffer);
        var resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);
        _core.device.ApplyShadowState();
        _core.device.ext.drawArraysInstanced(_core.device.gl.TRIANGLES, 0, 6, this.sprites.length);
        this._decl.ResetInstanceDivisors(resetData);
    }
};

/**
 * Renders the sprite set with pre-transformed quads
 * @param {Tw2Effect} overrideEffect
 * @param {mat4} world
 * @param {Tw2PerObjectData} perObjectData
 */
EveSpriteSet.prototype.RenderQuads = function (overrideEffect, world, perObjectData) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (!effect || !this._vertexBuffer) {
        return;
    }

    var effectRes = effect.GetEffectRes();
    if (!effectRes.IsGood()) {
        return;
    }
    _core.device.SetStandardStates(_core.device.RM_ADDITIVE);

    var array = new Float32Array(17 * this.sprites.length);
    var index = 0;
    var pos = EveSpriteSet.scratch.vec3_0;
    var bones = perObjectData.perObjectVSData.Get('JointMat');
    var sprite;
    for (var i = 0; i < this.sprites.length; ++i) {
        sprite = this.sprites[i];
        if (this.isSkinned) {
            var offset = sprite.boneIndex * 12;
            pos[0] = bones[offset] * sprite.position[0] + bones[offset + 1] * sprite.position[1] + bones[offset + 2] * sprite.position[2] + bones[offset + 3];
            pos[1] = bones[offset + 4] * sprite.position[0] + bones[offset + 5] * sprite.position[1] + bones[offset + 6] * sprite.position[2] + bones[offset + 7];
            pos[2] = bones[offset + 8] * sprite.position[0] + bones[offset + 9] * sprite.position[1] + bones[offset + 10] * sprite.position[2] + bones[offset + 11];
            _math.vec3.transformMat4(pos, pos, world);
        } else {
            _math.vec3.transformMat4(pos, sprite.position, world);
        }
        array[index++] = pos[0];
        array[index++] = pos[1];
        array[index++] = pos[2];
        array[index++] = 1;
        array[index++] = sprite.blinkPhase;
        array[index++] = sprite.blinkRate;
        array[index++] = sprite.minScale;
        array[index++] = sprite.maxScale;
        array[index++] = sprite.falloff;
        array[index++] = sprite.color[0];
        array[index++] = sprite.color[1];
        array[index++] = sprite.color[2];
        array[index++] = 1;
        array[index++] = sprite.warpColor[0];
        array[index++] = sprite.warpColor[1];
        array[index++] = sprite.warpColor[2];
        array[index++] = 1;
    }
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._instanceBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.DYNAMIC_DRAW);

    for (var pass = 0; pass < effect.GetPassCount(); ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
        this._vdecl.SetPartialDeclaration(passInput, 4);
        _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._instanceBuffer);
        var resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);
        _core.device.ApplyShadowState();
        _core.device.ext.drawArraysInstanced(_core.device.gl.TRIANGLES, 0, 6, this.sprites.length);
        this._decl.ResetInstanceDivisors(resetData);
    }
};

/**
 * Per frame update
 * @param {number} dt - Delta time
 */
EveSpriteSet.prototype.Update = function (dt) {
    this._time += dt;
};

/**
 * Clears the sprite set's sprites
 */
EveSpriteSet.prototype.Clear = function () {
    this.sprites = [];
};

/**
 * Adds a sprite set item to the sprite set
 * @param {vec3} pos
 * @param {number} blinkRate
 * @param {number} blinkPhase
 * @param {number} minScale
 * @param {number} maxScale
 * @param {number} falloff
 * @param {vec4} color
 * @constructor
 */
EveSpriteSet.prototype.Add = function (pos, blinkRate, blinkPhase, minScale, maxScale, falloff, color) {
    var item = new EveSpriteSetItem();
    item.display = true;
    _math.vec3.copy(item.position, pos);
    item.blinkRate = blinkRate;
    item.blinkPhase = blinkPhase;
    item.minScale = minScale;
    item.maxScale = maxScale;
    item.falloff = falloff;
    _math.vec4.copy(item.color, color);
    this.sprites.push(item);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.math = undefined;

var _core = __webpack_require__(1);

Object.keys(_core).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _core[key];
        }
    });
});

var _curve = __webpack_require__(41);

Object.keys(_curve).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _curve[key];
        }
    });
});

var _eve = __webpack_require__(130);

Object.keys(_eve).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _eve[key];
        }
    });
});

var _particle = __webpack_require__(39);

Object.keys(_particle).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _particle[key];
        }
    });
});

var _math = __webpack_require__(0);

var math = _interopRequireWildcard(_math);

var core = _interopRequireWildcard(_core);

var curve = _interopRequireWildcard(_curve);

var eve = _interopRequireWildcard(_eve);

var particle = _interopRequireWildcard(_particle);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var vec4 = math.vec4,
    mat4 = math.mat4;


_core.store.Register({

    uuid: false,

    resourcePaths: {
        'res': 'https://developers.eveonline.com/ccpwgl/assetpath/1097993/'
    },

    extensions: {
        'sm_hi': core.Tw2EffectRes,
        'sm_lo': core.Tw2EffectRes,
        'wbg': core.Tw2GeometryRes,
        'png': core.Tw2TextureRes,
        'cube': core.Tw2TextureRes
    },

    constructors: [core, curve, eve, particle],

    types: {
        'float': core.Tw2FloatParameter,
        'vector2': core.Tw2Vector2Parameter,
        'vector3': core.Tw2Vector3Parameter,
        'vector4': core.Tw2Vector4Parameter,
        'matrix4': core.Tw2MatrixParameter,
        'texture': core.Tw2TextureParameter
    },

    variables: {
        'u_DecalMatrix': mat4.create(),
        'u_InvDecalMatrix': mat4.create(),
        'EveSpaceSceneEnvMap': '',
        'EnvMap1': '',
        'EnvMap2': '',
        'EnvMap3': '',
        'ShadowLightness': 0,
        'LensflareFxDirectionScale': vec4.create(),
        'LensflareFxOccScale': vec4.fromValues(1, 1, 0, 0),
        'OccluderValue': vec4.create(),
        'WorldMat': mat4.create(),
        'ViewMat': mat4.create(),
        'ProjectionMat': mat4.create(),
        'ViewProjectionMat': mat4.create(),
        'ViewportSize': vec4.create(),
        'Time': vec4.create()
    }
});

exports.math = math;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec2 = undefined;

var _glMatrix = __webpack_require__(8);

exports.vec2 = _glMatrix.vec2;

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(31);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.quat = undefined;

var _glMatrix = __webpack_require__(8);

exports.quat = _glMatrix.quat;

/**
 * QuaternionExp
 *
 * @param {quat} out
 * @param {quat|vec3} a
 * @returns {quat}
 */

_glMatrix.quat.exp = function (out, a) {
    var norm = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    if (norm) {
        out[0] = Math.sin(norm) * a[0] / norm;
        out[1] = Math.sin(norm) * a[1] / norm;
        out[2] = Math.sin(norm) * a[2] / norm;
        out[3] = Math.cos(norm);
    } else {
        out[0] = 0.0;
        out[1] = 0.0;
        out[2] = 0.0;
        out[3] = 1.0;
    }
    return out;
};

/**
 * QuaternionLn
 *
 * @param {quat} out
 * @param {quat} q
 * @returns {quat}
 */
_glMatrix.quat.ln = function (out, q) {
    var norm = _glMatrix.quat.length(q);
    if (norm > 1.0001 || norm < 0.99999) {
        out[0] = q[0];
        out[1] = q[1];
        out[2] = q[2];
        out[3] = 0.0;
    } else {
        norm = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]);
        if (norm) {
            var theta = Math.atan2(norm, q[3]) / norm;
            out[0] = theta * q[0];
            out[1] = theta * q[1];
            out[2] = theta * q[2];
            out[3] = 0.0;
        } else {
            out[0] = 0.0;
            out[1] = 0.0;
            out[2] = 0.0;
            out[3] = 0.0;
        }
    }
    return out;
};

/**
 * QuaternionPow
 *
 * @param {quat} out
 * @param {quat} inq
 * @param {number} exponent
 * @returns {quat}
 */
_glMatrix.quat.pow = function (out, inq, exponent) {
    if (exponent === 1) {
        return _glMatrix.quat.copy(out, inq);
    }

    _glMatrix.quat.ln(out, inq);
    out[0] *= exponent;
    out[1] *= exponent;
    out[2] *= exponent;
    out[3] *= exponent;
    _glMatrix.quat.exp(out, out);
    return out;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mat3 = undefined;

var _glMatrix = __webpack_require__(8);

exports.mat3 = _glMatrix.mat3;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mat4 = undefined;

var _glMatrix = __webpack_require__(8);

exports.mat4 = _glMatrix.mat4;

/**
 * arcFromForward
 * @param {mat4} out
 * @param {vec3} v
 * @return {mat4} out
 */

_glMatrix.mat4.arcFromForward = function () {
    var vec3_0 = void 0;

    return function arcFromForward(out, v) {
        if (!vec3_0) vec3_0 = _glMatrix.vec3.create();

        var norm = _glMatrix.vec3.normalize(vec3_0, v);
        _glMatrix.mat4.identity(out);

        if (norm[2] < -0.99999) {
            return out;
        }

        if (norm[2] > 0.99999) {
            out[5] = -1.0;
            out[10] = -1.0;
            return out;
        }

        var h = (1 + norm[2]) / (norm[0] * norm[0] + norm[1] * norm[1]);
        out[0] = h * norm[1] * norm[1] - norm[2];
        out[1] = -h * norm[0] * norm[1];
        out[2] = norm[0];

        out[4] = out[1];
        out[5] = h * norm[0] * norm[0] - norm[2];
        out[6] = norm[1];

        out[8] = -norm[0];
        out[9] = -norm[1];
        out[10] = -norm[2];

        return out;
    };
}();

/**
 * Copies the translation component from one mat4 to another
 * @param {mat4} out
 * @param {mat4} a
 * @returns {mat4} out
 */
_glMatrix.mat4.copyTranslation = function (out, a) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    return out;
};

/**
 * Sets a mat4 from a mat4
 * @param {mat4} out
 * @param {mat3} m
 * @returns {mat4} out
 */
_glMatrix.mat4.fromMat3 = function (out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[4] = m[3];
    out[5] = m[4];
    out[6] = m[5];
    out[8] = m[6];
    out[9] = m[7];
    out[10] = m[8];
    out[3] = out[7] = out[11] = out[12] = out[13] = out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis from a left handed coordinate system
 *
 * @param {mat4} out - mat4 frustum matrix will be written into
 * @param {vec3} eye - Position of the viewer
 * @param {vec3} center - Point the viewer is looking at
 * @param {vec3} up - vec3 pointing up
 * @returns {mat4} out
 */
_glMatrix.mat4.lookAtGL = function () {
    var vec3_0 = void 0,
        vec3_1 = void 0,
        vec3_2 = void 0;

    return function lookAtGL(out, eye, center, up) {
        if (!vec3_0) {
            vec3_0 = _glMatrix.vec3.create();
            vec3_1 = _glMatrix.vec3.create();
            vec3_2 = _glMatrix.vec3.create();
        }

        _glMatrix.vec3.subtract(vec3_2, eye, center);

        if (_glMatrix.vec3.squaredLength(vec3_2) === 0) {
            vec3_2[2] = 1;
        }

        _glMatrix.vec3.normalize(vec3_2, vec3_2);
        _glMatrix.vec3.cross(vec3_0, up, vec3_2);

        if (_glMatrix.vec3.squaredLength(vec3_0) === 0) {
            vec3_2[2] += 0.0001;
            _glMatrix.vec3.cross(vec3_0, up, vec3_2);
        }

        _glMatrix.vec3.normalize(vec3_0, vec3_0);
        _glMatrix.vec3.cross(vec3_1, vec3_2, vec3_0);

        out[0] = vec3_0[0];
        out[1] = vec3_0[1];
        out[2] = vec3_0[2];

        out[4] = vec3_1[0];
        out[5] = vec3_1[1];
        out[6] = vec3_1[2];

        out[8] = vec3_2[0];
        out[9] = vec3_2[1];
        out[10] = vec3_2[2];

        return out;
    };
}();

/**
 * Sets a left handed co-ordinate system perspective from a right handed co-ordinate system
 * @param {mat4} out        - receiving mat4
 * @param {number} fovY     - Vertical field of view in radians
 * @param {number} aspect   - Aspect ratio. typically viewport width/height
 * @param {number} near     - Near bound of the frustum
 * @param {number} far      - Far bound of the frustum
 * @returns {mat4} out      - receiving mat4
 */
_glMatrix.mat4.perspectiveGL = function (out, fovY, aspect, near, far) {
    var fH = Math.tan(fovY / 360 * Math.PI) * near;
    var fW = fH * aspect;
    _glMatrix.mat4.frustum(out, -fW, fW, -fH, fH, near, far);
};

/**
 * Sets the translation component of a mat4 from a vec3
 * @param {mat4} out
 * @param {vec3} v
 * @returns {mat4} out
 */
_glMatrix.mat4.setTranslation = function (out, v) {
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    return out;
};

/**
 * Sets the translation component of a mat4 from values
 * @param {mat4} out
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @returns {mat4} out
 */
_glMatrix.mat4.setTranslationFromValues = function (out, x, y, z) {
    out[12] = x;
    out[13] = y;
    out[14] = z;
    return out;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.noise = undefined;

var _vec = __webpack_require__(32);

var _vec2 = __webpack_require__(33);

var noise = exports.noise = {};

/**
 * Generates turbulent noise
 *
 * @param {vec4} out
 * @param {number} pos_0
 * @param {number} pos_1
 * @param {number} pos_2
 * @param {number} pos_3
 * @param {number} power
 * @returns {vec4} out
 */
noise.turbulence = function () {
    var s_noiseLookup = [],
        s_permutations = [],
        s_globalNoiseTemps = [];

    var s_initialized = false;

    /**
     * Initializes noise
     */
    function initialize() {
        for (var _i = 0; _i < 256; _i++) {
            s_noiseLookup[_i] = _vec2.vec4.fromValues(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
            s_permutations[_i] = _i;
        }

        var i = 256;
        while (--i) {
            var tmp = s_permutations[i],
                index = Math.floor(Math.random() * 256);

            s_permutations[i] = s_permutations[index];
            s_permutations[index] = tmp;
        }

        for (var _i2 = 0; _i2 < 256; _i2++) {
            s_permutations[256 + _i2] = s_permutations[_i2];
            s_noiseLookup[256 + _i2] = s_noiseLookup[_i2];
            s_noiseLookup[256 * 2 + _i2] = s_noiseLookup[_i2];
        }

        for (var _i3 = 0; _i3 < 15; ++_i3) {
            s_globalNoiseTemps[_i3] = _vec.vec3.create();
        }

        s_initialized = true;
    }

    return function turbulence(out, pos_0, pos_1, pos_2, pos_3, power) {
        if (!s_initialized) initialize();

        pos_0 += 4096;
        pos_1 += 4096;
        pos_2 += 4096;
        pos_3 += 4096;

        var a_0 = Math.floor(pos_0),
            a_1 = Math.floor(pos_1),
            a_2 = Math.floor(pos_2),
            a_3 = Math.floor(pos_3);

        var t_0 = pos_0 - a_0,
            t_1 = pos_1 - a_1,
            t_2 = pos_2 - a_2,
            t_3 = pos_3 - a_3;

        a_0 &= 255;
        a_1 &= 255;
        a_2 &= 255;
        a_3 &= 255;

        var b_0 = a_0 + 1,
            b_1 = a_1 + 1,
            b_2 = a_2 + 1,
            b_3 = a_3 + 1;

        var i = s_permutations[a_0],
            j = s_permutations[b_0];

        var b00 = s_permutations[i + a_1],
            b10 = s_permutations[j + a_1],
            b01 = s_permutations[i + b_1],
            b11 = s_permutations[j + b_1];

        var c00 = _vec.vec3.lerp(s_globalNoiseTemps[0], s_noiseLookup[b00 + a_2 + a_3], s_noiseLookup[b10 + a_2 + a_3], t_0);
        var c10 = _vec.vec3.lerp(s_globalNoiseTemps[1], s_noiseLookup[b01 + a_2 + a_3], s_noiseLookup[b11 + a_2 + a_3], t_0);
        var c01 = _vec.vec3.lerp(s_globalNoiseTemps[2], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
        var c11 = _vec.vec3.lerp(s_globalNoiseTemps[3], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
        var c0 = _vec.vec3.lerp(s_globalNoiseTemps[4], c00, c10, t_1);
        var c1 = _vec.vec3.lerp(s_globalNoiseTemps[5], c01, c11, t_1);
        var c = _vec.vec3.lerp(s_globalNoiseTemps[6], c0, c1, t_2);

        c00 = _vec.vec3.lerp(s_globalNoiseTemps[7], s_noiseLookup[b00 + a_2 + b_3], s_noiseLookup[b10 + a_2 + b_3], t_0);
        c10 = _vec.vec3.lerp(s_globalNoiseTemps[8], s_noiseLookup[b01 + a_2 + b_3], s_noiseLookup[b11 + a_2 + b_3], t_0);
        c01 = _vec.vec3.lerp(s_globalNoiseTemps[9], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
        c11 = _vec.vec3.lerp(s_globalNoiseTemps[10], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
        c0 = _vec.vec3.lerp(s_globalNoiseTemps[11], c00, c10, t_1);
        c1 = _vec.vec3.lerp(s_globalNoiseTemps[12], c01, c11, t_1);
        var d = _vec.vec3.lerp(s_globalNoiseTemps[13], c0, c1, t_2);
        var r = _vec.vec3.lerp(s_globalNoiseTemps[14], c, d, t_3);

        out[0] += r[0] * power;
        out[1] += r[1] * power;
        out[2] += r[2] * power;
        return out;
    };
}();

/**
 * Perlin_noise1
 *
 * @param {number} a
 * @returns {number}
 */
noise.perlin1 = function () {
    var p_initialized = false,
        p_B = 0x100,
        p_BM = 0xff,
        p_N = 0x1000,
        p_p = null,
        p_g1 = null;

    /**
     * Initializes Perlin Noise
     */
    function initialize() {
        p_p = new Array(p_B + p_B + 2);
        p_g1 = new Array(p_B + p_B + 2);

        var i = 0,
            j = 0,
            k = 0;

        for (i = 0; i < p_B; i++) {
            p_p[i] = i;
            p_g1[i] = Math.random() * 2 - 1;
        }

        while (--i) {
            k = p_p[i];
            p_p[i] = p_p[j = Math.floor(Math.random() * p_B)];
            p_p[j] = k;
        }

        for (i = 0; i < p_B + 2; i++) {
            p_p[p_B + i] = p_p[i];
            p_g1[p_B + i] = p_g1[i];
        }

        p_initialized = true;
    }

    return function perlin1(a) {
        if (!p_initialized) initialize();

        var t = a + p_N,
            bx0 = Math.floor(t) & p_BM,
            bx1 = bx0 + 1 & p_BM,
            rx0 = t - Math.floor(t),
            rx1 = rx0 - 1;

        var sx = rx0 * rx0 * (3.0 - 2.0 * rx0),
            u = rx0 * p_g1[p_p[bx0]],
            v = rx1 * p_g1[p_p[bx1]];

        return u + sx * (v - u);
    };
}();

/**
 * PerlinNoise1D
 *
 * @param x
 * @param alpha
 * @param beta
 * @param n
 * @returns {number}
 */
noise.perlin1D = function (x, alpha, beta, n) {
    var sum = 0,
        p = x,
        scale = 1;

    for (var i = 0; i < n; ++i) {
        sum += noise.perlin1(p) / scale;
        scale *= alpha;
        p *= beta;
    }
    return sum;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var curve = exports.curve = {};

/**
 * Evaluates a curve
 *
 * @param {{}} curve
 * @param {Array} curve.knots
 * @param {number} curve.degree
 * @param {Array} curve.controls
 * @param {number} curve.dimension
 * @param {number} time
 * @param {*} value
 * @param {boolean} cycle
 * @param {number} duration
 */
curve.evaluate = function (curve, time, value, cycle, duration) {
    var count = curve.knots.length;
    var knot = count - 1;
    var t = 0;
    for (var i = 0; i < curve.knots.length; ++i) {
        if (curve.knots[i] > time) {
            knot = i;
            break;
        }
    }

    if (curve.degree === 0) {
        for (var _i = 0; _i < curve.dimension; ++_i) {
            value[_i] = curve.controls[knot * curve.dimension + _i];
        }
    } else if (curve.degree === 1) {
        var knot0 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;
        var dt = curve.knots[knot] - curve.knots[knot0];

        if (dt < 0) {
            dt += duration;
        }

        if (dt > 0) {
            t = (time - curve.knots[curve.knots.length - 1]) / dt;
        }

        for (var _i2 = 0; _i2 < curve.dimension; ++_i2) {
            value[_i2] = curve.controls[knot0 * curve.dimension + _i2] * (1 - t) + curve.controls[knot * curve.dimension + _i2] * t;
        }
    } else {
        var k_2 = cycle ? (knot + count - 2) % count : knot === 0 ? 0 : knot - 2;
        var k_1 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;

        var p1 = k_2 * curve.dimension;
        var p2 = k_1 * curve.dimension;
        var p3 = knot * curve.dimension;

        var ti_2 = curve.knots[k_2];
        var ti_1 = curve.knots[k_1];
        var ti = curve.knots[knot];
        var ti1 = curve.knots[(knot + 1) % count];

        if (ti_2 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }

        if (ti_1 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }

        if (ti1 < ti) {
            ti1 += duration;
        }

        var tmti_1 = time - ti_1;
        var tmti_2 = time - ti_2;
        var dL0 = ti - ti_1;
        var dL1_1 = ti - ti_2;
        var dL1_2 = ti1 - ti_1;

        var L0 = tmti_1 / dL0;
        var L1_1 = tmti_2 / dL1_1;
        var L1_2 = tmti_1 / dL1_2;

        var ci_2 = L1_1 + L0 - L0 * L1_1;
        var ci = L0 * L1_2;
        var ci_1 = ci_2 - ci;
        ci_2 = 1 - ci_2;

        for (var _i3 = 0; _i3 < curve.dimension; ++_i3) {
            value[_i3] = ci_2 * curve.controls[p1 + _i3] + ci_1 * curve.controls[p2 + _i3] + ci * curve.controls[p3 + _i3];
        }
    }
};

/**
 * ag_horner1
 *
 * @param P
 * @param deg
 * @param s
 * @returns {*}
 */
curve.ag_horner1 = function (P, deg, s) {
    var h = P[deg];
    while (--deg >= 0) {
        h = s * h + P[deg];
    }return h;
};

/**
 * ag_zeroin2
 *
 * @param a
 * @param b
 * @param fa
 * @param fb
 * @param tol
 * @param pars
 * @returns {*}
 */
curve.ag_zeroin2 = function (a, b, fa, fb, tol, pars) {
    var test = void 0;
    var c = void 0,
        d = void 0,
        e = void 0,
        fc = void 0,
        del = void 0,
        m = void 0,
        machtol = void 0,
        p = void 0,
        q = void 0,
        r = void 0,
        s = void 0;

    /* initialization */
    machtol = 1.192092896e-07;
    var label1 = true;

    /* start iteration */
    while (true) {
        if (label1) {
            c = a;
            fc = fa;
            d = b - a;
            e = d;
        }

        if (Math.abs(fc) < Math.abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        label1 = false;

        /* convergence test */
        del = 2.0 * machtol * Math.abs(b) + 0.5 * tol;
        m = 0.5 * (c - b);
        test = Math.abs(m) > del && fb !== 0.0;
        if (test) {
            if (Math.abs(e) < del || Math.abs(fa) <= Math.abs(fb)) {
                /* bisection */
                d = m;
                e = d;
            } else {
                s = fb / fa;
                if (a === c) {
                    /* linear interpolation */
                    p = 2.0 * m * s;
                    q = 1.0 - s;
                } else {
                    /* inverse quadratic interpolation */
                    q = fa / fc;
                    r = fb / fc;
                    p = s * (2.0 * m * q * (q - r) - (b - a) * (r - 1.0));
                    q = (q - 1.0) * (r - 1.0) * (s - 1.0);
                }
                /* adjust the sign */
                if (p > 0.0) q = -q;else p = -p;
                /* check if interpolation is acceptable */
                s = e;
                e = d;
                if (2.0 * p < 3.0 * m * q - Math.abs(del * q) && p < Math.abs(0.5 * s * q)) {
                    d = p / q;
                } else {
                    d = m;
                    e = d;
                }
            }
            /* complete step */
            a = b;
            fa = fb;
            if (Math.abs(d) > del) b += d;else if (m > 0.0) b += del;else b -= del;
            fb = curve.ag_horner1(pars.p, pars.deg, b);
            if (fb * (fc / Math.abs(fc)) > 0.0) {
                label1 = true;
            }
        } else {
            break;
        }
    }
    return b;
};

/**
 * ag_zeroin
 *
 * @param a
 * @param b
 * @param tol
 * @param pars
 * @returns {*}
 */
curve.ag_zeroin = function (a, b, tol, pars) {
    var fa = void 0,
        fb = void 0;

    fa = curve.ag_horner1(pars.p, pars.deg, a);
    if (Math.abs(fa) < 1.192092896e-07) return a;

    fb = curve.ag_horner1(pars.p, pars.deg, b);
    if (Math.abs(fb) < 1.192092896e-07) return b;

    return curve.ag_zeroin2(a, b, fa, fb, tol, pars);
};

/**
 * polyZeroes
 *
 * @param Poly
 * @param deg
 * @param a
 * @param a_closed
 * @param b
 * @param b_closed
 * @param Roots
 * @returns {*}
 */
curve.polyZeroes = function (Poly, deg, a, a_closed, b, b_closed, Roots) {
    var i = void 0,
        left_ok = void 0,
        right_ok = void 0,
        nr = void 0,
        ndr = void 0,
        skip = void 0;

    var e = void 0,
        f = void 0,
        s = void 0,
        pe = void 0,
        ps = void 0,
        tol = void 0,
        p = void 0,
        p_x = new Array(22),
        d = void 0,
        d_x = new Array(22),
        dr = void 0,
        dr_x = new Array(22);

    var ply = {
        p: [],
        deg: 0
    };

    e = pe = 0.0;
    f = 0.0;

    for (i = 0; i < deg + 1; ++i) {
        f += Math.abs(Poly[i]);
    }
    tol = (Math.abs(a) + Math.abs(b)) * (deg + 1) * 1.192092896e-07;

    /* Zero polynomial to tolerance? */
    if (f <= tol) return -1;

    p = p_x;
    d = d_x;
    dr = dr_x;
    for (i = 0; i < deg + 1; ++i) {
        p[i] = 1.0 / f * Poly[i];
    }

    /* determine true degree */
    while (Math.abs(p[deg]) < tol) {
        deg--;
    } /* Identically zero poly already caught so constant fn !== 0 */
    nr = 0;
    if (deg === 0) return nr;

    /* check for linear case */
    if (deg === 1) {
        Roots[0] = -p[0] / p[1];
        left_ok = a_closed ? a < Roots[0] + tol : a < Roots[0] - tol;
        right_ok = b_closed ? b > Roots[0] - tol : b > Roots[0] + tol;
        nr = left_ok && right_ok ? 1 : 0;
        if (nr) {
            if (a_closed && Roots[0] < a) Roots[0] = a;else if (b_closed && Roots[0] > b) Roots[0] = b;
        }
        return nr;
    }
    /* handle non-linear case */
    else {
            ply.p = p;
            ply.deg = deg;

            /* compute derivative */
            for (i = 1; i <= deg; i++) {
                d[i - 1] = i * p[i];
            } /* find roots of derivative */
            ndr = curve.polyZeroes(d, deg - 1, a, 0, b, 0, dr);
            if (ndr.length === 0) return 0;

            /* find roots between roots of the derivative */
            for (i = skip = 0; i <= ndr; i++) {
                if (nr > deg) return nr;
                if (i === 0) {
                    s = a;
                    ps = curve.ag_horner1(p, deg, s);
                    if (Math.abs(ps) <= tol && a_closed) Roots[nr++] = a;
                } else {
                    s = e;
                    ps = pe;
                }
                if (i === ndr) {
                    e = b;
                    skip = 0;
                } else e = dr[i];
                pe = curve.ag_horner1(p, deg, e);
                if (skip) skip = 0;else {
                    if (Math.abs(pe) < tol) {
                        if (i !== ndr || b_closed) {
                            Roots[nr++] = e;
                            skip = 1;
                        }
                    } else if (ps < 0 && pe > 0 || ps > 0 && pe < 0) {
                        Roots[nr++] = curve.ag_zeroin(s, e, 0.0, ply);
                        if (nr > 1 && Roots[nr - 2] >= Roots[nr - 1] - tol) {
                            Roots[nr - 2] = (Roots[nr - 2] + Roots[nr - 1]) * 0.5;
                            nr--;
                        }
                    }
                }
            }
        }

    return nr;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var util = exports.util = {};

/**
 * Generates a UUID
 * @author Three.js
 * @returns {string}
 */
util.generateUUID = function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    var lut = [];
    for (var i = 0; i < 256; i++) {
        lut[i] = (i < 16 ? '0' : '') + i.toString(16).toUpperCase();
    }

    return function generateUUID() {
        var d0 = Math.random() * 0xffffffff | 0,
            d1 = Math.random() * 0xffffffff | 0,
            d2 = Math.random() * 0xffffffff | 0,
            d3 = Math.random() * 0xffffffff | 0;

        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    };
}();

/**
 * Generates an object id
 * @returns {number}
 */
util.generateObjectID = function () {
    var OBJECT_COUNT = 0;

    return function generateID() {
        return OBJECT_COUNT++;
    };
}();

/**
 * Generates an id
 * @type {?Function}
 */
util.generateID = util.generateObjectID;

/**
 * Gets a source's property value if it exists else returns a default value
 * @param {*} src
 * @param {string} prop
 * @param {*} defaultValue
 * @returns {*}
 */
util.get = function (src, prop, defaultValue) {
    return src && prop in src ? src[prop] : defaultValue;
};

/**
 * Assigns a source's property value(s) if it isn't undefined
 * @param {*} dest
 * @param {*} src
 * @param {string} prop
 */
util.assignIfExists = function (dest, src, prop) {
    if (src && src[prop] !== undefined) {
        dest[prop] = src[prop];
    }
};

/**
 * Returns a value if it is an array, or a new array with the object in it
 * @param {*} a
 * @returns {Array}
 */
util.toArray = function (a) {
    return Array.isArray(a) ? a : [a];
};

/**
 * Checks if a value is an array
 * @param {*} a
 * @returns {boolean}
 */
util.isArray = Array.isArray;

/**
 * Checks if a value is a typed array
 * @param {*} a
 * @returns {boolean}
 */
util.isTyped = function (a) {
    return a && a.buffer instanceof ArrayBuffer && a.BYTES_PER_ELEMENT;
};

/**
 * Checks if a value is a vector
 * @param {*} a
 * @returns {boolean}
 */
util.isVector = function (a) {
    if (a) {
        if (util.isTyped(a)) {
            return true;
        }

        if (util.isArray(a)) {
            for (var i = 0; i < a.length; i++) {
                if (typeof a[i] !== 'number') return false;
            }
            return true;
        }
    }
    return false;
};

/**
 * Checks if a value is array like
 * @param {*} a
 * @returns {boolean}
 */
util.isArrayLike = function (a) {
    return a && util.isArray(a) || util.isTyped(a);
};

/**
 * Calls a function with arguments for each child in an array where that function exists
 * @param {Array} arr
 * @param {string} func
 * @param args
 */
util.perArrayChild = function (arr, func) {
    var len = arr.length;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    for (var i = 0; i < len; i++) {
        var _arr$i;

        if (func in arr) (_arr$i = arr[i])[func].apply(_arr$i, args);
    }
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

//Ported to node by Marcin Ignac on 2016-05-20

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {
var window

//polyfill window in node
if (typeof(window) == 'undefined') {
    window = global;
}

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};


/**
 * Which arguments are enums based on the number of arguments to the function.
 * So
 *    'texImage2D': {
 *       9: { 0:true, 2:true, 6:true, 7:true },
 *       6: { 0:true, 2:true, 3:true, 4:true },
 *    },
 *
 * means if there are 9 arguments then 6 and 7 are enums, if there are 6
 * arguments 3 and 4 are enums
 *
 * @type {!Object.<number, !Object.<number, string>}
 */
var glValidEnumContexts = {
  // Generic setters and getters

  'enable': {1: { 0:true }},
  'disable': {1: { 0:true }},
  'getParameter': {1: { 0:true }},

  // Rendering

  'drawArrays': {3:{ 0:true }},
  'drawElements': {4:{ 0:true, 2:true }},

  // Shaders

  'createShader': {1: { 0:true }},
  'getShaderParameter': {2: { 1:true }},
  'getProgramParameter': {2: { 1:true }},
  'getShaderPrecisionFormat': {2: { 0: true, 1:true }},

  // Vertex attributes

  'getVertexAttrib': {2: { 1:true }},
  'vertexAttribPointer': {6: { 2:true }},

  // Textures

  'bindTexture': {2: { 0:true }},
  'activeTexture': {1: { 0:true }},
  'getTexParameter': {2: { 0:true, 1:true }},
  'texParameterf': {3: { 0:true, 1:true }},
  'texParameteri': {3: { 0:true, 1:true, 2:true }},
  // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints
  'copyTexImage2D': {8: { 0:true, 2:true }},
  'copyTexSubImage2D': {8: { 0:true }},
  'generateMipmap': {1: { 0:true }},
  // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints

  // Buffer objects

  'bindBuffer': {2: { 0:true }},
  // bufferData and bufferSubData are defined below with WebGL 2 entrypoints
  'getBufferParameter': {2: { 0:true, 1:true }},

  // Renderbuffers and framebuffers

  'pixelStorei': {2: { 0:true, 1:true }},
  // readPixels is defined below with WebGL 2 entrypoints
  'bindRenderbuffer': {2: { 0:true }},
  'bindFramebuffer': {2: { 0:true }},
  'checkFramebufferStatus': {1: { 0:true }},
  'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},
  'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},
  'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},
  'getRenderbufferParameter': {2: { 0:true, 1:true }},
  'renderbufferStorage': {4: { 0:true, 1:true }},

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},
  'depthFunc': {1: { 0:true }},
  'blendFunc': {2: { 0:true, 1:true }},
  'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},
  'blendEquation': {1: { 0:true }},
  'blendEquationSeparate': {2: { 0:true, 1:true }},
  'stencilFunc': {3: { 0:true }},
  'stencilFuncSeparate': {4: { 0:true, 1:true }},
  'stencilMaskSeparate': {2: { 0:true }},
  'stencilOp': {3: { 0:true, 1:true, 2:true }},
  'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},

  // Culling

  'cullFace': {1: { 0:true }},
  'frontFace': {1: { 0:true }},

  // ANGLE_instanced_arrays extension

  'drawArraysInstancedANGLE': {4: { 0:true }},
  'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},

  // EXT_blend_minmax extension

  'blendEquationEXT': {1: { 0:true }},

  // WebGL 2 Buffer objects

  'bufferData': {
    3: { 0:true, 2:true }, // WebGL 1
    4: { 0:true, 2:true }, // WebGL 2
    5: { 0:true, 2:true }  // WebGL 2
  },
  'bufferSubData': {
    3: { 0:true }, // WebGL 1
    4: { 0:true }, // WebGL 2
    5: { 0:true }  // WebGL 2
  },
  'copyBufferSubData': {5: { 0:true, 1:true }},
  'getBufferSubData': {3: { 0:true }, 4: { 0:true }, 5: { 0:true }},

  // WebGL 2 Framebuffer objects

  'blitFramebuffer': {10: { 8: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }, 9:true }},
  'framebufferTextureLayer': {5: { 0:true, 1:true }},
  'invalidateFramebuffer': {2: { 0:true }},
  'invalidateSubFramebuffer': {6: { 0:true }},
  'readBuffer': {1: { 0:true }},

  // WebGL 2 Renderbuffer objects

  'getInternalformatParameter': {3: { 0:true, 1:true, 2:true }},
  'renderbufferStorageMultisample': {5: { 0:true, 2:true }},

  // WebGL 2 Texture objects

  'texStorage2D': {5: { 0:true, 2:true }},
  'texStorage3D': {6: { 0:true, 2:true }},
  'texImage2D': {
    9: { 0:true, 2:true, 6:true, 7:true }, // WebGL 1 & 2
    6: { 0:true, 2:true, 3:true, 4:true }, // WebGL 1
    10: { 0:true, 2:true, 6:true, 7:true } // WebGL 2
  },
  'texImage3D': {
    10: { 0:true, 2:true, 7:true, 8:true },
    11: { 0:true, 2:true, 7:true, 8:true }
  },
  'texSubImage2D': {
    9: { 0:true, 6:true, 7:true }, // WebGL 1 & 2
    7: { 0:true, 4:true, 5:true }, // WebGL 1
    10: { 0:true, 6:true, 7:true } // WebGL 2
  },
  'texSubImage3D': {
    11: { 0:true, 8:true, 9:true },
    12: { 0:true, 8:true, 9:true }
  },
  'copyTexSubImage3D': {9: { 0:true }},
  'compressedTexImage2D': {
    7: { 0: true, 2:true }, // WebGL 1 & 2
    8: { 0: true, 2:true }, // WebGL 2
    9: { 0: true, 2:true }  // WebGL 2
  },
  'compressedTexImage3D': {
    8: { 0: true, 2:true },
    9: { 0: true, 2:true },
    10: { 0: true, 2:true }
  },
  'compressedTexSubImage2D': {
    8: { 0: true, 6:true }, // WebGL 1 & 2
    9: { 0: true, 6:true }, // WebGL 2
    10: { 0: true, 6:true } // WebGL 2
  },
  'compressedTexSubImage3D': {
    10: { 0: true, 8:true },
    11: { 0: true, 8:true },
    12: { 0: true, 8:true }
  },

  // WebGL 2 Vertex attribs

  'vertexAttribIPointer': {5: { 2:true }},

  // WebGL 2 Writing to the drawing buffer

  'drawArraysInstanced': {4: { 0:true }},
  'drawElementsInstanced': {5: { 0:true, 2:true }},
  'drawRangeElements': {6: { 0:true, 4:true }},

  // WebGL 2 Reading back pixels

  'readPixels': {
    7: { 4:true, 5:true }, // WebGL 1 & 2
    8: { 4:true, 5:true }  // WebGL 2
  },

  // WebGL 2 Multiple Render Targets

  'clearBufferfv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferuiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferfi': {4: { 0:true }},

  // WebGL 2 Query objects

  'beginQuery': {2: { 0:true }},
  'endQuery': {1: { 0:true }},
  'getQuery': {2: { 0:true, 1:true }},
  'getQueryParameter': {2: { 1:true }},

  // WebGL 2 Sampler objects

  'samplerParameteri': {3: { 1:true, 2:true }},
  'samplerParameterf': {3: { 1:true }},
  'getSamplerParameter': {2: { 1:true }},

  // WebGL 2 Sync objects

  'fenceSync': {2: { 0:true, 1: { 'enumBitwiseOr': [] } }},
  'clientWaitSync': {3: { 1: { 'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT'] } }},
  'waitSync': {3: { 1: { 'enumBitwiseOr': [] } }},
  'getSyncParameter': {2: { 1:true }},

  // WebGL 2 Transform Feedback

  'bindTransformFeedback': {2: { 0:true }},
  'beginTransformFeedback': {1: { 0:true }},
  'transformFeedbackVaryings': {3: { 2:true }},

  // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers

  'bindBufferBase': {3: { 0:true }},
  'bindBufferRange': {5: { 0:true }},
  'getIndexedParameter': {2: { 0:true }},
  'getActiveUniforms': {3: { 2:true }},
  'getActiveUniformBlockParameter': {3: { 2:true }}
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Map of names to numbers.
 * @type {Object}
 */
var enumStringToValue = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    enumStringToValue = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
        enumStringToValue[propertyName] = ctx[propertyName];
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? ("gl." + name) :
      ("/*UNKNOWN WebGL ENUM*/ 0x" + value.toString(16) + "");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} numArgs the number of arguments passed to the function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    var funcInfo = funcInfo[numArgs];
    if (funcInfo !== undefined) {
      if (funcInfo[argumentIndex]) {
        if (typeof funcInfo[argumentIndex] === 'object' &&
            funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {
          var enums = funcInfo[argumentIndex]['enumBitwiseOr'];
          var orResult = 0;
          var orEnums = [];
          for (var i = 0; i < enums.length; ++i) {
            var enumValue = enumStringToValue[enums[i]];
            if ((value & enumValue) !== 0) {
              orResult |= enumValue;
              orEnums.push(glEnumToString(enumValue));
            }
          }
          if (orResult === value) {
            return orEnums.join(' | ');
          } else {
            return glEnumToString(value);
          }
        } else {
          return glEnumToString(value);
        }
      }
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  var numArgs = args.length;
  for (var ii = 0; ii < numArgs; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, numArgs, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 * @param {!WebGLRenderingContext} opt_err_ctx The webgl context
 *        to call getError on if different than ctx.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {
  opt_err_ctx = opt_err_ctx || ctx;
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        var numArgs = args.length;
        for (var ii = 0; ii < numArgs; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, numArgs, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = opt_err_ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
      if (propertyName != 'getExtension') {
        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
      } else {
        var wrapped = makeErrorWrapper(ctx, propertyName);
        wrapper[propertyName] = function () {
          var result = wrapped.apply(ctx, arguments);
          if (!result) {
            return null;
          }
          return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);
        };
      }
    } else {
      makePropertyWrapper(wrapper, ctx, propertyName);
    }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var isWebGL2RenderingContext = !!ctx.createTransformFeedback;

  if (isWebGL2RenderingContext) {
    ctx.bindVertexArray(null);
  }

  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
    if (isWebGL2RenderingContext) {
      ctx.vertexAttribDivisor(ii, 0);
    }
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
    if (isWebGL2RenderingContext) {
      ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);
      ctx.bindTexture(ctx.TEXTURE_3D, null);
      ctx.bindSampler(ii, null);
    }
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  if (isWebGL2RenderingContext) {
    ctx.drawBuffers([ctx.BACK]);
    ctx.readBuffer(ctx.BACK);
    ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);
    ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);
    var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
    for (var ii = 0; ii < numTransformFeedbacks; ++ii) {
      ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);
    }
    var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);
    for (var ii = 0; ii < numUBOs; ++ii) {
      ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);
    }
    ctx.disable(ctx.RASTERIZER_DISCARD);
    ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);
    ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);
    ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);
    ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);
  }

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;
  var isWebGL2RenderingContext;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if ((ctx instanceof WebGLRenderingContext) || (window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext))) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          isWebGL2RenderingContext = window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext);
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k[ii]];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
      else if (isWebGL2RenderingContext) {
        if (resource instanceof WebGLQuery) {
          unwrappedContext_.deleteQuery(resource);
        } else if (resource instanceof WebGLSampler) {
          unwrappedContext_.deleteSampler(resource);
        } else if (resource instanceof WebGLSync) {
          unwrappedContext_.deleteSync(resource);
        } else if (resource instanceof WebGLTransformFeedback) {
          unwrappedContext_.deleteTransformFeedback(resource);
        } else if (resource instanceof WebGLVertexArrayObject) {
          unwrappedContext_.deleteVertexArray(resource);
        }
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    if (isWebGL2RenderingContext) {
      creationFunctions.push(
        "createQuery",
        "createSampler",
        "fenceSync",
        "createTransformFeedback",
        "createVertexArray"
      );
    }
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    if (isWebGL2RenderingContext) {
      functionsThatShouldReturnNull.push(
        "getInternalformatParameter",
        "getQuery",
        "getQueryParameter",
        "getSamplerParameter",
        "getSyncParameter",
        "getTransformFeedbackVarying",
        "getIndexedParameter",
        "getUniformIndices",
        "getActiveUniforms",
        "getActiveUniformBlockParameter",
        "getActiveUniformBlockName"
      );
    }
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    if (isWebGL2RenderingContext) {
      isFunctions.push(
        "isQuery",
        "isSampler",
        "isSync",
        "isTransformFeedback",
        "isVertexArray"
      );
    }
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    if (isWebGL2RenderingContext) {
      wrappedContext_.getFragDataLocation = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return -1;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getFragDataLocation);

      wrappedContext_.clientWaitSync = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.WAIT_FAILED;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.clientWaitSync);

      wrappedContext_.getUniformBlockIndex = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.INVALID_INDEX;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getUniformBlockIndex);
    }

    return wrappedContext_;
  }
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} numArgs The number of arguments
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

module.exports = WebGLDebugUtils;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 66 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2RawData = __webpack_require__(21);

Object.defineProperty(exports, 'Tw2RawData', {
  enumerable: true,
  get: function get() {
    return _Tw2RawData.Tw2RawData;
  }
});

var _Tw2PerObjectData = __webpack_require__(35);

Object.defineProperty(exports, 'Tw2PerObjectData', {
  enumerable: true,
  get: function get() {
    return _Tw2PerObjectData.Tw2PerObjectData;
  }
});

var _Tw2BasicPerObjectData = __webpack_require__(68);

Object.defineProperty(exports, 'Tw2BasicPerObjectData', {
  enumerable: true,
  get: function get() {
    return _Tw2BasicPerObjectData.Tw2BasicPerObjectData;
  }
});
Object.defineProperty(exports, 'EveBasicPerObjectData', {
  enumerable: true,
  get: function get() {
    return _Tw2BasicPerObjectData.Tw2BasicPerObjectData;
  }
});

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2BasicPerObjectData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Tw2Device = __webpack_require__(2);

var _Tw2PerObjectData2 = __webpack_require__(35);

var _Tw2RawData = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2BasicPerObjectData/EveBasicPerObjectData
 *
 * @property {{}} [declarations]
 * @param {boolean} [skipCreate]
 * @property {Tw2RawData} [decl.FFEData]
 * @parameter {?Tw2RawData} perObjectFFEData - Fixed Function Emulation data
 * @class
 */
var Tw2BasicPerObjectData = exports.Tw2BasicPerObjectData = function (_Tw2PerObjectData) {
    _inherits(Tw2BasicPerObjectData, _Tw2PerObjectData);

    function Tw2BasicPerObjectData(declarations, skipCreate) {
        _classCallCheck(this, Tw2BasicPerObjectData);

        var _this = _possibleConstructorReturn(this, (Tw2BasicPerObjectData.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData)).call(this));

        _this.perObjectFFEData = null;

        if (declarations) _this.DeclareFromObject(declarations, skipCreate);
        return _this;
    }

    /**
     * Sets per object data to the device
     * @param constantBufferHandles
     */


    _createClass(Tw2BasicPerObjectData, [{
        key: 'SetPerObjectDataToDevice',
        value: function SetPerObjectDataToDevice(constantBufferHandles) {
            _get(Tw2BasicPerObjectData.prototype.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData.prototype), 'SetPerObjectDataToDevice', this).call(this, constantBufferHandles);

            if (this.perObjectFFEData && constantBufferHandles[5]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[5], this.perObjectFFEData.data);
            }
        }

        /**
         * Declares raw data from an object
         * @param {{}} declarations
         * @param {{}} [declarations.VSData]
         * @param {{}} [declarations.PSData]
         * @param {{}} [declarations.FFEData}
         * @param {boolean} [skipCreate]
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject(declarations, skipCreate) {
            _get(Tw2BasicPerObjectData.prototype.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData.prototype), 'DeclareFromObject', this).call(this, declarations, skipCreate);

            if (declarations.FFEData) {
                this.perObjectFFEData = new _Tw2RawData.Tw2RawData(declarations.FFEData, skipCreate);
            }
        }
    }]);

    return Tw2BasicPerObjectData;
}(_Tw2PerObjectData2.Tw2PerObjectData);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Track = Tw2Track;
exports.Tw2TrackGroup = Tw2TrackGroup;
exports.Tw2Animation = Tw2Animation;
exports.Tw2Bone = Tw2Bone;
exports.Tw2Model = Tw2Model;
exports.Tw2AnimationController = Tw2AnimationController;

var _math = __webpack_require__(0);

var _Tw2GeometryRes = __webpack_require__(22);

/**
 * Tw2Track
 * @property {Tw2GeometryTransformTrack} trackRes
 * @property {Tw2Bone} bone
 * @constructor
 */
function Tw2Track() {
    this.trackRes = null;
    this.bone = null;
}

/**
 * Tw2TrackGroup
 * @property {Tw2GeometryTrackGroup} trackGroupRes
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2GeometryTransformTrack>} transformTracks
 * @constructor
 */
function Tw2TrackGroup() {
    this.trackGroupRes = null;
    this.model = null;
    this.transformTracks = [];
}

/**
 * Tw2Animation
 * @property {Tw2GeometryAnimation} animationRes
 * @property {number} time
 * @property {number} timeScale
 * @property {boolean} cycle
 * @property {boolean} isPlaying
 * @property {Function} callback - Stores optional callback passed to prototypes
 * @property {Array} trackGroups - Array of {@link Tw2TrackGroup}
 * @constructor
 */
function Tw2Animation() {
    this.animationRes = null;
    this.time = 0;
    this.timeScale = 1.0;
    this.cycle = false;
    this.isPlaying = false;
    this.callback = null;
    this.trackGroups = [];
}

/**
 * Checks to see if the animation has finished playing
 * @return {boolean}
 * @prototype
 */
Tw2Animation.prototype.IsFinished = function () {
    return !this.cycle && this.time >= this.animationRes.duration;
};

/**
 * Tw2Bone
 * @property {Tw2GeometryBone} boneRes
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} offsetTransform
 * @constructor
 */
function Tw2Bone() {
    this.boneRes = null;
    this.localTransform = _math.mat4.create();
    this.worldTransform = _math.mat4.create();
    this.offsetTransform = _math.mat4.create();
}

/**
 * Tw2Model
 * @property {Tw2GeometryModel} modelRes
 * @property {Array.<Tw2Bone>} bones
 * @property {Object.<string, Tw2Bone>} bonesByName - An object containing every Tw2Bone name and it's object
 * @constructor
 */
function Tw2Model() {
    this.modelRes = null;
    this.bones = [];
    this.bonesByName = {};
}

/**
 * Tw2AnimationController
 * @param {Tw2GeometryRes} [geometryResource]
 * @property {Array.<Tw2GeometryRes>} geometryResources
 * @property {Array.<Tw2Model>} models
 * @property {Array.<Tw2Animation>} animations
 * @property {Array} meshBindings
 * @property {boolean} loaded
 * @property {boolean} update
 * @property _geometryResource
 * @property {Array} pendingCommands
 * @property {Function} [onLoaded] an optional callback fired when any commands are cleared
 * @prototype
 */
function Tw2AnimationController(geometryResource) {
    this.geometryResources = [];
    this.models = [];
    this.animations = [];
    this.meshBindings = [];
    this.loaded = false;
    this.update = true;
    this._geometryResource = null;
    this.pendingCommands = [];
    this.onPendingCleared = null;

    if (typeof geometryResource !== 'undefined') {
        this.SetGeometryResource(geometryResource);
    }
}

/**
 * Scratch variables
 */
Tw2AnimationController.scratch = {
    vec3_0: _math.vec3.create(),
    quat_0: _math.quat.create(),
    mat3_0: _math.mat3.create(),
    mat4_0: _math.mat4.create()
};

/**
 * Gets all animation controller res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */

Tw2AnimationController.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    for (var i = 0; i < this.geometryResources.length; i++) {
        if (out.indexOf(this.geometryResources[i]) === -1) {
            out.push(this.geometryResources[i]);
        }
    }
    return out;
};

/**
 * Clears any existing resources and loads the supplied geometry resource
 * @param {Tw2GeometryRes} geometryResource
 * @prototype
 */
Tw2AnimationController.prototype.SetGeometryResource = function (geometryResource) {
    this.models = [];
    this.animations = [];
    this.meshBindings = [];

    for (var i = 0; i < this.geometryResources.length; ++i) {
        this.geometryResources[i].UnregisterNotification(this);
    }

    this.loaded = false;
    this.geometryResources = [];

    if (geometryResource) {
        this.geometryResources.push(geometryResource);
        geometryResource.RegisterNotification(this);
    }
};

/**
 * Adds a Geometry Resource
 * @param {Tw2GeometryRes} geometryResource
 * @prototype
 */
Tw2AnimationController.prototype.AddGeometryResource = function (geometryResource) {
    for (var i = 0; i < this.geometryResources.length; ++i) {
        if (this.geometryResources[i] === geometryResource) {
            return;
        }
    }
    this.geometryResources.push(geometryResource);
    geometryResource.RegisterNotification(this);
};

/**
 * Adds animations from a resource
 * @param {Tw2GeometryRes} resource
 * @prototype
 */
Tw2AnimationController.prototype.AddAnimationsFromRes = function (resource) {
    for (var i = 0; i < resource.animations.length; ++i) {
        var animation = null;
        for (var j = 0; j < this.animations.length; ++j) {
            if (this.animations[j].animationRes === resource.animations[i]) {
                animation = this.animations[i];

                break;
            }
        }
        if (!animation) {
            animation = new Tw2Animation();
            animation.animationRes = resource.animations[i];
            this.animations.push(animation);
        }
        for (var j = 0; j < animation.animationRes.trackGroups.length; ++j) {
            var found = false;
            for (var k = 0; k < animation.trackGroups.length; ++k) {
                if (animation.trackGroups[k].trackGroupRes === animation.animationRes.trackGroups[j]) {
                    found = true;
                    break;
                }
            }
            if (found) {
                continue;
            }
            var model = null;
            for (var k = 0; k < this.models.length; ++k) {
                if (this.models[k].modelRes.name === animation.animationRes.trackGroups[j].name) {
                    model = this.models[k];
                    break;
                }
            }
            if (model !== null) {
                var group = new Tw2TrackGroup();
                group.trackGroupRes = animation.animationRes.trackGroups[j];
                for (var k = 0; k < group.trackGroupRes.transformTracks.length; ++k) {
                    for (var m = 0; m < model.bones.length; ++m) {
                        if (model.bones[m].boneRes.name === group.trackGroupRes.transformTracks[k].name) {
                            var track = new Tw2Track();
                            track.trackRes = group.trackGroupRes.transformTracks[k];
                            track.bone = model.bones[m];
                            group.transformTracks.push(track);
                            break;
                        }
                    }
                }
                animation.trackGroups.push(group);
            }
        }
    }
};

/**
 * Adds a model resource
 * @param {Tw2GeometryModel} modelRes
 * @returns {null|Tw2Model} Returns a newly created Tw2Model if the model resource doesn't already exist, and null if it does
 * @private
 */
Tw2AnimationController.prototype._AddModel = function (modelRes) {
    for (var i = 0; i < this.models.length; ++i) {
        if (this.models[i].modelRes.name === modelRes.name) {
            return null;
        }
    }
    var model = new Tw2Model();
    model.modelRes = modelRes;
    var skeleton = modelRes.skeleton;
    if (skeleton !== null) {
        for (var j = 0; j < skeleton.bones.length; ++j) {
            var bone = new Tw2Bone();
            bone.boneRes = skeleton.bones[j];
            model.bones.push(bone);
            model.bonesByName[bone.boneRes.name] = bone;
        }
    }
    this.models.push(model);
    return model;
};

/**
 * Finds a mesh binding for a supplied resource
 * @param {Tw2GeometryRes} resource
 * @returns {Object|null} Returns the mesh binding of a resource if it exists, null if it doesn't
 * @private
 */
Tw2AnimationController.prototype._FindMeshBindings = function (resource) {
    for (var i = 0; i < this.meshBindings.length; ++i) {
        if (this.meshBindings[i].resource === resource) {
            return this.meshBindings[i];
        }
    }
    return null;
};

/**
 * Rebuilds the cached data for a resource (unless it doesn't exist or is already good)
 * @param {Tw2GeometryRes} resource
 * @prototype
 */
Tw2AnimationController.prototype.RebuildCachedData = function (resource) {
    var found = false;
    for (var i = 0; i < this.geometryResources.length; ++i) {
        if (this.geometryResources[i] === resource) {
            found = true;
            break;
        }
    }
    if (!found) {
        return;
    }
    for (var i = 0; i < this.geometryResources.length; ++i) {
        if (!this.geometryResources[i].IsGood()) {
            return;
        }
    }
    for (var i = 0; i < this.geometryResources.length; ++i) {
        this._DoRebuildCachedData(this.geometryResources[i]);
    }
};

/**
 * _DoRebuildCachedData
 * TODO: Too many arguments supplied to this.AddAnimationsFromRes prototype
 * @param {Tw2GeometryRes} resource
 * @private
 */
Tw2AnimationController.prototype._DoRebuildCachedData = function (resource) {
    var newModels = [];
    if (resource.meshes.length) {
        for (var i = 0; i < resource.models.length; ++i) {
            var model = this._AddModel(resource.models[i]);
            if (model) {
                newModels.push(model);
            }
        }
    }
    for (var i = 0; i < this.geometryResources.length; ++i) {
        this.AddAnimationsFromRes(this.geometryResources[i], this.models);
    }

    if (resource.models.length === 0) {
        for (var i = 0; i < resource.meshes.length; ++i) {
            _Tw2GeometryRes.Tw2GeometryRes.BindMeshToModel(resource.meshes[i], this.geometryResources[0].models[0]);
        }
        resource.models.push(this.geometryResources[0].models[0]);
    }
    for (var i = 0; i < resource.models.length; ++i) {
        var model = null;
        for (var j = 0; j < this.models.length; ++j) {
            if (this.models[j].modelRes.name === resource.models[i].name) {
                model = this.models[j];
                break;
            }
        }
        if (model === null) {
            continue;
        }
        for (var j = 0; j < resource.models[i].meshBindings.length; ++j) {
            var meshIx = resource.meshes.indexOf(resource.models[i].meshBindings[j].mesh);
            var meshBindings = this._FindMeshBindings(resource);
            if (meshBindings === null) {
                meshBindings = [];
                meshBindings.resource = resource;
                this.meshBindings.push(meshBindings);
            }
            meshBindings[meshIx] = new Float32Array(resource.models[i].meshBindings[j].bones.length * 12);
            for (var k = 0; k < resource.models[i].meshBindings[j].bones.length; ++k) {
                for (var n = 0; n < model.bones.length; ++n) {
                    if (model.bones[n].boneRes.name === resource.models[i].meshBindings[j].bones[k].name) {
                        if (!model.bones[n].bindingArrays) {
                            model.bones[n].bindingArrays = [];
                        }
                        var arrayInfo = {
                            'array': meshBindings[meshIx],
                            'offset': k * 12
                        };
                        model.bones[n].bindingArrays[model.bones[n].bindingArrays.length] = arrayInfo;
                        //meshBindings[meshIx][k] = model.bones[n].offsetTransform;
                        break;
                    }
                }
            }
        }
    }
    if (resource.meshes.length && resource.models.length) {
        this.ResetBoneTransforms(resource.models);
    }
    this.loaded = true;
    if (this.animations.length) {
        if (this.pendingCommands.length) {
            for (var i = 0; i < this.pendingCommands.length; ++i) {
                if (!this.pendingCommands[i].args) {
                    this.pendingCommands[i].func.apply(this);
                } else {
                    this.pendingCommands[i].func.apply(this, this.pendingCommands[i].args);
                }
            }
        }
        this.pendingCommands = [];
        if (this.onPendingCleared) this.onPendingCleared(this);
    }
};

/**
 * Gets a loaded Tw2Animation by it's name
 * @param name
 * @returns {null|Tw2Animation} Returns the animation if found
 * @constructor
 */
Tw2AnimationController.prototype.GetAnimation = function (name) {
    for (var i = 0; i < this.animations.length; i++) {
        if (this.animations[i].animationRes.name === name) {
            return this.animations[i];
        }
    }

    return null;
};

/**
 * Resets a Tw2Animation by it's name
 * @param {String} name
 * @return {boolean}
 * @constructor
 */
Tw2AnimationController.prototype.ResetAnimation = function (name) {
    var animation = this.GetAnimation(name);
    if (animation) {
        animation.time = 0;
        animation.isPlaying = false;
        animation.callback = null;
        return true;
    }
};

/**
 * Plays a specific animation by it's name
 * @param {string} name - Animation's Name
 * @param {boolean} [cycle]
 * @param {Function} [callback] - Optional callback which is fired once the animation has completed
 * @return {boolean}
 * @prototype
 */
Tw2AnimationController.prototype.PlayAnimation = function (name, cycle, callback) {
    if (this.animations.length === 0) {
        this.pendingCommands.push({
            'func': this.PlayAnimation,
            'args': [name, cycle, callback]
        });
        return true;
    }

    var animation = this.GetAnimation(name);

    if (animation) {
        animation.time = 0;
        animation.isPlaying = true;
        if (typeof cycle !== 'undefined') {
            animation.cycle = cycle;
        }
        if (typeof callback !== 'undefined') {
            animation.callback = callback;
        }
        return true;
    }
};

/**
 * Plays a specific animation from a specific time
 * @param {string} name - Animation's Name
 * @param {number} from - Time to play from
 * @param {boolean} [cycle]
 * @param {Function} [callback] - Optional callback which is fired once the animation has completed
 * @returns {boolean}
 * @prototype
 */
Tw2AnimationController.prototype.PlayAnimationFrom = function (name, from, cycle, callback) {
    if (this.animations.length === 0) {
        this.pendingCommands.push({
            'func': this.PlayAnimationFrom,
            'args': [name, from, cycle, callback]
        });
        return true;
    }

    var animation = this.GetAnimation(name);

    if (animation) {
        from = from <= animation.animationRes.duration ? from : animation.animationRes.duration;
        animation.time = from < 0 ? 0 : from;
        animation.isPlaying = true;
        if (typeof cycle !== 'undefined') {
            animation.cycle = cycle;
        }
        if (typeof callback !== 'undefined') {
            animation.callback = callback;
        }

        return true;
    }
};

/**
 * Gets an array of all the currently playing animations by name
 * @returns {Array}
 * @constructor
 */
Tw2AnimationController.prototype.GetPlayingAnimations = function () {
    var result = [];

    for (var i = 0; i < this.animations.length; i++) {
        if (this.animations[i].isPlaying) {
            result.push(this.animations[i].animationRes.name);
        }
    }

    return result;
};

/**
 * Stops an animation or an array of animations from playing
 * @param {String| Array.<string>} names - Animation Name, or Array of Animation Names
 * @prototype
 */
Tw2AnimationController.prototype.StopAnimation = function (names) {
    if (this.animations.length === 0) {
        this.pendingCommands.push({
            'func': this.StopAnimation,
            'args': names
        });
        return;
    }

    if (typeof names === 'string' || names instanceof String) {
        names = [names];
    }

    var toStop = {};

    for (var n = 0; n < names.length; n++) {
        toStop[names[n]] = true;
    }

    for (var i = 0; i < this.animations.length; ++i) {
        if (this.animations[i].animationRes.name in toStop) {
            this.animations[i].isPlaying = false;
        }
    }
};

/**
 * Stops all animations from playing
 * @prototype
 */
Tw2AnimationController.prototype.StopAllAnimations = function () {
    if (this.animations.length === 0) {
        this.pendingCommands.push({
            'func': this.StopAllAnimations,
            'args': null
        });
        return;
    }

    for (var i = 0; i < this.animations.length; ++i) {
        this.animations[i].isPlaying = false;
    }
};

/**
 * Stops all but the supplied list of animations
 * @param {String| Array.<string>} names - Animation Names
 * @prototype
 */
Tw2AnimationController.prototype.StopAllAnimationsExcept = function (names) {
    if (this.animations.length === 0) {
        this.pendingCommands.push({
            'func': this.StopAllAnimationsExcept,
            'args': names
        });
        return;
    }

    if (typeof names === 'string' || names instanceof String) {
        names = [names];
    }

    var keepAnimating = {};

    for (var n = 0; n < names.length; n++) {
        keepAnimating[names[n]] = true;
    }

    for (var i = 0; i < this.animations.length; ++i) {
        if (!(this.animations[i].animationRes.name in keepAnimating)) {
            this.animations[i].isPlaying = false;
        }
    }
};

/**
 * Resets the bone transforms for the supplied models
 * @param {Array.<Tw2Model>} models
 * @prototype
 */
Tw2AnimationController.prototype.ResetBoneTransforms = function (models) {
    for (var i = 0; i < this.models.length; ++i) {
        for (var j = 0; j < this.models[i].bones.length; ++j) {
            var bone = this.models[i].bones[j];
            var boneRes = bone.boneRes;
            _math.mat4.copy(bone.localTransform, boneRes.localTransform);
            if (boneRes.parentIndex !== -1) {
                _math.mat4.multiply(bone.worldTransform, bone.localTransform, this.models[i].bones[bone.boneRes.parentIndex].worldTransform);
            } else {
                _math.mat4.set(bone.worldTransform, bone.localTransform);
            }
            _math.mat4.identity(bone.offsetTransform);
        }
    }
    var id = _math.mat4.create();
    for (var i = 0; i < this.meshBindings.length; ++i) {
        for (var j = 0; j < this.meshBindings[i].length; ++j) {
            for (var k = 0; k * 16 < this.meshBindings[i][j].length; ++k) {
                for (var m = 0; m < 16; ++m) {
                    this.meshBindings[i][j][k * 16 + m] = id[m];
                }
            }
        }
    }
};

/**
 * EvaluateCurve
 * @param {Tw2GeometryCurve} curve
 * @param {number} time
 * @param value
 * @param {boolean} cycle
 * @param {number} duration
 */
Tw2AnimationController.EvaluateCurve = function (curve, time, value, cycle, duration) {
    var count = curve.knots.length;
    var knot = count - 1;
    var t = 0;
    for (var i = 0; i < curve.knots.length; ++i) {
        if (curve.knots[i] > time) {
            knot = i;
            break;
        }
    }

    if (curve.degree === 0) {
        for (var i = 0; i < curve.dimension; ++i) {
            value[i] = curve.controls[knot * curve.dimension + i];
        }
    } else if (curve.degree === 1) {
        var knot0 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;
        var dt = curve.knots[knot] - curve.knots[knot0];
        if (dt < 0) {
            dt += duration;
        }
        if (dt > 0) {
            t = (time - curve.knots[i - 1]) / dt;
        }
        for (var i = 0; i < curve.dimension; ++i) {
            value[i] = curve.controls[knot0 * curve.dimension + i] * (1 - t) + curve.controls[knot * curve.dimension + i] * t;
        }
    } else {
        var k_2 = cycle ? (knot + count - 2) % count : knot === 0 ? 0 : knot - 2;
        var k_1 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;

        var p1 = k_2 * curve.dimension;
        var p2 = k_1 * curve.dimension;
        var p3 = knot * curve.dimension;

        var ti_2 = curve.knots[k_2];
        var ti_1 = curve.knots[k_1];
        var ti = curve.knots[knot];
        var ti1 = curve.knots[(knot + 1) % count];
        if (ti_2 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }
        if (ti_1 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }
        if (ti1 < ti) {
            ti1 += duration;
        }

        var tmti_1 = time - ti_1;
        var tmti_2 = time - ti_2;
        var dL0 = ti - ti_1;
        var dL1_1 = ti - ti_2;
        var dL1_2 = ti1 - ti_1;

        var L0 = tmti_1 / dL0;
        var L1_1 = tmti_2 / dL1_1;
        var L1_2 = tmti_1 / dL1_2;

        var ci_2 = L1_1 + L0 - L0 * L1_1;
        var ci = L0 * L1_2;
        var ci_1 = ci_2 - ci;
        ci_2 = 1 - ci_2;

        for (var i = 0; i < curve.dimension; ++i) {
            value[i] = ci_2 * curve.controls[p1 + i] + ci_1 * curve.controls[p2 + i] + ci * curve.controls[p3 + i];
        }
    }
};

/**
 * Internal render/update function which is called every frame
 * TODO: Fix commented out code (line 718)
 * @param {number} dt - Delta Time
 * @prototype
 */
Tw2AnimationController.prototype.Update = function (dt) {
    if (this.models === null || !this.update) {
        return;
    }

    for (var i = 0; i < this.geometryResources.length; ++i) {
        this.geometryResources[i].KeepAlive();
    }

    var scratch = Tw2AnimationController.scratch;
    var tempMat = scratch.mat4_0;
    var updateBones = false;
    for (var i = 0; i < this.animations.length; ++i) {
        var animation = this.animations[i];
        if (animation.isPlaying) {
            var res = animation.animationRes;
            animation.time += dt * animation.timeScale;
            if (animation.time > res.duration) {
                if (animation.callback !== null) {
                    animation.callback(this, animation);
                }
                if (animation.cycle) {
                    animation.time = animation.time % res.duration;
                } else {
                    animation.isPlaying = false;
                    animation.time = res.duration;
                }
            }
            var orientation = scratch.quat_0;
            var scale = scratch.mat3_0;
            var position = scratch.vec3_0;
            for (var j = 0; j < animation.trackGroups.length; ++j) {
                for (var k = 0; k < animation.trackGroups[j].transformTracks.length; ++k) {
                    var track = animation.trackGroups[j].transformTracks[k];
                    if (track.trackRes.position) {
                        Tw2AnimationController.EvaluateCurve(track.trackRes.position, animation.time, position, animation.cycle, res.duration);
                    } else {
                        position[0] = position[1] = position[2] = 0;
                    }
                    if (track.trackRes.orientation) {
                        Tw2AnimationController.EvaluateCurve(track.trackRes.orientation, animation.time, orientation, animation.cycle, res.duration);
                        _math.quat.normalize(orientation, orientation);
                    } else {
                        _math.quat.identity(orientation);
                    }
                    if (track.trackRes.scaleShear) {
                        Tw2AnimationController.EvaluateCurve(track.trackRes.scaleShear, animation.time, scale, animation.cycle, res.duration);
                    } else {
                        _math.mat3.identity(scale);
                    }

                    var l = track.bone.localTransform;
                    l[0] = scale[0];
                    l[1] = scale[1];
                    l[2] = scale[2];
                    l[4] = scale[3];
                    l[5] = scale[4];
                    l[6] = scale[5];
                    l[8] = scale[6];
                    l[9] = scale[7];
                    l[10] = scale[8];
                    l[3] = l[7] = l[11] = l[12] = l[13] = l[14] = 0;
                    l[15] = 1;

                    _math.mat4.multiply(track.bone.localTransform, track.bone.localTransform, _math.mat4.fromQuat(tempMat, orientation));
                    track.bone.localTransform[12] = position[0];
                    track.bone.localTransform[13] = position[1];
                    track.bone.localTransform[14] = position[2];
                    updateBones = true;
                }
            }
        }
    }
    //if (updateBones)
    {
        for (var i = 0; i < this.models.length; ++i) {
            for (var j = 0; j < this.models[i].bones.length; ++j) {
                var bone = this.models[i].bones[j];
                if (bone.boneRes.parentIndex !== -1) {
                    _math.mat4.multiply(bone.worldTransform, this.models[i].bones[bone.boneRes.parentIndex].worldTransform, bone.localTransform);
                } else {
                    _math.mat4.copy(bone.worldTransform, bone.localTransform);
                }
                _math.mat4.multiply(bone.offsetTransform, bone.worldTransform, bone.boneRes.worldTransformInv);
                if (bone.bindingArrays) {
                    for (var a = 0; a < bone.bindingArrays.length; ++a) {
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 0] = bone.offsetTransform[0];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 1] = bone.offsetTransform[4];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 2] = bone.offsetTransform[8];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 3] = bone.offsetTransform[12];

                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 4] = bone.offsetTransform[1];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 5] = bone.offsetTransform[5];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 6] = bone.offsetTransform[9];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 7] = bone.offsetTransform[13];

                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 8] = bone.offsetTransform[2];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 9] = bone.offsetTransform[6];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 10] = bone.offsetTransform[10];
                        bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 11] = bone.offsetTransform[14];
                    }
                }
            }
        }
    }
};

/**
 * RenderDebugInfo
 * TODO: Fix commented out code (lines 767 - 770)
 * @param {function} debugHelper
 * @prototype
 */
Tw2AnimationController.prototype.RenderDebugInfo = function (debugHelper) {
    /*for (var i = 0; i < this.geometryResources.length; ++i)
     {
     this.geometryResources[i].RenderDebugInfo(debugHelper);
     }*/
    for (var i = 0; i < this.models.length; ++i) {
        for (var j = 0; j < this.models[i].bones.length; ++j) {
            var b0 = this.models[i].bones[j];
            if (b0.boneRes.parentIndex >= 0) {
                var b1 = this.models[i].bones[b0.boneRes.parentIndex];
                debugHelper.AddLine([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]]);
            }
        }
    }
};

/**
 * GetBoneMatrices
 * @param {number} meshIndex
 * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
 * @returns {Float32Array}
 * @prototype
 */
Tw2AnimationController.prototype.GetBoneMatrices = function (meshIndex, geometryResource) {
    if (this.geometryResources.length === 0) {
        return new Float32Array();
    }

    if (typeof geometryResource === 'undefined') {
        geometryResource = this.geometryResources[0];
    }
    var meshBindings = this._FindMeshBindings(geometryResource);
    if (meshBindings && meshIndex < meshBindings.length) {
        return meshBindings[meshIndex];
    }
    return new Float32Array();
};

/**
 * FindModelForMesh
 * @param {number} meshIndex
 * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
 * @returns {Tw2Model|null} Returns the Tw2Model for the mesh if found and is good, else returns null
 * @prototype
 */
Tw2AnimationController.prototype.FindModelForMesh = function (meshIndex, geometryResource) {
    if (this.geometryResources.length === 0) {
        return null;
    }
    if (typeof geometryResource === 'undefined') {
        geometryResource = this.geometryResources[0];
    }
    if (!geometryResource.IsGood()) {
        return null;
    }
    var mesh = geometryResource.meshes[meshIndex];
    for (var i = 0; i < this.models.length; ++i) {
        for (var j = 0; j < this.models[i].modelRes.meshBindings.length; ++i) {
            if (this.models[i].modelRes.meshBindings[j].mesh === mesh) {
                return this.models[i];
            }
        }
    }
    return null;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2CurveSet = Tw2CurveSet;
/**
 * Tw2CurveSet
 * @property {string} name
 * @property {Array.<Tw2Curve>} curves
 * @property {Array} bindings
 * @property {number} scale
 * @property {boolean} playOnLoad
 * @property {boolean} isPlaying
 * @property {number} scaledTime
 * @constructor
 */
function Tw2CurveSet() {
    this.name = '';
    this.curves = [];
    this.bindings = [];
    this.scale = 1;
    this.playOnLoad = true;
    this.isPlaying = false;
    this.scaledTime = 0;
}

/**
 * Initializes the Tw2CurveSet
 * @prototype
 */
Tw2CurveSet.prototype.Initialize = function () {
    if (this.playOnLoad) {
        this.Play();
    }
};

/**
 * Plays the Tw2CurveSet
 * @prototype
 */
Tw2CurveSet.prototype.Play = function () {
    this.isPlaying = true;
    this.scaledTime = 0;
};

/**
 * Plays the Tw2CurveSet from a specific time
 * @param {number} time
 * @prototype
 */
Tw2CurveSet.prototype.PlayFrom = function (time) {
    this.isPlaying = true;
    this.scaledTime = time;
};

/**
 * Stops the Tw2CurveSet from playing
 * @prototype
 */
Tw2CurveSet.prototype.Stop = function () {
    this.isPlaying = false;
};

/**
 * Internal render/update function which is called every frame
 * @param {number} dt - Delta Time
 * @prototype
 */
Tw2CurveSet.prototype.Update = function (dt) {
    if (this.isPlaying) {
        this.scaledTime += dt * this.scale;
        var scaledTime = this.scaledTime;
        var curves = this.curves;
        for (var i = 0; i < curves.length; ++i) {
            curves[i].UpdateValue(scaledTime);
        }
        var bindings = this.bindings;
        for (var b = 0; b < bindings.length; ++b) {
            bindings[b].CopyValue();
        }
    }
};

/**
 * Gets the maximum curve duration
 * @returns {number}
 * @prototype
 */
Tw2CurveSet.prototype.GetMaxCurveDuration = function () {
    var length = 0;
    for (var i = 0; i < this.curves.length; ++i) {
        if ('GetLength' in this.curves[i]) {
            length = Math.max(length, this.curves[i].GetLength());
        }
    }
    return length;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2EffectRes = undefined;

var _math = __webpack_require__(0);

var _Tw2Device = __webpack_require__(2);

var _Tw2EventEmitter = __webpack_require__(6);

var _Tw2Resource2 = __webpack_require__(11);

var _Tw2BinaryReader = __webpack_require__(18);

var _Tw2SamplerState = __webpack_require__(19);

var _Tw2VertexDeclaration = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EffectRes
 * @property {Array} passes
 * @property {Object.<string, Array>} annotations
 * @inherits Tw2Resource
 * @constructor
 */
var Tw2EffectRes = exports.Tw2EffectRes = function (_Tw2Resource) {
    _inherits(Tw2EffectRes, _Tw2Resource);

    function Tw2EffectRes() {
        _classCallCheck(this, Tw2EffectRes);

        var _this = _possibleConstructorReturn(this, (Tw2EffectRes.__proto__ || Object.getPrototypeOf(Tw2EffectRes)).call(this));

        _this.passes = [];
        _this.annotations = {};
        return _this;
    }

    return Tw2EffectRes;
}(_Tw2Resource2.Tw2Resource);

/**
 * Request Response Type
 * @type {string}
 */


Tw2EffectRes.prototype.requestResponseType = 'arraybuffer';

/**
 * Prepares the effect
 * - Creates Shaders
 * - Sets shadow states for shaders
 * - Parses Jessica shader annotations
 * @param data
 */
Tw2EffectRes.prototype.Prepare = function (data) {
    this.passes = [];
    this.annotations = {};

    var reader = new _Tw2BinaryReader.Tw2BinaryReader(new Uint8Array(data));
    var stringTable = '';

    /**
     * ReadString
     * @returns {string}
     * @private
     */
    function ReadString() {
        var offset = reader.ReadUInt32();
        var end = offset;
        while (stringTable.charCodeAt(end)) {
            ++end;
        }
        return stringTable.substr(offset, end - offset);
    }

    /**
     * Compiles shader
     * @param {Number} stageType
     * @param {string} prefix
     * @param shaderCode
     * @param {string} path - Shader path
     * @returns {*}
     * @private
     */
    function CompileShader(stageType, prefix, shaderCode, path) {
        var shader = _Tw2Device.device.gl.createShader(stageType === 0 ? _Tw2Device.device.gl.VERTEX_SHADER : _Tw2Device.device.gl.FRAGMENT_SHADER);

        if (_Tw2Device.device.ext.ShaderBinary) {
            _Tw2Device.device.ext.ShaderBinary.shaderBinary(shader, shaderCode);
        } else {
            var source = prefix + (typeof shaderCode === 'string' ? shaderCode : String.fromCharCode.apply(null, shaderCode));
            source = source.substr(0, source.length - 1);
            _Tw2Device.device.gl.shaderSource(shader, source);
            _Tw2Device.device.gl.compileShader(shader);
        }
        if (!_Tw2Device.device.gl.getShaderParameter(shader, _Tw2Device.device.gl.COMPILE_STATUS)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2EffectRes', 'CompileShader'],
                msg: 'Error compiling shader',
                path: path,
                type: 'shader.compile',
                value: stageType === 0 ? 'VERTEX' : 'FRAGMENT',
                data: _Tw2Device.device.gl.getShaderInfoLog(shader)
            });

            return null;
        }
        return shader;
    }

    /**
     * Creates shader program
     * @param vertexShader
     * @param fragmentShader
     * @param pass
     * @param {string} path - Shader path
     * @returns {*}
     * @private
     */
    function CreateProgram(vertexShader, fragmentShader, pass, path) {
        var program = {};
        program.program = _Tw2Device.device.gl.createProgram();
        _Tw2Device.device.gl.attachShader(program.program, vertexShader);
        _Tw2Device.device.gl.attachShader(program.program, fragmentShader);
        _Tw2Device.device.gl.linkProgram(program.program);

        if (!_Tw2Device.device.gl.getProgramParameter(program.program, _Tw2Device.device.gl.LINK_STATUS)) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2EffectRes', 'CreateProgram'],
                msg: 'Error linking shaders',
                path: path,
                type: 'shader.linkstatus',
                data: _Tw2Device.device.gl.getProgramInfoLog(program.program)
            });
            return null;
        }

        _Tw2Device.device.gl.useProgram(program.program);
        program.constantBufferHandles = [];
        for (var j = 0; j < 16; ++j) {
            program.constantBufferHandles[j] = _Tw2Device.device.gl.getUniformLocation(program.program, 'cb' + j);
        }
        program.samplerHandles = [];
        for (var j = 0; j < 16; ++j) {
            program.samplerHandles[j] = _Tw2Device.device.gl.getUniformLocation(program.program, 's' + j);
            _Tw2Device.device.gl.uniform1i(program.samplerHandles[j], j);
        }
        for (var j = 0; j < 16; ++j) {
            program.samplerHandles[j + 12] = _Tw2Device.device.gl.getUniformLocation(program.program, 'vs' + j);
            _Tw2Device.device.gl.uniform1i(program.samplerHandles[j + 12], j + 12);
        }
        program.input = new _Tw2VertexDeclaration.Tw2VertexDeclaration();
        for (var j = 0; j < pass.stages[0].inputDefinition.elements.length; ++j) {
            var location = _Tw2Device.device.gl.getAttribLocation(program.program, 'attr' + j);
            if (location >= 0) {
                var el = new _Tw2VertexDeclaration.Tw2VertexElement(pass.stages[0].inputDefinition.elements[j].usage, pass.stages[0].inputDefinition.elements[j].usageIndex);
                el.location = location;
                program.input.elements.push(el);
            }
        }
        program.input.RebuildHash();

        program.shadowStateInt = _Tw2Device.device.gl.getUniformLocation(program.program, 'ssi');
        program.shadowStateFloat = _Tw2Device.device.gl.getUniformLocation(program.program, 'ssf');
        program.shadowStateYFlip = _Tw2Device.device.gl.getUniformLocation(program.program, 'ssyf');
        _Tw2Device.device.gl.uniform3f(program.shadowStateYFlip, 0, 0, 1);
        program.volumeSlices = [];
        for (var j = 0; j < pass.stages[1].samplers.length; ++j) {
            if (pass.stages[1].samplers[j].isVolume) {
                program.volumeSlices[pass.stages[1].samplers[j].registerIndex] = _Tw2Device.device.gl.getUniformLocation(program.program, 's' + pass.stages[1].samplers[j].registerIndex + 'sl');
            }
        }
        return program;
    }

    var version = reader.ReadUInt32();
    if (version < 2 || version > 5) {
        _Tw2EventEmitter.emitter.log('res.error', {
            log: 'error',
            src: ['Tw2EffectRes', 'CreateProgram'],
            msg: 'Invalid version of effect file',
            type: 'shader.effectversion',
            path: this.path,
            value: version
        });

        this.PrepareFinished(false);
        return;
    }

    var headerSize, stringTableSize;
    var stringTableOffset = 0;

    if (version < 5) {
        headerSize = reader.ReadUInt32();
        if (headerSize === 0) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2EffectRes', 'CreateProgram'],
                msg: 'File contains no compiled effects',
                path: this.path,
                type: 'shader.effectheadersize',
                value: 0
            });

            this.PrepareFinished(false);
            return;
        }
        /* var permutation = */
        reader.ReadUInt32();
        var offset = reader.ReadUInt32();
        reader.cursor = 2 * 4 + headerSize * 3 * 4;
        stringTableSize = reader.ReadUInt32();
        stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));

        reader.cursor = offset;
    } else {
        stringTableSize = reader.ReadUInt32();
        stringTableOffset = reader.cursor;
        stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));
        reader.cursor += stringTableSize;
        var permutationCount = reader.ReadUInt8();
        for (var perm = 0; perm < permutationCount; ++perm) {
            reader.ReadUInt32();
            reader.ReadUInt8();
            reader.ReadUInt32();
            var cnt = reader.ReadUInt8();
            for (var j = 0; j < cnt; ++j) {
                reader.ReadUInt32();
            }
        }
        headerSize = reader.ReadUInt32();
        if (headerSize === 0) {
            _Tw2EventEmitter.emitter.log('res.error', {
                log: 'error',
                src: ['Tw2EffectRes', 'CreateProgram'],
                msg: 'File contains no compiled effects',
                path: this.path,
                type: 'shader.effectheadersize',
                value: 0
            });

            this.PrepareFinished(false);
            return;
        }
        reader.ReadUInt32();
        reader.cursor = reader.ReadUInt32();
    }

    var passCount = reader.ReadUInt8();
    for (var passIx = 0; passIx < passCount; ++passIx) {
        var pass = {};
        pass.stages = [{}, {}];
        var stageCount = reader.ReadUInt8();
        var validShadowShader = true;
        for (var stageIx = 0; stageIx < stageCount; ++stageIx) {
            var stage = {};
            stage.inputDefinition = new _Tw2VertexDeclaration.Tw2VertexDeclaration();
            stage.constants = [];
            stage.textures = [];
            stage.samplers = [];
            var stageType = reader.ReadUInt8();
            var inputCount = reader.ReadUInt8();
            for (var inputIx = 0; inputIx < inputCount; ++inputIx) {
                var usage = reader.ReadUInt8();
                /* var registerIndex = */
                reader.ReadUInt8();
                var usageIndex = reader.ReadUInt8();
                /* var usedMask = */
                reader.ReadUInt8();
                stage.inputDefinition.elements[inputIx] = new _Tw2VertexDeclaration.Tw2VertexElement(usage, usageIndex, 0);
            }
            stage.inputDefinition.RebuildHash();

            var shaderSize, shaderCode, shadowShaderSize, shadowShaderCode;

            if (version < 5) {
                shaderSize = reader.ReadUInt32();
                shaderCode = reader.data.subarray(reader.cursor, reader.cursor + shaderSize);
                reader.cursor += shaderSize;

                shadowShaderSize = reader.ReadUInt32();
                shadowShaderCode = reader.data.subarray(reader.cursor, reader.cursor + shadowShaderSize);
                reader.cursor += shadowShaderSize;
            } else {
                shaderSize = reader.ReadUInt32();
                var so = reader.ReadUInt32();
                shaderCode = stringTable.substr(so, shaderSize);
                shadowShaderSize = reader.ReadUInt32();
                so = reader.ReadUInt32();
                shadowShaderCode = stringTable.substr(so, shadowShaderSize);
            }

            stage.shader = CompileShader(stageType, '', shaderCode, this.path);
            if (stage.shader === null) {
                this.PrepareFinished(false);
                return;
            }

            if (validShadowShader) {
                if (shadowShaderSize === 0) {
                    stage.shadowShader = CompileShader(stageType, '\n#define PS\n', shaderCode, this.path);
                } else {
                    stage.shadowShader = CompileShader(stageType, '', shadowShaderCode, this.path);
                }
                if (stage.shadowShader === null) {
                    validShadowShader = false;
                }
            } else {
                stage.shadowShader = null;
            }

            if (version >= 3) {
                reader.ReadUInt32();
                reader.ReadUInt32();
                reader.ReadUInt32();
            }

            stage.constantSize = 0;
            var constantCount = reader.ReadUInt32();
            for (var constantIx = 0; constantIx < constantCount; ++constantIx) {
                var constant = {};
                constant.name = ReadString();
                constant.offset = reader.ReadUInt32() / 4;
                constant.size = reader.ReadUInt32() / 4;
                constant.type = reader.ReadUInt8();
                constant.dimension = reader.ReadUInt8();
                constant.elements = reader.ReadUInt32();
                constant.isSRGB = reader.ReadUInt8();
                constant.isAutoregister = reader.ReadUInt8();
                stage.constants[constantIx] = constant;

                if (constant.name === 'PerFrameVS' || constant.name === 'PerObjectVS' || constant.name === 'PerFramePS' || constant.name === 'PerObjectPS') {
                    continue;
                }

                var last = constant.offset + constant.size;
                if (last > stage.constantSize) {
                    stage.constantSize = last;
                }
            }

            var constantValueSize = reader.ReadUInt32() / 4;
            stage.constantValues = new Float32Array(constantValueSize);
            if (version < 5) {
                for (var i = 0; i < constantValueSize; ++i) {
                    stage.constantValues[i] = reader.ReadFloat32();
                }
            } else {
                var co = reader.ReadUInt32();
                var bo = reader.cursor;
                reader.cursor = stringTableOffset + co;
                for (var i = 0; i < constantValueSize; ++i) {
                    stage.constantValues[i] = reader.ReadFloat32();
                }
                reader.cursor = bo;
            }
            stage.constantSize = Math.max(stage.constantSize, constantValueSize);

            var textureCount = reader.ReadUInt8();
            for (var textureIx = 0; textureIx < textureCount; ++textureIx) {
                var registerIndex = reader.ReadUInt8();
                var texture = {};
                texture.registerIndex = registerIndex;
                texture.name = ReadString();
                texture.type = reader.ReadUInt8();
                texture.isSRGB = reader.ReadUInt8();
                texture.isAutoregister = reader.ReadUInt8();
                stage.textures.push(texture);
            }

            var samplerCount = reader.ReadUInt8();
            for (var samplerIx = 0; samplerIx < samplerCount; ++samplerIx) {
                var registerIndex = reader.ReadUInt8();
                var samplerName = '';
                if (version >= 4) {
                    samplerName = ReadString();
                }
                /* var comparison = */
                reader.ReadUInt8();
                var minFilter = reader.ReadUInt8();
                var magFilter = reader.ReadUInt8();
                var mipFilter = reader.ReadUInt8();
                var addressU = reader.ReadUInt8();
                var addressV = reader.ReadUInt8();
                var addressW = reader.ReadUInt8();
                var mipLODBias = reader.ReadFloat32();
                var maxAnisotropy = reader.ReadUInt8();
                /* var comparisonFunc = */
                reader.ReadUInt8();
                var borderColor = _math.quat.create();
                borderColor[0] = reader.ReadFloat32();
                borderColor[1] = reader.ReadFloat32();
                borderColor[2] = reader.ReadFloat32();
                borderColor[3] = reader.ReadFloat32();
                var minLOD = reader.ReadFloat32();
                var maxLOD = reader.ReadFloat32();
                if (version < 4) {
                    reader.ReadUInt8();
                }
                var sampler = new _Tw2SamplerState.Tw2SamplerState();
                sampler.registerIndex = registerIndex;
                sampler.name = samplerName;
                if (minFilter === 1) {
                    switch (mipFilter) {
                        case 0:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST;
                            break;
                        case 1:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_NEAREST;
                            break;
                        default:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_LINEAR;
                    }
                    sampler.minFilterNoMips = _Tw2Device.device.gl.NEAREST;
                } else {
                    switch (mipFilter) {
                        case 0:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR;
                            break;
                        case 1:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_NEAREST;
                            break;
                        default:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_LINEAR;
                    }
                    sampler.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
                }
                if (magFilter === 1) {
                    sampler.magFilter = _Tw2Device.device.gl.NEAREST;
                } else {
                    sampler.magFilter = _Tw2Device.device.gl.LINEAR;
                }
                var wrapModes = [0, _Tw2Device.device.gl.REPEAT, _Tw2Device.device.gl.MIRRORED_REPEAT, _Tw2Device.device.gl.CLAMP_TO_EDGE, _Tw2Device.device.gl.CLAMP_TO_EDGE, _Tw2Device.device.gl.CLAMP_TO_EDGE];
                sampler.addressU = wrapModes[addressU];
                sampler.addressV = wrapModes[addressV];
                sampler.addressW = wrapModes[addressW];
                if (minFilter === 3 || magFilter === 3 || mipFilter === 3) {
                    sampler.anisotropy = Math.max(maxAnisotropy, 1);
                }
                for (var n = 0; n < stage.textures.length; ++n) {
                    if (stage.textures[n].registerIndex === sampler.registerIndex) {
                        sampler.samplerType = stage.textures[n].type === 4 ? _Tw2Device.device.gl.TEXTURE_CUBE_MAP : _Tw2Device.device.gl.TEXTURE_2D;
                        sampler.isVolume = stage.textures[n].type === 3;
                        break;
                    }
                }
                sampler.ComputeHash();

                stage.samplers.push(sampler);
            }
            if (version >= 3) {
                reader.ReadUInt8();
            }

            pass.stages[stageType] = stage;
        }

        pass.states = [];
        var stateCount = reader.ReadUInt8();
        for (var stateIx = 0; stateIx < stateCount; ++stateIx) {
            var state = reader.ReadUInt32();
            var value = reader.ReadUInt32();
            pass.states.push({
                'state': state,
                'value': value
            });
        }

        pass.shaderProgram = CreateProgram(pass.stages[0].shader, pass.stages[1].shader, pass, this.path);
        if (pass.shaderProgram === null) {
            this.PrepareFinished(false);
            return;
        }
        if (validShadowShader) {
            pass.shadowShaderProgram = CreateProgram(pass.stages[0].shadowShader, pass.stages[1].shadowShader, pass, this.path);
            if (pass.shadowShaderProgram === null) {
                pass.shadowShaderProgram = pass.shaderProgram;
            }
        } else {
            pass.shadowShaderProgram = pass.shaderProgram;
        }

        this.passes[passIx] = pass;
    }

    var parameterCount = reader.ReadUInt16();
    for (var paramIx = 0; paramIx < parameterCount; ++paramIx) {
        var name = ReadString();
        var annotations = [];
        var annotationCount = reader.ReadUInt8();
        for (var annotationIx = 0; annotationIx < annotationCount; ++annotationIx) {
            annotations[annotationIx] = {};
            annotations[annotationIx].name = ReadString();
            annotations[annotationIx].type = reader.ReadUInt8();
            switch (annotations[annotationIx].type) {
                case 0:
                    annotations[annotationIx].value = reader.ReadUInt32() !== 0;
                    break;
                case 1:
                    annotations[annotationIx].value = reader.ReadInt32();
                    break;
                case 2:
                    annotations[annotationIx].value = reader.ReadFloat32();
                    break;
                default:
                    annotations[annotationIx].value = ReadString();
            }
        }
        this.annotations[name] = annotations;
    }

    this.PrepareFinished(true);
};

/**
 * Applies an Effect Pass
 * @param {Number} pass - effect.passes index
 */
Tw2EffectRes.prototype.ApplyPass = function (pass) {
    pass = this.passes[pass];
    for (var i = 0; i < pass.states.length; ++i) {
        _Tw2Device.device.SetRenderState(pass.states[i].state, pass.states[i].value);
    }
    if (_Tw2Device.device.IsAlphaTestEnabled()) {
        _Tw2Device.device.gl.useProgram(pass.shadowShaderProgram.program);
        _Tw2Device.device.shadowHandles = pass.shadowShaderProgram;
    } else {
        _Tw2Device.device.gl.useProgram(pass.shaderProgram.program);
        _Tw2Device.device.shadowHandles = null;
    }
};

/**
 * Finds out if a parameter name is a valid shader input
 * @param {string} name - An Effect Parameter name
 * @returns {Boolean}
 */
Tw2EffectRes.prototype.IsValidParameter = function (name) {
    return name in this.annotations;
};

/**
 * Returns an array of valid parameter names for a specific annotation group
 * - Compatible with pre V5 shaders
 * @param {string} groupName - The name of an annotation group
 * @returns {Array.< string >}
 */
Tw2EffectRes.prototype.GetParametersByGroup = function (groupName) {
    var parameters = [];

    for (var param in this.annotations) {
        if (this.annotations.hasOwnProperty(param)) {
            for (var i = 0; i < this.annotations[param].length; i++) {
                if (this.annotations[param][i].name.toLowerCase() === 'group' && this.annotations[param][i].value.toLowerCase() === groupName.toLowerCase()) {
                    parameters.push(param);
                }
            }
        }
    }

    return parameters;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2Float = Tw2Float;
/**
 * Tw2Float
 * @property {number} value
 * @constructor
 */
function Tw2Float() {
  this.value = 0;
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Frustum = Tw2Frustum;

var _math = __webpack_require__(0);

/**
 * Tw2Frustum
 * @property {Array.<vec4>} planes
 * @property {vec3} viewPos
 * @property {vec3} viewDir
 * @property {number} halfWidthProjection
 * @constructor
 */
function Tw2Frustum() {
    this.planes = [_math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create()];
    this.viewPos = _math.vec3.create();
    this.viewDir = _math.vec3.create();
    this.halfWidthProjection = 1;
}

/**
 * Scratch variables
 */
Tw2Frustum.scratch = {
    mat4_0: _math.mat4.create(),
    vec3_0: _math.vec3.create()
};

/**
 * Initializes the Tw2Frustum
 * @param {mat4} view - View Matrix
 * @param {mat4} proj - Projection Matrix
 * @param {number} viewportSize
 * @param {mat4} [viewInverse] Optional viewInverse matrix
 * @param {mat4} [viewProjection] Optional viewProjection matrix
 * @prototype
 */
Tw2Frustum.prototype.Initialize = function (view, proj, viewportSize, viewInverse, viewProjection) {
    var mat4_0 = Tw2Frustum.scratch.mat4_0;

    var viewInv = viewInverse ? viewInverse : _math.mat4.invert(mat4_0, view);
    this.viewPos.set(viewInv.subarray(12, 14));
    this.viewDir.set(viewInv.subarray(8, 10));
    this.halfWidthProjection = proj[0] * viewportSize * 0.5;

    var viewProj = viewProjection ? viewProjection : _math.mat4.multiply(mat4_0, proj, view);
    this.planes[0][0] = viewProj[2];
    this.planes[0][1] = viewProj[6];
    this.planes[0][2] = viewProj[10];
    this.planes[0][3] = viewProj[14];

    this.planes[1][0] = viewProj[3] + viewProj[0];
    this.planes[1][1] = viewProj[7] + viewProj[4];
    this.planes[1][2] = viewProj[11] + viewProj[8];
    this.planes[1][3] = viewProj[15] + viewProj[12];

    this.planes[2][0] = viewProj[3] - viewProj[1];
    this.planes[2][1] = viewProj[7] - viewProj[5];
    this.planes[2][2] = viewProj[11] - viewProj[9];
    this.planes[2][3] = viewProj[15] - viewProj[13];

    this.planes[3][0] = viewProj[3] - viewProj[0];
    this.planes[3][1] = viewProj[7] - viewProj[4];
    this.planes[3][2] = viewProj[11] - viewProj[8];
    this.planes[3][3] = viewProj[15] - viewProj[12];

    this.planes[4][0] = viewProj[3] + viewProj[1];
    this.planes[4][1] = viewProj[7] + viewProj[5];
    this.planes[4][2] = viewProj[11] + viewProj[9];
    this.planes[4][3] = viewProj[15] + viewProj[13];

    this.planes[5][0] = viewProj[3] - viewProj[2];
    this.planes[5][1] = viewProj[7] - viewProj[6];
    this.planes[5][2] = viewProj[11] - viewProj[10];
    this.planes[5][3] = viewProj[15] - viewProj[14];

    for (var i = 0; i < 6; ++i) {
        var len = _math.vec3.length(this.planes[i]);
        this.planes[i][0] /= len;
        this.planes[i][1] /= len;
        this.planes[i][2] /= len;
        this.planes[i][3] /= len;
    }
};

/**
 * Checks to see if a sphere is visible within the frustum
 * @param {vec3} center
 * @param {number} radius
 * @returns {boolean}
 * @prototype
 */
Tw2Frustum.prototype.IsSphereVisible = function (center, radius) {
    for (var i = 0; i < 6; ++i) {
        if (this.planes[i][0] * center[0] + this.planes[i][1] * center[1] + this.planes[i][2] * center[2] + this.planes[i][3] < -radius) {
            return false;
        }
    }
    return true;
};

/**
 * GetPixelSizeAcross
 * @param {vec3} center
 * @param {number} radius
 * @returns {number}
 * @prototype
 */
Tw2Frustum.prototype.GetPixelSizeAcross = function (center, radius) {
    var d = _math.vec3.subtract(Tw2Frustum.scratch.vec3_0, this.viewPos, center);
    var depth = _math.vec3.dot(this.viewDir, d);
    var epsilon = 1e-5;
    if (depth < epsilon) {
        depth = epsilon;
    }
    if (radius < epsilon) {
        return 0;
    }
    var ratio = radius / depth;
    return ratio * this.halfWidthProjection * 2;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2InstancedMeshBatch = exports.Tw2InstancedMesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _Tw2ResMan = __webpack_require__(4);

var _Tw2Mesh2 = __webpack_require__(37);

var _Tw2BatchAccumulator = __webpack_require__(23);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2InstancedMesh
 * @property instanceGeometryResource
 * @property {string} instanceGeometryResPath
 * @property {number} instanceMeshIndex
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @inherit Tw2Mesh
 * @constructor
 */
var Tw2InstancedMesh = exports.Tw2InstancedMesh = function (_Tw2Mesh) {
    _inherits(Tw2InstancedMesh, _Tw2Mesh);

    function Tw2InstancedMesh() {
        _classCallCheck(this, Tw2InstancedMesh);

        var _this = _possibleConstructorReturn(this, (Tw2InstancedMesh.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh)).call(this));

        _this.instanceGeometryResource = null;
        _this.instanceGeometryResPath = '';
        _this.instanceMeshIndex = 0;
        _this.minBounds = _math.vec3.create();
        _this.maxBounds = _math.vec3.create();
        return _this;
    }

    /**
     * Initializes the Tw2InstancedMesh
     * @prototype
     */


    _createClass(Tw2InstancedMesh, [{
        key: 'Initialize',
        value: function Initialize() {
            _get(Tw2InstancedMesh.prototype.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh.prototype), 'Initialize', this).call(this);
            if (this.instanceGeometryResPath !== '') {
                this.instanceGeometryResource = _Tw2ResMan.resMan.GetResource(this.instanceGeometryResPath);
            }
        }
    }]);

    return Tw2InstancedMesh;
}(_Tw2Mesh2.Tw2Mesh);

/**
 * _GetAreaBatches
 * @param {Array.<Tw2MeshArea>} areas
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @private
 */


Tw2InstancedMesh.prototype._GetAreaBatches = function (areas, mode, accumulator, perObjectData) {
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.effect === null || area.debugIsHidden) {
            continue;
        }
        var batch = new Tw2InstancedMeshBatch();
        batch.renderMode = mode;
        batch.perObjectData = perObjectData;
        batch.instanceMesh = this;
        batch.meshIx = area.meshIndex;
        batch.start = area.index;
        batch.count = area.count;
        batch.effect = area.effect;
        accumulator.Commit(batch);
    }
};

/**
 * RenderAreas
 * @param {number} meshIx
 * @param {number} start
 * @param {number} count
 * @param {Tw2Effect} effect
 * @prototype
 */
Tw2InstancedMesh.prototype.RenderAreas = function (meshIx, start, count, effect) {
    if (this.geometryResource) {
        this.geometryResource.KeepAlive();
    }
    if (this.instanceGeometryResource && this.instanceGeometryResource.KeepAlive) {
        this.instanceGeometryResource.KeepAlive();
    }
    if (this.geometryResource && this.instanceGeometryResource) {
        if (!this.geometryResource.IsGood()) {
            return;
        }
        var buffer = this.instanceGeometryResource.GetInstanceBuffer(this.instanceMeshIndex);
        if (buffer) {
            this.geometryResource.RenderAreasInstanced(meshIx, start, count, effect, buffer, this.instanceGeometryResource.GetInstanceDeclaration(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceStride(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceCount(this.instanceMeshIndex));
        }
    }
};

/**
 * Tw2InstancedMeshBatch
 * @property {Tw2InstancedMesh} instanceMesh
 * @property {Tw2GeometryRes} geometryRes
 * @property {number} meshIx
 * @property {number} start
 * @property {number} count
 * @property {Tw2Effect|null} effect
 * @inherit Tw2RenderBatch
 * @class
 */

var Tw2InstancedMeshBatch = exports.Tw2InstancedMeshBatch = function (_Tw2RenderBatch) {
    _inherits(Tw2InstancedMeshBatch, _Tw2RenderBatch);

    function Tw2InstancedMeshBatch() {
        _classCallCheck(this, Tw2InstancedMeshBatch);

        var _this2 = _possibleConstructorReturn(this, (Tw2InstancedMeshBatch.__proto__ || Object.getPrototypeOf(Tw2InstancedMeshBatch)).call(this));

        _this2.instanceMesh = null;
        _this2.geometryRes = null;
        _this2.meshIx = 0;
        _this2.start = 0;
        _this2.count = 1;
        _this2.effect = null;
        return _this2;
    }

    return Tw2InstancedMeshBatch;
}(_Tw2BatchAccumulator.Tw2RenderBatch);

/**
 * Commits the Tw2InstancedMeshBatch for rendering
 * @param {Tw2Effect} [overrideEffect]
 * @prototype
 */


Tw2InstancedMeshBatch.prototype.Commit = function (overrideEffect) {
    var effect = typeof overrideEffect === 'undefined' ? this.effect : overrideEffect;
    if (this.instanceMesh && effect) {
        this.instanceMesh.RenderAreas(this.meshIx, this.start, this.count, effect);
    }
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MatrixParameter = Tw2MatrixParameter;

var _math = __webpack_require__(0);

/**
 * Tw2MatrixParameter
 * @param {string} [name='']
 * @param {mat4|Float32Array|Array} [value=mat4.create()]
 * @property {string} name
 * @property {mat4|Float32Array} value
 * @property {Float32Array} constantBuffer
 * @property {number} offset
 * @constructor
 */
function Tw2MatrixParameter(name, value) {
    this.name = name !== undefined ? name : '';
    this.value = value !== undefined ? _math.mat4.clone(value) : _math.mat4.create();
    this.constantBuffer = null;
    this.offset = 0;
}

/**
 * Binds the parameter's value to a constant buffer
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @returns {boolean}
 * @prototype
 */
Tw2MatrixParameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 16) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
};

/**
 * Unbinds the parameter's constant buffer
 * @prototype
 */
Tw2MatrixParameter.prototype.Unbind = function () {
    this.constantBuffer = null;
};

/**
 * Sets a supplied value
 * @param {mat4} value
 * @prototype
 */
Tw2MatrixParameter.prototype.SetValue = function (value) {
    _math.mat4.copy(this.value, value);
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Gets the current value
 * @return {mat4|Float32Array}
 * @prototype
 */
Tw2MatrixParameter.prototype.GetValue = function () {
    if (this.constantBuffer !== null) {
        return _math.mat4.clone(this.constantBuffer.subarray(this.offset, this.offset + this.value.length));
    }

    return _math.mat4.clone(this.value);
};

/**
 * Applies the current value to the supplied constant buffer at the supplied offset
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @prototype
 */
Tw2MatrixParameter.prototype.Apply = function (constantBuffer, offset) {
    constantBuffer.set(this.value, offset);
};

/**
 * Updates the constant buffer to the current value
 * @prototype
 */
Tw2MatrixParameter.prototype.OnValueChanged = function () {
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2MatrixParameter.is = function (value) {
    return _math.util.isArrayLike(value) && value.length === 16;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2PostProcess = Tw2PostProcess;

var _Tw2Device = __webpack_require__(2);

var _Tw2RenderTarget = __webpack_require__(38);

var _Tw2Effect = __webpack_require__(20);

var _Tw2TextureParameter = __webpack_require__(17);

var _Tw2Vector4Parameter = __webpack_require__(25);

var _Tw2FloatParameter = __webpack_require__(36);

var _Tw2TextureRes = __webpack_require__(24);

/**
 * Creates a bloom post effect
 * @property {number} width
 * @property {number} height
 * @property {Tw2TextureRes} texture
 * @property {Tw2RenderTarget} quadRT0
 * @property {Tw2RenderTarget} quadRT1
 * @property {Array.<Tw2Effect|Object>} steps
 * @constructor
 */
function Tw2PostProcess() {
    this.width = 0;
    this.height = 0;

    this.texture = null;
    this.quadRT0 = new _Tw2RenderTarget.Tw2RenderTarget();
    this.quadRT1 = new _Tw2RenderTarget.Tw2RenderTarget();

    this.steps = [];
    this.steps[0] = new _Tw2Effect.Tw2Effect();
    this.steps[0] = {
        'effect': new _Tw2Effect.Tw2Effect(),
        'rt': this.quadRT1,
        'inputs': {
            'BlitCurrent': null
        }
    };
    this.steps[0].effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorDownFilter4.fx';
    this.steps[0].effect.Initialize();
    this.steps[0].effect.parameters['BlitCurrent'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitCurrent');
    this.steps[0].effect.parameters['g_texelSize'] = new _Tw2Vector4Parameter.Tw2Vector4Parameter('g_texelSize');

    this.steps[1] = new _Tw2Effect.Tw2Effect();
    this.steps[1] = {
        'effect': new _Tw2Effect.Tw2Effect(),
        'rt': this.quadRT0,
        'inputs': {
            'BlitCurrent': this.quadRT1
        }
    };
    this.steps[1].effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorHighPassFilter.fx';
    this.steps[1].effect.Initialize();
    this.steps[1].effect.parameters['BlitCurrent'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitCurrent');
    this.steps[1].effect.parameters['LuminanceThreshold'] = new _Tw2FloatParameter.Tw2FloatParameter('LuminanceThreshold', 0.85);
    this.steps[1].effect.parameters['LuminanceScale'] = new _Tw2FloatParameter.Tw2FloatParameter('LuminanceScale', 2);

    this.steps[2] = new _Tw2Effect.Tw2Effect();
    this.steps[2] = {
        'effect': new _Tw2Effect.Tw2Effect(),
        'rt': this.quadRT1,
        'inputs': {
            'BlitCurrent': this.quadRT0
        }
    };
    this.steps[2].effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorExpBlurHorizontalBig.fx';
    this.steps[2].effect.Initialize();
    this.steps[2].effect.parameters['BlitCurrent'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitCurrent');
    this.steps[2].effect.parameters['g_texelSize'] = new _Tw2Vector4Parameter.Tw2Vector4Parameter('g_texelSize');

    this.steps[3] = new _Tw2Effect.Tw2Effect();
    this.steps[3] = {
        'effect': new _Tw2Effect.Tw2Effect(),
        'rt': this.quadRT0,
        'inputs': {
            'BlitCurrent': this.quadRT1
        }
    };
    this.steps[3].effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorExpBlurVerticalBig.fx';
    this.steps[3].effect.Initialize();
    this.steps[3].effect.parameters['BlitCurrent'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitCurrent');
    this.steps[3].effect.parameters['g_texelSize'] = new _Tw2Vector4Parameter.Tw2Vector4Parameter('g_texelSize');

    this.steps[4] = new _Tw2Effect.Tw2Effect();
    this.steps[4] = {
        'effect': new _Tw2Effect.Tw2Effect(),
        'rt': null,
        'inputs': {
            'BlitCurrent': this.quadRT0,
            'BlitOriginal': null
        }
    };
    this.steps[4].effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorUpFilter4_Add.fx';
    this.steps[4].effect.Initialize();
    this.steps[4].effect.parameters['BlitCurrent'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitCurrent');
    this.steps[4].effect.parameters['BlitOriginal'] = new _Tw2TextureParameter.Tw2TextureParameter('BlitOriginal');
    this.steps[4].effect.parameters['g_texelSize'] = new _Tw2Vector4Parameter.Tw2Vector4Parameter('g_texelSize');
    this.steps[4].effect.parameters['ScalingFactor'] = new _Tw2FloatParameter.Tw2FloatParameter('ScalingFactor', 1);
}

/**
 * Internal render/update function. It is called every frame.
 * @prototype
 */
Tw2PostProcess.prototype.Render = function () {
    var step, i;

    var width = _Tw2Device.device.viewportWidth;
    var height = _Tw2Device.device.viewportHeight;
    if (width <= 0 || height <= 0) {
        return;
    }
    if (this.texture === null) {
        this.texture = new _Tw2TextureRes.Tw2TextureRes();
        this.texture.Attach(_Tw2Device.device.gl.createTexture());
    }
    if (width !== this.width || height !== this.height) {
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, this.texture.texture);
        _Tw2Device.device.gl.texImage2D(_Tw2Device.device.gl.TEXTURE_2D, 0, _Tw2Device.device.gl.RGBA, width, height, 0, _Tw2Device.device.gl.RGBA, _Tw2Device.device.gl.UNSIGNED_BYTE, null);
        _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, null);

        this.quadRT0.Create(width / 4, height / 4, false);
        this.quadRT1.Create(width / 4, height / 4, false);

        this.width = width;
        this.height = height;

        for (i = 0; i < this.steps.length; ++i) {
            step = this.steps[i];
            for (var name in step.inputs) {
                if (step.inputs.hasOwnProperty(name)) {
                    if (step.inputs[name]) {
                        step.effect.parameters[name].textureRes = step.inputs[name].texture;
                    } else {
                        step.effect.parameters[name].textureRes = this.texture;
                    }
                }
            }
            if ('g_texelSize' in step.effect.parameters && 'BlitCurrent' in step.inputs) {
                var size = step.effect.parameters['g_texelSize'];
                var rt = step.inputs['BlitCurrent'];
                if (rt) {
                    size.value[0] = 1.0 / rt.width;
                    size.value[1] = 1.0 / rt.width;
                } else {
                    size.value[0] = 1.0 / width;
                    size.value[1] = 1.0 / width;
                }
                size.OnValueChanged();
            }
        }
    }
    _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, this.texture.texture);
    _Tw2Device.device.gl.copyTexImage2D(_Tw2Device.device.gl.TEXTURE_2D, 0, _Tw2Device.device.alphaBlendBackBuffer ? _Tw2Device.device.gl.RGBA : _Tw2Device.device.gl.RGB, 0, 0, width, height, 0);
    _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, null);

    _Tw2Device.device.SetStandardStates(_Tw2Device.device.RM_OPAQUE);

    for (i = 0; i < this.steps.length; ++i) {
        step = this.steps[i];
        if (step.rt !== null) {
            step.rt.Set();
        } else {
            _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, null);
            _Tw2Device.device.gl.viewport(0, 0, width, height);
        }
        _Tw2Device.device.RenderFullScreenQuad(step.effect);
    }
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RuntimeInstanceData = Tw2RuntimeInstanceData;

var _Tw2Device = __webpack_require__(2);

var _Tw2VertexDeclaration = __webpack_require__(12);

var _particle = __webpack_require__(39);

/**
 * Tw2RuntimeInstanceData
 * @property {string} name
 * @property {number} count
 * @constructor
 */
function Tw2RuntimeInstanceData() {
    this.name = '';
    this.count = 0;

    var declaration = null;
    var vb = null;
    var vertexStride = 0;
    var count = 0;
    var data = null;
    var dataDirty = true;

    /**
     * GetMaxInstanceCount
     * @returns {number}
     * @method
     */
    this.GetMaxInstanceCount = function () {
        return data ? data.length : 1;
    };

    /**
     * SetElementLayout
     * @param decl
     * @method
     */
    this.SetElementLayout = function (decl) {
        if (vb) {
            _Tw2Device.device.gl.deleteBuffer(vb);
            vb = null;
        }

        vertexStride = 0;
        declaration = new _Tw2VertexDeclaration.Tw2VertexDeclaration();

        for (var i = 0; i < decl.length; ++i) {
            var element = new _particle.Tw2ParticleElementDeclaration();
            element.elementType = decl[i][0];
            element.dimension = decl[i][2];
            element.usageIndex = decl[i][1];

            var d = element.GetDeclaration();
            d.offset = vertexStride * 4;
            declaration.elements.push(d);
            vertexStride += element.dimension;
        }

        declaration.RebuildHash();
    };

    /**
     * SetData
     * @param data_
     * @constructor
     */
    this.SetData = function (data_) {
        if (!declaration) {
            return;
        }
        data = data_;
        count = data.length;
        dataDirty = true;
        this.UpdateData();
    };

    /**
     * SetItemElement
     * @param index
     * @param elementIndex
     * @param value
     * @constructor
     */
    this.SetItemElement = function (index, elementIndex, value) {
        if (declaration.elements[elementIndex].elements > 1) {
            for (var i = 0; i < declaration.elements[elementIndex].elements; ++i) {
                data[index][elementIndex][i] = value[i];
            }
        } else {
            data[index][elementIndex] = value;
        }

        dataDirty = true;
    };

    /**
     * SetItemElementRef
     * @param index
     * @param elementIndex
     * @param value
     * @constructor
     */
    this.SetItemElementRef = function (index, elementIndex, value) {
        data[index][elementIndex] = value;
        dataDirty = true;
    };

    /**
     * GetItemElement
     * @param index
     * @param elementIndex
     * @returns {*}
     * @method
     */
    this.GetItemElement = function (index, elementIndex) {
        return data[index][elementIndex];
    };

    /**
     * UpdateData
     * @method
     */
    this.UpdateData = function () {
        if (!dataDirty || !declaration) {
            return;
        }

        var vbData = new Float32Array(data.length * vertexStride);
        var offset = 0;
        var i, j, k;

        for (i = 0; i < data.length; ++i) {
            for (j = 0; j < declaration.elements.length; ++j) {
                if (declaration.elements[j].elements === 1) {
                    vbData[offset++] = data[i][j];
                } else {
                    for (k = 0; k < declaration.elements[j].elements; ++k) {
                        vbData[offset++] = data[i][j][k];
                    }
                }
            }
        }

        if (!vb) {
            vb = _Tw2Device.device.gl.createBuffer();
        }

        _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ARRAY_BUFFER, vb);
        _Tw2Device.device.gl.bufferData(_Tw2Device.device.gl.ARRAY_BUFFER, vbData, _Tw2Device.device.gl.STATIC_DRAW);
        _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ARRAY_BUFFER, null);
        dataDirty = false;
    };

    /**
     * Unloads the webgl buffer
     * @method
     */
    this.Unload = function () {
        if (vb) {
            _Tw2Device.device.gl.deleteBuffer(vb);
            vb = null;
        }
    };

    /**
     * GetInstanceBuffer
     * @returns {WebglArrayBuffer}
     * @method
     */
    this.GetInstanceBuffer = function () {
        return vb;
    };

    /**
     * GetInstanceDeclaration
     * @returns {Tw2VertexDeclaration}
     * @method
     */
    this.GetInstanceDeclaration = function () {
        return declaration;
    };

    /**
     * GetInstanceStride
     * @returns {number}
     * @method
     */
    this.GetInstanceStride = function () {
        return vertexStride * 4;
    };

    /**
     * GetInstanceCount
     * @returns {number}
     * @method
     */
    this.GetInstanceCount = function () {
        return count;
    };
}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2StaticEmitter = __webpack_require__(79);

Object.keys(_Tw2StaticEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2StaticEmitter[key];
    }
  });
});

var _Tw2DynamicEmitter = __webpack_require__(80);

Object.keys(_Tw2DynamicEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2DynamicEmitter[key];
    }
  });
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2StaticEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _Tw2ParticleEmitter2 = __webpack_require__(40);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2StaticEmitter
 *
 * @property {string} name
 * @property {null|Tw2ParticleSystem} particleSystem
 * @property {string} geometryResourcePath
 * @property {Tw2GeometryRes} geometryResource
 * @property {Number} geometryIndex
 * @property {Boolean} _spawned
 * @inherits Tw2ParticleEmitter
 * @class
 */
var Tw2StaticEmitter = exports.Tw2StaticEmitter = function (_Tw2ParticleEmitter) {
    _inherits(Tw2StaticEmitter, _Tw2ParticleEmitter);

    function Tw2StaticEmitter() {
        _classCallCheck(this, Tw2StaticEmitter);

        var _this = _possibleConstructorReturn(this, (Tw2StaticEmitter.__proto__ || Object.getPrototypeOf(Tw2StaticEmitter)).call(this));

        _this.particleSystem = null;
        _this.geometryResourcePath = '';
        _this.geometryResource = null;
        _this.geometryIndex = 0;
        _this._spawned = false;
        return _this;
    }

    /**
     * Initializes the particle emitter
     */


    _createClass(Tw2StaticEmitter, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.geometryResourcePath !== '') {
                this.geometryResource = _core.resMan.GetResource(this.geometryResourcePath);
                this.geometryResource.systemMirror = true;
                this.geometryResource.RegisterNotification(this);
            }
            this._spawned = false;
        }

        /**
         * Rebuilds cached data
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData() {
            if (this.geometryResource && this.geometryResource.meshes.length) {
                if (!this.geometryResource.meshes[0].bufferData) {
                    this.geometryResource.systemMirror = true;
                    this.geometryResource.Reload();
                }
            }
        }

        /**
         * Per frame update
         */

    }, {
        key: 'Update',
        value: function Update() {
            if (!this._spawned && this.particleSystem && this.geometryResource && this.geometryResource.IsGood() && this.geometryResource.meshes.length > this.geometryIndex && this.geometryResource.meshes[this.geometryIndex].bufferData) {
                this._spawned = true;

                var mesh = this.geometryResource.meshes[this.geometryIndex],
                    elts = this.particleSystem.elements,
                    inputs = new Array(elts.length);

                for (var i = 0; i < elts.length; ++i) {
                    var d = elts[i].GetDeclaration(),
                        input = mesh.declaration.FindUsage(d.usage, d.usageIndex - 8);

                    if (input === null) {
                        _core.emitter.log('res.error', {
                            log: 'error',
                            src: ['Tw2StaticEmitter', 'Update'],
                            msg: 'Input geometry mesh lacks element required by particle system',
                            path: this.geometryResource.path,
                            type: 'geometry.elements',
                            data: {
                                elementUsage: d.usage,
                                elementUsageIndex: d.usageIndex
                            }
                        });
                        return;
                    }

                    if (input.elements < d.elements) {
                        _core.emitter.log('res.error', {
                            log: 'error',
                            src: ['Tw2StaticEmitter', 'Update'],
                            msg: 'Input geometry mesh elements do not have the required number of components',
                            path: this.geometryResource.path,
                            type: 'geometry.elementcomponents',
                            data: {
                                inputCount: input.elements,
                                elementCount: d.elements,
                                elementUsage: d.usage,
                                elementUsageIndex: d.usageIndex
                            }
                        });
                        return;
                    }

                    inputs[i] = input.offset / 4;
                }

                var vertexCount = mesh.bufferData.length / mesh.declaration.stride * 4;
                for (var _i = 0; _i < vertexCount; ++_i) {
                    var index = this.particleSystem.BeginSpawnParticle();
                    if (index === null) break;

                    for (var j = 0; j < this.particleSystem._elements.length; ++j) {
                        var e = this.particleSystem._elements[j];
                        for (var k = 0; k < e.dimension; ++k) {
                            e.buffer[e.instanceStride * index + e.startOffset + k] = mesh.bufferData[inputs[j] + k + _i * mesh.declaration.stride / 4];
                        }
                    }
                    this.particleSystem.EndSpawnParticle();
                }
            }
        }
    }]);

    return Tw2StaticEmitter;
}(_Tw2ParticleEmitter2.Tw2ParticleEmitter);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2DynamicEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ParticleEmitter2 = __webpack_require__(40);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2DynamicEmitter
 *
 * @property {string} name
 * @property {number} rate
 * @property {boolean} isValid
 * @property {null|Tw2ParticleSystem} particleSystem
 * @property {number} _accumulatedRate
 * @property {Array<Tw2ParticleAttributeGenerator>}} generators
 * @inherits Tw2ParticleEmitter
 * @class
 */
var Tw2DynamicEmitter = exports.Tw2DynamicEmitter = function (_Tw2ParticleEmitter) {
    _inherits(Tw2DynamicEmitter, _Tw2ParticleEmitter);

    function Tw2DynamicEmitter() {
        _classCallCheck(this, Tw2DynamicEmitter);

        var _this = _possibleConstructorReturn(this, (Tw2DynamicEmitter.__proto__ || Object.getPrototypeOf(Tw2DynamicEmitter)).call(this));

        _this.rate = 0;
        _this.isValid = false;
        _this._accumulatedRate = 0;
        _this.generators = [];
        return _this;
    }

    /**
     * Initializes the particle emitter
     */


    _createClass(Tw2DynamicEmitter, [{
        key: 'Initialize',
        value: function Initialize() {
            this.Rebind();
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this.SpawnParticles(null, null, Math.min(dt, 0.1));
        }

        /**
         * Rebinds the emitter's generators to it's particle system
         */

    }, {
        key: 'Rebind',
        value: function Rebind() {
            this.isValid = false;
            if (!this.particleSystem) return;

            for (var i = 0; i < this.generators.length; ++i) {
                if (!this.generators[i].Bind(this.particleSystem)) return;
            }

            this.isValid = true;
        }

        /**
         * Spawn particles
         * @param position
         * @param velocity
         * @param rateModifier
         */

    }, {
        key: 'SpawnParticles',
        value: function SpawnParticles(position, velocity, rateModifier) {
            if (!this.isValid) return;

            this._accumulatedRate += this.rate * rateModifier;
            var count = Math.floor(this._accumulatedRate);
            this._accumulatedRate -= count;

            for (var i = 0; i < count; ++i) {
                var index = this.particleSystem.BeginSpawnParticle();
                if (index === null) break;

                for (var j = 0; j < this.generators.length; ++j) {
                    this.generators[j].Generate(position, velocity, index);
                }

                this.particleSystem.EndSpawnParticle();
            }
        }
    }]);

    return Tw2DynamicEmitter;
}(_Tw2ParticleEmitter2.Tw2ParticleEmitter);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2ParticleAttractorForce = __webpack_require__(82);

Object.keys(_Tw2ParticleAttractorForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleAttractorForce[key];
    }
  });
});

var _Tw2ParticleDirectForce = __webpack_require__(83);

Object.keys(_Tw2ParticleDirectForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleDirectForce[key];
    }
  });
});

var _Tw2ParticleDragForce = __webpack_require__(84);

Object.keys(_Tw2ParticleDragForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleDragForce[key];
    }
  });
});

var _Tw2ParticleFluidDragForce = __webpack_require__(85);

Object.keys(_Tw2ParticleFluidDragForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleFluidDragForce[key];
    }
  });
});

var _Tw2ParticleSpring = __webpack_require__(86);

Object.keys(_Tw2ParticleSpring).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleSpring[key];
    }
  });
});

var _Tw2ParticleTurbulenceForce = __webpack_require__(87);

Object.keys(_Tw2ParticleTurbulenceForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleTurbulenceForce[key];
    }
  });
});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleAttractorForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleAttractorForce
 *
 * @property {number} magnitude
 * @property {vec3} position
 * @property {vec3} _tempVec
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleAttractorForce = exports.Tw2ParticleAttractorForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleAttractorForce, _Tw2ParticleForce);

    function Tw2ParticleAttractorForce() {
        _classCallCheck(this, Tw2ParticleAttractorForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleAttractorForce.__proto__ || Object.getPrototypeOf(Tw2ParticleAttractorForce)).call(this));

        _this.magnitude = 0;
        _this.position = _math.vec3.create();
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleAttractorForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            var vec3_0 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_0;

            vec3_0[0] = this.position[0] - position.buffer[position.offset];
            vec3_0[1] = this.position[1] - position.buffer[position.offset + 1];
            vec3_0[2] = this.position[2] - position.buffer[position.offset + 2];

            _math.vec3.normalize(vec3_0, vec3_0);
            _math.vec3.scale(vec3_0, vec3_0, this.magnitude);
            _math.vec3.add(force, force, vec3_0);
        }
    }]);

    return Tw2ParticleAttractorForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleDirectForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleDirectForce
 *
 * @property {vec3} force
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleDirectForce = exports.Tw2ParticleDirectForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleDirectForce, _Tw2ParticleForce);

    function Tw2ParticleDirectForce() {
        _classCallCheck(this, Tw2ParticleDirectForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleDirectForce.__proto__ || Object.getPrototypeOf(Tw2ParticleDirectForce)).call(this));

        _this.force = _math.vec3.create();
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleDirectForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            _math.vec3.add(force, force, this.force);
        }
    }]);

    return Tw2ParticleDirectForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleDragForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleDragForce
 *
 * @property {number} drag
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleDragForce = exports.Tw2ParticleDragForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleDragForce, _Tw2ParticleForce);

    function Tw2ParticleDragForce() {
        _classCallCheck(this, Tw2ParticleDragForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleDragForce.__proto__ || Object.getPrototypeOf(Tw2ParticleDragForce)).call(this));

        _this.drag = 0.1;
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleDragForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            force[0] += velocity.buffer[velocity.offset] * -this.drag;
            force[1] += velocity.buffer[velocity.offset + 1] * -this.drag;
            force[2] += velocity.buffer[velocity.offset + 2] * -this.drag;
        }
    }]);

    return Tw2ParticleDragForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleFluidDragForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleFluidDragForce
 *
 * @property {number} drag
 * @property {vec3} _tempVec
 * @property {vec3} _tempVec2
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleFluidDragForce = exports.Tw2ParticleFluidDragForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleFluidDragForce, _Tw2ParticleForce);

    function Tw2ParticleFluidDragForce() {
        _classCallCheck(this, Tw2ParticleFluidDragForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleFluidDragForce.__proto__ || Object.getPrototypeOf(Tw2ParticleFluidDragForce)).call(this));

        _this.drag = 0.1;
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     * @param {number} dt - delta time
     * @param { number} mass
     */


    _createClass(Tw2ParticleFluidDragForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force, dt, mass) {
            var vec3_0 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_0,
                vec3_1 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_1,
                speed = Math.sqrt(velocity.buffer[velocity.offset] * velocity.buffer[velocity.offset] + velocity.buffer[velocity.offset + 1] * velocity.buffer[velocity.offset + 1] + velocity.buffer[velocity.offset + 2] * velocity.buffer[velocity.offset + 2]);

            vec3_0[0] = velocity.buffer[velocity.offset] * -speed * this.drag;
            vec3_0[1] = velocity.buffer[velocity.offset + 1] * -speed * this.drag;
            vec3_0[2] = velocity.buffer[velocity.offset + 2] * -speed * this.drag;

            _math.vec3.scale(vec3_1, vec3_0, dt * mass);
            vec3_1[0] += velocity.buffer[velocity.offset];
            vec3_1[1] += velocity.buffer[velocity.offset + 1];
            vec3_1[2] += velocity.buffer[velocity.offset + 2];

            var dot = velocity.buffer[velocity.offset] * vec3_1[0] + velocity.buffer[velocity.offset + 1] * vec3_1[1] + velocity.buffer[velocity.offset + 2] * vec3_1[2];

            if (dot < 0) {
                force[0] = -velocity.buffer[velocity.offset] / dt / mass;
                force[1] = -velocity.buffer[velocity.offset + 1] / dt / mass;
                force[2] = -velocity.buffer[velocity.offset + 2] / dt / mass;
            } else {
                _math.vec3.copy(force, vec3_0);
            }
        }
    }]);

    return Tw2ParticleFluidDragForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleSpring = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleSpring
 *
 * @property {number} springConstant
 * @property {vec3} position
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleSpring = exports.Tw2ParticleSpring = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleSpring, _Tw2ParticleForce);

    function Tw2ParticleSpring() {
        _classCallCheck(this, Tw2ParticleSpring);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleSpring.__proto__ || Object.getPrototypeOf(Tw2ParticleSpring)).call(this));

        _this.springConstant = 0;
        _this.position = _math.vec3.create();
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleSpring, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            force[0] += (this.position[0] - position.buffer[position.offset]) * this.springConstant;
            force[1] += (this.position[1] - position.buffer[position.offset + 1]) * this.springConstant;
            force[2] += (this.position[2] - position.buffer[position.offset + 2]) * this.springConstant;
        }
    }]);

    return Tw2ParticleSpring;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleTurbulenceForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleTurbulenceForce
 *
 * @property {number} noiseLevel
 * @property {number} noiseRatio
 * @property {vec3} amplitude
 * @property {quat} frequency
 * @property {number} _time
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleTurbulenceForce = exports.Tw2ParticleTurbulenceForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleTurbulenceForce, _Tw2ParticleForce);

    function Tw2ParticleTurbulenceForce() {
        _classCallCheck(this, Tw2ParticleTurbulenceForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleTurbulenceForce.__proto__ || Object.getPrototypeOf(Tw2ParticleTurbulenceForce)).call(this));

        _this.noiseLevel = 3;
        _this.noiseRatio = 0.5;
        _this.amplitude = _math.vec3.fromValues(1, 1, 1);
        _this.frequency = _math.vec4.fromValues(1, 1, 1, 1);
        _this._time = 0;
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleTurbulenceForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            if (this.noiseLevel === 0) return;

            var pos_0 = position.buffer[position.offset] * this.frequency[0],
                pos_1 = position.buffer[position.offset + 1] * this.frequency[1],
                pos_2 = position.buffer[position.offset + 2] * this.frequency[2],
                pos_3 = this._time * this.frequency[3];

            var sum = 0,
                power = 0.5,
                frequency = 1 / this.noiseRatio;

            var out = _math.vec4.set(_Tw2ParticleForce2.Tw2ParticleForce.global.vec4_0, 0, 0, 0, 0);

            for (var i = 0; i < this.noiseLevel; ++i) {
                _math.noise.turbulence(out, pos_0, pos_1, pos_2, pos_3, power);
                sum += power;
                pos_0 *= frequency;
                pos_1 *= frequency;
                pos_2 *= frequency;
                pos_3 *= frequency;
                power *= this.noiseRatio;
            }

            force[0] += out[0] * this.amplitude[0] * sum;
            force[1] += out[1] * this.amplitude[1] * sum;
            force[2] += out[2] * this.amplitude[2] * sum;
        }

        /**
         * Per frame update (Called before ApplyForce)
         * @param {number} dt - delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this._time += dt;
        }
    }]);

    return Tw2ParticleTurbulenceForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2RandomIntegerAttributeGenerator = __webpack_require__(89);

Object.keys(_Tw2RandomIntegerAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomIntegerAttributeGenerator[key];
    }
  });
});

var _Tw2RandomUniformAttributeGenerator = __webpack_require__(90);

Object.keys(_Tw2RandomUniformAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomUniformAttributeGenerator[key];
    }
  });
});

var _Tw2SphereShapeAttributeGenerator = __webpack_require__(91);

Object.keys(_Tw2SphereShapeAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SphereShapeAttributeGenerator[key];
    }
  });
});

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RandomIntegerAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(13);

var _Tw2ParticleAttributeGenerator = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomIntegerAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */
var Tw2RandomIntegerAttributeGenerator = exports.Tw2RandomIntegerAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2RandomIntegerAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2RandomIntegerAttributeGenerator() {
        _classCallCheck(this, Tw2RandomIntegerAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2RandomIntegerAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2RandomIntegerAttributeGenerator)).call(this));

        _this.elementType = _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM;
        _this.customName = '';
        _this.minRange = _math.vec4.create();
        _this.maxRange = _math.vec4.create();
        _this._element = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2RandomIntegerAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === this.elementType && (this.elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM || ps._elements[i].customName === this.customName)) {
                    this._element = ps._elements[i];
                    return true;
                }
            }
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            for (var i = 0; i < this._element.dimension; ++i) {
                this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = Math.floor(this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]) + 0.5);
            }
        }
    }]);

    return Tw2RandomIntegerAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RandomUniformAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(13);

var _Tw2ParticleAttributeGenerator = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomUniformAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */
var Tw2RandomUniformAttributeGenerator = exports.Tw2RandomUniformAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2RandomUniformAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2RandomUniformAttributeGenerator() {
        _classCallCheck(this, Tw2RandomUniformAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2RandomUniformAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2RandomUniformAttributeGenerator)).call(this));

        _this.elementType = _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM;
        _this.customName = '';
        _this.minRange = _math.vec4.create();
        _this.maxRange = _math.vec4.create();
        _this._element = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2RandomUniformAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === this.elementType && (this.elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM || ps._elements[i].customName === this.customName)) {
                    this._element = ps._elements[i];
                    return true;
                }
            }
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            for (var i = 0; i < this._element.dimension; ++i) {
                this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]);
            }
        }
    }]);

    return Tw2RandomUniformAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2SphereShapeAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(13);

var _Tw2ParticleAttributeGenerator = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2SphereShapeAttributeGenerator
 *
 * @property {number} minRadius
 * @property {number} maxRadius
 * @property {number} minPhi
 * @property {number} maxPhi
 * @property {number} minTheta
 * @property {number} maxTheta
 * @property {boolean} controlPosition
 * @property {boolean} controlVelocity
 * @property {number} minSpeed
 * @property {number} maxSpeed
 * @property {number} parentVelocityFactor
 * @property {vec3} position
 * @property {quat} rotation
 * @property {?Tw2ParticleElement} _position
 * @property {?Tw2ParticleElement}_velocity
 * @inherits Tw2ParticleAttributeGenerator
 */
var Tw2SphereShapeAttributeGenerator = exports.Tw2SphereShapeAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2SphereShapeAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2SphereShapeAttributeGenerator() {
        _classCallCheck(this, Tw2SphereShapeAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2SphereShapeAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2SphereShapeAttributeGenerator)).call(this));

        _this.minRadius = 0;
        _this.maxRadius = 0;
        _this.minPhi = 0;
        _this.maxPhi = 360;
        _this.minTheta = 0;
        _this.maxTheta = 360;
        _this.controlPosition = true;
        _this.controlVelocity = true;
        _this.minSpeed = 0;
        _this.maxSpeed = 0;
        _this.parentVelocityFactor = 1;
        _this.position = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this._position = null;
        _this._velocity = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2SphereShapeAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            this._position = null;
            this._velocity = null;

            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION && this.controlPosition) {
                    this._position = ps._elements[i];
                } else if (ps._elements[i].elementType === _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY && this.controlVelocity) {
                    this._velocity = ps._elements[i];
                }
            }
            return (!this.controlPosition || this._position !== null) && (!this.controlVelocity || this._velocity !== null);
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            var phi = (this.minPhi + Math.random() * (this.maxPhi - this.minPhi)) / 180 * Math.PI,
                theta = (this.minTheta + Math.random() * (this.maxTheta - this.minTheta)) / 180 * Math.PI,
                rv = _Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator.global.vec3_0;

            rv[0] = Math.sin(phi) * Math.cos(theta);
            rv[1] = -Math.cos(phi);
            rv[2] = Math.sin(phi) * Math.sin(theta);
            _math.vec3.transformQuat(rv, rv, this.rotation);

            if (this._velocity) {
                var speed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed),
                    offset = this._velocity.instanceStride * index + this._velocity.startOffset;

                this._velocity.buffer[offset] = rv[0] * speed;
                this._velocity.buffer[offset + 1] = rv[1] * speed;
                this._velocity.buffer[offset + 2] = rv[2] * speed;

                if (velocity) {
                    this._velocity.buffer[offset] += velocity.buffer[velocity.offset] * this.parentVelocityFactor;
                    this._velocity.buffer[offset + 1] += velocity.buffer[velocity.offset + 1] * this.parentVelocityFactor;
                    this._velocity.buffer[offset + 2] += velocity.buffer[velocity.offset + 2] * this.parentVelocityFactor;
                }
            }

            if (this._position) {
                _math.vec3.scale(rv, rv, this.minRadius + Math.random() * (this.maxRadius - this.minRadius));
                _math.vec3.add(rv, rv, this.position);

                if (position) {
                    rv[0] += position.buffer[position.offset];
                    rv[1] += position.buffer[position.offset + 1];
                    rv[2] += position.buffer[position.offset + 2];
                }

                var _offset = this._position.instanceStride * index + this._position.startOffset;
                this._position.buffer[_offset] = rv[0];
                this._position.buffer[_offset + 1] = rv[1];
                this._position.buffer[_offset + 2] = rv[2];
            }
        }
    }]);

    return Tw2SphereShapeAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleSystem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _Tw2ParticleElement = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleSystem
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {number} aliveCount
 * @property {number} maxParticleCount
 * @property {*} emitParticleOnDeathEmitter
 * @property {*} emitParticleDuringLifeEmitter
 * @property {Array.<Tw2ParticleElement>} elements
 * @property {boolean} isValid
 * @property {boolean} requiresSorting
 * @property {boolean} updateSimulation
 * @property {boolean} applyForce
 * @property {boolean} applyAging
 * @property {boolean} isGlobal
 * @property {Array<Tw2ParticleForce>} forces
 * @property {Array<Tw2ParticleConstraint>} constraints
 * @property {boolean} updateBoundingBox
 * @property {vec3} aabbMin
 * @property {vec3} aabbMax
 * @property {number} peakAliveCount
 * @property {boolean} bufferDirty
 * @property {WebGLBuffer} _vb
 * @property {Tw2VertexDeclaration} _declaration
 * @property {Array<Tw2ParticleElement>} _stdElements
 * @property {Array<Tw2ParticleElement>} _elements
 * @property {Array} instanceStride
 * @property {Array} vertexStride
 * @property {Array} buffers
 * @class
 */
var Tw2ParticleSystem = exports.Tw2ParticleSystem = function () {
    function Tw2ParticleSystem() {
        _classCallCheck(this, Tw2ParticleSystem);

        this._id = _math.util.generateID();
        this.name = '';
        this.aliveCount = 0;
        this.maxParticleCount = 0;
        this.emitParticleOnDeathEmitter = null;
        this.emitParticleDuringLifeEmitter = null;
        this.elements = [];
        this.isValid = false;
        this.requiresSorting = false;
        this.updateSimulation = true;
        this.applyForce = true;
        this.applyAging = true;
        this.isGlobal = false;
        this.forces = [];
        this.constraints = [];
        this.updateBoundingBox = false;
        this.aabbMin = _math.vec3.create();
        this.aabbMax = _math.vec3.create();
        this.peakAliveCount = 0;
        this.bufferDirty = false;
        this._vb = null;
        this._declaration = null;
        this._stdElements = [null, null, null, null];
        this._elements = [];
        this.instanceStride = [null, null];
        this.vertexStride = [null, null];
        this.buffers = [null, null];

        Tw2ParticleSystem.init();
    }

    /**
     * Initializes the Particle System
     */


    _createClass(Tw2ParticleSystem, [{
        key: 'Initialize',
        value: function Initialize() {
            this.UpdateElementDeclaration();
        }

        /**
         * Updates Element Declarations
         */

    }, {
        key: 'UpdateElementDeclaration',
        value: function UpdateElementDeclaration() {
            this.isValid = false;

            if (this._vb) {
                _core.device.gl.deleteBuffer(this._vb);
                this._vb = null;
            }

            this._declaration = null;
            this.aliveCount = 0;

            if (this.elements.length === 0) return;

            this._stdElements = [null, null, null, null];
            this._elements = [];
            this.instanceStride = [0, 0];
            this.vertexStride = [0, 0];
            this._declaration = new _core.Tw2VertexDeclaration();
            this.buffers = [null, null];

            for (var i = 0; i < this.elements.length; ++i) {
                var bufferIndex = this.elements[i].usedByGPU ? 0 : 1,
                    el = new _Tw2ParticleElement.Tw2ParticleElement(this.elements[i]);
                //el.buffer = this.buffers[bufferIndex];

                el.startOffset = this.vertexStride[bufferIndex];
                el.offset = el.startOffset;
                if (this.elements[i].elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM) {
                    this._stdElements[this.elements[i].elementType] = el;
                }
                this.vertexStride[bufferIndex] += el.dimension;
                this._elements.push(el);
                if (bufferIndex === 0) {
                    var d = this.elements[i].GetDeclaration();
                    d.offset = el.startOffset * 4;
                    this._declaration.elements.push(d);
                }
            }

            this._declaration.RebuildHash();

            for (var _i = 0; _i < this._elements.length; ++_i) {
                var _bufferIndex = this._elements[_i].usedByGPU ? 0 : 1;
                this._elements[_i].vertexStride = this.vertexStride[_bufferIndex];
            }

            this.instanceStride[0] = this.vertexStride[0] * 4;
            this.instanceStride[1] = this.vertexStride[1] * 4;

            for (var _i2 = 0; _i2 < this._elements.length; ++_i2) {
                var _bufferIndex2 = this._elements[_i2].usedByGPU ? 0 : 1;
                this._elements[_i2].instanceStride = this.instanceStride[_bufferIndex2];
            }

            this.buffers = [null, null];
            if (this.instanceStride[0] && this.maxParticleCount) {
                this.buffers[0] = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
                this._vb = _core.device.gl.createBuffer();
                _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vb);
                _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, this.buffers[0].length, _core.device.gl.DYNAMIC_DRAW);
                _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);
            }

            if (this.instanceStride[1]) {
                this.buffers[1] = new Float32Array(this.instanceStride[1] * this.maxParticleCount);
            }

            for (var _i3 = 0; _i3 < this._elements.length; ++_i3) {
                var _bufferIndex3 = this._elements[_i3].usedByGPU ? 0 : 1;
                this._elements[_i3].buffer = this.buffers[_bufferIndex3];
            }

            if (this.requiresSorting) {
                this._sortedIndexes = new Array(this.maxParticleCount);
                this._sortedBuffer = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
                this._distancesBuffer = new Float32Array(this.maxParticleCount);
            }

            this.isValid = true;
            this.bufferDirty = true;
        }

        /**
         * Checks if an element type exists
         * @param {number} type
         * @returns {boolean}
         */

    }, {
        key: 'HasElement',
        value: function HasElement(type) {
            return this._stdElements[type] !== null;
        }

        /**
         * Gets an element by it's type
         * @param {number} type
         * @returns {Tw2ParticleElement}
         */

    }, {
        key: 'GetElement',
        value: function GetElement(type) {
            if (this._stdElements[type]) {
                this._stdElements[type].offset = this._stdElements[type].startOffset;
            }
            return this._stdElements[type];
        }

        /**
         * Begins particle spawning
         * @returns {?number}
         */

    }, {
        key: 'BeginSpawnParticle',
        value: function BeginSpawnParticle() {
            if (!this.isValid || this.aliveCount >= this.maxParticleCount) return null;
            return this.aliveCount++;
        }

        /**
         * Ends particle spawning
         */

    }, {
        key: 'EndSpawnParticle',
        value: function EndSpawnParticle() {
            this.bufferDirty = true;
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            dt = Math.min(dt, 0.1);

            if (this.applyAging && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.LIFETIME)) {
                var lifetime = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.LIFETIME),
                    position = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) : null,
                    velocity = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY) : null;

                for (var i = 0; i < this.aliveCount; ++i) {
                    lifetime.buffer[lifetime.offset] += dt / lifetime.buffer[lifetime.offset + 1];
                    if (lifetime.buffer[lifetime.offset] > 1) {
                        if (this.emitParticleOnDeathEmitter) {
                            this.emitParticleOnDeathEmitter.SpawnParticles(position, velocity, 1);
                        }

                        this.aliveCount--;
                        if (i < this.aliveCount) {
                            for (var j = 0; j < 2; ++j) {
                                if (this.buffers[j]) {
                                    this.buffers[j].set(this.buffers[j].subarray(this.instanceStride[j] * this.aliveCount, this.instanceStride[j] * this.aliveCount + this.instanceStride[j]), i * this.instanceStride[j]);
                                }
                            }
                            --i;
                            this.bufferDirty = true;
                        }
                    } else {
                        lifetime.offset += lifetime.instanceStride;
                        if (position) position.offset += position.instanceStride;
                        if (velocity) velocity.offset += velocity.instanceStride;
                    }
                }
                lifetime.dirty = true;
            }

            var vec3_0 = Tw2ParticleSystem.global.vec3_0;

            if (this.updateSimulation && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY)) {
                var hasForces = this.applyForce && this.forces.length;
                for (var _i4 = 0; _i4 < this.forces.length; ++_i4) {
                    this.forces[_i4].Update(dt);
                }

                var _position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                    _velocity = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY),
                    mass = hasForces ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.MASS) : null;

                for (var _i5 = 0; _i5 < this.aliveCount; ++_i5) {
                    if (hasForces) {
                        var amass = mass ? mass.buffer[mass.offset] : 1,
                            force = _math.vec3.set(vec3_0, 0, 0, 0);

                        for (var _j = 0; _j < this.forces.length; ++_j) {
                            this.forces[_j].ApplyForce(_position, _velocity, force, dt, amass);
                        }

                        if (mass) _math.vec3.scale(force, force, 1 / mass.buffer[mass.offset]);

                        _velocity.buffer[_velocity.offset] += force[0] * dt;
                        _velocity.buffer[_velocity.offset + 1] += force[1] * dt;
                        _velocity.buffer[_velocity.offset + 2] += force[2] * dt;
                    }

                    _position.buffer[_position.offset] += _velocity.buffer[_velocity.offset] * dt;
                    _position.buffer[_position.offset + 1] += _velocity.buffer[_velocity.offset + 1] * dt;
                    _position.buffer[_position.offset + 2] += _velocity.buffer[_velocity.offset + 2] * dt;

                    if (this.emitParticleDuringLifeEmitter) {
                        this.emitParticleDuringLifeEmitter.SpawnParticles(_position, _velocity, dt);
                    }

                    _position.offset += _position.instanceStride;
                    _velocity.offset += _velocity.instanceStride;

                    if (mass) mass.offset += mass.instanceStride;
                }
                _position.dirty = true;
                _velocity.dirty = true;
            }

            if (this.updateSimulation && this.constraints.length) {
                for (var _i6 = 0; _i6 < this.constraints.length; ++_i6) {
                    this.constraints[_i6].ApplyConstraint(this.buffers, this.instanceStride, this.aliveCount, dt);
                }
            }

            if (this.updateBoundingBox) {
                this.GetBoundingBox(this.aabbMin, this.aabbMax);
            }

            if (this.emitParticleDuringLifeEmitter && !(this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY)) && this.updateSimulation) {
                var _position2 = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                    _velocity2 = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY);

                for (var _i7 = 0; _i7 < this.aliveCount; ++_i7) {
                    this.emitParticleDuringLifeEmitter.SpawnParticles(_position2, _velocity2, 1);
                    if (_position2) _position2.offset += _position2.instanceStride;
                    if (_velocity2) _velocity2.offset += _velocity2.instanceStride;
                }
            }

            for (var _i8 = 0; _i8 < this._elements.length; ++_i8) {
                var el = this._elements[_i8];
                el.offset = el.startOffset;
                if (el.dirty) {
                    this.bufferDirty = true;
                    el.dirty = false;
                }
            }
        }

        /**
         * Gets bounding box
         * @param {vec3} aabbMin
         * @param {vec3} aabbMax
         * @returns {boolean}
         */

    }, {
        key: 'GetBoundingBox',
        value: function GetBoundingBox(aabbMin, aabbMax) {
            if (this.aliveCount && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION)) {
                var position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION);
                aabbMin[0] = position.buffer[position.offset];
                aabbMin[1] = position.buffer[position.offset + 1];
                aabbMin[2] = position.buffer[position.offset + 2];
                aabbMax[0] = position.buffer[position.offset];
                aabbMax[1] = position.buffer[position.offset + 1];
                aabbMax[2] = position.buffer[position.offset + 2];
                for (var i = 0; i < this.aliveCount; ++i) {
                    aabbMin[0] = Math.min(aabbMin[0], position.buffer[position.offset]);
                    aabbMin[1] = Math.min(aabbMin[1], position.buffer[position.offset + 1]);
                    aabbMin[2] = Math.min(aabbMin[2], position.buffer[position.offset + 2]);
                    aabbMax[0] = Math.max(aabbMax[0], position.buffer[position.offset]);
                    aabbMax[1] = Math.max(aabbMax[1], position.buffer[position.offset + 1]);
                    aabbMax[2] = Math.max(aabbMax[2], position.buffer[position.offset + 2]);
                    position.offset += position.instanceStride;
                }
                return true;
            }
            return false;
        }

        /**
         * _Sort
         * @private
         */

    }, {
        key: '_Sort',
        value: function _Sort() {
            var eye = _math.mat4.multiply(Tw2ParticleSystem.global.mat4_0, _core.device.projection, _core.device.view),
                //device.viewInverse;
            position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                count = this.aliveCount,
                distances = this._distancesBuffer;

            for (var i = 0; i < count; ++i) {
                var o0 = position.offset + position.instanceStride * i;
                var dd = position.buffer[o0] - eye[12],
                    l0 = dd * dd;

                dd = position.buffer[o0 + 1] - eye[13];
                l0 += dd * dd;
                dd = position.buffer[o0 + 2] - eye[14];
                l0 += dd * dd;
                distances[i] = l0;
            }

            /**
             * sortItems
             * @param a
             * @param b
             * @returns {number}
             * @private
             */
            function sortItems(a, b) {
                if (a >= count && b >= count) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                }

                if (a >= count) return 1;
                if (b >= count) return -1;

                var l0 = distances[a],
                    l1 = distances[b];

                if (l0 < l1) return 1;
                if (l0 > l1) return -1;
                return 0;
            }

            for (var _i9 = 0; _i9 < this.maxParticleCount; ++_i9) {
                this._sortedIndexes[_i9] = _i9;
            }

            this._sortedIndexes.sort(sortItems);
        }

        /**
         * Updates and gets the particle system's InstanceBuffer
         * @returns {?WebGLBuffer}
         */

    }, {
        key: 'GetInstanceBuffer',
        value: function GetInstanceBuffer() {
            if (this.aliveCount === 0) return undefined;

            var d = _core.device;
            if (this.requiresSorting && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.buffers) {
                this._Sort();

                var stride = this.instanceStride[0],
                    gpuBuffer = this.buffers[0];

                for (var i = 0; i < this.aliveCount; ++i) {
                    var toOffset = i * stride,
                        fromOffset = this._sortedIndexes[i] * stride;

                    for (var j = 0; j < stride; ++j) {
                        this._sortedBuffer[toOffset + j] = gpuBuffer[j + fromOffset];
                    }
                }

                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vb);
                d.gl.bufferSubData(d.gl.ARRAY_BUFFER, 0, this._sortedBuffer.subarray(0, this.vertexStride[0] * this.aliveCount));
                this.bufferDirty = false;
            } else if (this.bufferDirty) {
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vb);
                d.gl.bufferSubData(d.gl.ARRAY_BUFFER, 0, this.buffers[0].subarray(0, this.vertexStride[0] * this.aliveCount));
                this.bufferDirty = false;
            }

            return this._vb;
        }

        /**
         * Gets the particle system's InstanceDeclaration
         * @returns {Tw2VertexDeclaration}
         */

    }, {
        key: 'GetInstanceDeclaration',
        value: function GetInstanceDeclaration() {
            return this._declaration;
        }

        /**
         * Gets the particle system's InstanceStride
         * @returns {number}
         */

    }, {
        key: 'GetInstanceStride',
        value: function GetInstanceStride() {
            return this.instanceStride[0];
        }

        /**
         * Gets the particle system's InstanceCount
         * @returns {number}
         */

    }, {
        key: 'GetInstanceCount',
        value: function GetInstanceCount() {
            return this.aliveCount;
        }

        /**
         * Initializes class globals
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!Tw2ParticleSystem.global) {
                Tw2ParticleSystem.global = {
                    vec3_0: _math.vec3.create(),
                    mat4_0: _math.mat4.create()
                };
            }
        }
    }]);

    return Tw2ParticleSystem;
}();

/**
 * Class globals
 */


Tw2ParticleSystem.global = null;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TransformParameter = Tw2TransformParameter;

var _math = __webpack_require__(0);

/**
 * Tw2TransformParameter
 * @param {string} [name='']
 * @parameter {string} name
 * @parameter {vec3} scaling=[1,1,1]
 * @parameter {quat} rotation=[0,0,0,1]
 * @parameter {vec3} translation=[0,0,0]
 * @parameter {mat4} worldTransform
 * @constructor
 */
function Tw2TransformParameter(name) {
    if (typeof name !== 'undefined') {
        this.name = name;
    } else {
        this.name = '';
    }
    this.scaling = _math.vec3.fromValues(1, 1, 1);
    this.rotationCenter = _math.vec3.create();
    this.rotation = _math.quat.create();
    this.translation = _math.vec3.create();
    this.worldTransform = _math.mat4.create();
}

/**
 * Initializes the transform parameter
 * @prototype
 */
Tw2TransformParameter.prototype.Initialize = function () {
    this.OnModified();
};

/**
 * Updates the transform parameter's properties
 * @prototype
 */
Tw2TransformParameter.prototype.OnModified = function () {
    _math.mat4.fromRotationTranslationScaleOrigin(this.worldTransform, this.rotation, this.translation, this.scaling, this.rotationCenter);
    _math.mat4.transpose(this.worldTransform, this.worldTransform);
};

/**
 * Bind
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @returns {boolean}
 * @prototype
 */
Tw2TransformParameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 16) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
};

/**
 * A function that should be called when any of the transform parameter's properties have been changed
 * @prototype
 */
Tw2TransformParameter.prototype.OnValueChanged = function () {
    this.OnModified();
};

/**
 * Apply
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @constructor
 */
Tw2TransformParameter.prototype.Apply = function (constantBuffer, offset, size) {
    if (size >= 16) {
        constantBuffer.set(this.worldTransform, offset);
    } else {
        constantBuffer.set(this.worldTransform.subarray(0, size), offset);
    }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Tw2ValueBinding = Tw2ValueBinding;

var _math = __webpack_require__(0);

var _Tw2Vector4Parameter = __webpack_require__(25);

/**
 * Tw2ValueBinding
 * @property {string} name
 * @property {Object} sourceObject
 * @property {string} sourceAttribute
 * @property {number} _sourceElement
 * @property {boolean} sourceIsArray
 * @property {Object} destinationObject
 * @property {string} destinationAttribute
 * @property {number} _destinationElement
 * @property {boolean} destinationIsArray
 * @property {number} scale
 * @property {quat} offset
 * @property {null|Function} _copyFunc - The function to use when updating destination attributes
 * @constructor
 */
function Tw2ValueBinding() {
    this.name = '';
    this.sourceObject = null;
    this.sourceAttribute = '';
    this._sourceElement = null;
    this.sourceIsArray = null;

    this.destinationObject = null;
    this.destinationAttribute = '';
    this._destinationElement = null;
    this.destinationIsArray = null;

    this.scale = 1;
    this.offset = _math.quat.create();
    this._copyFunc = null;
}

/**
 * Initializes the Value Binding
 * @prototypes
 */
Tw2ValueBinding.prototype.Initialize = function () {
    if (!this.sourceObject || this.sourceAttribute === '') {
        return;
    }
    if (!this.destinationObject || this.destinationAttribute === '') {
        return;
    }

    var srcSwizzled = false;
    var destSwizzled = false;
    var srcSwizzle = this.sourceAttribute.substr(-2);

    if (srcSwizzle === '.x' || srcSwizzle === '.r') {
        srcSwizzled = true;
        this._sourceElement = 0;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
    } else if (srcSwizzle === '.y' || srcSwizzle === '.g') {
        srcSwizzled = true;
        this._sourceElement = 1;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
    } else if (srcSwizzle === '.z' || srcSwizzle === '.b') {
        srcSwizzled = true;
        this._sourceElement = 2;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
    } else if (srcSwizzle === '.w' || srcSwizzle === '.a') {
        srcSwizzled = true;
        this._sourceElement = 3;
        this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
    } else if (this.sourceObject instanceof _Tw2Vector4Parameter.Tw2Vector4Parameter) {
        if (this.sourceAttribute === 'v1') {
            srcSwizzled = true;
            this._sourceElement = 0;
            this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v2') {
            srcSwizzled = true;
            this._sourceElement = 1;
            this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v3') {
            srcSwizzled = true;
            this._sourceElement = 2;
            this.sourceAttribute = 'value';
        } else if (this.sourceAttribute === 'v4') {
            srcSwizzled = true;
            this._sourceElement = 3;
            this.sourceAttribute = 'value';
        }
    }

    var destSwizzle = this.destinationAttribute.substr(-2);
    if (destSwizzle === '.x' || destSwizzle === '.r') {
        destSwizzled = true;
        this._destinationElement = 0;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
    } else if (destSwizzle === '.y' || destSwizzle === '.g') {
        destSwizzled = true;
        this._destinationElement = 1;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
    } else if (destSwizzle === '.z' || destSwizzle === '.b') {
        destSwizzled = true;
        this._destinationElement = 2;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
    } else if (destSwizzle === '.w' || destSwizzle === '.a') {
        destSwizzled = true;
        this._destinationElement = 3;
        this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
    } else if (this.destinationObject instanceof _Tw2Vector4Parameter.Tw2Vector4Parameter) {
        if (this.destinationAttribute === 'v1') {
            destSwizzled = true;
            this._destinationElement = 0;
            this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v2') {
            destSwizzled = true;
            this._destinationElement = 1;
            this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v3') {
            destSwizzled = true;
            this._destinationElement = 2;
            this.destinationAttribute = 'value';
        } else if (this.destinationAttribute === 'v4') {
            destSwizzled = true;
            this._destinationElement = 3;
            this.destinationAttribute = 'value';
        }
    }
    if (!(this.sourceAttribute in this.sourceObject) || !(this.destinationAttribute in this.destinationObject)) {
        return;
    }

    this.sourceIsArray = this.sourceObject[this.sourceAttribute] instanceof Float32Array || Array.isArray(this.sourceObject[this.sourceAttribute]);
    this.destinationIsArray = this.destinationObject[this.destinationAttribute] instanceof Float32Array || Array.isArray(this.destinationObject[this.destinationAttribute]);

    if (this.sourceIsArray === this.destinationIsArray && _typeof(this.sourceObject[this.sourceAttribute]) === _typeof(this.destinationObject[this.destinationAttribute])) {
        if (this.sourceIsArray) {
            if (srcSwizzled) {
                if (destSwizzled) {
                    this._copyFunc = this._CopyElementToElement;
                } else {
                    this._copyFunc = this._ReplicateElement;
                }
            } else {
                if (this.sourceObject[this.sourceAttribute].length <= this.destinationObject[this.destinationAttribute].length) {
                    this._copyFunc = this._CopyArray;
                } else if (this.sourceObject[this.sourceAttribute].length === 16) {
                    this._copyFunc = this._ExtractPos;
                } else {
                    return;
                }
            }
        } else {
            this._copyFunc = this._CopyValueToValue;
        }
    } else if (this.sourceIsArray && srcSwizzled && typeof this.destinationObject[this.destinationAttribute] === 'number') {
        this._copyFunc = this._CopyElementToValue;
    } else if (this.destinationIsArray && typeof this.sourceObject[this.sourceAttribute] === 'number') {
        if (destSwizzled) {
            this._copyFunc = this._CopyValueToElement;
        } else {
            this._copyFunc = this._ReplicateValue;
        }
    } else if (typeof this.sourceObject[this.sourceAttribute] === 'number' && typeof this.destinationObject[this.destinationAttribute] === 'boolean') {
        this._copyFunc = this._CopyFloatToBoolean;
    } else {
        return;
    }
};

/**
 * CopyValue
 * @prototype
 */
Tw2ValueBinding.prototype.CopyValue = function () {
    if (this._copyFunc) {
        this._copyFunc.call(this);
        if ('OnValueChanged' in this.destinationObject) {
            this.destinationObject.OnValueChanged();
        }
    }
};

/**
 * _CopyValueToValue
 * @private
 */
Tw2ValueBinding.prototype._CopyValueToValue = function () {
    this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
};

/**
 * _CopyArray
 * @private
 */
Tw2ValueBinding.prototype._CopyArray = function () {
    var count = Math.min(this.destinationObject[this.destinationAttribute].length, this.sourceObject[this.sourceAttribute].length);
    for (var i = 0; i < count; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i] * this.scale + this.offset[i];
    }
};

/**
 * _CopyElementToElement
 * @private
 */
Tw2ValueBinding.prototype._CopyElementToElement = function () {
    this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
};

/**
 * _ReplicateValue
 * @private
 */
Tw2ValueBinding.prototype._ReplicateValue = function () {
    for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[i];
    }
};

/**
 * _CopyArray
 * @private
 */
Tw2ValueBinding.prototype._ReplicateElement = function () {
    for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[i];
    }
};

/**
 * _ExtractPos
 * @private
 */
Tw2ValueBinding.prototype._ExtractPos = function () {
    for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
        this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i + 12] * this.scale + this.offset[i];
    }
};

/**
 * _CopyElementToValue
 * @private
 */
Tw2ValueBinding.prototype._CopyElementToValue = function () {
    this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
};

/**
 * _CopyValueToElement
 * @private
 */
Tw2ValueBinding.prototype._CopyValueToElement = function () {
    this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
};

/**
 * _CopyFloatToBoolean
 * @private
 */
Tw2ValueBinding.prototype._CopyFloatToBoolean = function () {
    this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] !== 0;
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VariableParameter = Tw2VariableParameter;

var _Tw2VariableStore = __webpack_require__(16);

/**
 * Tw2VariableParameter
 * @param {string} [name=''] Parameter name
 * @param {string} [variableName='']
 * @property {string} name
 * @property {string} variableName
 * @constructor
 */
function Tw2VariableParameter(name, variableName) {
    if (typeof name !== 'undefined') {
        this.name = name;
    } else {
        this.name = '';
    }
    if (typeof variableName !== 'undefined') {
        this.variableName = variableName;
    } else {
        this.variableName = '';
    }
}

/**
 * Bind
 * @returns {boolean}
 * @prototype
 */
Tw2VariableParameter.prototype.Bind = function () {
    return false;
};

/**
 * Apply
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @prototype
 */
Tw2VariableParameter.prototype.Apply = function (constantBuffer, offset, size) {
    if (_Tw2VariableStore.store.HasVariable(this.variableName)) {
        _Tw2VariableStore.store.GetVariable(this.variableName).Apply(constantBuffer, offset, size);
    }
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector2Parameter = Tw2Vector2Parameter;

var _math = __webpack_require__(0);

/**
 * Tw2Vector2Parameter
 * @param {string} [name='']
 * @param {vec2|Float32Array} [value=[1,1]]
 * @property {string} name
 * @property {vec2} value
 * @property {Float32Array} constantBuffer
 * @property {number} offset
 * @constructor
 */
function Tw2Vector2Parameter(name, value) {
    this.name = name !== 'undefined' ? name : '';
    this.value = value !== undefined ? _math.vec2.clone(value) : _math.vec2.fromValues(1, 1);
    this.constantBuffer = null;
    this.offset = 0;
}

/**
 * Bind
 * TODO: Identify if @param size should be passed to the `Apply` prototype as it is currently redundant
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @returns {boolean}
 * @prototype
 */
Tw2Vector2Parameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 2) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
    return true;
};

/**
 * Unbind
 * @prototype
 */
Tw2Vector2Parameter.prototype.Unbind = function () {
    this.constantBuffer = null;
};

/**
 * Sets a supplied value
 * @param {vec2} value - Vector2 Array
 * @prototype
 */
Tw2Vector2Parameter.prototype.SetValue = function (value) {
    _math.vec2.copy(this.value, value);
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Updates the constant buffer to the current value
 * @prototype
 */
Tw2Vector2Parameter.prototype.OnValueChanged = function () {
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Applies the current value to the supplied constant buffer at the supplied offset
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @prototype
 */
Tw2Vector2Parameter.prototype.Apply = function (constantBuffer, offset) {
    constantBuffer.set(this.value, offset);
};

/**
 * Gets the current value array
 * @return {vec2} Vector2 Array
 * @prototype
 */
Tw2Vector2Parameter.prototype.GetValue = function () {
    if (this.constantBuffer !== null) {
        return _math.vec2.clone(this.constantBuffer.subarray(this.offset, this.offset + this.value.length));
    }

    return _math.vec2.clone(this.value);
};

/**
 * Returns a value from a specific index of the value array
 * @param {number} index
 * @returns {number}
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector2Parameter.prototype.GetIndexValue = function (index) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    if (this.constantBuffer !== null) {
        return this.constantBuffer[this.offset + index];
    }

    return this.value[index];
};

/**
 * Sets a value at a specific index of the value array
 * @param {number} index
 * @param {number} value
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector2Parameter.prototype.SetIndexValue = function (index, value) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    this.value[index] = value;

    if (this.constantBuffer !== null) {
        this.constantBuffer[this.offset + index] = value;
    }
};

/**
 * Sets all value array elements to a single value
 * @param {number} value - The value to fill the value array elements with
 * @prototype
 */
Tw2Vector2Parameter.prototype.FillWith = function (value) {
    this.SetValue([value, value]);
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2Vector2Parameter.is = function (value) {
    return _math.util.isArrayLike(value) && value.length === 2;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector3Parameter = Tw2Vector3Parameter;

var _math = __webpack_require__(0);

/**
 * Tw2Vector3Parameter
 * @param {string} [name='']
 * @param {vec3|Float32Array} [value=[1,1,1]]
 * @property {string} name
 * @property {vec3|Float32Array} value
 * @property {Float32Array} constantBuffer
 * @property {number} offset
 * @constructor
 */
function Tw2Vector3Parameter(name, value) {
    this.name = name !== 'undefined' ? name : '';
    this.value = value !== undefined ? _math.vec3.clone(value) : _math.vec3.fromValues(1, 1, 1);
    this.constantBuffer = null;
    this.offset = 0;
}

/**
 * Bind
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @param {number} size
 * @returns {boolean}
 * @prototype
 */
Tw2Vector3Parameter.prototype.Bind = function (constantBuffer, offset, size) {
    if (this.constantBuffer !== null || size < 3) {
        return false;
    }
    this.constantBuffer = constantBuffer;
    this.offset = offset;
    this.Apply(this.constantBuffer, this.offset, size);
    return true;
};

/**
 * Unbind
 * @prototype
 */
Tw2Vector3Parameter.prototype.Unbind = function () {
    this.constantBuffer = null;
};

/**
 * Sets a supplied value
 * @param {vec3|Float32Array} value - Vector3 Array
 * @prototype
 */
Tw2Vector3Parameter.prototype.SetValue = function (value) {
    _math.vec3.copy(this.value, value);
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Updates the constant buffer to the current value
 * @prototype
 */
Tw2Vector3Parameter.prototype.OnValueChanged = function () {
    if (this.constantBuffer !== null) {
        this.constantBuffer.set(this.value, this.offset);
    }
};

/**
 * Applies the current value to the supplied constant buffer at the supplied offset
 * @param {Float32Array} constantBuffer
 * @param {number} offset
 * @prototype
 */
Tw2Vector3Parameter.prototype.Apply = function (constantBuffer, offset) {
    constantBuffer.set(this.value, offset);
};

/**
 * Gets the current value array
 * @return {vec3|Float32Array} Vector3 Array
 * @prototype
 */
Tw2Vector3Parameter.prototype.GetValue = function () {
    if (this.constantBuffer !== null) {
        return _math.vec3.clone(this.constantBuffer.subarray(this.offset, this.offset + this.value.length));
    }

    return _math.vec3.clone(this.value);
};

/**
 * Returns a value from a specific index of the value array
 * @param {number} index
 * @returns {number}
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector3Parameter.prototype.GetIndexValue = function (index) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    if (this.constantBuffer !== null) {
        return this.constantBuffer[this.offset + index];
    }

    return this.value[index];
};

/**
 * Sets a value at a specific index of the value array
 * @param {number} index
 * @param {number} value
 * @throw Invalid Index
 * @prototype
 */
Tw2Vector3Parameter.prototype.SetIndexValue = function (index, value) {
    if (typeof this.value[index] === 'undefined') {
        throw 'Invalid Index';
    }

    this.value[index] = value;

    if (this.constantBuffer !== null) {
        this.constantBuffer[this.offset + index] = value;
    }
};

/**
 * Sets all value array elements to a single value
 * @param {number} value - The value to fill the value array elements with
 * @prototype
 */
Tw2Vector3Parameter.prototype.FillWith = function (value) {
    this.SetValue([value, value, value]);
};

/**
 * Checks if a value is a valid parameter input
 * @param {*} value
 * @returns {boolean}
 */
Tw2Vector3Parameter.is = function (value) {
    return _math.util.isArrayLike(value) && value.length === 3;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorCurve = exports.Tw2ColorKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorKey
 *
 * @property {vec4} value
 * @property {vec4} left
 * @property {vec4} right
 * @property {number} interpolation
 * @class
 */
var Tw2ColorKey = exports.Tw2ColorKey = function (_Tw2CurveKey) {
    _inherits(Tw2ColorKey, _Tw2CurveKey);

    function Tw2ColorKey() {
        _classCallCheck(this, Tw2ColorKey);

        var _this = _possibleConstructorReturn(this, (Tw2ColorKey.__proto__ || Object.getPrototypeOf(Tw2ColorKey)).call(this));

        _this.value = _math.vec4.create();
        _this.left = _math.vec4.create();
        _this.right = _math.vec4.create();
        _this.interpolation = 0;
        return _this;
    }

    return Tw2ColorKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ColorCurve
 *
 * @property {number} start
 * @property {vec4} currentValue
 * @property {number} extrapolation
 * @property {Array.<Tw2ColorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2ColorCurve = exports.Tw2ColorCurve = function (_Tw2Curve) {
    _inherits(Tw2ColorCurve, _Tw2Curve);

    function Tw2ColorCurve() {
        _classCallCheck(this, Tw2ColorCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2ColorCurve.__proto__ || Object.getPrototypeOf(Tw2ColorCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.vec4.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ColorCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4} value
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.vec4.copy(value, this.value);
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2ColorCurve.Extrapolation.NONE:
                        return _math.vec4.copy(value, this.value);

                    case Tw2ColorCurve.Extrapolation.CONSTANT:
                        return _math.vec4.copy(value, lastKey.value);

                    case Tw2ColorCurve.Extrapolation.GRADIENT:
                        return _math.vec4.scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2ColorCurve.Extrapolation.NONE:
                        return _math.vec4.copy(value, this.value);

                    case Tw2ColorCurve.Extrapolation.GRADIENT:
                        return _math.vec4.scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

                    default:
                        return _math.vec4.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);

            switch (ck_1.interpolation) {
                case Tw2ColorCurve.Interpolation.CONSTANT:
                    return _math.vec4.copy(value, ck_1.value);

                default:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
                    return value;
            }
        }
    }]);

    return Tw2ColorCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ColorCurve.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ColorCurve.ouputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ColorCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2ColorCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2ColorKey}
 */
Tw2ColorCurve.Key = Tw2ColorKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2ColorCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number}}
 */
Tw2ColorCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorCurve2 = exports.Tw2ColorKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorKey2
 *
 * @property {number} time
 * @property {vec4} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2ColorKey2 = exports.Tw2ColorKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2ColorKey2, _Tw2CurveKey);

    function Tw2ColorKey2() {
        _classCallCheck(this, Tw2ColorKey2);

        var _this = _possibleConstructorReturn(this, (Tw2ColorKey2.__proto__ || Object.getPrototypeOf(Tw2ColorKey2)).call(this));

        _this.value = _math.vec4.create();
        _this.leftTangent = _math.vec4.create();
        _this.rightTangent = _math.vec4.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2ColorKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ColorCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec4} startValue=[0,0,0,1]
 * @property {vec4} currentValue=[0,0,0,1]
 * @property {vec4} endValue=[0,0,0,1]
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ColorKey2>} keys
 * @class
 */


var Tw2ColorCurve2 = exports.Tw2ColorCurve2 = function (_Tw2Curve) {
    _inherits(Tw2ColorCurve2, _Tw2Curve);

    function Tw2ColorCurve2() {
        _classCallCheck(this, Tw2ColorCurve2);

        var _this2 = _possibleConstructorReturn(this, (Tw2ColorCurve2.__proto__ || Object.getPrototypeOf(Tw2ColorCurve2)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.currentValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.endValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.startTangent = _math.vec4.create();
        _this2.endTangent = _math.vec4.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ColorCurve2, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec4.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec4.copy(value, this.startValue);
                } else {
                    return _math.vec4.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2ColorKey2} lastKey
         * @param {Tw2ColorKey2} nextKey
         * @param {vec4} value
         * @returns {vec4} value
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec4.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2ColorCurve2.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
                    value[3] = startValue[3] + (endValue[3] - startValue[3]) * (time / deltaTime);
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2ColorCurve2;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ColorCurve2.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ColorCurve2.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ColorCurve2.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2ColorCurve2.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2ColorKey2}
 */
Tw2ColorCurve2.Key = Tw2ColorKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number}}
 */
Tw2ColorCurve2.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2EventCurve = exports.Tw2EventKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EventKey
 *
 * @property {string} value
 * @class
 */
var Tw2EventKey = exports.Tw2EventKey = function (_Tw2CurveKey) {
    _inherits(Tw2EventKey, _Tw2CurveKey);

    function Tw2EventKey() {
        _classCallCheck(this, Tw2EventKey);

        var _this = _possibleConstructorReturn(this, (Tw2EventKey.__proto__ || Object.getPrototypeOf(Tw2EventKey)).call(this));

        _this.value = '';
        return _this;
    }

    return Tw2EventKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2EventCurve
 *
 * @property {string} value
 * @property {Array.<Tw2EventKey>} keys
 * @property {number} extrapolation
 * @property {number} _time
 * @property {number} _currentKey
 * @property {number} _length
 * @class
 */


var Tw2EventCurve = exports.Tw2EventCurve = function (_Tw2Curve) {
    _inherits(Tw2EventCurve, _Tw2Curve);

    function Tw2EventCurve() {
        _classCallCheck(this, Tw2EventCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2EventCurve.__proto__ || Object.getPrototypeOf(Tw2EventCurve)).call(this));

        _this2.value = '';
        _this2.keys = [];
        _this2.extrapolation = 0;
        _this2._time = 0;
        _this2._currentKey = 0;
        _this2._length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2EventCurve, [{
        key: 'Sort',
        value: function Sort() {
            if (this.keys.length) {
                this.keys.sort(_Tw2Curve2.Tw2Curve.Compare);
                this._length = this.keys[this.keys.length - 1].time;
            }
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this._length;
        }

        /**
         * Gets a value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this._length <= 0) {
                return this.value;
            }

            var before = this._time;
            this._time = time;
            if (this._time < before) {
                this._currentKey = 0;
            }

            if (this.extrapolation === Tw2EventCurve.Extrapolation.CYCLE) {
                var now = this._time % this._length;
                if (now < before) this._currentKey = 0;
                this._time = now;
            }

            while (this._currentKey < this.keys.length && this._time >= this.keys[this._currentKey].time) {
                this.value = this.keys[this._currentKey].value;
                ++this._currentKey;
            }
        }
    }]);

    return Tw2EventCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2EventCurve.dimension = 1;

/**
 * The curve's output dimension
 * @type {number}
 */
Tw2EventCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2EventCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2EventCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2EventKey}
 */
Tw2EventCurve.Key = Tw2EventKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CYCLE: number}}
 */
Tw2EventCurve.Extrapolation = {
    NONE: 0,
    CYCLE: 3
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2PerlinCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2PerlinCurve
 *
 * @property {number} start
 * @property {number} speed
 * @property {number} alpha
 * @property {number} beta
 * @property {number} offset
 * @property {number} scale
 * @property {number} N
 * @property {number} _startOffset
 * @class
 */
var Tw2PerlinCurve = exports.Tw2PerlinCurve = function (_Tw2Curve) {
  _inherits(Tw2PerlinCurve, _Tw2Curve);

  function Tw2PerlinCurve() {
    _classCallCheck(this, Tw2PerlinCurve);

    var _this = _possibleConstructorReturn(this, (Tw2PerlinCurve.__proto__ || Object.getPrototypeOf(Tw2PerlinCurve)).call(this));

    _this.value = 0;
    _this.start = 0;
    _this.speed = 1;
    _this.alpha = 1.1;
    _this.beta = 2;
    _this.offset = 0;
    _this.scale = 1;
    _this.N = 3;
    _this._startOffset = Math.random() * 100;
    return _this;
  }

  /**
   * Updates the current value at the given time
   * @param {number} time
   */


  _createClass(Tw2PerlinCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time) {
      time -= this._startOffset;
      return (_math.noise.perlin1D(time * this.speed, this.alpha, this.beta, this.N) + 1) / 2 * this.scale + this.offset;
    }
  }]);

  return Tw2PerlinCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2PerlinCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2PerlinCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2PerlinCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2QuaternionCurve = exports.Tw2QuaternionKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionKey2
 *
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2QuaternionKey2 = exports.Tw2QuaternionKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2QuaternionKey2, _Tw2CurveKey);

    function Tw2QuaternionKey2() {
        _classCallCheck(this, Tw2QuaternionKey2);

        var _this = _possibleConstructorReturn(this, (Tw2QuaternionKey2.__proto__ || Object.getPrototypeOf(Tw2QuaternionKey2)).call(this));

        _this.value = _math.quat.create();
        _this.leftTangent = _math.vec4.create();
        _this.rightTangent = _math.vec4.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2QuaternionKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2QuaternionCurve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {quat} startValue
 * @property {quat} currentValue
 * @property {quat} endValue
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} length
 * @class
 */


var Tw2QuaternionCurve = exports.Tw2QuaternionCurve = function (_Tw2Curve) {
    _inherits(Tw2QuaternionCurve, _Tw2Curve);

    function Tw2QuaternionCurve() {
        _classCallCheck(this, Tw2QuaternionCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2QuaternionCurve.__proto__ || Object.getPrototypeOf(Tw2QuaternionCurve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.quat.create();
        _this2.currentValue = _math.quat.create();
        _this2.endValue = _math.quat.create();
        _this2.startTangent = _math.vec4.create();
        _this2.endTangent = _math.vec4.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2QuaternionCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;

            if (this.length <= 0 || time <= 0) {
                value[0] = this.startValue[0];
                value[1] = this.startValue[1];
                value[2] = this.startValue[2];
                return value;
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    value[0] = this.startValue[0];
                    value[1] = this.startValue[1];
                    value[2] = this.startValue[2];
                    return value;
                } else {
                    value[0] = this.endValue[0];
                    value[1] = this.endValue[1];
                    value[2] = this.endValue[2];
                    return value;
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {null|Tw2QuaternionKey} lastKey
         * @param {null|Tw2QuaternionKey} nextKey
         * @param {quat} value
         * @returns {*}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            value[0] = this.startValue[0];
            value[1] = this.startValue[1];
            value[2] = this.startValue[2];

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2QuaternionCurve.Interpolation.SPHERICAL_LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }

                    _math.quat.slerp(value, startValue, endValue, time / deltaTime);
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2QuaternionCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2QuaternionCurve.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2QuaternionCurve.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2QuaternionCurve.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2QuaternionCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2QuaternionKey2}
 */
Tw2QuaternionCurve.Key = Tw2QuaternionKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, SPHERICAL_LINEAR: number}}
 */
Tw2QuaternionCurve.Interpolation = {
    CONSTANT: 0,
    SPHERICAL_LINEAR: 4
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2RandomConstantCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomConstantCurve
 *
 * @property {number} currentValue
 * @property {number} min
 * @property {number} max
 * @property {boolean} hold
 * @class
 */
var Tw2RandomConstantCurve = exports.Tw2RandomConstantCurve = function (_Tw2Curve) {
  _inherits(Tw2RandomConstantCurve, _Tw2Curve);

  function Tw2RandomConstantCurve() {
    _classCallCheck(this, Tw2RandomConstantCurve);

    var _this = _possibleConstructorReturn(this, (Tw2RandomConstantCurve.__proto__ || Object.getPrototypeOf(Tw2RandomConstantCurve)).call(this));

    _this.value = 0;
    _this.min = 0;
    _this.max = 1;
    _this.hold = true;
    return _this;
  }

  /**
   * Updates the current value at the given time
   */


  _createClass(Tw2RandomConstantCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue() {
      this.value = this.GetValueAt();
    }

    /**
     * Gets a value at a specific time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt() {
      return this.hold ? this.value : this.min + (this.max - this.min) * Math.random();
    }
  }]);

  return Tw2RandomConstantCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2RandomConstantCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RandomConstantCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RandomConstantCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RigidOrientation = exports.Tw2Torque = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Torque
 *
 * @property {quat} rot0
 * @property {vec3} omega0
 * @property {vec3} torque
 * @class
 */
var Tw2Torque = exports.Tw2Torque = function (_Tw2CurveKey) {
    _inherits(Tw2Torque, _Tw2CurveKey);

    function Tw2Torque() {
        _classCallCheck(this, Tw2Torque);

        var _this = _possibleConstructorReturn(this, (Tw2Torque.__proto__ || Object.getPrototypeOf(Tw2Torque)).call(this));

        _this.rot0 = _math.quat.create();
        _this.omega0 = _math.vec3.create();
        _this.torque = _math.vec3.create();
        return _this;
    }

    return Tw2Torque;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2RigidOrientation
 *
 * @property {string} name
 * @property {number} I
 * @property {number} drag
 * @property {quat} value
 * @property {number} start
 * @property {Array.<Tw2Torque>} states
 * @property {number} length
 * @class
 */


var Tw2RigidOrientation = exports.Tw2RigidOrientation = function (_Tw2Curve) {
    _inherits(Tw2RigidOrientation, _Tw2Curve);

    function Tw2RigidOrientation() {
        _classCallCheck(this, Tw2RigidOrientation);

        var _this2 = _possibleConstructorReturn(this, (Tw2RigidOrientation.__proto__ || Object.getPrototypeOf(Tw2RigidOrientation)).call(this));

        _this2.name = '';
        _this2.I = 1;
        _this2.drag = 1;
        _this2.value = _math.quat.create();
        _this2.start = 0;
        _this2.states = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2RigidOrientation, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this, this.states);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.states.length === 0 || time < 0 || time < this.states[0].time) {
                return _math.quat.copy(value, this.value);
            }

            var key = 0;
            if (time >= this.states[this.states.length - 1].time) {
                key = this.states.length - 1;
            } else {
                for (; key + 1 < this.states.length; ++key) {
                    if (time >= this.states[key].time && time < this.states[key + 1].time) {
                        break;
                    }
                }
            }

            var vec3_0 = _Tw2Curve2.Tw2Curve.global.vec3_0,
                quat_0 = _Tw2Curve2.Tw2Curve.global.quat_0;

            var ck = this.states[key];
            _math.vec3.exponentialDecay(vec3_0, ck.omega0, ck.torque, this.I, this.drag, time - ck.time);
            _math.quat.exp(quat_0, vec3_0);
            _math.quat.multiply(value, this.states[key].rot0, quat_0);
            return value;
        }
    }]);

    return Tw2RigidOrientation;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2RigidOrientation.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2RigidOrientation.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RigidOrientation.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RigidOrientation.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2Torque}
 */
Tw2RigidOrientation.Key = Tw2Torque;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RotationCurve = exports.Tw2QuaternionKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionKey
 *
 * @property {number} time
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2QuaternionKey = exports.Tw2QuaternionKey = function (_Tw2CurveKey) {
    _inherits(Tw2QuaternionKey, _Tw2CurveKey);

    function Tw2QuaternionKey() {
        _classCallCheck(this, Tw2QuaternionKey);

        var _this = _possibleConstructorReturn(this, (Tw2QuaternionKey.__proto__ || Object.getPrototypeOf(Tw2QuaternionKey)).call(this));

        _this.value = _math.quat.create();
        _this.left = _math.vec4.create();
        _this.right = _math.vec4.create();
        _this.interpolation = 5;
        return _this;
    }

    return Tw2QuaternionKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2RotationCurve
 *
 * @property {number} start
 * @property {quat} value
 * @property {number} extrapolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class`
 */


var Tw2RotationCurve = exports.Tw2RotationCurve = function (_Tw2Curve) {
    _inherits(Tw2RotationCurve, _Tw2Curve);

    function Tw2RotationCurve() {
        _classCallCheck(this, Tw2RotationCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2RotationCurve.__proto__ || Object.getPrototypeOf(Tw2RotationCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.quat.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's children
     */


    _createClass(Tw2RotationCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.quat.copy(value, this.value);
            }

            var scratch = _Tw2Curve2.Tw2Curve.global,
                firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2RotationCurve.Extrapolation.NONE:
                        return _math.quat.copy(value, this.value);

                    case Tw2RotationCurve.Extrapolation.CONSTANT:
                        return _math.quat.copy(value, lastKey.value);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2RotationCurve.Extrapolation.NONE:
                        return _math.quat.copy(value, this.value);

                    default:
                        return _math.quat.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2RotationCurve.Interpolation.CONSTANT:
                    return _math.quat.copy(value, ck_1.value);

                case Tw2RotationCurve.Interpolation.LINEAR:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
                    return value;

                case Tw2RotationCurve.Interpolation.HERMITE:
                    var collect = _math.quat.identity(scratch.quat_0),
                        arr = [ck_1.value, ck_1.right, ck.left, ck.value];

                    for (var i = 3; i > 0; i--) {
                        var power = _math.num.biCumulative(nt, i);
                        if (power > 1) _math.quat.multiply(value, collect, arr[i]);
                        value[0] = -arr[i - 1][0];
                        value[1] = -arr[i - 1][1];
                        value[2] = -arr[i - 1][2];
                        value[3] = arr[i - 1][3];
                        _math.quat.multiply(value, value, arr[i]);
                        _math.quat.pow(value, value, power);
                        _math.quat.multiply(collect, collect, value);
                    }
                    return _math.quat.multiply(value, collect, ck_1.value);

                case Tw2RotationCurve.Interpolation.SLERP:
                    return _math.quat.slerp(value, ck_1.value, ck.value, nt);

                default:
                    return _math.quat.sqlerp(value, ck_1.value, ck_1.right, ck.left, ck.value, nt);
            }
        }
    }]);

    return Tw2RotationCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2RotationCurve.outputDimention = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2RotationCurve.inputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RotationCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RotationCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2QuaternionKey}
 */
Tw2RotationCurve.Child = Tw2QuaternionKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2RotationCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number, SLERP: number, SQUAD: number}}
 */
Tw2RotationCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3,
    SLERP: 5,
    SQUAD: 6
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarCurve = exports.Tw2ScalarKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarKey
 *
 * @property {number} value
 * @property {number} left
 * @property {number} right
 * @property {number} interpolation
 * @class
 */
var Tw2ScalarKey = exports.Tw2ScalarKey = function (_Tw2CurveKey) {
    _inherits(Tw2ScalarKey, _Tw2CurveKey);

    function Tw2ScalarKey() {
        _classCallCheck(this, Tw2ScalarKey);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarKey.__proto__ || Object.getPrototypeOf(Tw2ScalarKey)).call(this));

        _this.value = 0;
        _this.left = 0;
        _this.right = 0;
        _this.interpolation = 0;
        return _this;
    }

    return Tw2ScalarKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ScalarCurve
 *
 * @property {number} start
 * @property {number} timeScale
 * @property {number} timeOffset
 * @property {number} value
 * @property {number} extrapolation
 * @property {Array.<Tw2ScalarKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2ScalarCurve = exports.Tw2ScalarCurve = function (_Tw2Curve) {
    _inherits(Tw2ScalarCurve, _Tw2Curve);

    function Tw2ScalarCurve() {
        _classCallCheck(this, Tw2ScalarCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2ScalarCurve.__proto__ || Object.getPrototypeOf(Tw2ScalarCurve)).call(this));

        _this2.start = 0;
        _this2.timeScale = 1;
        _this2.timeOffset = 0;
        _this2.value = 0;
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ScalarCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.value = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            time = time / this.timeScale - this.timeOffset;

            if (this.length === 0) {
                return this.value;
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2ScalarCurve.Extrapolation.NONE:
                        return this.value;

                    case Tw2ScalarCurve.Extrapolation.CONSTANT:
                        return lastKey.value;

                    case Tw2ScalarCurve.Extrapolation.GRADIENT:
                        return lastKey.value + (time - lastKey.time) * lastKey.right;

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2ScalarCurve.Extrapolation.NONE:
                        return this.value;

                    case Tw2ScalarCurve.Extrapolation.GRADIENT:
                        return firstKey.value + (time * this.length - lastKey.time) * firstKey.left;

                    default:
                        return firstKey.value;
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2ScalarCurve.Interpolation.CONSTANT:
                    return ck_1.value;

                case Tw2ScalarCurve.Interpolation.LINEAR:
                    return ck_1.value * (1 - nt) + ck.value * nt;

                case Tw2ScalarCurve.Interpolation.HERMITE:
                    var k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                        k2 = -2 * nt * nt * nt + 3 * nt * nt,
                        k1 = nt * nt * nt - 2 * nt * nt + nt,
                        k0 = nt * nt * nt - nt * nt;
                    return k3 * ck_1.value + k2 * ck.value + k1 * ck_1.right + k0 * ck.left;

                default:
                    var sq = Math.sqrt(ck_1.value / ck.value),
                        exponent = Math.exp(-time / ck_1.right),
                        ret = 1.0 + (sq - 1.0) * exponent;
                    return ret * ret * ck.value;
            }
        }
    }]);

    return Tw2ScalarCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ScalarCurve.inputDimension = 1;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ScalarCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ScalarCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2ScalarCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2ScalarKey}
 */
Tw2ScalarCurve.Key = Tw2ScalarKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2ScalarCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number, CATMULROM: number}}
 */
Tw2ScalarCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3,
    CATMULROM: 4
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarCurve2 = exports.Tw2ScalarKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarKey2
 *
 * @property {number} value
 * @property {number} leftTangent
 * @property {number} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2ScalarKey2 = exports.Tw2ScalarKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2ScalarKey2, _Tw2CurveKey);

    function Tw2ScalarKey2() {
        _classCallCheck(this, Tw2ScalarKey2);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarKey2.__proto__ || Object.getPrototypeOf(Tw2ScalarKey2)).call(this));

        _this.value = 0;
        _this.leftTangent = 0;
        _this.rightTangent = 0;
        _this.interpolation = 1;
        return _this;
    }

    return Tw2ScalarKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ScalarCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {number} startValue
 * @property {number} currentValue
 * @property {number} endValue
 * @property {number} startTangent
 * @property {number} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ScalarKey2>} keys
 * @property {number} length
 * @class
 */


var Tw2ScalarCurve2 = exports.Tw2ScalarCurve2 = function (_Tw2Curve) {
    _inherits(Tw2ScalarCurve2, _Tw2Curve);

    function Tw2ScalarCurve2() {
        _classCallCheck(this, Tw2ScalarCurve2);

        var _this2 = _possibleConstructorReturn(this, (Tw2ScalarCurve2.__proto__ || Object.getPrototypeOf(Tw2ScalarCurve2)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = 0;
        _this2.currentValue = 0;
        _this2.endValue = 0;
        _this2.startTangent = 0;
        _this2.endTangent = 0;
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ScalarCurve2, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.currentValue = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return this.startValue;
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return this.startValue;
                } else {
                    return this.endValue;
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2ScalarKey2} lastKey
         * @param {Tw2ScalarKey2} nextKey
         * @returns {number}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey) {
            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2ScalarCurve2.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    return startValue + (endValue - startValue) * (time / deltaTime);

                case Tw2ScalarCurve2.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    return startValue * c1 + endValue * c2 + inTangent * c3 + outTangent * c4;

                default:
                    return this.startValue;
            }
        }
    }]);

    return Tw2ScalarCurve2;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ScalarCurve2.inputDimension = 1;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ScalarCurve2.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ScalarCurve2.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2ScalarCurve2.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2ScalarKey2}
 */
Tw2ScalarCurve2.Key = Tw2ScalarKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2ScalarCurve2.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2SineCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2SineCurve
 *
 * @property {string} name
 * @property {number} value
 * @property {number} offset
 * @property {number} scale
 * @property {number} speed
 */
var Tw2SineCurve = exports.Tw2SineCurve = function (_Tw2Curve) {
  _inherits(Tw2SineCurve, _Tw2Curve);

  function Tw2SineCurve() {
    _classCallCheck(this, Tw2SineCurve);

    var _this = _possibleConstructorReturn(this, (Tw2SineCurve.__proto__ || Object.getPrototypeOf(Tw2SineCurve)).call(this));

    _this.value = 0;
    _this.offset = 0;
    _this.scale = 1;
    _this.speed = 1;
    return _this;
  }

  /**
   * Updates the current value at the given time
   * @param {number} time
   */


  _createClass(Tw2SineCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time) {
      return Math.sin(time * Math.PI * 2 * this.speed) * this.scale + this.offset;
    }
  }]);

  return Tw2SineCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * THe curve's dimension
 * @type {number}
 */


Tw2SineCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2SineCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2SineCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector2Curve = exports.Tw2Vector2Key = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector2Key
 *
 * @property {vec2} value
 * @property {vec2} leftTangent
 * @property {vec2} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2Vector2Key = exports.Tw2Vector2Key = function (_Tw2CurveKey) {
    _inherits(Tw2Vector2Key, _Tw2CurveKey);

    function Tw2Vector2Key() {
        _classCallCheck(this, Tw2Vector2Key);

        var _this = _possibleConstructorReturn(this, (Tw2Vector2Key.__proto__ || Object.getPrototypeOf(Tw2Vector2Key)).call(this));

        _this.value = _math.vec2.create();
        _this.leftTangent = _math.vec2.create();
        _this.rightTangent = _math.vec2.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2Vector2Key;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector2Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec2} startValue - vec2 array
 * @property {vec2} currentValue - vec2 array
 * @property {vec2} endValue - vec2 array
 * @property {vec2} startTangent - vec2 array
 * @property {vec2} endTangent - vec2 array
 * @property {number} interpolation
 * @property {Array.<Tw2Vector2Key>} keys
 * @property {number} length
 * @class
 */


var Tw2Vector2Curve = exports.Tw2Vector2Curve = function (_Tw2Curve) {
    _inherits(Tw2Vector2Curve, _Tw2Curve);

    function Tw2Vector2Curve() {
        _classCallCheck(this, Tw2Vector2Curve);

        var _this2 = _possibleConstructorReturn(this, (Tw2Vector2Curve.__proto__ || Object.getPrototypeOf(Tw2Vector2Curve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec2.create();
        _this2.currentValue = _math.vec2.create();
        _this2.endValue = _math.vec2.create();
        _this2.startTangent = _math.vec2.create();
        _this2.endTangent = _math.vec2.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2Vector2Curve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec2} value - vec2 array
         * @returns {vec2} vec2 array
         * @prototype
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec2.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec2.copy(value, this.startValue);
                } else {
                    return _math.vec2.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2Vector2Key} lastKey
         * @param {Tw2Vector2Key} nextKey
         * @param {vec2} value - vec2 array
         * @returns {vec2} vec2 array
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec2.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2Vector2Curve.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    return value;

                case Tw2Vector2Curve.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
                    value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2Vector2Curve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2Vector2Curve.inputDimension = 2;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2Vector2Curve.outputDimension = 2;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2Vector2Curve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2Vector2Curve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2Vector2Key}
 */
Tw2Vector2Curve.Key = Tw2Vector2Key;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2Vector2Curve.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector3Curve = exports.Tw2Vector3Key = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector3Key
 *
 * @property {number} time
 * @property {vec3} value
 * @property {vec3} leftTangent
 * @property {vec3} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2Vector3Key = exports.Tw2Vector3Key = function (_Tw2CurveKey) {
    _inherits(Tw2Vector3Key, _Tw2CurveKey);

    function Tw2Vector3Key() {
        _classCallCheck(this, Tw2Vector3Key);

        var _this = _possibleConstructorReturn(this, (Tw2Vector3Key.__proto__ || Object.getPrototypeOf(Tw2Vector3Key)).call(this));

        _this.value = _math.vec3.create();
        _this.leftTangent = _math.vec3.create();
        _this.rightTangent = _math.vec3.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2Vector3Key;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector3Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec3} startValue
 * @property {vec3} currentValue
 * @property {vec3} endValue
 * @property {vec3} startTangent
 * @property {vec3} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2Vector3Key>} keys
 * @property {number} length
 * @class
 */


var Tw2Vector3Curve = exports.Tw2Vector3Curve = function (_Tw2Curve) {
    _inherits(Tw2Vector3Curve, _Tw2Curve);

    function Tw2Vector3Curve() {
        _classCallCheck(this, Tw2Vector3Curve);

        var _this2 = _possibleConstructorReturn(this, (Tw2Vector3Curve.__proto__ || Object.getPrototypeOf(Tw2Vector3Curve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec3.create();
        _this2.currentValue = _math.vec3.create();
        _this2.endValue = _math.vec3.create();
        _this2.startTangent = _math.vec3.create();
        _this2.endTangent = _math.vec3.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2Vector3Curve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec3.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec3.copy(value, this.startValue);
                } else {
                    return _math.vec3.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2Vector3Key} lastKey
         * @param {Tw2Vector3Key} nextKey
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec3.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2Vector3Curve.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }

                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
                    return value;

                case Tw2Vector3Curve.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
                    value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
                    value[2] = startValue[2] * c1 + endValue[2] * c2 + inTangent[2] * c3 + outTangent[2] * c4;
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2Vector3Curve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2Vector3Curve.inputDimension = 3;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2Vector3Curve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2Vector3Curve.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2Vector3Curve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2Vector3Key}
 */
Tw2Vector3Curve.Key = Tw2Vector3Key;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2Vector3Curve.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VectorCurve = exports.Tw2VectorKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VectorKey
 *
 * @property {vec3} value
 * @property {vec3} left
 * @property {vec3} right
 * @property {number} interpolation
 * @inherits Tw2CurveKey
 * @class
 */
var Tw2VectorKey = exports.Tw2VectorKey = function (_Tw2CurveKey) {
    _inherits(Tw2VectorKey, _Tw2CurveKey);

    function Tw2VectorKey() {
        _classCallCheck(this, Tw2VectorKey);

        var _this = _possibleConstructorReturn(this, (Tw2VectorKey.__proto__ || Object.getPrototypeOf(Tw2VectorKey)).call(this));

        _this.value = _math.vec3.create();
        _this.left = _math.vec3.create();
        _this.right = _math.vec3.create();
        _this.interpolation = 0;
        return _this;
    }

    return Tw2VectorKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector3Curve
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} extrapolation
 * @property {Array.<Tw2VectorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2VectorCurve = exports.Tw2VectorCurve = function (_Tw2Curve) {
    _inherits(Tw2VectorCurve, _Tw2Curve);

    function Tw2VectorCurve() {
        _classCallCheck(this, Tw2VectorCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2VectorCurve.__proto__ || Object.getPrototypeOf(Tw2VectorCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.vec3.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2VectorCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.vec3.copy(value, this.value);
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2VectorCurve.Extrapolation.NONE:
                        return _math.vec3.copy(value, this.value);

                    case Tw2VectorCurve.Extrapolation.CONSTANT:
                        return _math.vec3.copy(value, lastKey.value);

                    case Tw2VectorCurve.Extrapolation.GRADIENT:
                        return _math.vec3.scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2VectorCurve.Extrapolation.NONE:
                        return _math.vec3.copy(value, this.value);

                    case Tw2VectorCurve.Extrapolation.GRADIENT:
                        return _math.vec3.scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

                    default:
                        return _math.vec3.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2VectorCurve.Interpolation.CONSTANT:
                    return _math.vec3.copy(value, ck_1.value);

                case Tw2VectorCurve.Interpolation.LINEAR:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    return value;

                case Tw2VectorCurve.Interpolation.HERMITE:
                    var k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                        k2 = -2 * nt * nt * nt + 3 * nt * nt,
                        k1 = nt * nt * nt - 2 * nt * nt + nt,
                        k0 = nt * nt * nt - nt * nt;

                    value[0] = k3 * ck_1.value[0] + k2 * ck.value[0] + k1 * ck_1.right[0] + k0 * ck.left[0];
                    value[1] = k3 * ck_1.value[1] + k2 * ck.value[1] + k1 * ck_1.right[1] + k0 * ck.left[1];
                    value[2] = k3 * ck_1.value[2] + k2 * ck.value[2] + k1 * ck_1.right[2] + k0 * ck.left[2];
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2VectorCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2VectorCurve.inputDimension = 3;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2VectorCurve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2VectorCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2VectorCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2VectorKey}
 */
Tw2VectorCurve.Key = Tw2VectorKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2VectorCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2VectorCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2ColorSequencer = __webpack_require__(114);

Object.keys(_Tw2ColorSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorSequencer[key];
    }
  });
});

var _Tw2EulerRotation = __webpack_require__(115);

Object.keys(_Tw2EulerRotation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EulerRotation[key];
    }
  });
});

var _Tw2QuaternionSequencer = __webpack_require__(116);

Object.keys(_Tw2QuaternionSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2QuaternionSequencer[key];
    }
  });
});

var _Tw2RGBAScalarSequencer = __webpack_require__(117);

Object.keys(_Tw2RGBAScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RGBAScalarSequencer[key];
    }
  });
});

var _Tw2ScalarSequencer = __webpack_require__(118);

Object.keys(_Tw2ScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarSequencer[key];
    }
  });
});

var _Tw2VectorSequencer = __webpack_require__(119);

Object.keys(_Tw2VectorSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VectorSequencer[key];
    }
  });
});

var _Tw2XYZScalarSequencer = __webpack_require__(120);

Object.keys(_Tw2XYZScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2XYZScalarSequencer[key];
    }
  });
});

var _Tw2YPRSequencer = __webpack_require__(121);

Object.keys(_Tw2YPRSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2YPRSequencer[key];
    }
  });
});

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorSequencer
 *
 * @property {number} start
 * @property {vec4} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @class
 */
var Tw2ColorSequencer = exports.Tw2ColorSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2ColorSequencer, _Tw2CurveSequencer);

    function Tw2ColorSequencer() {
        _classCallCheck(this, Tw2ColorSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2ColorSequencer.__proto__ || Object.getPrototypeOf(Tw2ColorSequencer)).call(this));

        _this.start = 0;
        _this.value = _math.vec4.create();
        _this.operator = 0;
        _this.functions = [];
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2ColorSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            var vec4_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.vec4_0;

            switch (this.operator) {
                case Tw2ColorSequencer.Operator.MULTIPLY:
                    _math.vec4.set(value, 1, 1, 1, 1);
                    for (var i = 0; i < this.functions.length; ++i) {
                        this.functions[i].GetValueAt(time, vec4_0);
                        _math.vec4.multiply(value, value, vec4_0);
                    }
                    return value;

                default:
                    _math.vec4.set(value, 0, 0, 0, 0);
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        this.functions[_i].GetValueAt(time, vec4_0);
                        _math.vec4.add(value, value, vec4_0);
                    }
                    return value;
            }
        }
    }]);

    return Tw2ColorSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2ColorSequencer.inputDimension = 4;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2ColorSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2ColorSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2ColorSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve array
 * @type {string}
 */
Tw2ColorSequencer.childArray = 'functions';

/**
 * Operators
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2ColorSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2EulerRotation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EulerRotation
 *
 * @property {string} name
 * @property {Tw2Curve} [yawCurve]
 * @property {Tw2Curve} [pitchCurve]
 * @property {Tw2Curve} [rollCurve]
 * @property {quat} currentValue=[0,0,0,1]
 * @class
 */
var Tw2EulerRotation = exports.Tw2EulerRotation = function (_Tw2CurveSequencer) {
    _inherits(Tw2EulerRotation, _Tw2CurveSequencer);

    function Tw2EulerRotation() {
        _classCallCheck(this, Tw2EulerRotation);

        var _this = _possibleConstructorReturn(this, (Tw2EulerRotation.__proto__ || Object.getPrototypeOf(Tw2EulerRotation)).call(this));

        _this.yawCurve = null;
        _this.pitchCurve = null;
        _this.rollCurve = null;
        _this.currentValue = _math.quat.create();
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2EulerRotation, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            if (this.yawCurve && 'GetLength' in this.yawCurve) len = this.yawCurve.GetLength();
            if (this.pitchCurve && 'GetLength' in this.pitchCurve) len = Math.max(len, this.pitchCurve.GetLength());
            if (this.rollCurve && 'GetLength' in this.rollCurve) len = Math.max(len, this.rollCurve.GetLength());
            return len;
        }

        /**
         * Updates the current value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            var yaw = this.yawCurve ? this.yawCurve.GetValueAt(time) : 0.0,
                pitch = this.pitchCurve ? this.pitchCurve.GetValueAt(time) : 0.0,
                roll = this.rollCurve ? this.rollCurve.GetValueAt(time) : 0.0;

            var sinYaw = Math.sin(yaw / 2.0),
                cosYaw = Math.cos(yaw / 2.0),
                sinPitch = Math.sin(pitch / 2.0),
                cosPitch = Math.cos(pitch / 2.0),
                sinRoll = Math.sin(roll / 2.0),
                cosRoll = Math.cos(roll / 2.0);

            value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
            value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
            value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
            value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;

            return value;
        }
    }]);

    return Tw2EulerRotation;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2EulerRotation.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2EulerRotation.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2EulerRotation.valueProperty = 'currentValue';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2EulerRotation.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2EulerRotation.childProperties = ['yawCurve', 'pitchCurve', 'rollCurve'];

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2QuaternionSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {quat} value
 * @property {Array<Tw2Curve>} functions
 * @class
 */
var Tw2QuaternionSequencer = exports.Tw2QuaternionSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2QuaternionSequencer, _Tw2CurveSequencer);

    function Tw2QuaternionSequencer() {
        _classCallCheck(this, Tw2QuaternionSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2QuaternionSequencer.__proto__ || Object.getPrototypeOf(Tw2QuaternionSequencer)).call(this));

        _this.start = 0;
        _this.value = _math.quat.create();
        _this.functions = [];
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2QuaternionSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            _math.quat.identity(value);
            var quat_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.quat_0;
            for (var i = 0; i < this.functions.length; ++i) {
                this.functions[i].GetValueAt(time, quat_0);
                _math.quat.multiply(value, value, quat_0);
            }
            return value;
        }
    }]);

    return Tw2QuaternionSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2QuaternionSequencer.inputDimension = 4;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2QuaternionSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2QuaternionSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2QuaternionSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve array
 * @type {string}
 */
Tw2QuaternionSequencer.childArray = 'functions';

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2RGBAScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RGBAScalarSequencer
 *
 * @property {vec4} value
 * @property {Tw2Curve} RedCurve
 * @property {Tw2Curve} GreenCurve
 * @property {Tw2Curve} BlueCurve
 * @property {Tw2Curve} AlphaCurve
 * @class
 */
var Tw2RGBAScalarSequencer = exports.Tw2RGBAScalarSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2RGBAScalarSequencer, _Tw2CurveSequencer);

  function Tw2RGBAScalarSequencer() {
    _classCallCheck(this, Tw2RGBAScalarSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2RGBAScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2RGBAScalarSequencer)).call(this));

    _this.value = _math.vec4.create();
    _this.RedCurve = null;
    _this.GreenCurve = null;
    _this.BlueCurve = null;
    _this.AlphaCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2RGBAScalarSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.RedCurve && 'GetLength' in this.RedCurve) len = this.RedCurve.GetLength();
      if (this.GreenCurve && 'GetLength' in this.GreenCurve) len = Math.max(len, this.GreenCurve.GetLength());
      if (this.BlueCurve && 'GetLength' in this.BlueCurve) len = Math.max(len, this.BlueCurve.GetLength());
      if (this.AlphaCurve && 'GetLength' in this.AlphaCurve) len = Math.max(len, this.AlphaCurve.GetLength());
      return len;
    }

    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      value[0] = this.RedCurve ? this.RedCurve.GetValueAt(time) : 0;
      value[1] = this.GreenCurve ? this.GreenCurve.GetValueAt(time) : 0;
      value[2] = this.BlueCurve ? this.BlueCurve.GetValueAt(time) : 0;
      value[3] = this.AlphaCurve ? this.AlphaCurve.GetValueAt(time) : 0;
      return value;
    }
  }]);

  return Tw2RGBAScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2RGBAScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2RGBAScalarSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2RGBAScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2RGBAScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2RGBAScalarSequencer.childProperties = ['RedCurve', 'GreenCurve', 'BlueCurve', 'AlphaCurve'];

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarSequencer
 *
 * @property {string} name
 * @property {number} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @property {number} inMinClamp
 * @property {number} inMaxClamp
 * @property {number} outMinClamp
 * @property {number} outMaxClamp
 * @property {boolean} clamping
 * @class
 */
var Tw2ScalarSequencer = exports.Tw2ScalarSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2ScalarSequencer, _Tw2CurveSequencer);

    function Tw2ScalarSequencer() {
        _classCallCheck(this, Tw2ScalarSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2ScalarSequencer)).call(this));

        _this.value = 0;
        _this.operator = 0;
        _this.functions = [];
        _this.inMinClamp = 0;
        _this.inMaxClamp = 1;
        _this.outMinClamp = 0;
        _this.outMaxClamp = 1;
        _this.clamping = false;
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2ScalarSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates a value at a specific time
         *
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.value = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         *
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            var value = void 0;

            switch (this.operator) {
                case Tw2ScalarSequencer.Operator.MULTIPLY:
                    value = 1;
                    for (var i = 0; i < this.functions.length; ++i) {
                        var v = this.functions[i].GetValueAt(time);
                        if (this.clamping) {
                            v = Math.min(Math.max(v, this.inMinClamp), this.inMaxClamp);
                        }
                        value *= v;
                    }
                    break;

                default:
                    value = 0;
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        var _v = this.functions[_i].GetValueAt(time);
                        if (this.clamping) {
                            _v = Math.min(Math.max(_v, this.inMinClamp), this.inMaxClamp);
                        }
                        value += _v;
                    }
            }

            if (this.clamping) {
                value = Math.min(Math.max(value, this.outMinClamp), this.outMaxClamp);
            }

            return value;
        }
    }]);

    return Tw2ScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2ScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2ScalarSequencer.outputDimension = 1;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2ScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2ScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve properties
 * @type {string}
 */
Tw2ScalarSequencer.childArray = 'functions';

/**
 * Operator types
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2ScalarSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VectorSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VectorSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} operator
 * @property {Array.<Tw2Curve>} functions
 * @class
 */
var Tw2VectorSequencer = exports.Tw2VectorSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2VectorSequencer, _Tw2CurveSequencer);

    function Tw2VectorSequencer() {
        _classCallCheck(this, Tw2VectorSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2VectorSequencer.__proto__ || Object.getPrototypeOf(Tw2VectorSequencer)).call(this));

        _this.start = 0;
        _this.value = _math.vec3.create();
        _this.operator = 0;
        _this.functions = [];
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2VectorSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates the current value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            var vec3_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.vec3_0;

            switch (this.operator) {
                case Tw2VectorSequencer.Operator.MULTIPLY:
                    _math.vec3.set(value, 1, 1, 1);
                    for (var i = 0; i < this.functions.length; ++i) {
                        this.functions[i].GetValueAt(time, vec3_0);
                        _math.vec3.multiply(value, value, vec3_0);
                    }
                    return value;

                default:
                    _math.vec3.set(value, 0, 0, 0);
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        this.functions[_i].GetValueAt(time, vec3_0);
                        _math.vec3.add(value, value, vec3_0);
                    }
                    return value;
            }
        }
    }]);

    return Tw2VectorSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2VectorSequencer.inputDimension = 3;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2VectorSequencer.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2VectorSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2VectorSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve properties
 * @type {string}
 */
Tw2VectorSequencer.childArray = 'functions';

/**
 * Operator types
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2VectorSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2XYZScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2XYZScalarSequencer
 *
 * @property {string} name
 * @property {vec3} value
 * @property {Tw2CurveSequencer} XCurve
 * @property {Tw2CurveSequencer} YCurve
 * @property {Tw2CurveSequencer} ZCurve
 * @class
 */
var Tw2XYZScalarSequencer = exports.Tw2XYZScalarSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2XYZScalarSequencer, _Tw2CurveSequencer);

  function Tw2XYZScalarSequencer() {
    _classCallCheck(this, Tw2XYZScalarSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2XYZScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2XYZScalarSequencer)).call(this));

    _this.value = _math.vec3.create();
    _this.XCurve = null;
    _this.YCurve = null;
    _this.ZCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2XYZScalarSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.XCurve && 'GetLength' in this.XCurve) len = this.XCurve.GetLength();
      if (this.YCurve && 'GetLength' in this.YCurve) len = Math.max(len, this.YCurve.GetLength());
      if (this.ZCurve && 'GetLength' in this.ZCurve) len = Math.max(len, this.ZCurve.GetLength());
      return len;
    }

    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      value[0] = this.XCurve ? this.XCurve.GetValueAt(time) : 0;
      value[1] = this.YCurve ? this.YCurve.GetValueAt(time) : 0;
      value[2] = this.ZCurve ? this.ZCurve.GetValueAt(time) : 0;
      return value;
    }
  }]);

  return Tw2XYZScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2XYZScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2XYZScalarSequencer.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2XYZScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2XYZScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2XYZScalarSequencer.childProperties = ['XCurve', 'YCurve', 'ZCurve'];

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2YPRSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2YPRSequencer
 *
 * @property {quat} value
 * @property {vec3} YawPitchRoll
 * @property {Tw2Curve} YawCurve
 * @property {Tw2Curve} PitchCurve
 * @property {Tw2Curve} RollCurve
 * @class
 */
var Tw2YPRSequencer = exports.Tw2YPRSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2YPRSequencer, _Tw2CurveSequencer);

  function Tw2YPRSequencer() {
    _classCallCheck(this, Tw2YPRSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2YPRSequencer.__proto__ || Object.getPrototypeOf(Tw2YPRSequencer)).call(this));

    _this.value = _math.quat.create();
    _this.YawPitchRoll = _math.vec3.create();
    _this.YawCurve = null;
    _this.PitchCurve = null;
    _this.RollCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2YPRSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.YawCurve && 'GetLength' in this.YawCurve) len = this.YawCurve.GetLength();
      if (this.PitchCurve && 'GetLength' in this.PitchCurve) len = Math.max(len, this.PitchCurve.GetLength());
      if (this.RollCurve && 'GetLength' in this.RollCurve) len = Math.max(len, this.RollCurve.GetLength());
      return len;
    }

    /**
     * Updates a value at a specific time
     *
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     *
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      if (this.YawCurve) this.YawPitchRoll[0] = this.YawCurve.GetValueAt(time);
      if (this.PitchCurve) this.YawPitchRoll[1] = this.PitchCurve.GetValueAt(time);
      if (this.RollCurve) this.YawPitchRoll[2] = this.RollCurve.GetValueAt(time);

      var sinYaw = Math.sin(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
          cosYaw = Math.cos(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
          sinPitch = Math.sin(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
          cosPitch = Math.cos(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
          sinRoll = Math.sin(this.YawPitchRoll[2] / 180 * Math.PI / 2.0),
          cosRoll = Math.cos(this.YawPitchRoll[2] / 180 * Math.PI / 2.0);

      value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
      value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
      value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;

      return value;
    }
  }]);

  return Tw2YPRSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2YPRSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2YPRSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2YPRSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2YPRSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2YPRSequencer.childProperties = ['YawCurve', 'PitchCurve', 'RollCurve'];

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2WbgTrack = __webpack_require__(123);

Object.keys(_Tw2WbgTrack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2WbgTrack[key];
    }
  });
});

var _Tw2TransformTrack = __webpack_require__(124);

Object.keys(_Tw2TransformTrack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TransformTrack[key];
    }
  });
});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2WbgTrack = Tw2WbgTrack;
exports.Tw2WbgTransformTrack = Tw2WbgTransformTrack;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * Tw2WbgTrack
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {string} geometryResPath
 * @property {Object} geometryRes
 * @property {string} group
 * @property {number} duration
 * @property {boolean} cycle
 */
function Tw2WbgTrack() {
    this._id = _math.util.generateID();
    this.name = '';
    this.geometryResPath = '';
    this.geometryRes = null;
    this.group = '';
    this.duration = 0;
    this.cycle = false;

    /**
     * SetCurves
     * @param self
     * @private
     */
    function SetCurves(self) {
        if (!self.name || !self.group || !self.geometryRes) {
            return;
        }

        for (var i = 0; i < self.geometryRes.animations.length; ++i) {
            var animation = self.geometryRes.animations[i];
            for (var j = 0; j < animation.trackGroups.length; ++j) {
                if (animation.trackGroups[j].name === self.group) {
                    self._ApplyTracks(animation.trackGroups[j], animation.duration);
                }
            }
        }
    }

    /**
     * Initialize
     * @method
     */
    this.Initialize = function () {
        if (this.geometryResPath) {
            this.geometryRes = _core.resMan.GetResource(this.geometryResPath);
            var self = this;
            var notification = {
                RebuildCachedData: function RebuildCachedData() {
                    SetCurves(self);
                }
            };
            this.geometryRes.RegisterNotification(notification);
        }
    };

    /**
     * Updates a value at a specific time
     * @param {number} time
     * @prototype
     */
    this.UpdateValue = function (time) {
        if (!this._TracksReady()) return;
        if (this.cycle) time = time % this.duration;
        if (time <= this.duration && time >= 0) this._UpdateValue(time);
    };
}

/**
 * Tw2WbgTransformTrack
 *
 * @property {string|number} _id
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @variable {*} positionCurve
 * @variable {*} rotationCurve
 * @variable {*} scaleCurve
 * @variable {mat4} scaleShear
 */
function Tw2WbgTransformTrack() {
    this._id = _math.util.generateID();
    this.translation = _math.vec3.create();
    this.rotation = _math.quat.create();
    this.rotation[3] = 1;
    this.scale = _math.vec3.create();

    var positionCurve = null;
    var rotationCurve = null;
    var scaleCurve = null;
    var scaleShear = _math.mat4.create();

    /**
     * _TracksReady
     * @returns {*}
     * @private
     */
    this._TracksReady = function () {
        return positionCurve || rotationCurve || scaleCurve;
    };

    /**
     * _ApplyTracks
     * @param trackGroup
     * @param duration
     * @private
     */
    this._ApplyTracks = function (trackGroup, duration) {
        for (var i = 0; i < trackGroup.transformTracks.length; ++i) {
            var track = trackGroup.transformTracks[i];
            if (track.name === this.name) {
                this.duration = duration;
                positionCurve = track.position;
                rotationCurve = track.orientation;
                scaleCurve = track.scaleShear;
            }
        }
        this.UpdateValue(0);
    };

    /**
     * Updates a value at a specific time
     * @param {number} time
     * @prototype
     */
    this._UpdateValue = function (time) {
        if (positionCurve) {
            _math.curve.evaluate(positionCurve, time, this.translation, this.cycle, this.duration);
        }

        if (rotationCurve) {
            _math.curve.evaluate(rotationCurve, time, this.rotation, this.cycle, this.duration);
            _math.quat.normalize(this.rotation, this.rotation);
        }

        if (scaleCurve) {
            _math.curve.evaluate(scaleCurve, time, scaleShear, this.cycle, this.duration);
        }

        this.scale[0] = scaleShear[0];
        this.scale[1] = scaleShear[5];
        this.scale[2] = scaleShear[10];
    };
}

/**
 * @type {Tw2WbgTrack}
 * @prototype
 */
Tw2WbgTransformTrack.prototype = new Tw2WbgTrack();

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TransformTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2TransformTrack
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {string} resPath
 * @property {Object} res
 * @property {string} group
 * @property {boolean} cycle
 * @property {number} duration
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @property positionCurve
 * @property orientationCurve
 * @property scaleCurve
 * @property {mat4} _scaleShear
 * @class
 */
var Tw2TransformTrack = exports.Tw2TransformTrack = function () {
    function Tw2TransformTrack() {
        _classCallCheck(this, Tw2TransformTrack);

        this._id = _math.util.generateID();
        this.name = '';
        this.resPath = '';
        this.res = null;
        this.group = '';
        this.cycle = false;
        this.duration = 0;
        this.translation = _math.vec3.create();
        this.rotation = _math.quat.create();
        this.scale = _math.vec3.fromValues(0, 0, 0);
        this.scaleShear = _math.mat4.create();
        this.positionCurve = null;
        this.orientationCurve = null;
        this.scaleCurve = null;
    }

    /**
     * Initializes the Curve
     */


    _createClass(Tw2TransformTrack, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.resPath !== '') {
                this.res = _core.resMan.GetResource(this.resPath);
            }
        }

        /**
         * Gets curve length
         *
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.duration;
        }

        /**
         * Updates a value at a specific time
         *
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (!this.res || !this.res.IsGood()) return;
            if (!this.positionCurve) this.FindTracks();
            if (!this.positionCurve) return;
            if (this.cycle) time = time % this.duration;
            if (time > this.duration || time < 0) return;

            _math.curve.evaluate(this.positionCurve, time, this.translation, this.cycle, this.duration);
            _math.curve.evaluate(this.orientationCurve, time, this.rotation, this.cycle, this.duration);
            _math.quat.normalize(this.rotation, this.rotation);
            _math.curve.evaluate(this.scaleCurve, time, this.scaleShear, this.cycle, this.duration);
            _math.mat4.getScaling(this.scale, this.scaleCurve);
        }

        /**
         * FindTracks
         */

    }, {
        key: 'FindTracks',
        value: function FindTracks() {
            var group = null;
            for (var i = 0; i < this.res.animations.length; ++i) {
                for (var j = 0; j < this.res.animations[i].trackGroups.length; ++j) {
                    if (this.res.animations[i].trackGroups[j].name === this.group) {
                        this.duration = this.res.animations[i].duration;
                        group = this.res.animations[i].trackGroups[j];
                        break;
                    }
                }
            }

            if (!group) return;

            for (var _i = 0; _i < group.transformTracks.length; ++_i) {
                if (this.name === group.transformTracks[_i].name) {
                    this.positionCurve = group.transformTracks[_i].position;
                    this.orientationCurve = group.transformTracks[_i].orientation;
                    this.scaleCurve = group.transformTracks[_i].scaleShear;
                    break;
                }
            }
        }
    }]);

    return Tw2TransformTrack;
}();

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2MayaEulerRotationCurve = __webpack_require__(126);

Object.keys(_Tw2MayaEulerRotationCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaEulerRotationCurve[key];
    }
  });
});

var _Tw2MayaScalarCurve = __webpack_require__(127);

Object.keys(_Tw2MayaScalarCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaScalarCurve[key];
    }
  });
});

var _Tw2MayaVector3Curve = __webpack_require__(128);

Object.keys(_Tw2MayaVector3Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaVector3Curve[key];
    }
  });
});

var _Tw2MayaAnimationEngine = __webpack_require__(129);

Object.keys(_Tw2MayaAnimationEngine).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaAnimationEngine[key];
    }
  });
});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaEulerRotationCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _curves = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaEulerRotationCurve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {?Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} eulerValue
 * @property {boolean} updateQuaternion
 * @property {quat} quatValue
 * @property {number} length
 * @class
 */
var Tw2MayaEulerRotationCurve = exports.Tw2MayaEulerRotationCurve = function (_Tw2Curve) {
    _inherits(Tw2MayaEulerRotationCurve, _Tw2Curve);

    function Tw2MayaEulerRotationCurve() {
        _classCallCheck(this, Tw2MayaEulerRotationCurve);

        var _this = _possibleConstructorReturn(this, (Tw2MayaEulerRotationCurve.__proto__ || Object.getPrototypeOf(Tw2MayaEulerRotationCurve)).call(this));

        _this.xIndex = -1;
        _this.yIndex = -1;
        _this.zIndex = -1;
        _this.animationEngine = null;
        _this.eulerValue = _math.vec3.create();
        _this.updateQuaternion = false;
        _this.quatValue = _math.quat.create();
        _this.length = 0;
        return _this;
    }

    /**
     * Sorts the curve
     */


    _createClass(Tw2MayaEulerRotationCurve, [{
        key: 'Sort',
        value: function Sort() {
            this.ComputeLength();
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this.animationEngine) {
                if (this.xIndex) {
                    this.eulerValue[0] = this.animationEngine.Evaluate(this.xIndex, time);
                }

                if (this.yIndex) {
                    if (this.yIndex === this.xIndex) {
                        this.eulerValue[1] = this.eulerValue[0];
                    } else {
                        this.eulerValue[1] = this.animationEngine.Evaluate(this.yIndex, time);
                    }
                }

                if (this.zIndex) {
                    if (this.zIndex === this.xIndex) {
                        this.eulerValue[2] = this.eulerValue[0];
                    } else {
                        this.eulerValue[2] = this.animationEngine.Evaluate(this.zIndex, time);
                    }
                }

                if (this.updateQuaternion) {
                    var sinYaw = Math.sin(this.eulerValue[0] / 2),
                        cosYaw = Math.cos(this.eulerValue[0] / 2),
                        sinPitch = Math.sin(this.eulerValue[1] / 2),
                        cosPitch = Math.cos(this.eulerValue[1] / 2),
                        sinRoll = Math.sin(this.eulerValue[2] / 2),
                        cosRoll = Math.cos(this.eulerValue[2] / 2);

                    this.quatValue[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
                    this.quatValue[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
                    this.quatValue[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
                    this.quatValue[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
                }
            }
        }

        /**
         * Computes curve Length
         */

    }, {
        key: 'ComputeLength',
        value: function ComputeLength() {
            if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;

            this.length = 0;
            if (this.xIndex >= 0) {
                this.length = this.animationEngine.GetLength(this.xIndex);
            }

            if (this.yIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
            }

            if (this.zIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
            }
        }
    }]);

    return Tw2MayaEulerRotationCurve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaEulerRotationCurve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaEulerRotationCurve.valueProperty = 'eulerValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaEulerRotationCurve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaScalarCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _curves = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaScalarCurve
 *
 * @property {number} index
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {number} value
 * @property {number} length
 * @class
 */
var Tw2MayaScalarCurve = exports.Tw2MayaScalarCurve = function (_Tw2Curve) {
    _inherits(Tw2MayaScalarCurve, _Tw2Curve);

    function Tw2MayaScalarCurve() {
        _classCallCheck(this, Tw2MayaScalarCurve);

        var _this = _possibleConstructorReturn(this, (Tw2MayaScalarCurve.__proto__ || Object.getPrototypeOf(Tw2MayaScalarCurve)).call(this));

        _this.index = -1;
        _this.animationEngine = null;
        _this.value = 0;
        _this.length = 0;
        return _this;
    }

    /**
     * Sorts the curve
     */


    _createClass(Tw2MayaScalarCurve, [{
        key: 'Sort',
        value: function Sort() {
            this.ComputeLength();
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this.animationEngine) {
                this.value = this.animationEngine.Evaluate(this.index, time);
            }
        }

        /**
         * Computes curve Length
         */

    }, {
        key: 'ComputeLength',
        value: function ComputeLength() {
            if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;
            if (this.index >= 0) this.length = this.animationEngine.GetLength(this.index);
        }
    }]);

    return Tw2MayaScalarCurve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaScalarCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaScalarCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaScalarCurve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaVector3Curve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _curves = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaVector3Curve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} value
 * @property {number} length
 */
var Tw2MayaVector3Curve = exports.Tw2MayaVector3Curve = function (_Tw2Curve) {
    _inherits(Tw2MayaVector3Curve, _Tw2Curve);

    function Tw2MayaVector3Curve() {
        _classCallCheck(this, Tw2MayaVector3Curve);

        var _this = _possibleConstructorReturn(this, (Tw2MayaVector3Curve.__proto__ || Object.getPrototypeOf(Tw2MayaVector3Curve)).call(this));

        _this.xIndex = -1;
        _this.yIndex = -1;
        _this.zIndex = -1;
        _this.animationEngine = null;
        _this.value = _math.vec3.create();
        _this.length = 0;
        return _this;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2MayaVector3Curve, [{
        key: 'Sort',
        value: function Sort() {
            this.ComputeLength();
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this.animationEngine) {
                if (this.xIndex) {
                    this.value[0] = this.animationEngine.Evaluate(this.xIndex, time);
                }

                if (this.yIndex) {
                    if (this.yIndex === this.xIndex) {
                        this.value[1] = this.value[0];
                    } else {
                        this.value[1] = this.animationEngine.Evaluate(this.yIndex, time);
                    }
                }

                if (this.zIndex) {
                    if (this.zIndex === this.xIndex) {
                        this.value[2] = this.value[0];
                    } else {
                        this.value[2] = this.animationEngine.Evaluate(this.zIndex, time);
                    }
                }
            }
        }

        /**
         * Computes curve Length
         */

    }, {
        key: 'ComputeLength',
        value: function ComputeLength() {
            if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;

            this.length = 0;
            if (this.xIndex >= 0) {
                this.length = this.animationEngine.GetLength(this.xIndex);
            }

            if (this.yIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
            }

            if (this.zIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
            }
        }
    }]);

    return Tw2MayaVector3Curve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaVector3Curve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaVector3Curve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaVector3Curve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaAnimationEngine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2MayaAnimationEngine
 * TODO: Complete the prototype `_EvaluteBezier`
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {Array} curves
 * @property {Array} hermiteSegments
 * @property {Array} bezierSegments
 * @property {number} _currentCurveIndex
 * @property _evalCache
 */
var Tw2MayaAnimationEngine = exports.Tw2MayaAnimationEngine = function () {
    function Tw2MayaAnimationEngine() {
        _classCallCheck(this, Tw2MayaAnimationEngine);

        this._id = _math.util.generateID();
        this.name = '';
        this.curves = [];
        this.hermiteSegments = [];
        this.bezierSegments = [];
        this._currentCurveIndex = 0;
        this._evalCache = null;
    }

    /**
     * Evaluate
     * @param curveIndex
     * @param time
     * @returns {*}
     */


    _createClass(Tw2MayaAnimationEngine, [{
        key: 'Evaluate',
        value: function Evaluate(curveIndex, time) {
            if (this.curves.length <= curveIndex) return 0;

            this._currentCurveIndex = curveIndex;
            if (!this._evalCache) {
                this._evalCache = new Array(this.curves.length);
                for (var i = 0; i < this._evalCache.length; ++i) {
                    this._evalCache[i] = -1;
                }
            }

            var animCurve = this.curves[curveIndex];
            var firstSegment = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET];
            var segments = null;

            if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                segments = this.bezierSegments;
            } else {
                segments = this.hermiteSegments;
            }

            if (time < segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.PRE_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
                    return segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                }
                return this._EvaluateInfinities(animCurve, segments, firstSegment, time, true);
            }

            if (time > animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME]) {
                if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.POST_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
                    return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                }
                return this._EvaluateInfinities(animCurve, segments, firstSegment, time, false);
            }

            return this._EvaluateImpl(animCurve, segments, firstSegment, time);
        }

        /**
         * _EvaluateImpl
         * @param animCurve
         * @param segments
         * @param firstSegment
         * @param time
         * @returns {*}
         */

    }, {
        key: '_EvaluateImpl',
        value: function _EvaluateImpl(animCurve, segments, firstSegment, time) {
            var withinInterval = false,
                nextSegment = null,
                lastSegment = null,
                index = void 0;

            if (this._evalCache[this._currentCurveIndex] >= 0) {
                lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];
                if (this._evalCache[this._currentCurveIndex] < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS - 1] && time > segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                    nextSegment = firstSegment + this._evalCache[this._currentCurveIndex] + 1;
                    if (time === segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        this._evalCache[this._currentCurveIndex]++;
                        return segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    } else if (time < segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        index = this._evalCache[this._currentCurveIndex] + 1;
                        withinInterval = true;
                    } else {
                        nextSegment = null;
                    }
                } else if (this._evalCache[this._currentCurveIndex] > 0 && time < segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                    var prevSegment = firstSegment + this._evalCache[this._currentCurveIndex] - 1;
                    if (time > segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        index = this._evalCache[this._currentCurveIndex];
                        withinInterval = true;
                    } else if (time === segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        this._evalCache[this._currentCurveIndex]--;
                        return segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    }
                }
            }

            if (!withinInterval) {
                var result = this._Find(animCurve, time, segments, firstSegment);
                index = result[1];
                if (result[0] || index === 0) {
                    if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
                        index--;
                        this._evalCache[this._currentCurveIndex] = index;
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    } else {
                        this._evalCache[this._currentCurveIndex] = index;
                        return segments[firstSegment + index][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    }
                } else if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1) {
                    this._evalCache[this._currentCurveIndex] = 0;
                    return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                }
            }

            if (this._evalCache[this._currentCurveIndex] !== index - 1) {
                this._evalCache[this._currentCurveIndex] = index - 1;
                lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];
                if (nextSegment === null) nextSegment = firstSegment + index;
            }

            if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                var bSegment = segments[lastSegment];
                if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP]) {
                    return bSegment[Tw2MayaAnimationEngine.BezierSegment.VALUE];
                } else if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP_NEXT]) {
                    if (nextSegment === null) {
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    }
                    return segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.VALUE];
                } else {
                    var nextKeyTime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];
                    if (this._evalCache[this._currentCurveIndex] + 1 < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
                        nextKeyTime = segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.TIME];
                    }
                    return this._EvaluateBezier(bSegment, time, nextKeyTime);
                }
            } else {
                var hSegment = segments[lastSegment];
                if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP]) {
                    return hSegment[Tw2MayaAnimationEngine.HermiteSegment.VALUE];
                } else if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP_NEXT]) {
                    if (nextSegment === null) {
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    }
                    return segments[nextSegment][Tw2MayaAnimationEngine.HermiteSegment.VALUE];
                } else {
                    return this._EvaluateHermite(hSegment, time);
                }
            }
        }

        /* eslint-disable no-unused-vars */

        /**
         * A static helper function to evaluate the infinity portion of an animation curve.
         * The infinity portion is the parts of the animation curve outside the range of keys.
         * @param curve - The animation curve to evaluate
         * @param segments
         * @param startSegment
         * @param {time} time
         * @param {boolean} bool - false: evaluate the post-infinity portion, true: evaluate the pre-infinity portion
         */

    }, {
        key: '_EvaluateInfinities',
        value: function _EvaluateInfinities(curve, segments, startSegment, time, bool) {

            throw new Error('_EvaluateInfinities not implemented');
        }

        /* eslint-enable no-unused-vars */

        /**
         * _EvaluateHermite
         * @param segment
         * @param time
         * @returns {*}
         */

    }, {
        key: '_EvaluateHermite',
        value: function _EvaluateHermite(segment, time) {
            var t = time - segment[Tw2MayaAnimationEngine.HermiteSegment.TIME];
            var coeff = segment[Tw2MayaAnimationEngine.HermiteSegment.COEFF];
            return t * (t * (t * coeff[0] + coeff[1]) + coeff[2]) + coeff[3];
        }

        /**
         * _EvaluateBezier
         * @param segment
         * @param time
         * @param nextSegmentTime
         * @returns {*}
         */

    }, {
        key: '_EvaluateBezier',
        value: function _EvaluateBezier(segment, time, nextSegmentTime) {
            var t = void 0,
                s = void 0;

            s = (time - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]) / (nextSegmentTime - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]);

            if (segment[Tw2MayaAnimationEngine.BezierSegment.IS_LINEAR]) {
                t = s;
            } else {
                var _poly = _math.vec4.create();
                _poly[3] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][3];
                _poly[2] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][2];
                _poly[1] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][1];
                _poly[0] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][0] - s;
                var roots = [];
                if (_math.curve.polyZeroes(_poly, 3, 0.0, 1, 1.0, 1, roots) === 1) t = roots[0];else t = 0.0;
            }

            var poly = segment[Tw2MayaAnimationEngine.BezierSegment.POLYY];
            return t * (t * (t * poly[3] + poly[2]) + poly[1]) + poly[0];
        }

        /**
         * _Find
         * @param animCurve
         * @param time
         * @param segments
         * @param firstSegment
         * @returns {*}
         */

    }, {
        key: '_Find',
        value: function _Find(animCurve, time, segments, firstSegment) {
            var len = void 0,
                mid = void 0,
                low = void 0,
                high = void 0;

            /* use a binary search to find the key */
            var index = 0;
            len = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1;
            var segment = null;
            var stime = 0.0;

            if (len > 0) {
                low = 0;
                high = len - 1;
                do {
                    mid = low + high >> 1;
                    if (mid < len - 1) {
                        segment = firstSegment + mid;
                        stime = segments[segment][Tw2MayaAnimationEngine.AnimSegment.TIME];
                    } else {
                        stime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];
                    }

                    if (time < stime) {
                        high = mid - 1;
                    } else if (time > stime) {
                        low = mid + 1;
                    } else {
                        index = mid;
                        return [true, index];
                    }
                } while (low <= high);
                index = low;
            }
            return [false, index];
        }

        /**
         * Returns the total number of curves
         * @returns {number}
         */

    }, {
        key: 'GetNumberOfCurves',
        value: function GetNumberOfCurves() {
            return this.curves.length;
        }

        /**
         * Gets specific curve's length
         * @property {number} index
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength(index) {
            if (index < 0 || index >= this.curves.length) return 0;
            var curve = this.curves[index];
            var firstSegment = void 0;

            if (curve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                firstSegment = this.bezierSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
            } else {
                firstSegment = this.hermiteSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
            }

            return curve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME] - firstSegment[Tw2MayaAnimationEngine.AnimSegment.TIME];
        }
    }]);

    return Tw2MayaAnimationEngine;
}();

Tw2MayaAnimationEngine.AnimCurveFields = {
    NUM_SEGMENTS: 0,
    SEGMENT_OFFSET: 1,
    END_TIME: 2,
    END_VALUE: 3,
    IN_TANGENT: 4,
    OUT_TANGENT: 5,
    PRE_INFINITY: 6,
    POST_INFINITY: 7,
    IS_WEIGHTED: 8
};

Tw2MayaAnimationEngine.AnimSegment = {
    TIME: 0,
    VALUE: 1
};

Tw2MayaAnimationEngine.HermiteSegment = {
    TIME: 0,
    VALUE: 1,
    COEFF: 2,
    IS_STEP: 3,
    IS_STEP_NEXT: 4
};

Tw2MayaAnimationEngine.BezierSegment = {
    TIME: 0,
    VALUE: 1,
    COEFF: 2,
    POLYY: 3,
    IS_STEP: 4,
    IS_STEP_NEXT: 5,
    IS_LINEAR: 6
};

Tw2MayaAnimationEngine.INFINITY = 0;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _child = __webpack_require__(131);

Object.keys(_child).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _child[key];
    }
  });
});

var _object = __webpack_require__(136);

Object.keys(_object).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _object[key];
    }
  });
});

var _effect = __webpack_require__(140);

Object.keys(_effect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _effect[key];
    }
  });
});

var _item = __webpack_require__(145);

Object.keys(_item).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _item[key];
    }
  });
});

var _EveSpaceScene = __webpack_require__(148);

Object.keys(_EveSpaceScene).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceScene[key];
    }
  });
});

var _EveSOF = __webpack_require__(149);

Object.keys(_EveSOF).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSOF[key];
    }
  });
});

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveChild = __webpack_require__(10);

Object.keys(_EveChild).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChild[key];
    }
  });
});

var _EveChildBillboard = __webpack_require__(132);

Object.keys(_EveChildBillboard).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildBillboard[key];
    }
  });
});

var _EveChildContainer = __webpack_require__(133);

Object.keys(_EveChildContainer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildContainer[key];
    }
  });
});

var _EveChildExplosion = __webpack_require__(134);

Object.keys(_EveChildExplosion).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildExplosion[key];
    }
  });
});

var _EveChildMesh = __webpack_require__(42);

Object.keys(_EveChildMesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildMesh[key];
    }
  });
});

var _EveChildParticleSystem = __webpack_require__(135);

Object.keys(_EveChildParticleSystem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildParticleSystem[key];
    }
  });
});

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Mesh attachment to space object and oriented towards the camera
 *
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveChildBillboard = exports.EveChildBillboard = function (_EveChild) {
    _inherits(EveChildBillboard, _EveChild);

    function EveChildBillboard() {
        _classCallCheck(this, EveChildBillboard);

        var _this = _possibleConstructorReturn(this, (EveChildBillboard.__proto__ || Object.getPrototypeOf(EveChildBillboard)).call(this));

        _this.mesh = null;
        _this._perObjectData = new _core.Tw2BasicPerObjectData(_EveChild2.EveChild.perObjectDataDecl);
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildBillboard, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildBillboard.prototype.__proto__ || Object.getPrototypeOf(EveChildBillboard.prototype), 'Update', this).call(this, dt, parentTransform);

            var viewInverse = _EveChild2.EveChild.global.mat4_0,
                finalScale = _EveChild2.EveChild.global.vec3_0;

            _math.mat4.lookAt(viewInverse, _core.device.eyePosition, this.worldTransform.subarray(12), [0, 1, 0]);
            _math.mat4.transpose(viewInverse, viewInverse);
            _math.mat4.getScaling(finalScale, parentTransform);
            _math.vec3.multiply(finalScale, finalScale, this.scaling);

            this.worldTransform[0] = viewInverse[0] * finalScale[0];
            this.worldTransform[1] = viewInverse[1] * finalScale[0];
            this.worldTransform[2] = viewInverse[2] * finalScale[0];
            this.worldTransform[4] = viewInverse[4] * finalScale[1];
            this.worldTransform[5] = viewInverse[5] * finalScale[1];
            this.worldTransform[6] = viewInverse[6] * finalScale[1];
            this.worldTransform[8] = viewInverse[8] * finalScale[2];
            this.worldTransform[9] = viewInverse[9] * finalScale[2];
            this.worldTransform[10] = viewInverse[10] * finalScale[2];
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveChildBillboard;
}(_EveChild2.EveChild);

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildContainer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _EveChild2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Container for other child effects
 *
 * @parameter {Array.<{}>} objects
 * @parameter {Array.<Tw2CurveSet>} curveSets
 * @class
 */
var EveChildContainer = exports.EveChildContainer = function (_EveChild) {
    _inherits(EveChildContainer, _EveChild);

    function EveChildContainer() {
        _classCallCheck(this, EveChildContainer);

        var _this = _possibleConstructorReturn(this, (EveChildContainer.__proto__ || Object.getPrototypeOf(EveChildContainer)).call(this));

        _this.objects = [];
        _this.curveSets = [];
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */


    _createClass(EveChildContainer, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.objects.length; i++) {
                if ('GetResources' in this.objects[i]) {
                    this.objects[i].GetResources(out);
                }
            }
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildContainer.prototype.__proto__ || Object.getPrototypeOf(EveChildContainer.prototype), 'Update', this).call(this, dt, parentTransform);

            for (var i = 0; i < this.curveSets.length; i++) {
                this.curveSets[i].Update(dt);
            }

            for (var _i = 0; _i < this.objects.length; _i++) {
                this.objects[_i].Update(dt, this.worldTransform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display) {
                for (var i = 0; i < this.objects.length; i++) {
                    this.objects[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }
    }]);

    return EveChildContainer;
}(_EveChild2.EveChild);

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildExplosion = undefined;

var _EveChild2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 'Complex' explosion object. Not implemented.
 * 
 * @class
 */
var EveChildExplosion = exports.EveChildExplosion = function (_EveChild) {
    _inherits(EveChildExplosion, _EveChild);

    function EveChildExplosion() {
        _classCallCheck(this, EveChildExplosion);

        return _possibleConstructorReturn(this, (EveChildExplosion.__proto__ || Object.getPrototypeOf(EveChildExplosion)).call(this));
    }

    return EveChildExplosion;
}(_EveChild2.EveChild);

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildParticleSystem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Particle system attachment to space object
 *
 * @property {Tw2Mesh} mesh
 * @property {Array<Tw2ParticleEmitter>} particleEmitters
 * @property {Array<Tw2ParticleSystem>} particleSystems
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveChildParticleSystem = exports.EveChildParticleSystem = function (_EveChild) {
    _inherits(EveChildParticleSystem, _EveChild);

    function EveChildParticleSystem() {
        _classCallCheck(this, EveChildParticleSystem);

        var _this = _possibleConstructorReturn(this, (EveChildParticleSystem.__proto__ || Object.getPrototypeOf(EveChildParticleSystem)).call(this));

        _this.particleEmitters = [];
        _this.particleSystems = [];
        _this.mesh = null;
        _this._perObjectData = new _core.Tw2BasicPerObjectData(_EveChild2.EveChild.perObjectDataDecl);
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildParticleSystem, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildParticleSystem.prototype.__proto__ || Object.getPrototypeOf(EveChildParticleSystem.prototype), 'Update', this).call(this, dt, parentTransform);

            for (var i = 0; i < this.particleEmitters.length; ++i) {
                this.particleEmitters[i].Update(dt);
            }

            for (var _i = 0; _i < this.particleSystems.length; ++_i) {
                this.particleSystems[_i].Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveChildParticleSystem;
}(_EveChild2.EveChild);

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveEffectRoot = __webpack_require__(137);

Object.keys(_EveEffectRoot).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveEffectRoot[key];
    }
  });
});

var _EveMissile = __webpack_require__(138);

Object.keys(_EveMissile).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveMissile[key];
    }
  });
});

var _EvePlanet = __webpack_require__(139);

Object.keys(_EvePlanet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EvePlanet[key];
    }
  });
});

var _EveShip = __webpack_require__(44);

Object.keys(_EveShip).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveShip[key];
    }
  });
});

var _EveSpaceObject = __webpack_require__(27);

Object.keys(_EveSpaceObject).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceObject[key];
    }
  });
});

var _EveTransform = __webpack_require__(43);

Object.keys(_EveTransform).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTransform[key];
    }
  });
});
Object.defineProperty(exports, 'EveStation', {
  enumerable: true,
  get: function get() {
    return _EveSpaceObject.EveSpaceObject;
  }
});

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveEffectRoot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveEffectRoot root objects for FX, can be put into scene's objects array
 *
 * @property {string} name
 * @property {boolean} display
 * @property {[{}]} curveSets
 * @property {[{}]} effectChildren
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {mat4} localTransform
 * @property {mat4} rotationTransform
 * @property {vec3} boundingSphereCenter
 * @property {number} boundingSphereRadius
 * @property {number} duration
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveEffectRoot = exports.EveEffectRoot = function (_EveObject) {
    _inherits(EveEffectRoot, _EveObject);

    function EveEffectRoot() {
        _classCallCheck(this, EveEffectRoot);

        var _this = _possibleConstructorReturn(this, (EveEffectRoot.__proto__ || Object.getPrototypeOf(EveEffectRoot)).call(this));

        _this.curveSets = [];
        _this.effectChildren = [];
        _this.duration = 0;
        _this.scaling = _math.vec3.fromValues(1, 1, 1);
        _this.rotation = _math.quat.create();
        _this.translation = _math.vec3.create();
        _this.localTransform = _math.mat4.create();
        _this.rotationTransform = _math.mat4.create();
        _this.boundingSphereCenter = _math.vec3.create();
        _this.boundingSphereRadius = 0;
        _this._perObjectData = new _core.Tw2PerObjectData(EveEffectRoot.perObjectDataDecl);
        return _this;
    }

    /**
     * Gets effect root res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2EffectRes|Tw2TextureRes>} [out]
     */


    _createClass(EveEffectRoot, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.effectChildren.length; ++i) {
                this.effectChildren[i].GetResources(out);
            }
            return out;
        }

        /**
         * Internal per frame update
         * @param {number} dt - Delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            _math.quat.normalize(this.rotation, this.rotation); // Don't really need to normalize...
            _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);

            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            for (var _i = 0; _i < this.effectChildren.length; ++_i) {
                this.effectChildren[_i].Update(dt, this.localTransform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display) return;

            for (var i = 0; i < this.effectChildren.length; ++i) {
                this.effectChildren[i].GetBatches(mode, accumulator, this._perObjectData);
            }
        }

        /**
         * Starts playing the effectRoot's curveSets if they exist
         */

    }, {
        key: 'Start',
        value: function Start() {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Play();
            }
        }

        /**
         * Stops the effectRoot's curveSets from playing
         */

    }, {
        key: 'Stop',
        value: function Stop() {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Stop();
            }
        }
    }]);

    return EveEffectRoot;
}(_EveObject2.EveObject);

/**
 * Per object data declarations
 * @type {{VSData: *[], PSData: *[]}}
 */


EveEffectRoot.perObjectDataDecl = {
    VSData: [{ name: 'WorldMat', size: 16 }, { name: 'WorldMatLast', size: 16 }, { name: 'Shipdata', size: 4 }, { name: 'Clipdata1', size: 4 }, { name: 'EllipsoidRadii', size: 4 }, { name: 'EllipsoidCenter', size: 4 }, { name: 'CustomMaskMatrix0', size: 16 }, { name: 'CustomMaskMatrix1', size: 16 }, { name: 'CustomMaskData0', size: 4 }, { name: 'CustomMaskData1', size: 4 }, { name: 'JointMat', size: 696 }],
    PSData: [{ name: 'Shipdata', size: 4 }, { name: 'Clipdata1', size: 4 }, { name: 'Clipdata2', size: 4 }, { name: 'ShLighting', size: 4 * 7 }, { name: 'CustomMaskMaterialID0', size: 4 }, { name: 'CustomMaskMaterialID1', size: 4 }, { name: 'CustomMaskTarget0', size: 4 }, { name: 'CustomMaskTarget1', size: 4 }]
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveMissile = exports.EveMissileWarhead = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveMissileWarhead
 *
 * @property {String} name
 * @property {Boolean} display
 * @property {Tw2Mesh} mesh
 * @property {EveSpriteSet} spriteSet
 * @property {Number} state
 * @property {Number} time
 * @property {Number} durationEjectPhase
 * @property {Number} startEjectVelocity
 * @property {Number} acceleration
 * @property {Number} maxExplosionDistance
 * @property {Number} impactSize
 * @property {Number} impactDuration
 * @property {vec3} pathOffset
 * @property {mat4} transform
 * @property {vec3} velocity
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveMissileWarhead = exports.EveMissileWarhead = function (_EveObject) {
    _inherits(EveMissileWarhead, _EveObject);

    function EveMissileWarhead() {
        _classCallCheck(this, EveMissileWarhead);

        var _this = _possibleConstructorReturn(this, (EveMissileWarhead.__proto__ || Object.getPrototypeOf(EveMissileWarhead)).call(this));

        _this.mesh = null;
        _this.spriteSet = null;
        _this.state = EveMissileWarhead.State.READY;
        _this.time = 0;
        _this.durationEjectPhase = 0;
        _this.startEjectVelocity = 0;
        _this.acceleration = 1;
        _this.maxExplosionDistance = 40;
        _this.impactSize = 0;
        _this.impactDuration = 0.6;
        _this.pathOffset = _math.vec3.create();
        _this.transform = _math.mat4.create();
        _this.velocity = _math.vec3.create();
        _this._perObjectData = new _core.Tw2PerObjectData(EveMissileWarhead.perObjectDataDecl);

        EveMissile.init();
        return _this;
    }

    /**
     * Initializes the warhead
     */


    _createClass(EveMissileWarhead, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.spriteSet) this.spriteSet.UseQuads(true);
        }

        /**
         * Sets up the warhead for rendering
         * @param {mat4} transform - Initial local to world transform
         */

    }, {
        key: 'Launch',
        value: function Launch(transform) {
            _math.mat4.copy(this.transform, transform);
            this.velocity[0] = transform[8] * this.startEjectVelocity;
            this.velocity[1] = transform[9] * this.startEjectVelocity;
            this.velocity[2] = transform[10] * this.startEjectVelocity;
            this.time = 0;
            this.state = EveMissileWarhead.State.IN_FLIGHT;
        }

        /**
         * Creates a clone of the warhead
         * @returns {EveMissileWarhead}
         */

    }, {
        key: 'Clone',
        value: function Clone() {
            var warhead = new EveMissileWarhead();
            warhead.mesh = this.mesh;
            warhead.spriteSet = this.spriteSet;
            return warhead;
        }

        /**
         * Gets warhead resources
         * @param {Array} [out=[]] - Receiving array
         * @returns {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.mesh) this.mesh.GetResources(out);
            if (this.spriteSet) this.spriteSet.GetResources(out);
        }

        /**
         * Per frame view dependent data update
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            if (!this.display || this.state === EveMissileWarhead.State.DEAD) return;
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);
        }

        /**
         * Per frame update
         * @param {Number} dt - Time since previous frame
         * @param {vec3} missilePosition - Missile position
         * @param {vec3} missileTarget - Missile target position
         */

    }, {
        key: 'Update',
        value: function Update(dt, missilePosition, missileTarget) {
            if (this.state === EveMissileWarhead.State.IN_FLIGHT) {
                var g = EveMissile.global,
                    position = _math.mat4.getTranslation(g.vec3_0, this.transform),
                    tmp = g.vec3_1,
                    x = g.vec3_2,
                    y = g.vec3_3;

                this.time += dt;
                if (this.time > this.durationEjectPhase) {
                    _math.vec3.subtract(position, this.velocity, missilePosition);
                    _math.vec3.lerp(position, position, missilePosition, 1 - Math.exp(-dt * 0.9999));
                    _math.mat4.setTranslation(this.transform, position);
                    _math.vec3.subtract(tmp, missileTarget, position);
                    if (_math.vec3.length(tmp) < this.maxExplosionDistance) {
                        console.log(position, tmp);
                        this.state = EveMissileWarhead.State.DEAD;
                    }
                } else {
                    _math.vec3.scale(tmp, this.velocity, dt);
                    this.transform[12] += tmp[0];
                    this.transform[13] += tmp[1];
                    this.transform[14] += tmp[2];
                }

                var z = _math.vec3.normalize(tmp, this.velocity);

                if (Math.abs(z[0]) < 0.99) {
                    _math.vec3.cross(x, z, [1, 0, 0]);
                } else {
                    _math.vec3.cross(x, z, [0, 1, 0]);
                }

                _math.vec3.normalize(x, x);
                _math.vec3.cross(y, x, z);
                this.transform[0] = x[0];
                this.transform[1] = x[1];
                this.transform[2] = x[2];
                this.transform[4] = y[0];
                this.transform[5] = y[1];
                this.transform[6] = y[2];
                this.transform[8] = z[0];
                this.transform[9] = z[1];
                this.transform[10] = z[2];
            }

            if (this.spriteSet) {
                this.spriteSet.Update(dt);
            }
        }

        /**
         * Accumulates render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh && this.state !== EveMissileWarhead.State.DEAD) {
                if (this.mesh) {
                    this.mesh.GetBatches(mode, accumulator, this._perObjectData);
                }

                if (this.spriteSet) {
                    this.spriteSet.GetBatches(mode, accumulator, this._perObjectData, this.transform);
                }
            }
        }
    }]);

    return EveMissileWarhead;
}(_EveObject2.EveObject);

/**
 * Raw per object data
 * @type {{VSData: *[], PSData: *[]}}
 */


EveMissileWarhead.perObjectDataDecl = {
    VSData: [{ name: 'WorldMat', size: 16 }, { name: 'WorldMatLast', size: 16 }, { name: 'Shipdata', size: 4, value: [0, 1, 0, -10] }, { name: 'Clipdata1', size: 4 }],
    PSData: [{ name: 'Shipdata', size: 4, value: [0, 1, 0, 1] }, { name: 'Clipdata1', size: 4 }, { name: 'Clipdata2', size: 4 }]
};

/**
 * Missile warhead states
 * @type {{READY: number, IN_FLIGHT: number, DEAD: number}}
 */
EveMissileWarhead.State = {
    READY: 0,
    IN_FLIGHT: 1,
    DEAD: 2
};

/**
 * EveMissile
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {Boolean} display
 * @property {Array} warheads
 * @property {Array} curveSets
 * @property {vec3} boundingSphereCenter
 * @property {Number} boundingSphereRadius
 * @property {vec3} position
 * @property {vec3} target
 * @property {Number} speed
 * @property {?function(EveMissileWarhead): void} warheadExplosionCallback
 * @property {?function(EveMissile): void} missileFinishedCallback
 * @class
 */

var EveMissile = exports.EveMissile = function () {
    function EveMissile() {
        _classCallCheck(this, EveMissile);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.warheads = [];
        this.curveSets = [];
        this.speed = 1;
        this.position = _math.vec3.create();
        this.target = _math.vec3.create();
        this.boundingSphereCenter = _math.vec3.create();
        this.boundingSphereRadius = 0;
        this.warheadExplosionCallback = null;
        this.missileFinishedCallback = null;

        EveMissile.init();
    }

    /**
     * Prepares missile for rendering
     * @param {vec3} position - Missile starting position
     * @param {Array} turretTransforms - Turret muzzle local to world transforms
     * @param {vec3} target - Target position
     */


    _createClass(EveMissile, [{
        key: 'Launch',
        value: function Launch(position, turretTransforms, target) {
            _math.vec3.copy(this.position, position);
            _math.vec3.copy(this.target, target);

            if (this.warheads.length > turretTransforms.length) {
                this.warheads.splice(turretTransforms.length);
            } else {
                while (this.warheads.length < turretTransforms.length) {
                    this.warheads.push(this.warheads[0].Clone());
                }
            }

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[0].Launch(turretTransforms[i]);
            }
        }

        /**
         * Gets missile res objects
         * @param {Array} [out=[]] - Receiving array
         * @returns {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].GetResources(out);
            }
        }

        /**
         * Per frame view dependent data update
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - Time since previous frame
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            var tmp = _math.vec3.subtract(EveMissile.global.vec3_0, this.target, this.position),
                distance = _math.vec3.length(tmp);

            if (distance > 0.1) {
                _math.vec3.normalize(tmp, tmp);
                _math.vec3.scale(tmp, tmp, Math.min(dt * this.speed, distance));
                _math.vec3.add(this.position, this.position, tmp);
            }

            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            var checkDead = false;
            for (var _i = 0; _i < this.warheads.length; ++_i) {
                var state = this.warheads[_i].state;
                this.warheads[_i].Update(dt, this.position, this.target);
                if (state !== EveMissileWarhead.State.DEAD && this.warheads[_i].state === EveMissileWarhead.State.DEAD) {
                    if (this.warheadExplosionCallback) {
                        this.warheadExplosionCallback(this.warheads[_i]);
                    }
                    checkDead = true;
                }
            }

            if (checkDead && this.missileFinishedCallback) {
                for (var _i2 = 0; _i2 < this.warheads.length; ++_i2) {
                    if (this.warheads[_i2].state !== EveMissileWarhead.State.DEAD) {
                        return;
                    }
                }
                this.missileFinishedCallback(this);
            }
        }

        /**
         * Accumulates render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display) return;

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].GetBatches(mode, accumulator);
            }
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveMissile.global) {
                EveMissile.global = {
                    vec3_0: _math.vec3.create(),
                    vec3_1: _math.vec3.create(),
                    vec3_2: _math.vec3.create(),
                    vec3_3: _math.vec3.create()
                };
            }
        }
    }]);

    return EveMissile;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveMissile.global = null;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvePlanet = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _EveTransform = __webpack_require__(43);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EvePlanet
 *
 * @property {string} name
 * @property {boolean} display
 * @property {EveTransform} highDetail
 * @property {Tw2Effect} effectHeight
 * @property {Tw2RenderTarget} heightMap
 * @property {*} zOnlyModel
 * @property {number} itemID
 * @property {string} heightMapResPath1
 * @property {string} heightMapResPath2
 * @property {boolean} heightDirty
 * @property {Array} lockedResources
 * @property {Array.<Resource>} watchedResources
 * @class
 */
var EvePlanet = exports.EvePlanet = function (_EveObject) {
    _inherits(EvePlanet, _EveObject);

    function EvePlanet() {
        _classCallCheck(this, EvePlanet);

        var _this = _possibleConstructorReturn(this, (EvePlanet.__proto__ || Object.getPrototypeOf(EvePlanet)).call(this));

        _this.highDetail = new _EveTransform.EveTransform();
        _this.effectHeight = new _core.Tw2Effect();
        _this.heightMap = new _core.Tw2RenderTarget();
        _this.zOnlyModel = null;
        _this.itemID = 0;
        _this.heightMapResPath1 = '';
        _this.heightMapResPath2 = '';
        _this.heightDirty = false;
        _this.lockedResources = [];
        _this.watchedResources = [];
        return _this;
    }

    /**
     * Creates the planet
     * @param {number} itemID - the item id is used for randomization
     * @param {string} planetPath - .red file for a planet, or planet template
     * @param {string} [atmospherePath] - optional .red file for a planet's atmosphere
     * @param {string} heightMap1
     * @param {string} heightMap2
     */


    _createClass(EvePlanet, [{
        key: 'Create',
        value: function Create(itemID, planetPath, atmospherePath, heightMap1, heightMap2) {
            var _this2 = this;

            this.itemID = itemID;
            this.heightMapResPath1 = heightMap1;
            this.heightMapResPath2 = heightMap2;
            this.highDetail.children = [];
            this.heightDirty = true;

            _core.resMan.GetObject(planetPath, function (obj) {
                return EvePlanet.MeshLoaded(_this2, obj);
            });
            _core.resMan.GetObject('res:/dx9/model/worldobject/planet/planetzonly.red', function (obj) {
                return _this2.zOnlyModel = obj;
            });

            if (atmospherePath) {
                _core.resMan.GetObject(atmospherePath, function (obj) {
                    return _this2.highDetail.children.push(obj);
                });
            }
        }

        /**
         * GetPlanetResources
         * Todo: Replace this using this.GetResources();
         * @param obj
         * @param visited
         * @param result
         */

    }, {
        key: 'GetPlanetResources',
        value: function GetPlanetResources(obj, visited, result) {
            if (visited.includes(obj)) return;
            visited.push(obj);

            if (obj && _typeof(obj['doNotPurge']) !== ( true ? 'undefined' : _typeof(undefined))) {
                result.push(obj);
                return;
            }

            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (_typeof(obj[prop]) === 'object') {
                        this.GetPlanetResources(obj[prop], visited, result);
                    }
                }
            }
        }

        /**
         * Gets planet res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.highDetail) this.highDetail.GetResources(out);
            if (this.effectHeight) this.effectHeight.GetResources(out);
            return out;
        }

        /**
         * Updates view dependent data
         * @param {mat4} parentTransform
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData(parentTransform) {
            this.highDetail.UpdateViewDependentData(parentTransform);
            if (this.zOnlyModel) {
                this.zOnlyModel.translation = this.highDetail.translation;
                this.zOnlyModel.scaling = this.highDetail.scaling;
                this.zOnlyModel.UpdateViewDependentData(parentTransform);
            }
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this.highDetail.Update(dt);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.heightDirty && this.watchedResources.length && this.heightMapResPath1 !== '') {
                for (var i = 0; i < this.watchedResources.length; ++i) {
                    if (this.watchedResources[i] && !this.watchedResources[i].IsGood()) return;
                }

                this.watchedResources = [];

                this.heightMap.Set();
                _core.device.SetStandardStates(_core.device.RM_FULLSCREEN);
                _core.device.gl.clearColor(0.0, 0.0, 0.0, 0.0);
                _core.device.gl.clear(_core.device.gl.COLOR_BUFFER_BIT);
                _core.device.RenderFullScreenQuad(this.effectHeight);
                this.heightMap.Unset();

                this.heightDirty = false;
                for (var _i = 0; _i < this.lockedResources.length; ++_i) {
                    this.lockedResources[_i].doNotPurge--;
                }

                var mainMesh = this.highDetail.children[0].mesh;
                var originalEffect = null;

                if (mainMesh.transparentAreas.length) {
                    originalEffect = mainMesh.transparentAreas[0].effect;
                } else if (mainMesh.opaqueAreas.length) {
                    originalEffect = mainMesh.opaqueAreas[0].effect;
                }

                if (originalEffect) {
                    originalEffect.parameters['HeightMap'].textureRes = this.heightMap.texture;
                }
            }

            if (this.display) {
                this.highDetail.GetBatches(mode, accumulator);
            }
        }

        /**
         * Gets z buffer only batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetZOnlyBatches',
        value: function GetZOnlyBatches(mode, accumulator) {
            if (this.display && this.zOnlyModel) {
                this.zOnlyModel.GetBatches(mode, accumulator);
            }
        }

        /**
         * Internal helper function that fires when the planet's mesh has loaded
         * @property {EvePlanet} planet
         * @property {*} obj
         */

    }], [{
        key: 'MeshLoaded',
        value: function MeshLoaded(planet, obj) {
            planet.highDetail.children.unshift(obj);
            planet.lockedResources = [];
            planet.GetPlanetResources(planet.highDetail, [], planet.lockedResources);

            var mainMesh = planet.highDetail.children[0].mesh,
                originalEffect = null,
                resPath = void 0;

            if (mainMesh.transparentAreas.length) {
                originalEffect = mainMesh.transparentAreas[0].effect;
                resPath = originalEffect.effectFilePath;
            } else if (mainMesh.opaqueAreas.length) {
                originalEffect = mainMesh.opaqueAreas[0].effect;
                resPath = originalEffect.effectFilePath;
            } else {
                resPath = 'res:/Graphics/Effect/Managed/Space/Planet/EarthlikePlanet.fx';
            }
            resPath = resPath.replace('.fx', 'BlitHeight.fx');

            planet.watchedResources = [];
            for (var param in originalEffect.parameters) {
                if (originalEffect.parameters.hasOwnProperty(param)) {
                    planet.effectHeight.parameters[param] = originalEffect.parameters[param];
                    if ('textureRes' in originalEffect.parameters[param]) {
                        planet.watchedResources.push(originalEffect.parameters[param].textureRes);
                    }
                }
            }

            for (var i = 0; i < planet.highDetail.children[0].children.length; ++i) {
                mainMesh = planet.highDetail.children[0].children[i].mesh;
                if (!mainMesh) continue;

                originalEffect = null;
                if (mainMesh.transparentAreas.length) {
                    originalEffect = mainMesh.transparentAreas[0].effect;
                } else if (mainMesh.opaqueAreas.length) {
                    originalEffect = mainMesh.opaqueAreas[0].effect;
                } else {
                    continue;
                }

                for (var _param in originalEffect.parameters) {
                    if (originalEffect.parameters.hasOwnProperty(_param)) {
                        planet.effectHeight.parameters[_param] = originalEffect.parameters[_param];
                        if ('textureRes' in originalEffect.parameters[_param]) {
                            planet.watchedResources.push(originalEffect.parameters[_param].textureRes);
                        }
                    }
                }
            }

            var NormalHeight1 = new _core.Tw2TextureParameter('NormalHeight1', planet.heightMapResPath1);
            NormalHeight1.Initialize();
            planet.watchedResources.push(NormalHeight1.textureRes);
            planet.lockedResources.push(NormalHeight1.textureRes);
            planet.effectHeight.parameters.NormalHeight1 = NormalHeight1;

            var NormalHeight2 = new _core.Tw2TextureParameter('NormalHeight2', planet.heightMapResPath2);
            NormalHeight2.Initialize();
            planet.watchedResources.push(NormalHeight2.textureRes);
            planet.lockedResources.push(NormalHeight2.textureRes);
            planet.effectHeight.parameters.NormalHeight2 = NormalHeight2;

            planet.effectHeight.parameters.Random = new _core.Tw2FloatParameter('Random', planet.itemID % 100);
            planet.effectHeight.parameters.TargetTextureHeight = new _core.Tw2FloatParameter('TargetTextureHeight', 1024);

            planet.effectHeight.effectFilePath = resPath;
            planet.effectHeight.Initialize();
            planet.heightDirty = true;
            planet.heightMap.Create(2048, 1024, false);
            planet.watchedResources.push(planet.effectHeight.effectRes);

            for (var _i2 = 0; _i2 < planet.lockedResources.length; ++_i2) {
                planet.lockedResources[_i2].doNotPurge++;
                if (planet.lockedResources[_i2].IsPurged()) {
                    planet.lockedResources[_i2].Reload();
                }
            }
        }
    }]);

    return EvePlanet;
}(_EveObject2.EveObject);

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveLensflare = __webpack_require__(141);

Object.keys(_EveLensflare).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveLensflare[key];
    }
  });
});

var _EveMeshOverlayEffect = __webpack_require__(142);

Object.keys(_EveMeshOverlayEffect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveMeshOverlayEffect[key];
    }
  });
});

var _EveOccluder = __webpack_require__(45);

Object.keys(_EveOccluder).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveOccluder[key];
    }
  });
});

var _EveStretch = __webpack_require__(143);

Object.keys(_EveStretch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveStretch[key];
    }
  });
});

var _EveTurretFiringFX = __webpack_require__(144);

Object.keys(_EveTurretFiringFX).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTurretFiringFX[key];
    }
  });
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveLensflare = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveOccluder = __webpack_require__(45);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveLensFlare
 *
 * @property {number|string} _id
 * @property {String} name=
 * @property {boolean} display
 * @property {boolean} update
 * @property {boolean} doOcclusionQueries
 * @property {number} cameraFactor
 * @property {vec3} position
 * @property {Array} flares
 * @property {Array.<EveOccluder>} occluders
 * @property {Array.<EveOccluder>} backgroundOccluders
 * @property {number} occlusionIntensity
 * @property {number} backgroundOcclusionIntensity
 * @property {Array} distanceToEdgeCurves
 * @property {Array} distanceToCenterCurves
 * @property {Array} radialAngleCurves
 * @property {Array} xDistanceToCenter
 * @property {Array} yDistanceToCenter
 * @property {Array} bindings
 * @property {Array.<Tw2CurveSet> curveSets
 * @property {?Tw2Mesh} mesh
 * @property {vec3} _direction
 * @property {mat4} _transform
 * @property {*} _backBuffer
 * @class
 */
var EveLensflare = exports.EveLensflare = function () {
    function EveLensflare() {
        _classCallCheck(this, EveLensflare);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.update = true;
        this.doOcclusionQueries = true;
        this.cameraFactor = 20;
        this.position = _math.vec3.create();
        this.flares = [];
        this.occluders = [];
        this.backgroundOccluders = [];
        this.occlusionIntensity = 1;
        this.backgroundOcclusionIntensity = 1;
        this.distanceToEdgeCurves = [];
        this.distanceToCenterCurves = [];
        this.radialAngleCurves = [];
        this.xDistanceToCenter = [];
        this.yDistanceToCenter = [];
        this.bindings = [];
        this.curveSets = [];
        this.mesh = null;
        this._direction = _math.vec3.create();
        this._transform = _math.mat4.create();
        this._backBuffer = null;

        EveLensflare.init();
    }

    /**
     * Gets lensflares's res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */


    _createClass(EveLensflare, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.mesh) this.mesh.GetResources(out);

            for (var i = 0; i < this.flares.length; i++) {
                this.flares[i].GetResources(out);
            }

            if (_EveOccluder.EveOccluder.global && _EveOccluder.EveOccluder.global.effect && !out.includes(_EveOccluder.EveOccluder.global.effect)) {
                out.push(_EveOccluder.EveOccluder.global.effect);
            }

            return out;
        }

        /**
         * Updates Occluders
         */

    }, {
        key: 'UpdateOccluders',
        value: function UpdateOccluders() {
            if (!this.doOcclusionQueries) return;

            var g = EveLensflare.global;

            if (!g.occluderLevels[0].texture || g.occluderLevels[0].width < this.occluders.length * 2) {
                for (var i = 0; i < g.occluderLevels.length; ++i) {
                    g.occluderLevels[i].Create(this.occluders.length * 2, 1, false);
                }
            }

            // TODO: Is this deprecated?
            for (var j = 0; j < this.flares.length; ++j) {
                if ('_backBuffer' in this.flares[j]) {
                    this.flares[j]._backBuffer.textureRes = g.occluderLevels.texture;
                }
            }

            this.occlusionIntensity = 1;
            this.backgroundOcclusionIntensity = 1;

            g.occluderLevels[g.occludedLevelIndex].Set();
            _core.device.SetStandardStates(_core.device.RM_OPAQUE);
            _core.device.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            _core.device.gl.clear(_core.device.gl.COLOR_BUFFER_BIT);
            g.occluderLevels[g.occludedLevelIndex].Unset();

            var samples = 1;
            if (_core.device.antialiasing) {
                samples = _core.device.msaaSamples;
                _core.device.gl.sampleCoverage(1.0 / samples, false);
            }

            for (var _i = 0; _i < this.occluders.length; ++_i) {
                _core.device.SetRenderState(_core.device.RS_COLORWRITEENABLE, 8);
                _core.device.gl.colorMask(false, false, false, true);
                _core.device.gl.clearColor(0.0, 0.0, 0.0, 0.0);
                _core.device.gl.clear(_core.device.gl.COLOR_BUFFER_BIT);

                // Turn off antialiasing
                if (_core.device.antialiasing) {
                    _core.device.gl.enable(_core.device.gl.SAMPLE_COVERAGE);
                    _core.device.gl.sampleCoverage(0.25, false);
                }
                this.occluders[_i].UpdateValue(this._transform, _i);
                if (_core.device.antialiasing) _core.device.gl.disable(_core.device.gl.SAMPLE_COVERAGE);

                // Copy back buffer into a texture
                if (!g.backBuffer.texture) g.backBuffer.Attach(_core.device.gl.createTexture());
                _core.device.gl.bindTexture(_core.device.gl.TEXTURE_2D, g.backBuffer.texture);
                if (g.backBuffer.width !== _core.device.viewportWidth || g.backBuffer.height !== _core.device.viewportHeight) {
                    _core.device.gl.texImage2D(_core.device.gl.TEXTURE_2D, 0, _core.device.gl.RGBA, _core.device.viewportWidth, _core.device.viewportHeight, 0, _core.device.gl.RGBA, _core.device.gl.UNSIGNED_BYTE, null);
                    _core.device.gl.texParameteri(_core.device.gl.TEXTURE_2D, _core.device.gl.TEXTURE_MAG_FILTER, _core.device.gl.LINEAR);
                    _core.device.gl.texParameteri(_core.device.gl.TEXTURE_2D, _core.device.gl.TEXTURE_MIN_FILTER, _core.device.gl.LINEAR);
                    g.backBuffer.width = _core.device.viewportWidth;
                    g.backBuffer.height = _core.device.viewportHeight;
                }
                _core.device.gl.copyTexImage2D(_core.device.gl.TEXTURE_2D, 0, _core.device.alphaBlendBackBuffer ? _core.device.gl.RGBA : _core.device.gl.RGB, 0, 0, g.backBuffer.width, g.backBuffer.height, 0);
                _core.device.gl.bindTexture(_core.device.gl.TEXTURE_2D, null);

                // Collect samples
                g.occluderLevels[g.occludedLevelIndex].Set();
                _EveOccluder.EveOccluder.CollectSamples(g.backBuffer, _i, g.occluderLevels[0].width / 2, samples);
                g.occluderLevels[g.occludedLevelIndex].Unset();
            }

            if (_core.device.antialiasing) _core.device.gl.sampleCoverage(1, false);

            g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Set();
            var pixels = new Uint8Array(g.occluderLevels[0].width * 4);
            _core.device.gl.readPixels(0, 0, 2, 1, _core.device.gl.RGBA, _core.device.gl.UNSIGNED_BYTE, pixels);
            g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Unset();

            this.occlusionIntensity = 1;
            for (var _i2 = 0; _i2 < g.occluderLevels[0].width * 2; _i2 += 4) {
                this.occlusionIntensity *= pixels[_i2 + 1] ? pixels[_i2] / pixels[_i2 + 1] : 1;
            }

            this.backgroundOcclusionIntensity = this.occlusionIntensity;
            _math.vec3.set(_core.store.GetVariable('LensflareFxOccScale').value, this.occlusionIntensity, this.occlusionIntensity, 0, 0);
            g.occludedLevelIndex = (g.occludedLevelIndex + 1) % g.occluderLevels.length;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display) {
                var viewDir = _math.vec4.set(EveLensflare.global.vec4_0, 0, 0, 1, 0);
                _math.vec4.transformMat4(viewDir, viewDir, _core.device.viewInverse);
                if (_math.vec3.dot(viewDir, this._direction) < 0) return;

                for (var i = 0; i < this.flares.length; ++i) {
                    this.flares[i].GetBatches(mode, accumulator, perObjectData);
                }

                if (this.mesh) {
                    this.mesh.GetBatches(mode, accumulator, perObjectData);
                }
            }
        }

        /**
         * Prepares the lensflare for rendering
         */

    }, {
        key: 'PrepareRender',
        value: function PrepareRender() {
            if (!this.display) return;

            var g = EveLensflare.global,
                viewDir = g.vec4_0,
                cameraPos = g.vec3_0,
                scaleMat = _math.mat4.identity(g.mat4_0),
                cameraSpacePos = g.vec3_2,
                negDirVec = g.vec3_3,
                negPos = g.vec3_1,
                dist = g.vec4_1;

            _math.vec3.transformMat4(cameraPos, [0, 0, 0], _core.device.viewInverse);
            if (_math.vec3.length(this.position) === 0) {
                _math.vec3.negate(negPos, cameraPos);
                //let distScale = vec3.length(negPos);
                //distScale = distScale > 1.5 ? 1 / Math.log(distScale) : 2.5;
            } else {
                _math.vec3.negate(negPos, this.position);
                _math.vec3.normalize(this._direction, negPos);
            }

            _math.vec4.transformMat4(viewDir, [0, 0, 1, 0], _core.device.viewInverse);
            _math.vec3.scaleAndAdd(cameraSpacePos, cameraPos, viewDir, -this.cameraFactor);
            _math.vec3.negate(negDirVec, this._direction);
            _math.mat4.arcFromForward(this._transform, negDirVec);
            _math.mat4.setTranslation(this._transform, cameraSpacePos);
            _math.mat4.scale(scaleMat, scaleMat, [this.occlusionIntensity, this.occlusionIntensity, 1]);
            //mat4.multiply(scaleMat, scaleMat, this._transform);

            var dir = this._direction;
            _math.vec4.set(_core.store.GetVariable('LensflareFxDirectionScale').value, dir[0], dir[1], dir[2], 1);
            _math.vec4.set(dist, dir[0], dir[1], dir[2], 0);
            _math.vec4.transformMat4(dist, dist, _core.device.view);
            _math.vec4.transformMat4(dist, dist, _core.device.projection);
            dist[0] /= dist[3];
            dist[1] /= dist[3];

            var distToEdge = 1 - Math.min(1 - Math.abs(dist[0]), 1 - Math.abs(dist[1])),
                distToCenter = Math.sqrt(dist[0] * dist[0] + dist[1] * dist[1]),
                radialAngle = Math.atan2(dist[1], dist[0]) + Math.PI;

            for (var i = 0; i < this.distanceToEdgeCurves.length; ++i) {
                this.distanceToEdgeCurves[i].UpdateValue(distToEdge);
            }

            for (var _i3 = 0; _i3 < this.distanceToCenterCurves.length; ++_i3) {
                this.distanceToCenterCurves[_i3].UpdateValue(distToCenter);
            }

            for (var _i4 = 0; _i4 < this.radialAngleCurves.length; ++_i4) {
                this.radialAngleCurves[_i4].UpdateValue(radialAngle);
            }

            for (var _i5 = 0; _i5 < this.xDistanceToCenter.length; ++_i5) {
                this.xDistanceToCenter[_i5].UpdateValue(dist[0] + 10);
            }

            for (var _i6 = 0; _i6 < this.yDistanceToCenter.length; ++_i6) {
                this.yDistanceToCenter[_i6].UpdateValue(dist[1] + 10);
            }

            for (var _i7 = 0; _i7 < this.bindings.length; ++_i7) {
                this.bindings[_i7].CopyValue();
            }

            for (var _i8 = 0; _i8 < this.flares.length; ++_i8) {
                this.flares[_i8].UpdateViewDependentData(this._transform);
            }
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveLensflare.global) {
                var g = EveLensflare.global = {};
                g.vec3_0 = _math.vec3.create();
                g.vec3_1 = _math.vec3.create();
                g.vec3_2 = _math.vec3.create();
                g.vec3_3 = _math.vec3.create();
                g.vec4_0 = _math.vec4.create();
                g.vec4_1 = _math.mat4.create();
                g.mat4_0 = _math.mat4.create();

                g.backBuffer = new _core.Tw2TextureRes();
                g.backBuffer.width = 0;
                g.backBuffer.height = 0;
                g.backBuffer.hasMipMaps = false;
                g.occludedLevelIndex = 0;
                g.occluderLevels = [new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget()];
            }
        }
    }]);

    return EveLensflare;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveLensflare.global = null;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveMeshOverlayEffect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Constructor for Overlay Effects
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display                     - Enables/ disables all batch accumulations
 * @property {{}} visible                          - Batch accumulation options for the overlay effect
 * @property {boolean} visible.opaqueEffects       - Enables/ disables opaque effect batch accumulation
 * @property {boolean} visible.decalEffects        - Enables/ disables decal effect batch accumulation
 * @property {boolean} visible.transparentEffects  - Enables/ disables transparent effect batch accumulation
 * @property {boolean} visible.additiveEffects     - Enables/ disables additive effect batch accumulation
 * @property {boolean} visible.distortionEffects   - Currently not supported
 * @property {boolean} update
 * @property {Tw2CurveSet} curveSet
 * @property {Array.<Tw2Effect>} opaqueEffects
 * @property {Array.<Tw2Effect>} decalEffects
 * @property {Array.<Tw2Effect>} transparentEffects
 * @property {Array.<Tw2Effect>} additiveEffects
 * @property {Array.<Tw2Effect>} distortionEffects - Currently not supported

 * @class
 */
var EveMeshOverlayEffect = exports.EveMeshOverlayEffect = function () {
    function EveMeshOverlayEffect() {
        _classCallCheck(this, EveMeshOverlayEffect);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.visible = {};
        this.visible.opaqueEffects = true;
        this.visible.decalEffects = true;
        this.visible.transparentEffects = true;
        this.visible.additiveEffects = true;
        this.visible.distortionEffects = false;
        this.update = true;
        this.curveSet = null;
        this.opaqueEffects = [];
        this.decalEffects = [];
        this.transparentEffects = [];
        this.additiveEffects = [];
        this.distortionEffects = [];
    }

    /**
     * Gets the mesh overlay's resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */


    _createClass(EveMeshOverlayEffect, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            _math.util.perArrayChild(this.opaqueEffects, 'GetResources', out);
            _math.util.perArrayChild(this.decalEffects, 'GetResources', out);
            _math.util.perArrayChild(this.transparentEffects, 'GetResources', out);
            _math.util.perArrayChild(this.additiveEffects, 'GetResources', out);
            _math.util.perArrayChild(this.distortionEffects, 'GetResources', out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt - delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this.update && this.curveSet) this.curveSet.Update(dt);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {Tw2Mesh} mesh
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData, mesh) {
            if (!this.display || !mesh || !mesh.geometryResource) return;

            var effects = this.GetEffects(mode);
            for (var i = 0; i < effects.length; i++) {
                var batch = new _core.Tw2GeometryBatch();
                batch.renderMode = mode;
                batch.perObjectData = perObjectData;
                batch.geometryRes = mesh.geometryResource;
                batch.meshIx = mesh.meshIndex;
                batch.start = 0;
                batch.count = mesh.geometryResource.meshes[mesh.meshIndex].areas.length;
                batch.effect = effects[i];
                accumulator.Commit(batch);
            }
        }

        /**
         * Gets effects
         * @param {number} mode
         * @returns {Array.<Tw2Effect>}
         */

    }, {
        key: 'GetEffects',
        value: function GetEffects(mode) {
            if (this.display) {
                switch (mode) {
                    case _core.device.RM_OPAQUE:
                        if (this.visible.opaqueEffects) return this.opaqueEffects;
                        break;

                    case _core.device.RM_TRANSPARENT:
                        if (this.visible.transparentEffects) return this.transparentEffects;
                        break;

                    case _core.device.RM_ADDITIVE:
                        if (this.visible.additiveEffects) return this.additiveEffects;
                        break;

                    case _core.device.RM_DECAL:
                        if (this.visible.decalEffects) return this.decalEffects;
                        break;
                }
            }
            return [];
        }
    }]);

    return EveMeshOverlayEffect;
}();

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveStretch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveStretch
 *
 * @property {String} name
 * @property {boolean} display
 * @property {boolean} update
 * @property {*} source
 * @property {*} dest
 * @property {*} sourceObject
 * @property {*} destObject
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {Tw2Float} length
 * @property {number} _time
 * @property {boolean} _useTransformsForStretch
 * @property {vec3} _sourcePosition
 * @property {vec3} _destinationPosition
 * @property {boolean} _displaySourceObject
 * @property {mat4} _sourceTransform
 * @property {boolean} _displayDestObject
 * @property {boolean} _useTransformsForStretch
 * @property {boolean} _isNegZForward
 * @class
 */
var EveStretch = exports.EveStretch = function () {
    function EveStretch() {
        _classCallCheck(this, EveStretch);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.update = true;
        this.curveSets = [];
        this.source = null;
        this.dest = null;
        this.sourceObject = null;
        this.destObject = null;
        this.stretchObject = null;
        this.length = new _core.Tw2Float();
        this._time = 0;
        this._useTransformsForStretch = false;
        this._sourcePosition = _math.vec3.create();
        this._destinationPosition = _math.vec3.create();
        this._displaySourceObject = true;
        this._sourceTransform = null;
        this._displayDestObject = true;
        this._useTransformsForStretch = false;
        this._isNegZForward = false;

        EveStretch.init();
    }

    /**
     * Per frame update
     * @param {number} dt - delta time
     */


    _createClass(EveStretch, [{
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            this._time += dt;

            if (this.source) {
                this.source.GetValueAt(this._time, this._sourcePosition);
            } else if (this._useTransformsForStretch) {
                this._sourcePosition[0] = this._sourceTransform[12];
                this._sourcePosition[1] = this._sourceTransform[13];
                this._sourcePosition[2] = this._sourceTransform[14];
            }

            if (this.dest) {
                this.source.GetValueAt(this._time, this._destinationPosition);
            }

            var directionVec = _math.vec3.subtract(EveStretch.global.vec3_0, this._destinationPosition, this._sourcePosition);
            this.length.value = _math.vec3.length(directionVec);
            _math.vec3.normalize(directionVec, directionVec);

            if (this.sourceObject && this._displaySourceObject) {
                this.sourceObject.Update(dt);
            }

            if (this.stretchObject) {
                this.stretchObject.Update(dt);
            }

            if (this.destObject && this._displayDestObject) {
                this.destObject.Update(dt);
            }
        }

        /**
         * Updates view dependent data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            if (!this.display) return;

            var g = EveStretch.global,
                directionVec = _math.vec3.subtract(g.vec3_0, this._destinationPosition, this._sourcePosition),
                m = _math.mat4.identity(g.mat4_0),
                x = _math.vec3.set(g.vec3_1, 0, 0, 0),
                up = _math.vec3.set(g.vec3_2, 0, 0, 0),
                s = _math.mat4.identity(g.mat4_1);

            var scalingLength = _math.vec3.length(directionVec);
            _math.vec3.normalize(directionVec, directionVec);

            if (this._useTransformsForStretch) {
                _math.mat4.rotateX(m, m, -Math.PI / 2);
                _math.mat4.multiply(m, this._sourceTransform, m);
            } else {
                if (Math.abs(directionVec[1]) > 0.9) {
                    up[2] = 1;
                } else {
                    up[1] = 1;
                }
                _math.vec3.cross(x, up, directionVec);
                _math.vec3.normalize(x, x);
                _math.vec3.cross(up, directionVec, x);
                m[0] = x[0];
                m[1] = x[1];
                m[2] = x[2];
                m[4] = -directionVec[0];
                m[5] = -directionVec[1];
                m[6] = -directionVec[2];
                m[8] = up[0];
                m[9] = up[1];
                m[10] = up[2];
            }
            if (this.destObject && this._displayDestObject) {
                _math.mat4.setTranslation(m, this._destinationPosition);
                this.destObject.UpdateViewDependentData(m);
            }
            if (this.sourceObject && this._displaySourceObject) {
                if (this._useTransformsForStretch) {
                    _math.mat4.identity(m);
                    _math.mat4.rotateX(m, m, -Math.PI / 2);
                    _math.mat4.multiply(m, this._sourceTransform, m);
                } else {
                    _math.mat4.setTranslation(m, this._sourcePosition);
                }
                this.sourceObject.UpdateViewDependentData(m);
            }

            if (this.stretchObject) {
                if (this._useTransformsForStretch) {
                    _math.mat4.identity(m);
                    _math.mat4.scale(m, m, [1, 1, scalingLength]);
                    _math.mat4.multiply(m, this._sourceTransform, m);
                } else {
                    m[0] = x[0];
                    m[1] = x[1];
                    m[2] = x[2];
                    m[4] = up[0];
                    m[5] = up[1];
                    m[6] = up[2];
                    m[8] = -directionVec[0];
                    m[9] = -directionVec[1];
                    m[10] = -directionVec[2];
                    if (this._isNegZForward) scalingLength = -scalingLength;
                    _math.mat4.scale(s, s, [1, 1, scalingLength]);
                    _math.mat4.multiply(m, m, s);
                }
                this.stretchObject.UpdateViewDependentData(m);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display) return;

            if (this.sourceObject && this._displaySourceObject) {
                this.sourceObject.GetBatches(mode, accumulator, perObjectData);
            }

            if (this.destObject && this._displayDestObject) {
                this.destObject.GetBatches(mode, accumulator, perObjectData);
            }

            if (this.stretchObject) {
                this.stretchObject.GetBatches(mode, accumulator, perObjectData);
            }
        }

        /**
         * Gets source position
         * @param {vec3} position
         */

    }, {
        key: 'SetSourcePosition',
        value: function SetSourcePosition(position) {
            this._useTransformsForStretch = false;
            this._sourcePosition = position;
        }

        /**
         * Sets the destination position
         * @param {vec3} position
         */

    }, {
        key: 'SetDestinationPosition',
        value: function SetDestinationPosition(position) {
            this._destinationPosition = position;
        }

        /**
         * Sets the source transform
         * @param {mat4} transform
         */

    }, {
        key: 'SetSourceTransform',
        value: function SetSourceTransform(transform) {
            this._useTransformsForStretch = true;
            this._sourceTransform = transform;
        }

        /**
         * SetIsNegZForward
         * @param {boolean} isNegZForward
         */

    }, {
        key: 'SetIsNegZForward',
        value: function SetIsNegZForward(isNegZForward) {
            this._isNegZForward = isNegZForward;
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveStretch.global) {
                EveStretch.global = {
                    vec3_0: _math.vec3.create(),
                    vec3_1: _math.vec3.create(),
                    vec3_2: _math.vec3.create(),
                    mat4_0: _math.mat4.create(),
                    mat4_1: _math.mat4.create()
                };
            }
        }
    }]);

    return EveStretch;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveStretch.global = null;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTurretFiringFX = exports.EvePerMuzzleData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EvePerMuzzleData
 * Todo: Remove reference in this.muzzlePosition
 *
 * @param {boolean} started
 * @param {boolean} readyToStart
 * @param muzzlePositionBone
 * @param {mat4} muzzleTransform
 * @param {vec3} muzzlePosition
 * @param {number} currentStartDelay
 * @param {number} constantDelay
 * @param {number} elapsedTime
 * @class
 */
var EvePerMuzzleData = exports.EvePerMuzzleData = function EvePerMuzzleData() {
    _classCallCheck(this, EvePerMuzzleData);

    this._id = _math.util.generateID();
    this.started = false;
    this.readyToStart = false;
    this.muzzlePositionBone = null;
    this.muzzleTransform = _math.mat4.create();
    this.muzzlePosition = this.muzzleTransform.subarray(12, 15);
    this.currentStartDelay = 0;
    this.constantDelay = 0;
    this.elapsedTime = 0;
};

/**
 * EveTurretFiringFX
 *
 * @param {string} name
 * @param {boolean} display
 * @param {Array.<EveStretch>} stretch
 * @param {boolean} useMuzzleTransform
 * @param {boolean} isFiring
 * @param {boolean} isLoopFiring
 * @param {number} firingDelay1
 * @param {number} firingDelay2
 * @param {number} firingDelay3
 * @param {number} firingDelay4
 * @param {number} firingDelay5
 * @param {number} firingDelay6
 * @param {number} firingDelay7
 * @param {number} firingDelay8
 * @param {vec3} endPosition
 * @param {number} _firingDuration
 * @param {Array.<EvePerMuzzleData>} _perMuzzleData
 * @class
 */


var EveTurretFiringFX = exports.EveTurretFiringFX = function () {
    function EveTurretFiringFX() {
        _classCallCheck(this, EveTurretFiringFX);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.stretch = [];
        this.useMuzzleTransform = false;
        this.isFiring = false;
        this.isLoopFiring = false;
        this.firingDelay1 = 0;
        this.firingDelay2 = 0;
        this.firingDelay3 = 0;
        this.firingDelay4 = 0;
        this.firingDelay5 = 0;
        this.firingDelay6 = 0;
        this.firingDelay7 = 0;
        this.firingDelay8 = 0;
        this.endPosition = _math.vec3.create();
        this._firingDuration = 0;
        this._perMuzzleData = [];
    }

    /**
     * Initializes the turret firing fx
     */


    _createClass(EveTurretFiringFX, [{
        key: 'Initialize',
        value: function Initialize() {
            this._firingDuration = this.GetCurveDuration();
            for (var i = 0; i < this.stretch.length; ++i) {
                this._perMuzzleData[i] = new EvePerMuzzleData();
            }if (this._perMuzzleData.length > 0) this._perMuzzleData[0].constantDelay = this.firingDelay1;
            if (this._perMuzzleData.length > 1) this._perMuzzleData[1].constantDelay = this.firingDelay2;
            if (this._perMuzzleData.length > 2) this._perMuzzleData[2].constantDelay = this.firingDelay3;
            if (this._perMuzzleData.length > 3) this._perMuzzleData[3].constantDelay = this.firingDelay4;
            if (this._perMuzzleData.length > 4) this._perMuzzleData[4].constantDelay = this.firingDelay5;
            if (this._perMuzzleData.length > 5) this._perMuzzleData[5].constantDelay = this.firingDelay6;
            if (this._perMuzzleData.length > 6) this._perMuzzleData[6].constantDelay = this.firingDelay7;
            if (this._perMuzzleData.length > 7) this._perMuzzleData[7].constantDelay = this.firingDelay8;
        }

        /**
         * Gets the total curve duration
         * @returns {number}
         */

    }, {
        key: 'GetCurveDuration',
        value: function GetCurveDuration() {
            var maxDuration = 0;
            for (var i = 0; i < this.stretch.length; ++i) {
                var stretch = this.stretch[i];
                for (var j = 0; j < stretch.curveSets.length; ++j) {
                    maxDuration = Math.max(maxDuration, stretch.curveSets[j].GetMaxCurveDuration());
                }
            }
            return maxDuration;
        }

        /**
         * Gets a count of stretch effects
         * @returns {Number}
         */

    }, {
        key: 'GetPerMuzzleEffectCount',
        value: function GetPerMuzzleEffectCount() {
            return this.stretch.length;
        }

        /**
         * Sets muzzle bone id
         * @param {number} index
         * @param bone
         */

    }, {
        key: 'SetMuzzleBoneID',
        value: function SetMuzzleBoneID(index, bone) {
            this._perMuzzleData[index].muzzlePositionBone = bone;
        }

        /**
         * Gets a muzzle's transform
         * @param {number} index
         * @returns {mat4}
         */

    }, {
        key: 'GetMuzzleTransform',
        value: function GetMuzzleTransform(index) {
            return this._perMuzzleData[index].muzzleTransform;
        }

        /**
         * Prepares the firing effect
         * @param {number} delay
         * @param {number} [muzzleID=-1]
         */

    }, {
        key: 'PrepareFiring',
        value: function PrepareFiring(delay) {
            var muzzleID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

            for (var i = 0; i < this.stretch.length; ++i) {
                if (muzzleID < 0 || muzzleID === i) {
                    this._perMuzzleData[i].currentStartDelay = delay + this._perMuzzleData[i].constantDelay;
                    this._perMuzzleData[i].started = false;
                    this._perMuzzleData[i].readyToStart = false;
                    this._perMuzzleData[i].elapsedTime = 0;
                } else {
                    this._perMuzzleData[i].currentStartDelay = Number.MAX_VALUE;
                    this._perMuzzleData[i].started = false;
                    this._perMuzzleData[i].readyToStart = false;
                    this._perMuzzleData[i].elapsedTime = 0;
                }
            }
            this.isFiring = true;
        }

        /**
         * Starts a muzzle effect
         * @param {number} muzzleID
         */

    }, {
        key: 'StartMuzzleEffect',
        value: function StartMuzzleEffect(muzzleID) {
            var stretch = this.stretch[muzzleID];
            for (var i = 0; i < stretch.curveSets.length; ++i) {
                var curveSet = stretch.curveSets[i];
                switch (curveSet.name) {
                    case 'play_start':
                    case 'play_loop':
                        curveSet.PlayFrom(-this._perMuzzleData[muzzleID].currentStartDelay);
                        break;

                    case 'play_stop':
                        curveSet.Stop();
                        break;
                }
            }
            this._perMuzzleData[muzzleID].started = true;
            this._perMuzzleData[muzzleID].readyToStart = false;
        }

        /**
         * Stops the firing effect
         */

    }, {
        key: 'StopFiring',
        value: function StopFiring() {
            for (var j = 0; j < this.stretch.length; ++j) {
                var stretch = this.stretch[j];
                for (var i = 0; i < stretch.curveSets.length; ++i) {
                    var curveSet = stretch.curveSets[i];
                    switch (curveSet.name) {
                        case 'play_start':
                        case 'play_loop':
                            curveSet.Stop();
                            break;

                        case 'play_stop':
                            curveSet.Play();
                            break;
                    }
                }
                this._perMuzzleData[j].started = false;
                this._perMuzzleData[j].readyToStart = false;
                this._perMuzzleData[j].currentStartDelay = 0;
                this._perMuzzleData[j].elapsedTime = 0;
            }
            this.isFiring = false;
        }

        /**
         * Gets resources
         * @param {Array} [out=[]}
         * @returns {Array<Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.stretch.length; i++) {
                this.stretch[i].GetResources(out);
            }
            return out;
        }

        /**
         * Updates view dependant data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.stretch.length; ++i) {
                this.stretch[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {number} dt - Delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.stretch.length; ++i) {
                if (this._perMuzzleData[i].started) {
                    this._perMuzzleData[i].elapsedTime += dt;
                }

                if (this._perMuzzleData[i].elapsedTime < this._firingDuration || this.isLoopFiring) {
                    if (this.isFiring) {
                        if (!this._perMuzzleData[i].started) {
                            if (this._perMuzzleData[i].readyToStart) {
                                this.StartMuzzleEffect(i);
                                this._perMuzzleData[i].currentStartDelay = 0;
                                this._perMuzzleData[i].elapsedTime = 0;
                            } else {
                                this._perMuzzleData[i].currentStartDelay -= dt;
                            }

                            if (this._perMuzzleData[i].currentStartDelay <= 0) {
                                this._perMuzzleData[i].readyToStart = true;
                            }
                        } else {
                            if (this.useMuzzleTransform) {
                                this.stretch[i].SetSourceTransform(this._perMuzzleData[i].muzzleTransform);
                            } else {
                                this.stretch[i].SetSourcePosition(this._perMuzzleData[i].muzzlePosition);
                            }
                            this.stretch[i].SetDestinationPosition(this.endPosition);
                            this.stretch[i].SetIsNegZForward(true);
                        }
                    }
                }
                this.stretch[i].Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display || !this.isFiring) return;

            for (var i = 0; i < this.stretch.length; ++i) {
                if (this._perMuzzleData[i].started && (this._firingDuration >= this._perMuzzleData[i].elapsedTime || this.isLoopFiring)) {
                    this.stretch[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }
    }]);

    return EveTurretFiringFX;
}();

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveBoosterSet = __webpack_require__(46);

Object.keys(_EveBoosterSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveBoosterSet[key];
    }
  });
});

var _EveCurveLineSet = __webpack_require__(146);

Object.keys(_EveCurveLineSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveCurveLineSet[key];
    }
  });
});

var _EveLocator = __webpack_require__(47);

Object.keys(_EveLocator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveLocator[key];
    }
  });
});

var _EvePlaneSet = __webpack_require__(48);

Object.keys(_EvePlaneSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EvePlaneSet[key];
    }
  });
});

var _EveSpaceObjectDecal = __webpack_require__(49);

Object.keys(_EveSpaceObjectDecal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceObjectDecal[key];
    }
  });
});

var _EveSpotlightSet = __webpack_require__(50);

Object.keys(_EveSpotlightSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpotlightSet[key];
    }
  });
});

var _EveSpriteSet = __webpack_require__(51);

Object.keys(_EveSpriteSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpriteSet[key];
    }
  });
});

var _EveTurretSet = __webpack_require__(147);

Object.keys(_EveTurretSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTurretSet[key];
    }
  });
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveCurveLineSet = EveCurveLineSet;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * EveCurveLineSet
 * @property {String} name
 * @property {Boolean} display
 * @property {Boolean} disableDepth
 * @property {Number} lineWidthFactor
 * @property {Array} lines
 * @property {Array} emptyLineID
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} transform
 * @property {Tw2Effect} lineEffect
 * @property {null|Tw2Effect} pickEffect
 * @property {Boolean} additive
 * @property {Tw2PerObjectData} perObjectData
 * @property {Number} _vertexSize
 * @property {WebGLBuffer} _vertexBuffer
 * @property {Number} _vertexBufferSize
 * @property {Tw2VertexDeclaration} declaration
 * @constructor
 */
function EveCurveLineSet() {
    this.name = '';
    this.display = true;
    this.disableDepth = false;
    this.lineWidthFactor = 1;
    this.lines = [];
    this.emptyLineID = [];

    this.translation = _math.vec3.create();
    this.rotation = _math.quat.create();
    this.scaling = _math.vec3.fromValues(1, 1, 1);
    this.transform = _math.mat4.create();

    this.lineEffect = new _core.Tw2Effect();
    this.lineEffect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/SpecialFX/Lines3D.fx';
    this.lineEffect.parameters['TexMap'] = new _core.Tw2TextureParameter('TexMap', 'res:/texture/global/white.dds.0.png');
    this.lineEffect.parameters['OverlayTexMap'] = new _core.Tw2TextureParameter('OverlayTexMap', 'res:/texture/global/white.dds.0.png');
    this.lineEffect.Initialize();
    this.pickEffect = null;

    this.additive = false;
    this.pickable = true;

    this.perObjectData = new _core.Tw2PerObjectData();
    this.perObjectData.perObjectVSData = new _core.Tw2RawData();
    this.perObjectData.perObjectVSData.Declare('WorldMat', 16);
    this.perObjectData.perObjectVSData.Create();
    this.perObjectData.perObjectPSData = new _core.Tw2RawData();
    this.perObjectData.perObjectPSData.Declare('WorldMat', 16);
    this.perObjectData.perObjectPSData.Create();

    this._vertexSize = 26;
    this._vertexBuffer = null;
    this._vertexBufferSize = 0;
    this.declaration = new _core.Tw2VertexDeclaration();
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 12));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 28));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 3, 44));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 56));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 1, _core.device.gl.FLOAT, 4, 72));
    this.declaration.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 2, _core.device.gl.FLOAT, 4, 88));
    this.declaration.stride = 4 * this._vertexSize;
    this.declaration.RebuildHash();
}

/**
 * Initializes the Curve line set
 */
EveCurveLineSet.prototype.Initialize = function () {
    _math.mat4.fromRotationTranslationScale(this.transform, this.rotation, this.translation, this.scaling);
};

/**
 * Adds a line
 * @param line
 * @returns {Number} Line index
 * @private
 */
EveCurveLineSet.prototype._addLine = function (line) {
    if (this.emptyLineID.length) {
        var index = this.emptyLineID.pop();
        this.lines[index] = line;
        return index;
    }
    this.lines.push(line);
    return this.lines.length - 1;
};

/**
 * Adds a straight line
 * @param {vec3} startPosition
 * @param {quat3} startColor
 * @param {vec3} endPosition
 * @param {quat} endColor
 * @param {Number} lineWidth
 * @returns {Number} line index
 */
EveCurveLineSet.prototype.AddStraightLine = function (startPosition, startColor, endPosition, endColor, lineWidth) {
    var line = {
        type: EveCurveLineSet.LINETYPE_STRAIGHT,
        position1: _math.vec3.clone(startPosition),
        color1: _math.vec4.clone(startColor),
        position2: _math.vec3.clone(endPosition),
        color2: _math.vec4.clone(endColor),
        intermediatePosition: _math.vec3.create(),
        width: lineWidth,
        multiColor: _math.vec4.create(),
        multiColorBorder: -1,
        overlayColor: _math.vec4.create(),
        animationSpeed: 0,
        animationScale: 1,
        numOfSegments: 1
    };
    return this._addLine(line);
};

/**
 * Adds a curved line using cartesian co-ordinates
 * @param {vec3} startPosition
 * @param {quat} startColor
 * @param {vec3} endPosition
 * @param {quat} endColor
 * @param {vec3} middle
 * @param {Number} lineWidth
 * @returns {Number} line index
 */
EveCurveLineSet.prototype.AddCurvedLineCrt = function (startPosition, startColor, endPosition, endColor, middle, lineWidth) {
    var line = {
        type: EveCurveLineSet.LINETYPE_CURVED,
        position1: _math.vec3.clone(startPosition),
        color1: _math.vec4.clone(startColor),
        position2: _math.vec3.clone(endPosition),
        color2: _math.vec4.clone(endColor),
        intermediatePosition: _math.vec3.clone(middle),
        width: lineWidth,
        multiColor: _math.vec4.create(),
        multiColorBorder: -1,
        overlayColor: _math.vec4.create(),
        animationSpeed: 0,
        animationScale: 1,
        numOfSegments: 20
    };
    return this._addLine(line);
};

/**
 * Adds a curved line using spherical co-ordinates
 * @param {vec3} startPosition
 * @param {quat} startColor
 * @param {vec3} endPosition
 * @param {quat} endColor
 * @param {vec3} center
 * @param {vec3} middle
 * @param {Number} lineWidth
 * @returns {Number} line index
 */
EveCurveLineSet.prototype.AddCurvedLineSph = function (startPosition, startColor, endPosition, endColor, center, middle, lineWidth) {
    return this.AddCurvedLineCrt(EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), startPosition, center), startColor, EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), endPosition, center), endColor, EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), middle, center), lineWidth);
};

/**
 * Adds a sphered line using cartesian co-ordinates
 * @param {vec3} startPosition
 * @param {quat} startColor
 * @param {vec3} endPosition
 * @param {quat} endColor
 * @param {vec3} center
 * @param {Number} lineWidth
 * @returns {Number} line index
 */
EveCurveLineSet.prototype.AddSpheredLineCrt = function (startPosition, startColor, endPosition, endColor, center, lineWidth) {
    var line = {
        type: EveCurveLineSet.LINETYPE_SPHERED,
        position1: _math.vec3.clone(startPosition),
        color1: _math.vec4.clone(startColor),
        position2: _math.vec3.clone(endPosition),
        color2: _math.vec4.clone(endColor),
        intermediatePosition: _math.vec3.clone(center),
        width: lineWidth,
        multiColor: _math.vec4.create(),
        multiColorBorder: -1,
        overlayColor: _math.vec4.create(),
        animationSpeed: 0,
        animationScale: 1,
        numOfSegments: 20
    };
    return this._addLine(line);
};

/**
 * Adds a sphered line using spherical co-ordinates
 * @param {vec3} startPosition
 * @param {quat} startColor
 * @param {vec3} endPosition
 * @param {quat} endColor
 * @param {vec3} center
 * @param {Number} lineWidth
 * @returns {Number} line index
 */
EveCurveLineSet.prototype.AddSpheredLineSph = function (startPosition, startColor, endPosition, endColor, center, lineWidth) {
    return this.AddSpheredLineCrt(EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), startPosition, center), startColor, EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), endPosition, center), endColor, center, lineWidth);
};

/**
 * Changes a line's colors
 * @param {Number} lineID
 * @param {quat} startColor
 * @param {quat} endColor
 */
EveCurveLineSet.prototype.ChangeLineColor = function (lineID, startColor, endColor) {
    this.lines[lineID].color1 = startColor;
    this.lines[lineID].color2 = endColor;
};

/**
 * Changes a line's width
 * @param {Number} lineID
 * @param {Number} width
 */
EveCurveLineSet.prototype.ChangeLineWidth = function (lineID, width) {
    this.lines[lineID].width = width;
};

/**
 * Changes a lines start and end positions using Cartesian co-ordinates
 * @param {Number} lineID
 * @param {vec3} startPosition
 * @param {vec3} endPosition
 */
EveCurveLineSet.prototype.ChangeLinePositionCrt = function (lineID, startPosition, endPosition) {
    this.lines[lineID].position1 = startPosition;
    this.lines[lineID].position2 = endPosition;
};

/**
 * Changes a lines start, end and center positions using Spherical co-orindates
 * @param {Number} lineID
 * @param {vec3} startPosition
 * @param {vec3} endPosition
 * @param {vec3} center
 */
EveCurveLineSet.prototype.ChangeLinePositionSph = function (lineID, startPosition, endPosition, center) {
    this.ChangeLinePositionCrt(lineID, EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), startPosition, center), EveCurveLineSet.cartFromSphericalAndCenter(_math.vec3.create(), endPosition, center));
};

/**
 * Changes a line's intermediate position
 * @param {Number} lineID
 * @param {vec3} intermediatePosition
 */
EveCurveLineSet.prototype.ChangeLineIntermediateCrt = function (lineID, intermediatePosition) {
    this.lines[lineID].intermediatePosition = intermediatePosition;
};

/**
 * Changes a line's intermediate and middle positions
 * @param {Number} lineID
 * @param {vec3} intermediatePosition
 * @param {vec3} middle
 */
EveCurveLineSet.prototype.ChangeLineIntermediateSph = function (lineID, intermediatePosition, middle) {
    EveCurveLineSet.cartFromSphericalAndCenter(this.lines[lineID].intermediatePosition, intermediatePosition, middle);
};

/**
 * Changes line multi color parameters
 * @param {Number} lineID
 * @param {quat} color
 * @param {Number} border
 */
EveCurveLineSet.prototype.ChangeLineMultiColor = function (lineID, color, border) {
    this.lines[lineID].multiColor = color;
    this.lines[lineID].multiColorBorder = border;
};

/**
 * Changes a line's animation parameters
 * @param {Number} lineID
 * @param {quat} color
 * @param {Number} speed
 * @param {Number} scale
 */
EveCurveLineSet.prototype.ChangeLineAnimation = function (lineID, color, speed, scale) {
    this.lines[lineID].overlayColor = color;
    this.lines[lineID].animationSpeed = speed;
    this.lines[lineID].animationScale = scale;
};

/**
 * Changes a line's segmentation
 * @param {Number} lineID
 * @param {Number} numOfSegments
 */
EveCurveLineSet.prototype.ChangeLineSegmentation = function (lineID, numOfSegments) {
    if (this.lines[lineID].type !== EveCurveLineSet.LINETYPE_STRAIGHT) {
        this.lines[lineID].numOfSegments = numOfSegments;
    }
};

/**
 * Removes a line
 * @param {Number} lineID
 */
EveCurveLineSet.prototype.RemoveLine = function (lineID) {
    this.emptyLineID.push(lineID);
    this.lines[lineID].type = EveCurveLineSet.LINETYPE_INVALID;
};

/**
 * Clears all lines
 */
EveCurveLineSet.prototype.ClearLines = function () {
    this.lines = [];
    this.emptyLineID = [];
};

/**
 * Gets line count
 * @returns {Number}
 * @private
 */
EveCurveLineSet.prototype._lineCount = function () {
    var count = 0;
    for (var i = 0; i < this.lines.length; ++i) {
        if (this.lines[i].type !== EveCurveLineSet.LINETYPE_INVALID) {
            count += this.lines[i].numOfSegments;
        }
    }
    return count;
};

/**
 * Fills color vertices
 * @param lineData
 * @param buffer
 * @param offset
 * @returns {*}
 * @private
 */
EveCurveLineSet.prototype._fillColorVertices = function (lineData, buffer, offset) {
    buffer[offset++] = lineData.multiColor[0];
    buffer[offset++] = lineData.multiColor[1];
    buffer[offset++] = lineData.multiColor[2];
    buffer[offset++] = lineData.multiColor[3];
    buffer[offset++] = lineData.overlayColor[0];
    buffer[offset++] = lineData.overlayColor[1];
    buffer[offset++] = lineData.overlayColor[2];
    buffer[offset++] = lineData.overlayColor[3];
    return offset;
};

/**
 * Writes line vertices to the vertex buffer
 * @param {EveCurveLineSet} self
 * @param {vec3} position1
 * @param {quat} color1
 * @param length1
 * @param {vec3} position2
 * @param {quat} color2
 * @param length2
 * @param {Number} lineID
 * @param buffer
 * @param {Number} offset
 * @private
 */
EveCurveLineSet.prototype._writeLineVerticesToBuffer = function (self, position1, color1, length1, position2, color2, length2, lineID, buffer, offset) {
    var lineData = this.lines[lineID];

    buffer[offset++] = position1[0];
    buffer[offset++] = position1[1];
    buffer[offset++] = position1[2];
    buffer[offset++] = position2[0] - position1[0];
    buffer[offset++] = position2[1] - position1[1];
    buffer[offset++] = position2[2] - position1[2];
    buffer[offset++] = -self.lineWidthFactor * lineData.width;
    buffer[offset++] = 0;
    buffer[offset++] = length1;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color1[0];
    buffer[offset++] = color1[1];
    buffer[offset++] = color1[2];
    buffer[offset++] = color1[3];
    offset = this._fillColorVertices(lineData, buffer, offset);

    buffer[offset++] = position1[0];
    buffer[offset++] = position1[1];
    buffer[offset++] = position1[2];
    buffer[offset++] = position2[0] - position1[0];
    buffer[offset++] = position2[1] - position1[1];
    buffer[offset++] = position2[2] - position1[2];
    buffer[offset++] = self.lineWidthFactor * lineData.width;
    buffer[offset++] = 0;
    buffer[offset++] = length1;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color1[0];
    buffer[offset++] = color1[1];
    buffer[offset++] = color1[2];
    buffer[offset++] = color1[3];
    offset = this._fillColorVertices(lineData, buffer, offset);

    buffer[offset++] = position2[0];
    buffer[offset++] = position2[1];
    buffer[offset++] = position2[2];
    buffer[offset++] = position1[0] - position2[0];
    buffer[offset++] = position1[1] - position2[1];
    buffer[offset++] = position1[2] - position2[2];
    buffer[offset++] = -self.lineWidthFactor * lineData.width;
    buffer[offset++] = 1;
    buffer[offset++] = length2;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color2[0];
    buffer[offset++] = color2[1];
    buffer[offset++] = color2[2];
    buffer[offset++] = color2[3];
    offset = this._fillColorVertices(lineData, buffer, offset);

    buffer[offset++] = position1[0];
    buffer[offset++] = position1[1];
    buffer[offset++] = position1[2];
    buffer[offset++] = position2[0] - position1[0];
    buffer[offset++] = position2[1] - position1[1];
    buffer[offset++] = position2[2] - position1[2];
    buffer[offset++] = self.lineWidthFactor * lineData.width;
    buffer[offset++] = 0;
    buffer[offset++] = length1;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color1[0];
    buffer[offset++] = color1[1];
    buffer[offset++] = color1[2];
    buffer[offset++] = color1[3];
    offset = this._fillColorVertices(lineData, buffer, offset);

    buffer[offset++] = position2[0];
    buffer[offset++] = position2[1];
    buffer[offset++] = position2[2];
    buffer[offset++] = position1[0] - position2[0];
    buffer[offset++] = position1[1] - position2[1];
    buffer[offset++] = position1[2] - position2[2];
    buffer[offset++] = self.lineWidthFactor * lineData.width;
    buffer[offset++] = 1;
    buffer[offset++] = length2;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color2[0];
    buffer[offset++] = color2[1];
    buffer[offset++] = color2[2];
    buffer[offset++] = color2[3];
    offset = this._fillColorVertices(lineData, buffer, offset);

    buffer[offset++] = position2[0];
    buffer[offset++] = position2[1];
    buffer[offset++] = position2[2];
    buffer[offset++] = position1[0] - position2[0];
    buffer[offset++] = position1[1] - position2[1];
    buffer[offset++] = position1[2] - position2[2];
    buffer[offset++] = -self.lineWidthFactor * lineData.width;
    buffer[offset++] = 1;
    buffer[offset++] = length2;
    buffer[offset++] = lineData.multiColorBorder;
    buffer[offset++] = length2 - length1;
    buffer[offset++] = lineData.animationSpeed;
    buffer[offset++] = lineData.animationScale;
    buffer[offset++] = lineID;
    buffer[offset++] = color2[0];
    buffer[offset++] = color2[1];
    buffer[offset++] = color2[2];
    buffer[offset++] = color2[3];
    offset = this._fillColorVertices(lineData, buffer, offset);
};

/**
 * Scratch variables
 */
EveCurveLineSet.scratch = {
    vec3_0: _math.vec3.create(), // start direction
    vec3_1: _math.vec3.create(), // end direction
    vec3_2: _math.vec3.create(), // start direction normalized
    vec3_3: _math.vec3.create(), // end direction normalized
    vec3_4: _math.vec3.create(), // rotationAxis
    vec3_5: _math.vec3.create(), // direction1
    vec3_6: _math.vec3.create(), // direction2
    vec3_7: _math.vec3.create(), // position 1
    vec3_8: _math.vec3.create(), // position 2
    vec3_9: _math.vec3.create(), // tangent1
    vec3_10: _math.vec3.create(), // tangent2
    vec4_0: _math.vec4.create(), // color 1
    vec4_1: _math.vec4.create(), // color 2
    mat4_0: _math.mat4.create() // rotationMatrix
};

/**
 * Updates line changes
 */
EveCurveLineSet.prototype.SubmitChanges = function () {
    var scratch = EveCurveLineSet.scratch;

    this._vertexBuffer = null;
    if (!this.lines.length) {
        return;
    }

    this._vertexBufferSize = this._lineCount();
    var data = new Float32Array(this._vertexBufferSize * 6 * this._vertexSize);
    var offset = 0;

    var startDir = scratch.vec3_0,
        endDir = scratch.vec3_1,
        startDirNrm = scratch.vec3_2,
        endDirNrm = scratch.vec3_3,
        rotationAxis = scratch.vec3_4,
        dir1 = scratch.vec3_5,
        dir2 = scratch.vec3_6,
        pos1 = scratch.vec3_7,
        pos2 = scratch.vec3_8,
        tangent1 = scratch.vec3_9,
        tangent2 = scratch.vec3_10,
        col1 = scratch.vec4_0,
        col2 = scratch.vec4_1,
        rotationMatrix = scratch.mat4_0;

    var j, tmp, segmentFactor;

    for (var i = 0; i < this.lines.length; ++i) {
        var item = this.lines[i];

        switch (item.type) {
            case EveCurveLineSet.LINETYPE_INVALID:
                break;

            case EveCurveLineSet.LINETYPE_STRAIGHT:
                this._writeLineVerticesToBuffer(this, item.position1, item.color1, 0, item.position2, item.color2, 1, i, data, offset);
                offset += 6 * this._vertexSize;
                break;

            case EveCurveLineSet.LINETYPE_SPHERED:
                _math.vec3.subtract(startDir, item.position1, item.intermediatePosition);
                _math.vec3.subtract(endDir, item.position2, item.intermediatePosition);
                _math.vec3.normalize(startDirNrm, startDir);
                _math.vec3.normalize(endDirNrm, endDir);
                _math.vec3.cross(rotationAxis, startDir, endDir);

                var fullAngle = Math.acos(_math.vec3.dot(startDirNrm, endDirNrm));
                var segmentAngle = fullAngle / item.numOfSegments;
                _math.mat4.identity(rotationMatrix);
                _math.mat4.rotate(rotationMatrix, rotationMatrix, segmentAngle, rotationAxis);
                _math.vec3.copy(dir1, startDir);
                _math.vec4.copy(col1, item.color1);

                for (j = 0; j < this.lines[i].numOfSegments; ++j) {
                    segmentFactor = (j + 1) / item.numOfSegments;
                    _math.vec3.transformMat4(dir2, dir1, rotationMatrix);
                    col2[0] = item.color1[0] * (1 - segmentFactor) + item.color2[0] * segmentFactor;
                    col2[1] = item.color1[1] * (1 - segmentFactor) + item.color2[1] * segmentFactor;
                    col2[2] = item.color1[2] * (1 - segmentFactor) + item.color2[2] * segmentFactor;
                    col2[3] = item.color1[3] * (1 - segmentFactor) + item.color2[3] * segmentFactor;
                    _math.vec3.add(pos1, dir1, item.intermediatePosition);
                    _math.vec3.add(pos2, dir2, item.intermediatePosition);
                    this._writeLineVerticesToBuffer(this, pos1, col1, j / this.lines[i].numOfSegments, pos2, col2, segmentFactor, i, data, offset);
                    offset += 6 * this._vertexSize;

                    tmp = dir1;
                    dir1 = dir2;
                    dir2 = tmp;
                    tmp = col1;
                    col1 = col2;
                    col2 = tmp;
                }
                break;

            case EveCurveLineSet.LINETYPE_CURVED:
                _math.vec3.subtract(tangent1, item.intermediatePosition, item.position1);
                _math.vec3.subtract(tangent2, item.position2, item.intermediatePosition);
                _math.vec3.copy(pos1, item.position1);
                _math.vec3.copy(col1, item.color1);

                for (j = 0; j < item.numOfSegments; ++j) {
                    segmentFactor = (j + 1) / item.numOfSegments;
                    _math.vec3.hermite(pos2, item.position1, tangent1, item.position2, tangent2, segmentFactor);
                    col2[0] = item.color1[0] * (1 - segmentFactor) + item.color2[0] * segmentFactor;
                    col2[1] = item.color1[1] * (1 - segmentFactor) + item.color2[1] * segmentFactor;
                    col2[2] = item.color1[2] * (1 - segmentFactor) + item.color2[2] * segmentFactor;
                    col2[3] = item.color1[3] * (1 - segmentFactor) + item.color2[3] * segmentFactor;
                    this._writeLineVerticesToBuffer(this, pos1, col1, j / this.lines[i].numOfSegments, pos2, col2, segmentFactor, i, data, offset);
                    offset += 6 * this._vertexSize;

                    tmp = pos1;
                    pos1 = pos2;
                    pos2 = tmp;
                    tmp = col1;
                    col1 = col2;
                    col2 = tmp;
                }
        }
    }

    if (this._vertexBuffer) {
        _core.device.gl.deleteBuffer(this._vertexBuffer);
    }

    this._vertexBuffer = _core.device.gl.createBuffer();
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
    _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, data, _core.device.gl.STATIC_DRAW);
    _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);
};

EveCurveLineSet.LINETYPE_INVALID = 0;
EveCurveLineSet.LINETYPE_STRAIGHT = 1;
EveCurveLineSet.LINETYPE_SPHERED = 2;
EveCurveLineSet.LINETYPE_CURVED = 3;

/**
 * Accumulates render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 */
EveCurveLineSet.prototype.GetBatches = function (mode, accumulator) {
    if (!this.display || !this._vertexBuffer) {
        return;
    }

    switch (mode) {
        case _core.device.RM_TRANSPARENT:
            if (!this.lineEffect || this.additive) return;
            break;

        case _core.device.RM_ADDITIVE:
            if (!this.lineEffect || !this.additive) return;
            break;

        case _core.device.RM_PICKABLE:
            if (!this.pickEffect || !this.pickable) return;
            break;

        default:
            return;
    }

    var batch = new _core.Tw2ForwardingRenderBatch();
    _math.mat4.transpose(this.perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
    _math.mat4.transpose(this.perObjectData.perObjectPSData.Get('WorldMat'), this.transform);
    batch.perObjectData = this.perObjectData;
    batch.geometryProvider = this;
    batch.renderMode = mode;
    accumulator.Commit(batch);
};

/**
 * Unloads the curve line set vertex buffer
 */
EveCurveLineSet.prototype.Unload = function () {
    if (this._vertexBuffer) {
        _core.device.gl.deleteBuffer(this._vertexBuffer);
        this._vertexBuffer = null;
    }
};

/**
 * Renders lines
 * @param {RenderBatch} batch
 * @param {Tw2Effect} [overrideEffect]
 * @returns {Boolean}
 */
EveCurveLineSet.prototype.Render = function (batch, overrideEffect) {
    var effect = overrideEffect || batch.renderMode === _core.device.RM_PICKABLE ? this.pickEffect : this.lineEffect;
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood) {
        return false;
    }

    var d = _core.device;
    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vertexBuffer);

    if (this.disableDepth) _core.device.gl.disable(_core.device.gl.DEPTH_TEST);

    var passCount = effect.GetPassCount();
    for (var pass = 0; pass < passCount; ++pass) {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (!this.declaration.SetDeclaration(passInput, this.declaration.stride)) {
            return false;
        }
        d.ApplyShadowState();
        d.gl.drawArrays(d.gl.TRIANGLES, 0, this._vertexBufferSize * 6);
    }

    if (this.disableDepth) _core.device.gl.enable(_core.device.gl.DEPTH_TEST);
    return true;
};

/**
 * Per frame update
 */
EveCurveLineSet.prototype.Update = function () {};

/**
 * Per frame view dependent data update
 * @param {mat4} parentTransform
 */
EveCurveLineSet.prototype.UpdateViewDependentData = function (parentTransform) {
    _math.mat4.fromRotationTranslationScale(this.transform, this.rotation, this.translation, this.scaling);
    _math.mat4.multiply(this.transform, this.transform, parentTransform);
};

/**
 * Gets curve line set res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes>} [out]
 */
EveCurveLineSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    this.lineEffect.GetResources(out);

    if (this.pickEffect !== null) {
        this.pickEffect.GetResources(out);
    }

    return out;
};

/**
 * Sets a vec3 with cartesian coordinates converted from a vec3 containing spherical coordinate values
 *
 * @param {vec3} out            - receiving vec3
 * @param {vec3} spherical      - source vec3 with spherical coordinates (phi, theta, radius)
 * @returns {vec3} out          - receiving vec3
 */
EveCurveLineSet.cartFromSpherical = function (out, spherical) {
    var phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];

    out[0] = radius * Math.sin(phi) * Math.sin(theta);
    out[1] = radius * Math.cos(theta);
    out[2] = radius * Math.cos(phi) * Math.sin(theta);
    return out;
};

/**
 * Sets a vec3 with cartesian coordinates from a vec3 containing spherical coordinate values, and a center point
 *
 * @param {vec3} out            - receiving vec3
 * @param {vec3} spherical      - source vec3 with spherical coordinates (phi, theta, radius)
 * @param {vec3} center         - center
 * @returns {vec3} out          - receiving vec3
 */
EveCurveLineSet.cartFromSphericalAndCenter = function (out, spherical, center) {
    var phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];

    out[0] = radius * Math.sin(phi) * Math.sin(theta) + center[0];
    out[1] = radius * Math.cos(theta) + center[1];
    out[2] = radius * Math.cos(phi) * Math.sin(theta) + center[2];
    return out;
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTurretData = EveTurretData;
exports.EveTurretSet = EveTurretSet;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * EveTurretData
 * @property {String} name
 * @property {boolean} visible
 * @property {mat4} localTransform
 * @property {quat} rotation
 * @constructor
 */
function EveTurretData() {
    this.name = '';
    this.visible = true;
    this.localTransform = _math.mat4.create();
    this.rotation = _math.quat.create();
}

/**
 * EveTurretSet
 * @property {boolean} display
 * @property {string} name
 * @property {quat} boundingSphere
 * @property {number} bottomClipHeight
 * @property {string} locatorName
 * @property {Tw2Effect} turretEffect
 * @property {vec3} targetPosition
 * @property {number} sysBoneHeight
 * @property {string} firingEffectResPath
 * @property {EveTurretFiringFX} firingEffect
 * @property {boolean} hasCyclingFiringPos
 * @property {string} geometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @property {Tw2AnimationController} activeAnimation
 * @property {Tw2AnimationController} inactiveAnimation
 * @property {mat4} parentMatrix
 * @property {Array.<EveTurretData>} turrets
 * @property {number} STATE_INACTIVE
 * @property {number} STATE_IDLE
 * @property {number} STATE_FIRING
 * @property {number} STATE_PACKING
 * @property {number} STATE_UNPACKING
 * @property {number} state
 * @property {Tw2PerObjectData} _perObjectDataActive
 * @property {Tw2PerObjectData} _perObjectDataInactive
 * @property {Array.<string>} worldNames
 * @property {number} _activeTurret
 * @property {number} _recheckTimeLeft
 * @property {number} _currentCyclingFiresPos
 * @constructor
 */
function EveTurretSet() {
    this.display = true;
    this.name = '';
    this.boundingSphere = _math.quat.create();
    this.bottomClipHeight = 0;
    this.locatorName = '';
    this.sysBoneHeight = 0;

    this.turrets = [];
    this.turretEffect = null;
    this.targetPosition = _math.vec3.create();
    this.firingEffectResPath = '';
    this.firingEffect = null;
    this.fireCallback = null;
    this.fireCallbackPending = false;

    this.hasCyclingFiringPos = false;
    this.geometryResPath = '';
    this.geometryResource = null;

    this.activeAnimation = new _core.Tw2AnimationController();
    this.inactiveAnimation = new _core.Tw2AnimationController();

    this.parentMatrix = _math.mat4.create();

    this.STATE_INACTIVE = 0;
    this.STATE_IDLE = 1;
    this.STATE_FIRING = 2;
    this.STATE_PACKING = 3;
    this.STATE_UNPACKING = 4;

    this.state = this.STATE_IDLE;

    this._perObjectDataActive = new _core.Tw2PerObjectData();
    this._perObjectDataActive.perObjectVSData = new _core.Tw2RawData();
    this._perObjectDataActive.perObjectVSData.Declare('baseCutoffData', 4);
    this._perObjectDataActive.perObjectVSData.Declare('turretSetData', 4);
    this._perObjectDataActive.perObjectVSData.Declare('shipMatrix', 16);
    this._perObjectDataActive.perObjectVSData.Declare('turretTranslation', 4 * 24);
    this._perObjectDataActive.perObjectVSData.Declare('turretRotation', 4 * 24);
    this._perObjectDataActive.perObjectVSData.Declare('turretPoseTransAndRot', 2 * 4 * 72);
    this._perObjectDataActive.perObjectVSData.Create();

    this._perObjectDataInactive = new _core.Tw2PerObjectData();
    this._perObjectDataInactive.perObjectVSData = new _core.Tw2RawData();
    this._perObjectDataInactive.perObjectVSData.Declare('baseCutoffData', 4);
    this._perObjectDataInactive.perObjectVSData.Declare('turretSetData', 4);
    this._perObjectDataInactive.perObjectVSData.Declare('shipMatrix', 16);
    this._perObjectDataInactive.perObjectVSData.Declare('turretTranslation', 4 * 24);
    this._perObjectDataInactive.perObjectVSData.Declare('turretRotation', 4 * 24);
    this._perObjectDataInactive.perObjectVSData.Declare('turretPoseTransAndRot', 2 * 4 * 72);
    this._perObjectDataInactive.perObjectVSData.Create();

    this.worldNames = ['turretWorld0', 'turretWorld1', 'turretWorld2'];

    this._activeTurret = -1;
    this._recheckTimeLeft = 0;
    this._currentCyclingFiresPos = 0;
}

/**
 * Bone Skeleton Names
 * @type {string[]}
 */
EveTurretSet.positionBoneSkeletonNames = ['Pos_Fire01', 'Pos_Fire02', 'Pos_Fire03', 'Pos_Fire04', 'Pos_Fire05', 'Pos_Fire06', 'Pos_Fire07', 'Pos_Fire08'];

/**
 * Initializes the Turret Set
 */
EveTurretSet.prototype.Initialize = function () {
    if (this.turretEffect && this.geometryResPath !== '') {
        this.geometryResource = _core.resMan.GetResource(this.geometryResPath);
        this.activeAnimation.SetGeometryResource(this.geometryResource);
        this.inactiveAnimation.SetGeometryResource(this.geometryResource);
        if (this.geometryResource) {
            this.geometryResource.RegisterNotification(this);
        }
    }
    if (this.firingEffectResPath !== '') {
        var self = this;
        _core.resMan.GetObject(this.firingEffectResPath, function (object) {
            self.firingEffect = object;
        });
    }
};

/**
 * Gets turret set res objects
 * @param {Array} [out=[]] - Optional receiving array
 * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
 */
EveTurretSet.prototype.GetResources = function (out) {
    if (out === undefined) {
        out = [];
    }

    if (this.geometryResource !== null) {
        if (out.indexOf(this.geometryResource) === -1) {
            out.push(this.geometryResource);
        }
    }

    if (this.turretEffect !== null) {
        this.turretEffect.GetResources(out);
    }

    if (this.firingEffect !== null) {
        this.firingEffect.GetResources(out);
    }

    return out;
};

/**
 * Rebuilds the turret sets cached data
 */
EveTurretSet.prototype.RebuildCachedData = function () {
    var instancedElement = new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 2);
    for (var i = 0; i < this.geometryResource.meshes.length; ++i) {
        this.geometryResource.meshes[i].declaration.elements.push(instancedElement);
        this.geometryResource.meshes[i].declaration.RebuildHash();
    }
    var self = this;
    switch (this.state) {
        case this.STATE_INACTIVE:
            this.activeAnimation.PlayAnimation('Inactive', true);
            this.inactiveAnimation.PlayAnimation('Inactive', true);
            break;
        case this.STATE_IDLE:
            this.activeAnimation.PlayAnimation('Active', true);
            this.inactiveAnimation.PlayAnimation('Active', true);
            break;
        case this.STATE_FIRING:
            this.activeAnimation.PlayAnimation('Fire', false, function () {
                self.activeAnimation.PlayAnimation('Active', true);
            });
            this.inactiveAnimation.PlayAnimation('Active', true);
            break;
        case this.STATE_PACKING:
            this.EnterStateIdle();
            break;
        case this.STATE_UNPACKING:
            this.EnterStateDeactive();
            break;
    }
};

/**
 * Initializes turret set firing effect
 */
EveTurretSet.prototype.InitializeFiringEffect = function () {
    if (!this.firingEffect) {
        return;
    }
    if (this.geometryResource && this.geometryResource.models.length) {
        var model = this.geometryResource.models[0];
        for (var i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
            this.firingEffect.SetMuzzleBoneID(i, model.FindBoneByName(EveTurretSet.positionBoneSkeletonNames[i]));
        }
    }
};

/**
 * Sets the local transform for a specific turret index
 * @param {number} index
 * @param {mat4} localTransform
 * @param {String} locatorName
 */
EveTurretSet.prototype.SetLocalTransform = function (index, localTransform, locatorName) {
    var transform = _math.mat4.clone(localTransform);
    _math.vec3.normalize(transform.subarray(0, 3), transform.subarray(0, 3));
    _math.vec3.normalize(transform.subarray(4, 7), transform.subarray(4, 7));
    _math.vec3.normalize(transform.subarray(8, 11), transform.subarray(8, 11));
    if (index >= this.turrets.length) {
        var data = new EveTurretData();
        data.name = locatorName;
        data.localTransform.set(transform);
        this.turrets[index] = data;
    } else {
        this.turrets[index].localTransform.set(transform);
    }
    mat4toquat(this.turrets[index].localTransform, this.turrets[index].rotation);
};

function mat3x4toquat(mm, index, out, outIndex) {
    index *= 12;
    outIndex *= 4;
    var m = mat3x4toquat._tempMat;
    m[0] = mm[index + 0];
    m[1] = mm[index + 4];
    m[2] = mm[index + 8];
    m[3] = 0;
    m[4] = mm[index + 1];
    m[5] = mm[index + 5];
    m[6] = mm[index + 9];
    m[7] = 0;
    m[8] = mm[index + 2];
    m[9] = mm[index + 6];
    m[10] = mm[index + 10];
    m[11] = 0;
    m[12] = mm[index + 3];
    m[13] = mm[index + 7];
    m[14] = mm[index + 11];
    m[15] = 1;
    var q = mat3x4toquat._tempQuat;
    mat4toquat(m, q);
    out[outIndex] = q[0];
    out[outIndex + 1] = q[1];
    out[outIndex + 2] = q[2];
    out[outIndex + 3] = q[3];
}

mat3x4toquat._tempMat = _math.mat4.create();
mat3x4toquat._tempQuat = _math.quat.create();

function mat4toquat(m, out) {
    out = out || _math.quat.create();
    var trace = m[0] + m[5] + m[10] + 1.0;
    if (trace > 1.0) {
        out[0] = (m[6] - m[9]) / (2.0 * Math.sqrt(trace));
        out[1] = (m[8] - m[2]) / (2.0 * Math.sqrt(trace));
        out[2] = (m[1] - m[4]) / (2.0 * Math.sqrt(trace));
        out[3] = Math.sqrt(trace) / 2.0;
        return out;
    }
    var maxi = 0;
    var maxdiag = m[0];
    for (var i = 1; i < 3; i++) {
        if (m[i * 4 + i] > maxdiag) {
            maxi = i;
            maxdiag = m[i * 4 + i];
        }
    }
    var S;
    switch (maxi) {
        case 0:
            S = 2.0 * Math.sqrt(1.0 + m[0] - m[5] - m[10]);
            out[0] = 0.25 * S;
            out[1] = (m[1] + m[4]) / S;
            out[2] = (m[2] + m[8]) / S;
            out[3] = (m[6] - m[9]) / S;
            break;
        case 1:
            S = 2.0 * Math.sqrt(1.0 + m[5] - m[0] - m[10]);
            out[0] = (m[1] + m[4]) / S;
            out[1] = 0.25 * S;
            out[2] = (m[6] + m[9]) / S;
            out[3] = (m[8] - m[2]) / S;
            break;
        case 2:
            S = 2.0 * Math.sqrt(1.0 + m[10] - m[0] - m[5]);
            out[0] = (m[2] + m[8]) / S;
            out[1] = (m[6] + m[9]) / S;
            out[2] = 0.25 * S;
            out[3] = (m[1] - m[4]) / S;
            break;
    }
    return out;
}

/**
 * Updates per object data
 * @param {Tw2PerObjectData} perObjectData
 * @param transforms
 * @private
 */
EveTurretSet.prototype._UpdatePerObjectData = function (perObjectData, transforms) {
    _math.mat4.transpose(perObjectData.Get('shipMatrix'), this.parentMatrix);
    var transformCount = transforms.length / 12;
    perObjectData.Get('turretSetData')[0] = transformCount;
    perObjectData.Get('baseCutoffData')[0] = this.bottomClipHeight;
    var translation = perObjectData.Get('turretTranslation');
    var rotation = perObjectData.Get('turretRotation');
    var pose = perObjectData.Get('turretPoseTransAndRot');
    for (var i = 0; i < this.turrets.length; ++i) {
        for (var j = 0; j < transformCount; ++j) {
            pose[(i * transformCount + j) * 2 * 4] = transforms[j * 12 + 3];
            pose[(i * transformCount + j) * 2 * 4 + 1] = transforms[j * 12 + 7];
            pose[(i * transformCount + j) * 2 * 4 + 2] = transforms[j * 12 + 11];
            pose[(i * transformCount + j) * 2 * 4 + 3] = 1;
            mat3x4toquat(transforms, j, pose, (i * transformCount + j) * 2 + 1);
        }
        translation[i * 4] = this.turrets[i].localTransform[12];
        translation[i * 4 + 1] = this.turrets[i].localTransform[13];
        translation[i * 4 + 2] = this.turrets[i].localTransform[14];
        translation[i * 4 + 3] = 1;
        rotation[i * 4] = this.turrets[i].rotation[0];
        rotation[i * 4 + 1] = this.turrets[i].rotation[1];
        rotation[i * 4 + 2] = this.turrets[i].rotation[2];
        rotation[i * 4 + 3] = this.turrets[i].rotation[3];
    }
};

/**
 * Gets turret set render batches
 * @param {number} mode
 * @param {Tw2BatchAccumulator} accumulator
 * @param {Tw2PerObjectData} perObjectData
 * @returns {boolean}
 */
EveTurretSet.prototype.GetBatches = function (mode, accumulator, perObjectData) {
    if (!this.turretEffect || this.geometryResource === null || !this.display) {
        return false;
    }
    if (mode === _core.device.RM_OPAQUE) {
        var transforms = this.inactiveAnimation.GetBoneMatrices(0);
        if (transforms.length === 0) {
            return true;
        }
        this._UpdatePerObjectData(this._perObjectDataInactive.perObjectVSData, transforms);
        this._perObjectDataInactive.perObjectPSData = perObjectData.perObjectPSData;

        var batch = new _core.Tw2ForwardingRenderBatch();
        batch.renderMode = mode;
        batch.renderActive = false;
        batch.perObjectData = this._perObjectDataInactive;
        batch.geometryProvider = this;
        accumulator.Commit(batch);

        if (this.state === this.STATE_FIRING) {
            transforms = this.activeAnimation.GetBoneMatrices(0);
            if (transforms.length === 0) {
                return true;
            }
            this._UpdatePerObjectData(this._perObjectDataActive.perObjectVSData, transforms);
            this._perObjectDataActive.perObjectPSData = perObjectData.perObjectPSData;

            batch = new _core.Tw2ForwardingRenderBatch();
            batch.renderActive = true;
            batch.perObjectData = this._perObjectDataActive;
            batch.geometryProvider = this;
            accumulator.Commit(batch);
        }
    }
    if (this.firingEffect) {
        this.firingEffect.GetBatches(mode, accumulator, perObjectData);
    }
    return true;
};

/**
 * Per frame update
 * @param {number} dt - Delta Time
 * @param {mat4} parentMatrix
 */
EveTurretSet.prototype.Update = function (dt, parentMatrix) {
    if (this.turretEffect) {
        this.activeAnimation.Update(dt);
        this.inactiveAnimation.Update(dt);
    }
    _math.mat4.copy(this.parentMatrix, parentMatrix);
    if (this.firingEffect) {
        if (this._activeTurret !== -1) {
            if (this.firingEffect.isLoopFiring) {
                if (this.state === this.STATE_FIRING) {
                    this._recheckTimeLeft -= dt;
                    if (this._recheckTimeLeft <= 0) {
                        this._DoStartFiring();
                    }
                }
            }
            var i;
            if (this.activeAnimation.models.length) {
                var bones = this.activeAnimation.models[0].bonesByName;
                for (i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                    var transform = bones[EveTurretSet.positionBoneSkeletonNames[i]].worldTransform;
                    var out = this.firingEffect.GetMuzzleTransform(i);
                    _math.mat4.multiply(out, this.turrets[this._activeTurret].localTransform, transform);
                    _math.mat4.multiply(out, out, parentMatrix);
                }
            } else {
                for (i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                    _math.mat4.multiply(this.firingEffect.GetMuzzleTransform(i), parentMatrix, this.turrets[this._activeTurret].localTransform);
                }
            }
            if (this.fireCallbackPending) {
                if (this.fireCallback) {
                    var cbTransforms = [];
                    for (i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                        cbTransforms.push(this.firingEffect.GetMuzzleTransform(i));
                    }
                    this.fireCallback(this, cbTransforms);
                }
                this.fireCallbackPending = false;
            }
        }

        _math.vec3.copy(this.firingEffect.endPosition, this.targetPosition);
        this.firingEffect.Update(dt);
    }
};

/**
 * Renders the turret set
 * @param batch
 * @param {Tw2Effect} overrideEffect
 */
EveTurretSet.prototype.Render = function (batch, overrideEffect) {
    var effect = !overrideEffect ? this.turretEffect : overrideEffect;
    var index = 0;
    var customSetter = function customSetter(el) {
        _core.device.gl.disableVertexAttribArray(el.location);
        _core.device.gl.vertexAttrib2f(el.location, index, index);
    };
    for (var i = 0; i < this.geometryResource.meshes.length; ++i) {
        var decl = this.geometryResource.meshes[i].declaration;
        decl.FindUsage(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1).customSetter = customSetter;
    }
    for (; index < this.turrets.length; ++index) {
        if (this.turrets[index].visible) {
            var isActive = this.state === this.STATE_FIRING && index === this._activeTurret;
            if (batch.renderActive === isActive) {
                this.geometryResource.RenderAreas(0, 0, 1, effect);
            }
        }
    }
};

/**
 * Animation helper function for deactivating a turret set
 */
EveTurretSet.prototype.EnterStateDeactive = function () {
    if (this.state === this.STATE_INACTIVE || this.state === this.STATE_PACKING) {
        return;
    }
    var self = this;
    if (this.turretEffect) {
        this.activeAnimation.StopAllAnimations();
        this.inactiveAnimation.StopAllAnimations();
        this.activeAnimation.PlayAnimation('Pack', false, function () {
            self.state = self.STATE_INACTIVE;
            self.activeAnimation.PlayAnimation('Inactive', true);
        });
        this.inactiveAnimation.PlayAnimation('Pack', false, function () {
            self.state = self.STATE_INACTIVE;
            self.inactiveAnimation.PlayAnimation('Inactive', true);
        });
        this.state = this.STATE_PACKING;
    } else {
        this.state = self.STATE_INACTIVE;
    }
    this._activeTurret = -1;
    if (this.firingEffect) {
        this.firingEffect.StopFiring();
    }
};

/**
 * Animation helper function for putting a turret set into idle state
 */
EveTurretSet.prototype.EnterStateIdle = function () {
    var self = this;
    if (this.state === this.STATE_IDLE || this.state === this.STATE_UNPACKING) {
        return;
    }
    if (this.turretEffect) {
        this.activeAnimation.StopAllAnimations();
        this.inactiveAnimation.StopAllAnimations();
        if (this.state === this.STATE_FIRING) {
            this.activeAnimation.PlayAnimation('Active', true);
            this.inactiveAnimation.PlayAnimation('Active', true);
        } else {
            this.activeAnimation.PlayAnimation('Deploy', false, function () {
                self.state = self.STATE_IDLE;
                self.activeAnimation.PlayAnimation('Active', true);
            });
            this.inactiveAnimation.PlayAnimation('Deploy', false, function () {
                self.state = self.STATE_IDLE;
                self.inactiveAnimation.PlayAnimation('Active', true);
            });
        }
        this.state = this.STATE_UNPACKING;
    } else {
        this.state = self.STATE_IDLE;
    }
    this._activeTurret = -1;
    if (this.firingEffect) {
        this.firingEffect.StopFiring();
    }
};

/**
 * Animation helper function for putting a turret set into a firing state
 */
EveTurretSet.prototype.EnterStateFiring = function () {
    var self = this;

    if (!this.turretEffect || this.state === this.STATE_FIRING) {
        this._DoStartFiring();
        if (this.turretEffect) {
            this.activeAnimation.PlayAnimation('Fire', false, function () {
                self.activeAnimation.PlayAnimation('Active', true);
            });
        }
        return;
    }
    this.activeAnimation.StopAllAnimations();
    this.inactiveAnimation.StopAllAnimations();
    if (this.state === this.STATE_INACTIVE) {
        this.activeAnimation.PlayAnimation('Deploy', false, function () {
            self._DoStartFiring();
            self.activeAnimation.PlayAnimation('Fire', false, function () {
                self.activeAnimation.PlayAnimation('Active', true);
            });
        });
        this.inactiveAnimation.PlayAnimation('Deploy', false, function () {
            self.inactiveAnimation.PlayAnimation('Active', true);
        });
        this.state = this.STATE_UNPACKING;
    } else {
        this._DoStartFiring();
        this.activeAnimation.PlayAnimation('Fire', false, function () {
            self.activeAnimation.PlayAnimation('Active', true);
        });
        this.inactiveAnimation.PlayAnimation('Active', true);
    }
};

/**
 * Updates view dependent data
 * @constructor
 */
EveTurretSet.prototype.UpdateViewDependentData = function () {
    if (this.firingEffect) {
        this.firingEffect.UpdateViewDependentData();
    }
};

/**
 * Animation helper function for turret firing
 * @private
 */
EveTurretSet.prototype._DoStartFiring = function () {
    if (this.hasCyclingFiringPos) {
        this._currentCyclingFiresPos = 1 - this._currentCyclingFiresPos;
    }
    var turret = this.GetClosestTurret();
    if (this.firingEffect) {
        this.firingEffect.PrepareFiring(0, this.hasCyclingFiringPos ? this._currentCyclingFiresPos : -1);
    }
    this._activeTurret = turret;
    this.state = this.STATE_FIRING;
    this._recheckTimeLeft = 2;

    if (this.fireCallback) {
        this.fireCallbackPending = true;
    }
};

EveTurretSet._tempVec3 = [_math.vec3.create(), _math.vec3.create()];
EveTurretSet._tempQuat4 = [_math.quat.create(), _math.quat.create()];

/**
 * Helper function for finding out what turret should be firing
 * @returns {number}
 */
EveTurretSet.prototype.GetClosestTurret = function () {
    var closestTurret = -1;
    var closestAngle = -2;
    var nrmToTarget = EveTurretSet._tempVec3[0];
    var nrmUp = EveTurretSet._tempQuat4[0];
    var turretPosition = EveTurretSet._tempQuat4[1];
    for (var i = 0; i < this.turrets.length; ++i) {
        turretPosition[0] = this.turrets[i].localTransform[12];
        turretPosition[1] = this.turrets[i].localTransform[13];
        turretPosition[2] = this.turrets[i].localTransform[14];
        turretPosition[3] = 1;
        _math.vec4.transformMat4(turretPosition, turretPosition, this.parentMatrix);
        _math.vec3.subtract(nrmToTarget, this.targetPosition, turretPosition);
        _math.vec3.normalize(nrmToTarget, nrmToTarget);
        nrmUp[0] = 0;
        nrmUp[1] = 1;
        nrmUp[2] = 0;
        nrmUp[3] = 0;
        _math.vec4.transformMat4(nrmUp, nrmUp, this.turrets[i].localTransform);
        _math.vec4.transformMat4(nrmUp, nrmUp, this.parentMatrix);
        var angle = _math.vec3.dot(nrmUp, nrmToTarget);
        if (angle > closestAngle) {
            closestTurret = i;
            closestAngle = angle;
        }
    }
    return closestTurret;
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpaceScene = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveSpaceScene
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {{}} visible
 * @property {boolean} visible.lensflare
 * @property {boolean} visible.objects
 * @property {boolean} visible.planets
 * @property {boolean} visible.fog
 * @property {boolean} visible.clearColor
 * @property {boolean} visible.nebula
 * @property {Array.<EveLensflare>} lensflares - Scene lensflares
 * @property {Array.<*>} objects - Scene objects
 * @property {Array.<EvePlanet>} planets - Scene planets
 * @property {number} nebulaIntensity - controls nebula intensity on scene objects
 * @property {vec4} ambientColor - unused
 * @property {null|Tw2Effect} backgroundEffect
 * @property {number} backgroundRenderingEnabled - Toggles background effect visibility
 * @property {vec3} endMapScaling - controls the scale of the environment maps
 * @property {quat} envMapRotation - controls the rotation of the environment maps
 * @property {boolean} logEnabled - toggles LOD
 * @property {number} fogStart - fog start distance
 * @property {number} fogEnd - fog end distance
 * @property {number} fogMax - fog maximum opacity
 * @property {number} fogType - fog blend type
 * @property {number} fogBlur - fog blur mode
 * @property {vec4} fogColor - fog color
 * @property {vec3} sunDirection - the direction of the scene sun
 * @property {vec4} sunDiffuseColor - the colour of the light from the sun
 * @property {String} envMapResPath - nebula reflection map path
 * @property {String} envMap1ResPath - nebula diffuse map path
 * @property {String} envMap2ResPath - nebular blur map path
 * @property {String} envMap3ResPath - unused
 * @property {null|Tw2TextureRes} envMapRes
 * @property {null|Tw2TextureRes} envMap1Res
 * @property {null|Tw2TextureRes} envMap2Res
 * @property {null} envMap3Res - unused
 * @property {Tw2BatchAccumulator} _batches - Scene batch accumulator
 * @property {Tw2RawData} _perFrameVS
 * @property {Tw2RawData} _perFramePS
 * @property {boolean} renderDebugInfo
 * @property {*} _debugHelper
 * @class
 */
var EveSpaceScene = exports.EveSpaceScene = function () {
    function EveSpaceScene() {
        var _this = this;

        _classCallCheck(this, EveSpaceScene);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.visible = {};
        this.visible.lensflares = true;
        this.visible.objects = true;
        this.visible.planets = true;
        this.visible.fog = true;
        this.visible.clearColor = true;
        this.visible.reflection = true;
        this.visible.diffuse = true;
        this.visible.blur = true;
        this.lensflares = [];
        this.objects = [];
        this.planets = [];
        this.nebulaIntensity = 1;
        this.ambientColor = _math.quat.fromValues(0.25, 0.25, 0.25, 1);
        this.backgroundEffect = null;
        this.backgroundRenderingEnabled = 1;
        this.clearColor = _math.vec4.fromValues(0, 0, 0, 0);
        this.lodEnabled = false;
        this.fogStart = 0;
        this.fogEnd = 0;
        this.fogMax = 0;
        this.fogType = 0;
        this.fogBlur = 0;
        this.fogColor = _math.vec4.fromValues(0.25, 0.25, 0.25, 1);
        this.sunDirection = _math.vec3.fromValues(1, -1, 1);
        this.sunDiffuseColor = _math.vec4.fromValues(1, 1, 1, 1);
        this.envMapScaling = _math.vec3.fromValues(1, 1, 1);
        this.envMapRotation = _math.quat.create();
        this.envMapResPath = '';
        this.envMap1ResPath = '';
        this.envMap2ResPath = '';
        this.envMap3ResPath = '';
        this.envMapRes = null;
        this.envMap1Res = null;
        this.envMap2Res = null;
        this.envMap3Res = null;
        this.renderDebugInfo = false;
        this._debugHelper = null;
        this._batches = new _core.Tw2BatchAccumulator();
        this._perFrameVS = new _core.Tw2RawData(EveSpaceScene.perObjectDataDecl.VSData);
        this._perFramePS = new _core.Tw2RawData(EveSpaceScene.perObjectDataDecl.PSData);

        Object.defineProperty(this.visible, 'environment', {
            get: function get() {
                return _this.backgroundRenderingEnabled;
            },
            set: function set(bool) {
                _this.backgroundRenderingEnabled = bool ? 1 : 0;
            }
        });

        EveSpaceScene.init();
    }

    /**
     * Initializes the space scene
     */


    _createClass(EveSpaceScene, [{
        key: 'Initialize',
        value: function Initialize() {
            this.SetEnvMapReflection(this.envMapResPath);
            this.SetEnvMapDiffuse(this.envMap1ResPath);
            this.SetEnvMapBlur(this.envMap2ResPath);
            this.SetEnvMapPath(3, this.envMap3ResPath);
        }

        /**
         * Keeps the scene and it's object's resources alive
         */

    }, {
        key: 'KeepAlive',
        value: function KeepAlive() {
            var res = this.GetResources();
            for (var i = 0; i < res.length; i++) {
                res[i].KeepAlive();
            }
        }

        /**
         * Enables LOD
         * @param {boolean} enable
         */

    }, {
        key: 'EnableLod',
        value: function EnableLod(enable) {
            this.lodEnabled = enable;

            if (!enable) {
                for (var i = 0; i < this.objects.length; ++i) {
                    if (this.objects[i].ResetLod) {
                        this.objects[i].ResetLod();
                    }
                }
            }
        }

        /**
         * Sets the environment's reflection map
         * @param {String} path
         */

    }, {
        key: 'SetEnvMapReflection',
        value: function SetEnvMapReflection(path) {
            this.SetEnvMapPath(0, path);
        }

        /**
         * Sets the environment's diffuse map
         * @param {string} path
         */

    }, {
        key: 'SetEnvMapDiffuse',
        value: function SetEnvMapDiffuse(path) {
            this.SetEnvMapPath(1, path);
        }

        /**
         * Sets the environment's blur map (used for fog)
         * @param {string} path
         */

    }, {
        key: 'SetEnvMapBlur',
        value: function SetEnvMapBlur(path) {
            this.SetEnvMapPath(2, path);
        }

        /**
         * Sets an environment map
         * @param {number} index
         * @param {String} path
         */

    }, {
        key: 'SetEnvMapPath',
        value: function SetEnvMapPath(index, path) {
            var _this2 = this;

            var setEnvPath = function setEnvPath(path, pathTarget, resTarget) {
                path = path.toLowerCase();
                _this2[pathTarget] = path;
                _this2[resTarget] = path === '' ? null : _core.resMan.GetResource(path);
                return true;
            };

            switch (index) {
                case 0:
                    // Reflection
                    return setEnvPath(path, 'envMapResPath', 'envMapRes');

                case 1:
                    // Diffuse
                    return setEnvPath(path, 'envMap1ResPath', 'envMap1Res');

                case 2:
                    // Blur
                    return setEnvPath(path, 'envMap2ResPath', 'envMap2Res');

                case 3:
                    // Unused
                    return setEnvPath(path, 'envMap3ResPath', 'envMap3Res');
            }

            return false;
        }

        /**
         * Gets scene's resources
         * @param {Array} [out=[]] - Optional receiving array
         * @param {boolean} [excludeChildren]
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            for (var i = 0; i < this.lensflares.length; i++) {
                this.lensflares[i].GetResources(out);
            }

            if (this.backgroundEffect) {
                this.backgroundEffect.GetResources(out);
            }

            if (this.envMapRes && !out.includes(this.envMapRes)) out.push(this.envMapRes);
            if (this.envMap1Res && !out.includes(this.envMap1Res)) out.push(this.envMapRes);
            if (this.envMap2Res && !out.includes(this.envMap2Res)) out.push(this.envMapRes);
            if (this.envMap3Res && !out.includes(this.envMap3Res)) out.push(this.envMapRes);

            if (!excludeChildren) {
                for (var _i = 0; _i < this.planets.length; _i++) {
                    this.planets[_i].GetResources(out);
                }

                for (var _i2 = 0; _i2 < this.objects.length; _i2++) {
                    if ('GetResources' in this.objects[_i2]) {
                        this.objects[_i2].GetResources(out);
                    }
                }
            }

            return out;
        }

        /**
         * Per frame update that is called per frame
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.planets.length; ++i) {
                if ('Update' in this.planets[i]) {
                    this.planets[i].Update(dt);
                }
            }

            for (var _i3 = 0; _i3 < this.objects.length; ++_i3) {
                if ('Update' in this.objects[_i3]) {
                    this.objects[_i3].Update(dt);
                }
            }
        }

        /**
         * Gets batches for rendering
         * @param {number} mode
         * @param {Array.<EveObject>} objectArray
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'RenderBatches',
        value: function RenderBatches(mode, objectArray) {
            var accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._batches;

            for (var i = 0; i < objectArray.length; ++i) {
                if ('GetBatches' in objectArray[i]) {
                    objectArray[i].GetBatches(mode, accumulator);
                }
            }
        }

        /**
         * Updates children's view dependent data and renders them
         */

    }, {
        key: 'Render',
        value: function Render() {
            this.ApplyPerFrameData();

            var g = EveSpaceScene.global,
                id = _math.mat4.identity(g.mat4_ID),
                show = this.visible;

            if (this.backgroundRenderingEnabled && this.backgroundEffect) {
                _core.device.SetStandardStates(_core.device.RM_FULLSCREEN);
                _core.device.RenderCameraSpaceQuad(this.backgroundEffect);
            }

            if (show.planets && this.planets.length) {
                var tempProj = _math.mat4.copy(g.mat4_0, _core.device.projection),
                    newProj = _math.mat4.copy(g.mat4_1, _core.device.projection),
                    zn = 10000,
                    zf = 1e11;

                newProj[10] = zf / (zn - zf);
                newProj[14] = zf * zn / (zn - zf);
                _core.device.SetProjection(newProj, true);
                this.ApplyPerFrameData();

                for (var i = 0; i < this.planets.length; ++i) {
                    if (this.planets[i].UpdateViewDependentData) {
                        this.planets[i].UpdateViewDependentData(id);
                    }
                }

                this._batches.Clear();
                _core.device.gl.depthRange(0.9, 1);
                this.RenderBatches(_core.device.RM_OPAQUE, this.planets);
                this.RenderBatches(_core.device.RM_DECAL, this.planets);
                this.RenderBatches(_core.device.RM_TRANSPARENT, this.planets);
                this.RenderBatches(_core.device.RM_ADDITIVE, this.planets);
                this._batches.Render();
                _core.device.SetProjection(tempProj, true);
                this.ApplyPerFrameData();
                _core.device.gl.depthRange(0, 0.9);
            }

            if (this.lodEnabled) {
                g.frustum.Initialize(_core.device.view, _core.device.projection, _core.device.viewportWidth, _core.device.viewInverse, _core.device.viewProjection);
                for (var _i4 = 0; _i4 < this.objects.length; ++_i4) {
                    if (this.objects[_i4].UpdateLod) {
                        this.objects[_i4].UpdateLod(g.frustum);
                    }
                }
            }

            if (show.objects) {
                for (var _i5 = 0; _i5 < this.objects.length; ++_i5) {
                    if (this.objects[_i5].UpdateViewDependentData) {
                        this.objects[_i5].UpdateViewDependentData(id);
                    }
                }
            }

            if (show.lensflares) {
                for (var _i6 = 0; _i6 < this.lensflares.length; ++_i6) {
                    this.lensflares[_i6].PrepareRender();
                }
            }

            this._batches.Clear();

            if (this.visible.planets) {
                for (var _i7 = 0; _i7 < this.planets.length; ++_i7) {
                    this.planets[_i7].GetZOnlyBatches(_core.device.RM_OPAQUE, this._batches);
                }
            }

            if (this.visible.objects) {
                this.RenderBatches(_core.device.RM_OPAQUE, this.objects);
                this.RenderBatches(_core.device.RM_DECAL, this.objects);
                this.RenderBatches(_core.device.RM_TRANSPARENT, this.objects);
                this.RenderBatches(_core.device.RM_ADDITIVE, this.objects);
            }

            if (this.visible.lensflares) {
                for (var _i8 = 0; _i8 < this.lensflares.length; ++_i8) {
                    this.lensflares[_i8].GetBatches(_core.device.RM_ADDITIVE, this._batches);
                }
            }

            this._batches.Render();

            if (this.visible.lensflares) {
                for (var _i9 = 0; _i9 < this.lensflares.length; ++_i9) {
                    this.lensflares[_i9].UpdateOccluders();
                }
            }

            if (this.renderDebugInfo) {
                if (EveSpaceScene.DebugRenderer) {
                    if (!this._debugHelper) {
                        this._debugHelper = new EveSpaceScene.DebugRenderer();
                    }

                    for (var _i10 = 0; _i10 < this.objects.length; ++_i10) {
                        if (typeof this.objects[_i10].RenderDebugInfo !== 'undefined') {
                            this.objects[_i10].RenderDebugInfo(this._debugHelper);
                        }
                    }

                    this._debugHelper.Render();
                }
            }
        }

        /**
         * Applies per frame data
         */

    }, {
        key: 'ApplyPerFrameData',
        value: function ApplyPerFrameData() {
            var g = EveSpaceScene.global,
                envMapTransform = g.mat4_2,
                sunDir = g.vec3_0;

            _math.mat4.fromQuat(envMapTransform, this.envMapRotation);
            _math.mat4.scale(envMapTransform, envMapTransform, this.envMapScaling);
            _math.mat4.transpose(envMapTransform, envMapTransform);
            _math.vec3.negate(sunDir, this.sunDirection);
            _math.vec3.normalize(sunDir, sunDir);

            var distance = this.fogEnd - this.fogStart;
            if (Math.abs(distance) < 1e-5) distance = 1e-5;
            var f = 1.0 / distance;

            var VSData = this._perFrameVS;
            VSData.Set('FogFactors', [this.fogEnd * f, f, this.visible.fog ? this.fogMax : 0, 1]);
            VSData.Set('ViewportAdjustment', [1, 1, 1, 1]);
            VSData.Set('MiscSettings', [_core.device.currentTime, 0, _core.device.viewportWidth, _core.device.viewportHeight]);
            VSData.Set('SunData.DirWorld', sunDir);
            VSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
            VSData.Set('TargetResolution', _core.device.targetResolution);
            VSData.Set('ViewInverseTransposeMat', _core.device.viewInverse);
            VSData.Set('ViewProjectionMat', _core.device.viewProjectionTranspose);
            VSData.Set('ViewMat', _core.device.viewTranspose);
            VSData.Set('ProjectionMat', _core.device.projectionTranspose);
            VSData.Set('EnvMapRotationMat', envMapTransform);
            _core.device.perFrameVSData = VSData;

            var PSData = this._perFramePS;
            PSData.Set('ViewInverseTransposeMat', _core.device.viewInverse);
            PSData.Set('ViewMat', _core.device.viewTranspose);
            PSData.Set('EnvMapRotationMat', envMapTransform);
            PSData.Set('SunData.DirWorld', sunDir);
            PSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
            PSData.Set('SceneData.AmbientColor', this.ambientColor);
            PSData.Set('MiscSettings', [_core.device.currentTime, this.fogType, this.fogBlur, 1]);
            PSData.Set('SceneData.FogColor', this.fogColor);
            PSData.Set('FovXY', [_core.device.targetResolution[3], _core.device.targetResolution[2]]);
            PSData.Set('ShadowMapSettings', [1, 1, 0, 0]);
            PSData.Set('TargetResolution', _core.device.targetResolution);
            PSData.Get('SceneData.NebulaIntensity')[0] = this.nebulaIntensity;
            PSData.Get('ViewportSize')[0] = _core.device.viewportWidth;
            PSData.Get('ViewportSize')[1] = _core.device.viewportHeight;
            PSData.Get('ShadowCameraRange')[0] = 1;
            PSData.Get('ProjectionToView')[0] = -_core.device.projection[14];
            PSData.Get('ProjectionToView')[1] = -_core.device.projection[10] - 1;
            _core.device.perFramePSData = PSData;

            var _store$_variables = _core.store._variables,
                EveSpaceSceneEnvMap = _store$_variables.EveSpaceSceneEnvMap,
                EnvMap1 = _store$_variables.EnvMap1,
                EnvMap2 = _store$_variables.EnvMap2,
                EnvMap3 = _store$_variables.EnvMap3;

            EveSpaceSceneEnvMap.textureRes = this.envMapRes && this.visible.reflection ? this.envMapRes : g.emptyTexture;
            EnvMap1.textureRes = this.envMap1Res && this.visible.diffuse ? this.envMap1Res : g.emptyTexture;
            EnvMap2.textureRes = this.envMap2Res && this.visible.blur ? this.envMap2Res : g.emptyTexture;
            EnvMap3.textureRes = this.envMap3Res ? this.envMap3Res : g.emptyTexture;
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveSpaceScene.global) {
                EveSpaceScene.global = {
                    vec3_0: _math.vec3.create(),
                    vec4_0: _math.vec4.create(),
                    mat4_0: _math.mat4.create(),
                    mat4_1: _math.mat4.create(),
                    mat4_2: _math.mat4.create(),
                    mat4_ID: _math.mat4.create(),
                    frustum: new _core.Tw2Frustum(),
                    emptyTexture: _core.resMan.GetResource('res:/texture/global/black.dds.0.png')
                };
            }
        }
    }]);

    return EveSpaceScene;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveSpaceScene.global = null;

/**
 * Per object data declarations
 * @type {{VSData: *[], PSData: *[]}}
 */
EveSpaceScene.perObjectDataDecl = {
    VSData: [{ name: 'ViewInverseTransposeMat', size: 16 }, { name: 'ViewProjectionMat', size: 16 }, { name: 'ViewMat', size: 16 }, { name: 'ProjectionMat', size: 16 }, { name: 'ShadowViewMat', size: 16 }, { name: 'ShadowViewProjectionMat', size: 16 }, { name: 'EnvMapRotationMat', size: 16 }, { name: 'SunData.DirWorld', size: 4 }, { name: 'SunData.DiffuseColor', size: 4 }, { name: 'FogFactors', size: 4 }, { name: 'TargetResolution', size: 4 }, { name: 'ViewportAdjustment', size: 4 }, { name: 'MiscSettings', size: 4 }],
    PSData: [{ name: 'ViewInverseTransposeMat', size: 16 }, { name: 'ViewMat', size: 16 }, { name: 'EnvMapRotationMat', size: 16 }, { name: 'SunData.DirWorld', size: 4 }, { name: 'SunData.DiffuseColor', size: 4 }, { name: 'SceneData.AmbientColor', size: 3 }, { name: 'SceneData.NebulaIntensity', size: 1 }, { name: 'SceneData.FogColor', size: 4 }, { name: 'ViewportOffset', size: 2 }, { name: 'ViewportSize', size: 2 }, { name: 'TargetResolution', size: 4 }, { name: 'ShadowMapSettings', size: 4 }, { name: 'ShadowCameraRange', size: 4 }, { name: 'ProjectionToView', size: 2 }, { name: 'FovXY', size: 2 }, { name: 'MiscSettings', size: 4 }]
};

/**
 * Debug renderer
 * @type {?Function}
 */
EveSpaceScene.DebugRenderer = 'Tw2DebugRenderer' in window ? window['Tw2DebugRenderer'] : null;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSOF = EveSOF;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _curve = __webpack_require__(41);

var _EveBoosterSet = __webpack_require__(46);

var _EveChildMesh = __webpack_require__(42);

var _EveLocator = __webpack_require__(47);

var _EvePlaneSet = __webpack_require__(48);

var _EveSpaceObjectDecal = __webpack_require__(49);

var _EveSpotlightSet = __webpack_require__(50);

var _EveSpriteSet = __webpack_require__(51);

var _EveSpaceObject = __webpack_require__(27);

var _EveShip = __webpack_require__(44);

function EveSOF() {
    var data = null;
    var spriteEffect = null;

    function _get(obj, property, defaultValue) {
        if (property in obj) {
            return obj[property];
        }
        return defaultValue;
    }

    /**
     * @return {string}
     */
    function GetShaderPrefix(isAnimated) {
        return isAnimated ? _get(data['generic'], 'shaderPrefixAnimated', '') : _get(data['generic'], 'shaderPrefix', '');
    }

    function ModifyTextureResPath(path, name, area, faction, commands) {
        var pathInsert = null;
        if (_get(faction, 'resPathInsert', '').length) {
            pathInsert = faction.resPathInsert;
        }
        if ('respathinsert' in commands && commands.respathinsert.length === 1) {
            if (commands.respathinsert[0] === 'none') {
                return path;
            } else {
                pathInsert = commands.respathinsert[0];
            }
        }
        if (name === 'MaterialMap' || name === 'PaintMaskMap' || name === 'PmdgMap') {
            var index = path.lastIndexOf('/');
            var pathCopy = path;
            if (index >= 0) {
                pathCopy = path.substr(0, index + 1) + pathInsert + '/' + path.substr(index + 1);
            }
            index = pathCopy.lastIndexOf('_');
            if (index >= 0) {
                pathCopy = pathCopy.substr(0, index) + '_' + pathInsert + pathCopy.substr(index);
                var textureOverrides = _get(area, 'textureOverrides', {});
                if (name in textureOverrides && faction.name in textureOverrides[name]) {
                    return pathCopy;
                }
            }
        }
        return path;
    }

    /**
     * @return {string}
     */
    function ModifyShaderPath(shader, isSkinned) {
        var prefix = GetShaderPrefix(isSkinned);
        shader = '/' + shader;
        var index = shader.lastIndexOf('/');
        return shader.substr(0, index + 1) + prefix + shader.substr(index + 1);
    }

    function FindPrefix(prefixes, name) {
        for (var m = 0; m < prefixes.length; ++m) {
            if (name.substr(0, prefixes[m].length) === prefixes[m]) {
                return m;
            }
        }
        return null;
    }

    function GetOverridenParameter(name, area, commands, race) {
        var prefixes, materialIndex, materialData, shortName;
        if ('mesh' in commands) {
            prefixes = data.generic.materialPrefixes;
            materialIndex = FindPrefix(prefixes, name);
            if (materialIndex !== null && materialIndex < commands.mesh.length && (_get(area, 'blockedMaterials', 0) & 1 << materialIndex) === 0) {
                materialData = _get(data.material, commands.mesh[materialIndex], null);
                if (materialData) {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }
        prefixes = data.generic.patternMaterialPrefixes;
        materialIndex = FindPrefix(prefixes, name);
        if ('pattern' in commands) {
            if (materialIndex !== null && 1 + materialIndex < commands.pattern.length) {
                materialData = _get(data.material, commands.pattern[1 + materialIndex], null);
                if (materialData) {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }

        if (materialIndex !== null) {
            materialData = _get(data.material, race.defaultPatternLayer1MaterialName, null);
            if (materialData) {
                shortName = name.substr(prefixes[materialIndex].length);
                return _get(materialData.parameters, shortName, undefined);
            }
        }
    }

    function GetAddressMode(projectionType) {
        switch (projectionType) {
            case 2:
                return 4;
            case 1:
                return 3;
            default:
                return 1;
        }
    }

    function FillMeshAreas(areas, areasName, hull, faction, race, pattern, commands, shaderOverride) {
        var hullAreas = _get(hull, areasName, []);
        for (var i = 0; i < hullAreas.length; ++i) {
            var area = hullAreas[i];
            var effect = new _core.Tw2Effect();
            effect.effectFilePath = data['generic']['areaShaderLocation'] + ModifyShaderPath(shaderOverride ? shaderOverride : area.shader, hull['isSkinned']);
            var names = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'parameters', []);
            for (var j = 0; j < names.length; ++j) {
                var name = names[j];
                var param = GetOverridenParameter(name, area, commands, race);
                param = param || _get(_get(_get(data.generic.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(race.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(faction.areas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(area, 'parameters', {}), name);
                if (param) {
                    effect.parameters[name] = new _core.Tw2Vector4Parameter(name, param);
                }
            }

            var hullTextures = _get(area, 'textures', []);
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j)) {
                    var path = hullTextures[j];
                    path = ModifyTextureResPath(path, j, area, faction, commands);
                    effect.parameters[j] = new _core.Tw2TextureParameter(j, path);
                }
            }

            for (j = 0; j < pattern.layers.length; ++j) {
                if (pattern.layers[j] && !(pattern.layers[j].textureName in effect.parameters)) {
                    var patternTex = new _core.Tw2TextureParameter(pattern.layers[j].textureName);
                    patternTex.resourcePath = pattern.layers[j].textureResFilePath;
                    patternTex.useAllOverrides = true;
                    patternTex.addressUMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeU', 0));
                    patternTex.addressVMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeV', 0));
                    patternTex.Initialize();
                    effect.parameters[pattern.layers[j].textureName] = patternTex;
                }
            }

            var defaultTextures = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures) {
                if (defaultTextures.hasOwnProperty(texName)) {
                    if (!(texName in effect.parameters)) {
                        effect.parameters[texName] = new _core.Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var newArea = new _core.Tw2MeshArea();
            newArea.name = area.name;
            newArea.effect = effect;
            newArea.index = _get(area, 'index', 0);
            newArea.count = _get(area, 'count', 1);
            areas.push(newArea);
        }
    }

    function SetupMesh(ship, hull, faction, race, commands, pattern) {
        var mesh = new _core.Tw2Mesh();
        mesh.geometryResPath = hull['geometryResFilePath'];
        ship.boundingSphereCenter[0] = hull.boundingSphere[0];
        ship.boundingSphereCenter[1] = hull.boundingSphere[1];
        ship.boundingSphereCenter[2] = hull.boundingSphere[2];
        ship.boundingSphereRadius = hull.boundingSphere[3];
        FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'transparentAreas', []), 'transparentAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'additiveAreas', []), 'additiveAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'decalAreas', []), 'decalAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'depthAreas', []), 'depthAreas', hull, faction, race, pattern, commands);
        mesh.Initialize();
        ship.mesh = mesh;
        if ('shapeEllipsoidCenter' in hull) {
            ship.shapeEllipsoidCenter = hull.shapeEllipsoidCenter;
        }
        if ('shapeEllipsoidRadius' in hull) {
            ship.shapeEllipsoidRadius = hull.shapeEllipsoidRadius;
        }
    }

    function SetupPattern(hull, race, commands) {
        var pattern = {
            patterns: [],
            layers: []
        };
        if ('pattern' in commands) {
            var p = {};
            for (var k = 0; k < data.pattern.length; ++k) {
                if (data.pattern[k].name === commands.pattern[0]) {
                    p = data.pattern[k];
                    break;
                }
            }
            var layer = _get(p, 'layer1', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            layer = _get(p, 'layer2', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            var projections = _get(p, 'projections', []);
            for (var i = 0; i < projections.length; ++i) {
                if (projections[i].name === hull.name) {
                    p = projections[i];
                    layer = _get(p, 'transformLayer1', null);
                    if (layer) {
                        pattern.patterns.push(layer);
                    }
                    layer = _get(p, 'transformLayer2', null);
                    if (layer) {
                        pattern.patterns.push(layer);
                    }
                }
            }
        } else if (_get(hull, 'defaultPattern')) {
            p = _get(hull, 'defaultPattern', {});
            layer = _get(p, 'transformLayer1', null);
            if (layer) {
                pattern.patterns.push(layer);
            }
            layer = _get(p, 'transformLayer2', null);
            if (layer) {
                pattern.patterns.push(layer);
            }
            p = _get(race, 'defaultPattern', {});
            layer = _get(p, 'layer1', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            layer = _get(p, 'layer2', null);
            if (layer) {
                pattern.layers.push(layer);
            }
        }
        return pattern;
    }

    function SetupCustomMasks(ship, pattern) {
        for (var i = 0; i < pattern.patterns.length; ++i) {
            if (pattern.patterns[i] && pattern.layers[i]) {
                var p = pattern.patterns[i];
                var l = pattern.layers[i];
                ship.AddCustomMask(_get(p, 'position', _math.vec3.create()), _get(p, 'scaling', _math.vec3.fromValues(1, 1, 1)), _get(p, 'rotation', _math.quat.create()), _get(p, 'isMirrored', false), _get(l, 'materialSource', 0), _math.vec4.fromValues(_get(l, 'isTargetMtl1', true) ? 1 : 0, _get(l, 'isTargetMtl2', true) ? 1 : 0, _get(l, 'isTargetMtl3', true) ? 1 : 0, _get(l, 'isTargetMtl4', true) ? 1 : 0));
            }
        }
    }

    function SetupDecals(ship, hull, faction) {
        var hullDecals = _get(hull, 'hullDecals', []);
        for (var i = 0; i < hullDecals.length; ++i) {
            var hullDecal = hullDecals[i];
            var factionDecal = null;
            var factionIndex = 'group' + _get(hullDecal, 'groupIndex', -1);
            if (faction.decals && factionIndex in faction.decals) {
                factionDecal = faction.decals[factionIndex];
            }
            if (factionDecal && !factionDecal['isVisible']) {
                continue;
            }
            var effect = new _core.Tw2Effect();
            if (factionDecal && factionDecal.shader && factionDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + factionDecal.shader;
            } else if (hullDecal.shader && hullDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + hullDecal.shader;
            } else {
                continue;
            }
            var hullParameters = _get(hullDecal, 'parameters', {});
            for (var j in hullParameters) {
                if (hullParameters.hasOwnProperty(j)) {
                    effect.parameters[j] = new _core.Tw2Vector4Parameter(j, hullParameters[j]);
                }
            }
            var hullTextures = _get(hullDecal, 'textures', {});
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j)) {
                    effect.parameters[j] = new _core.Tw2TextureParameter(j, hullTextures[j]);
                }
            }
            if (factionDecal) {
                var factionParameters = _get(factionDecal, 'parameters', {});
                for (j in factionParameters) {
                    if (factionParameters.hasOwnProperty(j)) {
                        effect.parameters[j] = new _core.Tw2Vector4Parameter(j, factionParameters[j]);
                    }
                }
                var factionTextures = _get(factionDecal, 'textures', {});
                for (j in factionTextures) {
                    if (factionTextures.hasOwnProperty(j) && !(j in effect.parameters)) {
                        effect.parameters[j] = new _core.Tw2TextureParameter(j, factionTextures[j]);
                    }
                }
            }

            var defaultTextures = _get(_get(data['generic']['decalShaders'], hullDecal.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures) {
                if (defaultTextures.hasOwnProperty(texName)) {
                    if (!(texName in effect.parameters)) {
                        effect.parameters[texName] = new _core.Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var decal = new _EveSpaceObjectDecal.EveSpaceObjectDecal();
            _math.vec3.copy(decal.position, _get(hullDecal, 'position', [0, 0, 0]));
            _math.quat.copy(decal.rotation, _get(hullDecal, 'rotation', [0, 0, 0, 1]));
            _math.vec3.copy(decal.scaling, _get(hullDecal, 'scaling', [1, 1, 1]));
            decal.parentBoneIndex = _get(hullDecal, 'boneIndex', -1);
            decal.indexBuffer = new Uint16Array(hullDecal.indexBuffer);
            decal.decalEffect = effect;
            decal.name = _get(hullDecals[i], 'name', '');
            if ('groupIndex' in hullDecals[i]) {
                decal.groupIndex = hullDecals[i].groupIndex;
            }
            decal.Initialize();
            ship.decals.push(decal);
        }
    }

    function SetupInstancedMeshes(ship, hull, faction, race, commands, pattern) {
        var instancedMeshes = _get(hull, 'instancedMeshes', []);
        for (var i = 0; i < instancedMeshes.length; ++i) {
            var him = instancedMeshes[i];
            var mesh = new _core.Tw2InstancedMesh();
            mesh.instanceGeometryResPath = him.instanceGeometryResPath;
            mesh.geometryResPath = him.geometryResPath;
            mesh.Initialize();

            FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands, him.shader);

            var child = new _EveChildMesh.EveChildMesh();
            child.mesh = mesh;
            ship.effectChildren.push(child);
        }
    }

    function SetupSpriteSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spriteSets', []);
        var factionSets = _get(faction, 'spriteSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var spriteSet = new _EveSpriteSet.EveSpriteSet(true, !!(hull['isSkinned'] && hullSets[i]['skinned']));
            spriteSet.name = _get(hullSets[i], 'name', '');
            spriteSet.effect = spriteEffect;
            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                if (!('group' + _get(hullData[j], 'groupIndex', -1) in factionSets)) continue;
                var item = new _EveSpriteSet.EveSpriteSetItem();
                item.blinkPhase = _get(hullData[j], 'blinkPhase', 0);
                item.blinkRate = _get(hullData[j], 'blinkRate', 0.1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.falloff = _get(hullData[j], 'falloff', 0);
                item.maxScale = _get(hullData[j], 'maxScale', 10);
                item.minScale = _get(hullData[j], 'minScale', 1);
                item.name = _get(hullData[j], 'name', '');
                item.groupIndex = _get(hullData[j], 'groupIndex', -1);
                _math.vec3.copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));

                var factionSet = factionSets['group' + item.groupIndex];
                if (factionSet) {
                    item.groupName = factionSet.name;
                    if ('color' in factionSet) _math.vec4.copy(item.color, factionSet.color);
                }
                spriteSet.sprites.push(item);
            }
            spriteSet.Initialize();
            ship.spriteSets.push(spriteSet);
        }
    }

    function SetupSpotlightSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spotlightSets', []);
        var factionSets = _get(faction, 'spotlightSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var spotlightSet = new _EveSpotlightSet.EveSpotlightSet();
            spotlightSet.name = _get(hullSets[i], 'name', '');
            spotlightSet.coneEffect = new _core.Tw2Effect();
            spotlightSet.glowEffect = new _core.Tw2Effect();
            if (hullSets[i]['skinned']) {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightglow.fx';
            } else {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightglow.fx';
            }
            spotlightSet.coneEffect.parameters['TextureMap'] = new _core.Tw2TextureParameter('TextureMap', hullSets[i]['coneTextureResPath']);
            spotlightSet.glowEffect.parameters['TextureMap'] = new _core.Tw2TextureParameter('TextureMap', hullSets[i]['glowTextureResPath']);
            spotlightSet.coneEffect.parameters['zOffset'] = new _core.Tw2FloatParameter('zOffset', _get(hullSets[i], 'zOffset', 0));
            spotlightSet.coneEffect.Initialize();
            spotlightSet.glowEffect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                var item = new _EveSpotlightSet.EveSpotlightSetItem();
                item.name = _get(hullData[j], 'name', '');
                item.groupIndex = _get(hullData[j], 'groupIndex', -1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.boosterGainInfluence = _get(hullData[j], 'boosterGainInfluence', 0);

                item.coneIntensity = _get(hullData[j], 'coneIntensity', 0);
                item.spriteIntensity = _get(hullData[j], 'spriteIntensity', 0);
                item.flareIntensity = _get(hullData[j], 'flareIntensity', 0);

                var factionSet = factionSets['group' + item.groupIndex];
                if (factionSet) {
                    _math.vec4.copy(item.coneColor, _get(factionSet, 'coneColor', [0, 0, 0, 0]));
                    _math.vec4.copy(item.spriteColor, _get(factionSet, 'spriteColor', [0, 0, 0, 0]));
                    _math.vec4.copy(item.flareColor, _get(factionSet, 'flareColor', [0, 0, 0, 0]));
                }
                _math.vec3.copy(item.spriteScale, _get(hullData[j], 'spriteScale', [1, 1, 1]));

                if ('transform' in hullData[j]) {
                    _math.mat4.copy(item.transform, hullData[j].transform);
                } else {
                    _math.mat4.identity(item.transform);
                }

                spotlightSet.spotlightItems.push(item);
            }
            spotlightSet.Initialize();
            ship.spotlightSets.push(spotlightSet);
        }
    }

    function _assignIfExists(dest, src, attr) {
        if (attr in src) {
            dest[attr] = src[attr];
        }
    }

    function SetupPlaneSets(ship, hull, faction) {
        var hullSets = _get(hull, 'planeSets', []);
        var factionSets = _get(faction, 'planeSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var planeSet = new _EvePlaneSet.EvePlaneSet();
            planeSet.name = _get(hullSets[i], 'name', '');
            planeSet.effect = new _core.Tw2Effect();
            if (hullSets[i]['skinned']) {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_planeglow.fx';
            } else {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/planeglow.fx';
            }
            planeSet.effect.parameters['Layer1Map'] = new _core.Tw2TextureParameter('Layer1Map', hullSets[i]['layer1MapResPath']);
            planeSet.effect.parameters['Layer2Map'] = new _core.Tw2TextureParameter('Layer2Map', hullSets[i]['layer2MapResPath']);
            planeSet.effect.parameters['MaskMap'] = new _core.Tw2TextureParameter('MaskMap', hullSets[i]['maskMapResPath']);
            planeSet.effect.parameters['PlaneData'] = new _core.Tw2Vector4Parameter('PlaneData', _get(hullSets[i], 'planeData', [1, 0, 0, 0]));
            planeSet.effect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                var item = new _EvePlaneSet.EvePlaneSetItem();
                _assignIfExists(item, hullData[j], 'groupIndex');
                _assignIfExists(item, hullData[j], 'name');
                item.boneIndex = _get(hullData[j], 'boneIndex', -1);
                item.maskAtlasID = _get(hullData[j], 'maskMapAtlasIndex', 0);
                // Do not copy reference!
                _math.vec3.copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));
                _math.quat.copy(item.rotation, _get(hullData[j], 'rotation', [0, 0, 0, 1]));
                _math.vec3.copy(item.scaling, _get(hullData[j], 'scaling', [1, 1, 1]));
                _math.vec4.copy(item.color, _get(hullData[j], 'color', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer1Transform, _get(hullData[j], 'layer1Transform', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer1Scroll, _get(hullData[j], 'layer1Scroll', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer2Transform, _get(hullData[j], 'layer2Transform', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer2Scroll, _get(hullData[j], 'layer2Scroll', [0, 0, 0, 0]));

                var factionSet = factionSets['group' + _get(hullData[j], 'groupIndex', -1)];
                if (factionSet) _math.vec4.copy(item.color, _get(factionSet, 'color', [0, 0, 0, 0]));
                planeSet.planes.push(item);
            }
            planeSet.Initialize();
            ship.planeSets.push(planeSet);
        }
    }

    function SetupBoosters(ship, hull, race) {
        if (!('booster' in hull)) {
            return;
        }
        var booster = new _EveBoosterSet.EveBoosterSet();
        var hullBooster = hull['booster'];
        var raceBooster = _get(race, 'booster', {});
        _assignIfExists(booster, raceBooster, 'glowScale');
        _assignIfExists(booster, raceBooster, 'symHaloScale');
        _assignIfExists(booster, raceBooster, 'haloScaleX');
        _assignIfExists(booster, raceBooster, 'haloScaleY');
        _assignIfExists(booster, raceBooster, 'haloColor');
        _math.vec4.copy(booster.glowColor, _get(raceBooster, 'glowColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.warpGlowColor, _get(raceBooster, 'warpGlowColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.warpHaloColor, _get(raceBooster, 'warpHalpColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.trailColor, _get(raceBooster, 'trailColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.trailSize, _get(raceBooster, 'trailSize', [0, 0, 0, 0]));

        booster.effect = new _core.Tw2Effect();
        booster.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterVolumetric.fx';
        booster.effect.parameters['NoiseFunction0'] = new _core.Tw2FloatParameter('NoiseFunction0', _get(raceBooster.shape0, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed0'] = new _core.Tw2FloatParameter('NoiseSpeed0', _get(raceBooster.shape0, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart0'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeStart0', _get(raceBooster.shape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd0'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeEnd0', _get(raceBooster.shape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency0'] = new _core.Tw2Vector4Parameter('NoiseFrequency0', _get(raceBooster.shape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color0'] = new _core.Tw2Vector4Parameter('Color0', _get(raceBooster.shape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['NoiseFunction1'] = new _core.Tw2FloatParameter('NoiseFunction1', _get(raceBooster.shape1, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed1'] = new _core.Tw2FloatParameter('NoiseSpeed1', _get(raceBooster.shape1, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart1'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeStart1', _get(raceBooster.shape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd1'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeEnd1', _get(raceBooster.shape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency1'] = new _core.Tw2Vector4Parameter('NoiseFrequency1', _get(raceBooster.shape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color1'] = new _core.Tw2Vector4Parameter('Color1', _get(raceBooster.shape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction0'] = new _core.Tw2FloatParameter('WarpNoiseFunction0', _get(raceBooster.warpShape0, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed0'] = new _core.Tw2FloatParameter('WarpNoiseSpeed0', _get(raceBooster.warpShape0, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart0'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeStart0', _get(raceBooster.warpShape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd0'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeEnd0', _get(raceBooster.warpShape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency0'] = new _core.Tw2Vector4Parameter('WarpNoiseFrequency0', _get(raceBooster.warpShape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor0'] = new _core.Tw2Vector4Parameter('WarpColor0', _get(raceBooster.warpShape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction1'] = new _core.Tw2FloatParameter('WarpNoiseFunction1', _get(raceBooster.warpShape1, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed1'] = new _core.Tw2FloatParameter('WarpNoiseSpeed1', _get(raceBooster.warpShape1, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart1'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeStart1', _get(raceBooster.warpShape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd1'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeEnd1', _get(raceBooster.warpShape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency1'] = new _core.Tw2Vector4Parameter('WarpNoiseFrequency1', _get(raceBooster.warpShape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor1'] = new _core.Tw2Vector4Parameter('WarpColor1', _get(raceBooster.warpShape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['ShapeAtlasSize'] = new _core.Tw2Vector4Parameter('ShapeAtlasSize', [_get(raceBooster, 'shapeAtlasHeight', 0), _get(raceBooster, 'shapeAtlasCount', 0), 0, 0]);
        booster.effect.parameters['BoosterScale'] = new _core.Tw2Vector4Parameter('BoosterScale', _get(raceBooster, 'scale', [1, 1, 1, 1]));

        booster.effect.parameters['ShapeMap'] = new _core.Tw2TextureParameter('ShapeMap', raceBooster.shapeAtlasResPath);
        booster.effect.parameters['GradientMap0'] = new _core.Tw2TextureParameter('GradientMap0', raceBooster.gradient0ResPath);
        booster.effect.parameters['GradientMap1'] = new _core.Tw2TextureParameter('GradientMap1', raceBooster.gradient1ResPath);
        booster.effect.parameters['NoiseMap'] = new _core.Tw2TextureParameter('ShapeMap', 'res:/Texture/Global/noise32cube_volume.dds.0.png');

        booster.effect.Initialize();

        booster.glows = new _EveSpriteSet.EveSpriteSet(true);
        booster.glows.effect = new _core.Tw2Effect();
        booster.glows.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterGlowAnimated.fx';
        booster.glows.effect.parameters['DiffuseMap'] = new _core.Tw2TextureParameter('DiffuseMap', 'res:/Texture/Particle/whitesharp.dds.0.png');
        booster.glows.effect.parameters['NoiseMap'] = new _core.Tw2TextureParameter('NoiseMap', 'res:/Texture/global/noise.dds.0.png');
        booster.glows.effect.Initialize();

        var items = _get(hullBooster, 'items', []);
        for (var i = 0; i < items.length; ++i) {
            var locator = new _EveLocator.EveLocator();
            locator.name = 'locator_booster_' + (i + 1);
            if ('transform' in items[i]) {
                _math.mat4.copy(locator.transform, items[i].transform);
            } else {
                _math.mat4.identity(locator.transform);
            }
            locator.atlasIndex0 = _get(items[i], 'atlasIndex0', 0);
            locator.atlasIndex1 = _get(items[i], 'atlasIndex1', 0);
            ship.locators.push(locator);
        }
        booster.Initialize();
        ship.boosters = booster;
    }

    function SetupLocators(ship, hull) {
        var hullLocators = _get(hull, 'locatorTurrets', []);
        for (var i = 0; i < hullLocators.length; ++i) {
            var locator = new _EveLocator.EveLocator();
            locator.name = hullLocators[i].name;
            if ('transform' in hullLocators[i]) {
                _math.mat4.copy(locator.transform, hullLocators[i].transform);
            } else {
                _math.mat4.identity(locator.transform);
            }
            ship.locators.push(locator);
        }
    }

    function BindParticleEmitters(obj, curveSet, curve) {
        for (var i = 0; i < obj.particleEmitters.length; ++i) {
            if ('rate' in obj.particleEmitters[i]) {
                var binding = new _core.Tw2ValueBinding();
                binding.sourceObject = curve;
                binding.sourceAttribute = 'currentValue';
                binding.destinationObject = obj.particleEmitters[i];
                binding.destinationAttribute = 'rate';
                binding.Initialize();
                curveSet.bindings.push(binding);
            }
        }
        for (i = 0; i < obj.children.length; ++i) {
            BindParticleEmitters(obj.children[i], curveSet, curve);
        }
    }

    function SetupChildren(ship, hull, curveSet, curves) {
        function onChildLoaded(child) {
            return function (obj) {
                if (obj.isEffectChild) {
                    ship.effectChildren.push(obj);
                } else {
                    ship.children.push(obj);
                }
                _math.vec3.copy(obj.translation, _get(child, 'translation', [0, 0, 0]));
                _math.quat.copy(obj.rotation, _get(child, 'rotation', [0, 0, 0, 1]));
                _math.vec3.copy(obj.scaling, _get(child, 'scaling', [1, 1, 1]));
                var id = _get(child, 'id', -1);
                if (id !== -1 && curves[id]) {
                    BindParticleEmitters(obj, curveSet, curves[id]);
                }
            };
        }

        var children = _get(hull, 'children', []);
        for (var i = 0; i < children.length; ++i) {
            _core.resMan.GetObject(children[i]['redFilePath'], onChildLoaded(children[i]));
        }
    }

    function SetupAnimations(ship, hull) {
        var id_curves = [];
        var curveSet = null;
        var animations = _get(hull, 'animations', []);
        for (var i = 0; i < animations.length; ++i) {
            if (_get(animations[i], 'id', -1) !== -1 && _get(animations[i], 'startRate', -1) !== -1) {
                if (!curveSet) {
                    curveSet = new _core.Tw2CurveSet();
                }
                var curve = new _curve.Tw2ScalarCurve2();
                curve.keys.push(new _curve.Tw2ScalarKey2());
                curve.keys.push(new _curve.Tw2ScalarKey2());
                curve.keys[0].value = _get(animations[i], 'startRate', -1);
                curve.keys[1].time = 1;
                curve.keys[1].value = _get(animations[i], 'endRate', -1);
                curve.Initialize();
                curveSet.curves.push(curve);
                ship.curveSets.push(curveSet);
                id_curves[_get(animations[i], 'id', -1)] = curve;
            }
        }
        if (curveSet) {
            curveSet.Initialize();
        }
        return [curveSet, id_curves];
    }

    var dataLoading = false;
    var pendingLoads = [];

    function Build(dna) {
        var parts = dna.split(':');
        var commands = {};
        for (var i = 3; i < parts.length; ++i) {
            var subparts = parts[i].split('?');
            commands[subparts[0]] = subparts[1].split(';');
        }
        var hull = data['hull'][parts[0]];
        var faction = data['faction'][parts[1]];
        var race = data['race'][parts[2]];
        var ship = new (_get(hull, 'buildClass', 0) === 2 ? _EveSpaceObject.EveSpaceObject : _EveShip.EveShip)();
        var pattern = SetupPattern(hull, race, commands);
        SetupMesh(ship, hull, faction, race, commands, pattern);
        SetupCustomMasks(ship, pattern);
        SetupDecals(ship, hull, faction);
        SetupSpriteSets(ship, hull, faction);
        SetupSpotlightSets(ship, hull, faction);
        SetupPlaneSets(ship, hull, faction);
        SetupBoosters(ship, hull, race);
        SetupLocators(ship, hull);
        var curves = SetupAnimations(ship, hull);
        SetupChildren(ship, hull, curves[0], curves[1]);
        SetupInstancedMeshes(ship, hull, faction, race, commands, pattern);

        ship.Initialize();
        return ship;
    }

    this.LoadData = function (callback) {
        if (data === null) {
            if (callback) {
                pendingLoads.push(callback);
            }
            if (!dataLoading) {
                spriteEffect = new _core.Tw2Effect();
                spriteEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/blinkinglightspool.fx';
                spriteEffect.parameters['MainIntensity'] = new _core.Tw2FloatParameter('MainIntensity', 1);
                spriteEffect.parameters['GradientMap'] = new _core.Tw2TextureParameter('GradientMap', 'res:/texture/particle/whitesharp_gradient.dds.0.png');
                spriteEffect.Initialize();

                _core.resMan.GetObject('res:/dx9/model/spaceobjectfactory/data.red', function (obj) {
                    data = obj;
                    for (var i = 0; i < pendingLoads.length; ++i) {
                        pendingLoads[i]();
                    }
                    pendingLoads = [];
                });
                dataLoading = true;
            }
        } else {
            if (callback) {
                callback();
            }
        }
    };

    this.BuildFromDNA = function (dna, callback) {
        if (data === null) {
            this.LoadData(function () {
                var result = Build(dna);
                if (callback) {
                    callback(result);
                }
            });
        } else {
            var result = Build(dna);
            if (callback) {
                callback(result);
            }
        }
    };

    function GetTurretMaterialParameter(name, parentFaction, areaData) {
        var materialIdx = -1;
        for (var i = 0; i < data['generic']['materialPrefixes'].length; ++i) {
            if (name.substr(0, data['generic']['materialPrefixes'][i].length) === data['generic']['materialPrefixes'][i]) {
                materialIdx = i;
                name = name.substr(data['generic']['materialPrefixes'][i].length);
            }
        }
        if (materialIdx !== -1) {
            var turretMaterialIndex = _get(parentFaction, 'materialUsageMtl' + (materialIdx + 1), materialIdx);
            if (turretMaterialIndex >= 0 && turretMaterialIndex < data['generic']['materialPrefixes'].length) {
                name = data['generic']['materialPrefixes'][turretMaterialIndex] + name;
                if (name in areaData.parameters) {
                    return areaData.parameters[name];
                }
            }
        }
    }

    var zeroColor = [0, 0, 0, 0];

    function CombineTurretMaterial(name, parentValue, turretValue, overrideMethod) {
        switch (overrideMethod) {
            case 'overridable':
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'half_overridable':
                if (name.indexOf('GlowColor') >= 0) {
                    return turretValue ? turretValue : zeroColor;
                }
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'not_overridable':
            case 'half_overridable_2':
                return turretValue ? turretValue : zeroColor;
        }
        return zeroColor;
    }

    function SetupTurretMaterial(turretSet, parentFactionName, turretFactionName) {
        var parentFaction = data['faction'][parentFactionName];
        var turretFaction = data['faction'][turretFactionName];
        var parentArea = null;
        if (parentFaction && parentFaction.areas && 'hull' in parentFaction.areas) {
            parentArea = parentFaction.areas.hull;
        }
        var turretArea = null;
        if (turretFaction && turretFaction.areas && 'hull' in turretFaction.areas) {
            turretArea = turretFaction.areas.hull;
        }
        if (!parentArea && !turretArea) {
            return;
        }
        if (turretSet.turretEffect) {
            var params = turretSet.turretEffect.parameters;
            for (var i in params) {
                if (params.hasOwnProperty(i)) {
                    if (params[i].constructor.prototype !== _core.Tw2Vector4Parameter.prototype) {
                        continue;
                    }
                    var parentValue = null;
                    var turretValue = null;
                    if (parentArea) {
                        parentValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    if (turretArea) {
                        turretValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    _math.vec4.copy(params[i].value, CombineTurretMaterial(i, parentValue, turretValue, turretSet.turretEffect.name));
                }
            }
            turretSet.turretEffect.BindParameters();
        }
    }

    this.SetupTurretMaterial = function (turretSet, parentFactionName, turretFactionName, callback) {
        if (data === null) {
            this.LoadData(function () {
                SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
                if (callback) {
                    callback();
                }
            });
        } else {
            SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
            if (callback) {
                callback();
            }
        }
    };

    function getDataKeys(name) {
        if (name !== 'all') {
            var names = {};
            for (var i in data[name]) {
                if (data[name].hasOwnProperty(i)) {
                    names[i] = data[name][i].description || '';
                }
            }
            return names;
        } else {
            return data;
        }
    }

    this.GetHullNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('hull'));
        });
    };

    this.GetFactionNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('faction'));
        });
    };

    this.GetRaceNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('race'));
        });
    };

    this.GetSofData = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('all'));
        });
    };
}

/***/ })
/******/ ]);
});